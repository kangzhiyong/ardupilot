/***************************************************************************
**                                                                        **
**  QCustomPlot, an easy to use, modern plotting widget for Qt            **
**  Copyright (C) 2011-2017 Emanuel Eichhammer                            **
**                                                                        **
**  This program is free software: you can redistribute it and/or modify  **
**  it under the terms of the GNU General Public License as published by  **
**  the Free Software Foundation, either version 3 of the License, or     **
**  (at your option) any later version.                                   **
**                                                                        **
**  This program is distributed in the hope that it will be useful,       **
**  but WITHOUT ANY WARRANTY; without even the implied warranty of        **
**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         **
**  GNU General Public License for more details.                          **
**                                                                        **
**  You should have received a copy of the GNU General Public License     **
**  along with this program.  If not, see http://www.gnu.org/licenses/.   **
**                                                                        **
****************************************************************************
**           Author: Emanuel Eichhammer                                   **
**  Website/Contact: http://www.qcustomplot.com/                          **
**             Date: 04.09.17                                             **
**          Version: 2.0.0                                                **
****************************************************************************/
/***************************************************************************
** **
** QCustomPlot, Qt ** 용 최신 플로팅 위젯 사용하기 쉽습니다.
** Copyright (C) 2011-2017 Emanuel Eichhammer **
** **
**이 프로그램은 자유 소프트웨어입니다 : 재배포 및 / 또는 수정 가능 **
** **에 의해 출판 된 GNU General Public License의 조건에 따라 **
** 자유 소프트웨어 재단, 라이센스 버전 3 또는 **
** (귀하의 선택에 따라) 이후 버전. **
** **
**이 프로그램은 유용 할 것이라는 희망으로 배포됩니다 **
** 그러나 어떠한 보증도하지 않습니다. ** 묵시적 보증없이
** 상품성 또는 특정 목적에의 적합성. **
** 자세한 내용은 GNU General Public License를 참조하십시오. **
** **
** GNU 일반 공중 사용 허가서 사본을 받아야합니다 **
**이 프로그램과 함께. 그렇지 않은 경우 http://www.gnu.org/licenses/를 참조하십시오. **
** **
****************************************************************************
** 저자 : Emanuel Eichhammer **
** 웹 사이트 / 연락처 : http://www.qcustomplot.com/ **
** 날짜 : 04.09.17 **
** 버전 : 2.0.0 **
****************************************************************************/
#include "qcustomplot.h"


/* including file 'src/vector2d.cpp', size 7340                              */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 파일 'src / vector2d.cpp'포함, 크기 7340 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPVector2D
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPVector2D
  \brief Represents two doubles as a mathematical 2D vector
  
  This class acts as a replacement for QVector2D with the advantage of double precision instead of
  single, and some convenience methods tailored for the QCustomPlot library.
*/
/*! \ class QCPVector2D
  \ brief 두 개의 double을 수학 2D 벡터로 나타냅니다.
  
  이 클래스는 QVector2D를 대신하여 배정도를 사용하여 QVector2D를 대체합니다.
  단일 및 QCustomPlot 라이브러리에 맞게 조정 된 몇 가지 편리한 방법을 제공합니다.
*/

/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */
/*! \fn void QCPVector2D::setX(double x)
  
  Sets the x coordinate of this vector to \a x.
  
  \see setY
*/
/*! \ fn void QCPVector2D :: setX (double x)
  
  이 벡터의 x 좌표를 \ a x로 설정합니다.
  
  \ setY를 보아라.
*/

/*! \fn void QCPVector2D::setY(double y)
  
  Sets the y coordinate of this vector to \a y.
  
  \see setX
*/
/*! \ fn void QCPVector2D :: setY (double y)
  
  Vector의 y 좌표를 \ y로 설정합니다.
  
  \ see setX
*/

/*! \fn double QCPVector2D::length() const
  
  Returns the length of this vector.
  
  \see lengthSquared
*/
/*! \ fn double QCPVector2D :: length () const
  
  이 벡터의 길이를 반환합니다.
  
  \ see lengthSquared
*/

/*! \fn double QCPVector2D::lengthSquared() const
  
  Returns the squared length of this vector. In some situations, e.g. when just trying to find the
  shortest vector of a group, this is faster than calculating \ref length, because it avoids
  calculation of a square root.
  
  \see length
*/
/*! \ fn double QCPVector2D :: lengthSquared () const
  
  이 벡터의 제곱 길이를 반환합니다. 어떤 상황에서는 예를 들어
  그룹의 가장 짧은 벡터. \ ref 길이를 계산하는 것보다 빠릅니다. 왜냐하면 피할 수 있기 때문입니다.
  평방근 계산.
  
  \ 길이보기
*/


/*! \fn QPoint QCPVector2D::toPoint() const
  
  Returns a QPoint which has the x and y coordinates of this vector, truncating any floating point
  information.
  
  \see toPointF
*/
/*! \ fn QPoint QCPVector2D :: toPoint () const
  
  이 벡터의 x 및 y 좌표를 갖는 QPoint를 반환하고 부동 소수점을 자릅니다
  정보.
  
  \를 참조하십시오.
*/

/*! \fn QPointF QCPVector2D::toPointF() const
  
  Returns a QPointF which has the x and y coordinates of this vector.
  
  \see toPoint
*/
/*! \ fn QPointF QCPVector2D :: toPointF () const
  
  이 벡터의 x와 y 좌표를 갖는 QPointF를 리턴합니다.
  
  \ to를 참조하십시오.
*/

/*! \fn bool QCPVector2D::isNull() const
  
  Returns whether this vector is null. A vector is null if \c qIsNull returns true for both x and y
  coordinates, i.e. if both are binary equal to 0.
*/

/*! \ fn bool QCPVector2D :: isNull () const
  
  이 벡터가 null인지 여부를 반환합니다. \ c qIsNull이 x와 y 모두에 대해 true를 반환하면 벡터는 null입니다.
  좌표, 즉, 양쪽 모두가 0에 동일한 경우
*/

/*! \fn QCPVector2D QCPVector2D::perpendicular() const
  
  Returns a vector perpendicular to this vector, with the same length.
*/
/*! \ fn QCPVector2D QCPVector2D :: perpendicular () const
  
  이 벡터에 수직 인 벡터를 같은 길이로 반환합니다.
*/

/*! \fn double QCPVector2D::dot() const
  
  Returns the dot/scalar product of this vector with the specified vector \a vec.
*/
/*! \ fn double QCPVector2D :: dot () const
  
  이 벡터의 도트 / 스칼라 곱을 지정된 벡터 \ a vec로 반환합니다.
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */

/*!
  Creates a QCPVector2D object and initializes the x and y coordinates to 0.
*/
/*!
  QCPVector2D 객체를 생성하고 x 및 y 좌표를 0으로 초기화합니다.
*/
QCPVector2D::QCPVector2D() :
  mX(0),
  mY(0)
{
}

/*!
  Creates a QCPVector2D object and initializes the \a x and \a y coordinates with the specified
  values.
*/
/*!
  QCPVector2D 객체를 생성하고 \ ax와 \ y 좌표를 지정된 값으로 초기화합니다.
  값.
*/
QCPVector2D::QCPVector2D(double x, double y) :
  mX(x),
  mY(y)
{
}

/*!
  Creates a QCPVector2D object and initializes the x and y coordinates respective coordinates of
  the specified \a point.
*/
/*!
  QCPVector2D 오브젝트를 작성해, x 좌표 및 y 좌표의 각 좌표를 초기화합니다.
  지정된 \ a 점.
*/
QCPVector2D::QCPVector2D(const QPoint &point) :
  mX(point.x()),
  mY(point.y())
{
}

/*!
  Creates a QCPVector2D object and initializes the x and y coordinates respective coordinates of
  the specified \a point.
*/
/*!
  QCPVector2D 오브젝트를 작성해, x 좌표 및 y 좌표의 각 좌표를 초기화합니다.
  지정된 \ a 점.
*/
QCPVector2D::QCPVector2D(const QPointF &point) :
  mX(point.x()),
  mY(point.y())
{
}

/*!
  Normalizes this vector. After this operation, the length of the vector is equal to 1.
  
  \see normalized, length, lengthSquared
*/
/*!
  이 벡터를 정규화합니다. 이 작업 후에 벡터의 길이는 1입니다.
  
  \ 표준화, 길이, 길이를 볼 수 있습니다 .Squared
*/

void QCPVector2D::normalize()
{
  double len = length();
  mX /= len;
  mY /= len;
}

/*!
  Returns a normalized version of this vector. The length of the returned vector is equal to 1.
  
  \see normalize, length, lengthSquared
*/
/*!
  Vector의 정규화 된 버전을 리턴합니다. 반환 된 벡터의 길이는 1입니다.
  
  \ normalize, length, lengthSquared를 참조하십시오.
*/
QCPVector2D QCPVector2D::normalized() const
{
  QCPVector2D result(mX, mY);
  result.normalize();
  return result;
}

/*! \overload
  
  Returns the squared shortest distance of this vector (interpreted as a point) to the finite line
  segment given by \a start and \a end.
  
  \see distanceToStraightLine
*/
/*! \초과 적재
  
  이 벡터 (점으로 해석 됨)의 유한 선에 대한 제곱 된 최단 거리를 반환합니다.
  세그먼트는 \ a start와 \ end에 의해 주어진다.
  
  \ see distanceToStraightLine
*/
double QCPVector2D::distanceSquaredToLine(const QCPVector2D &start, const QCPVector2D &end) const
{
  QCPVector2D v(end-start);
  double vLengthSqr = v.lengthSquared();
  if (!qFuzzyIsNull(vLengthSqr))
  {
    double mu = v.dot(*this-start)/vLengthSqr;
    if (mu < 0)
      return (*this-start).lengthSquared();
    else if (mu > 1)
      return (*this-end).lengthSquared();
    else
      return ((start + mu*v)-*this).lengthSquared();
  } else
    return (*this-start).lengthSquared();
}

/*! \overload
  
  Returns the squared shortest distance of this vector (interpreted as a point) to the finite line
  segment given by \a line.
  
  \see distanceToStraightLine
*/
/*! \초과 적재
  
  이 벡터 (점으로 해석 됨)의 유한 선에 대한 제곱 된 최단 거리를 반환합니다.
  세그먼트는 \ a 라인으로 주어진다.
  
  \ see distanceToStraightLine
*/
double QCPVector2D::distanceSquaredToLine(const QLineF &line) const
{
  return distanceSquaredToLine(QCPVector2D(line.p1()), QCPVector2D(line.p2()));
}

/*!
  Returns the shortest distance of this vector (interpreted as a point) to the infinite straight
  line given by a \a base point and a \a direction vector.
  
  \see distanceSquaredToLine
*/
/*!
  이 벡터의 점 (점으로 해석 됨)에서 무한 직선까지의 최단 거리를 반환합니다.
  행은 \ a 기준점과 \ a 방향 벡터에 의해 주어진다.
  
  \ see distanceSquaredToLine
*/
double QCPVector2D::distanceToStraightLine(const QCPVector2D &base, const QCPVector2D &direction) const
{
  return qAbs((*this-base).dot(direction.perpendicular()))/direction.length();
}

/*!
  Scales this vector by the given \a factor, i.e. the x and y components are multiplied by \a
  factor.
*/
/*!
  이 벡터의 배율을 주어진 \ a 요소로 조정합니다. 즉, x 및 y 구성 요소에 \ a를 곱합니다.
  인자.
*/
QCPVector2D &QCPVector2D::operator*=(double factor)
{
  mX *= factor;
  mY *= factor;
  return *this;
}

/*!
  Scales this vector by the given \a divisor, i.e. the x and y components are divided by \a
  divisor.
*/
/*!
  이 벡터를 주어진 \ divisor로 크기 조정합니다. 즉, x 및 y 구성 요소를 \ a로 나눕니다.
  제수.
*/
QCPVector2D &QCPVector2D::operator/=(double divisor)
{
  mX /= divisor;
  mY /= divisor;
  return *this;
}

/*!
  Adds the given \a vector to this vector component-wise.
*/
/*!
  주어진 벡터를이 벡터에 추가합니다.
*/
QCPVector2D &QCPVector2D::operator+=(const QCPVector2D &vector)
{
  mX += vector.mX;
  mY += vector.mY;
  return *this;
}

/*!
  subtracts the given \a vector from this vector component-wise.
*/
/*!
  주어진 벡터로부터이 주어진 벡터를 뺍니다.
*/
QCPVector2D &QCPVector2D::operator-=(const QCPVector2D &vector)
{
  mX -= vector.mX;
  mY -= vector.mY;
  return *this;
}
/* end of 'src/vector2d.cpp' */
/* 'src / vector2d.cpp'의 끝 */



/* including file 'src/painter.cpp', size 8670                               */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 파일 'src / painter.cpp', 크기 8670  포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPPainter
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPPainter
  \brief QPainter subclass used internally
  
  This QPainter subclass is used to provide some extended functionality e.g. for tweaking position
  consistency between antialiased and non-antialiased painting. Further it provides workarounds
  for QPainter quirks.
  
  \warning This class intentionally hides non-virtual functions of QPainter, e.g. setPen, save and
  restore. So while it is possible to pass a QCPPainter instance to a function that expects a
  QPainter pointer, some of the workarounds and tweaks will be unavailable to the function (because
  it will call the base class implementations of the functions actually hidden by QCPPainter).
*/
/*! \ class QCPPainter
  \ brief 내부적으로 사용되는 QPainter 서브 클래스
  
  이 QPainter 서브 클래스는, 예를 들어 위치의 조정을 위해서 (때문에) 확장 된 기능을 제공하기 위해서 사용됩니다.
  앤티 엘리 어싱 된 페인팅과 비 앤티 앨리어스가 적용된 페인팅 간의 일관성. 또한 해결 방법을 제공합니다.
  QPainter 단점.
  
  \ warning이 클래스는 의도적으로 QPainter의 비 가상 함수를 숨 깁니다. 예를 들어 setPen, save 및
  복원. QCPPainter 인스턴스를 다음과 같은 함수에 전달할 수는 있지만,
  QPainter 포인터, 몇 가지 해결 방법 및 비틀기 기능을 사용할 수 없습니다 (왜냐하면
  실제로 QCPPainter에 의해 숨겨진 함수의 기본 클래스 구현을 호출 할 것이다).
*/

/*!
  Creates a new QCPPainter instance and sets default values
*/
/*!
  새 QCPPainter 인스턴스를 만들고 기본값을 설정합니다.
*/
QCPPainter::QCPPainter() :
  QPainter(),
  mModes(pmDefault),
  mIsAntialiasing(false)
{
  // don't setRenderHint(QPainter::NonCosmeticDefautPen) here, because painter isn't active yet and
  // a call to begin() will follow
  // painter가 아직 활성화되지 않았으므로 setRenderHint (QPainter :: NonCosmeticDefautPen)를 여기에서 사용하지 마십시오.
  // begin ()에 대한 호출이 따라옵니다.
}

/*!
  Creates a new QCPPainter instance on the specified paint \a device and sets default values. Just
  like the analogous QPainter constructor, begins painting on \a device immediately.
  
  Like \ref begin, this method sets QPainter::NonCosmeticDefaultPen in Qt versions before Qt5.
*/
/*!
  지정된 paint \ a 디바이스에 새 QCPPainter 인스턴스를 작성하고 기본값을 설정합니다. 다만
  유사한 QPainter 생성자와 마찬가지로, 장치에서 즉시 페인팅을 시작합니다.
  
  \ ref와 마찬가지로이 메소드는 Qt 버전 전에 QPainter :: NonCosmeticDefaultPen을 설정합니다.
*/
QCPPainter::QCPPainter(QPaintDevice *device) :
  QPainter(device),
  mModes(pmDefault),
  mIsAntialiasing(false)
{
#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0) // before Qt5, default pens used to be cosmetic if NonCosmeticDefaultPen flag isn't set. So we set it to get consistency across Qt versions.
// Qt5 이전에는 NonCosmeticDefaultPen 플래그가 설정되지 않은 경우 기본 펜이 사용되었습니다. 그래서 우리는 Qt 버전간에 일관성을 유지하도록 설정했습니다.
  if (isActive())
    setRenderHint(QPainter::NonCosmeticDefaultPen);
#endif
}

/*!
  Sets the pen of the painter and applies certain fixes to it, depending on the mode of this
  QCPPainter.
  
  \note this function hides the non-virtual base class implementation.
*/
/*!
  Painter의 펜을 설정하고이 모드의 모드에 따라 특정 수정 사항을 적용합니다.
  QCPPainter.
  
  이 함수는 비 가상 기본 클래스 구현을 숨 깁니다.
*/
void QCPPainter::setPen(const QPen &pen)
{
  QPainter::setPen(pen);
  if (mModes.testFlag(pmNonCosmetic))
    makeNonCosmetic();
}

/*! \overload
  
  Sets the pen (by color) of the painter and applies certain fixes to it, depending on the mode of
  this QCPPainter.
  
  \note this function hides the non-virtual base class implementation.
*/
/*! \초과 적재
  
  Painter의 펜 (색상 별)을 설정하고 해당 모드의 모드에 따라 특정 수정 사항을 적용합니다.
  이 QCPPainter.
  
  이 함수는 비 가상 기본 클래스 구현을 숨 깁니다.
*/
void QCPPainter::setPen(const QColor &color)
{
  QPainter::setPen(color);
  if (mModes.testFlag(pmNonCosmetic))
    makeNonCosmetic();
}

/*! \overload
  
  Sets the pen (by style) of the painter and applies certain fixes to it, depending on the mode of
  this QCPPainter.
  
  \note this function hides the non-virtual base class implementation.
*/
/*! \초과 적재
  
  페인터의 펜 (스타일 별)을 설정하고 모드에 따라 특정 수정 사항을 적용합니다.
  이 QCPPainter.
  
  이 함수는 비 가상 기본 클래스 구현을 숨 깁니다.
*/
void QCPPainter::setPen(Qt::PenStyle penStyle)
{
  QPainter::setPen(penStyle);
  if (mModes.testFlag(pmNonCosmetic))
    makeNonCosmetic();
}

/*! \overload
  
  Works around a Qt bug introduced with Qt 4.8 which makes drawing QLineF unpredictable when
  antialiasing is disabled. Thus when antialiasing is disabled, it rounds the \a line to
  integer coordinates and then passes it to the original drawLine.
  
  \note this function hides the non-virtual base class implementation.
*/
/*! \초과 적재
  
  언제 QLineF를 예측할 수 없게 만드는 Qt 4.8과 관련된 Qt 버그를 해결할 수 있습니까?
  안티 앨리어싱이 비활성화됩니다. 따라서 앤티 앨리어싱을 비활성화하면 \ a 행을 반올림합니다.
  정수 좌표를 가져 와서 원래의 drawLine으로 전달합니다.
  
  이 함수는 비 가상 기본 클래스 구현을 숨 깁니다.
*/
void QCPPainter::drawLine(const QLineF &line)
{
  if (mIsAntialiasing || mModes.testFlag(pmVectorized))
    QPainter::drawLine(line);
  else
    QPainter::drawLine(line.toLine());
}

/*!
  Sets whether painting uses antialiasing or not. Use this method instead of using setRenderHint
  with QPainter::Antialiasing directly, as it allows QCPPainter to regain pixel exactness between
  antialiased and non-antialiased painting (Since Qt < 5.0 uses slightly different coordinate systems for
  AA/Non-AA painting).
*/
/*!
  페인팅에서 앤티 엘리 어싱을 사용할지 여부를 설정합니다. setRenderHint를 사용하는 대신에이 메서드를 사용한다.
  QPainter :: Antialiasing을 직접 사용하면 QCPPainter가 픽셀 정확성을 회복 할 수 있습니다.
  앤티 앨리어스 및 비 안티 앨리어싱 페인팅 (Qt <5.0에서는 약간 다른 좌표계를 사용하기 때문에
  AA / 비 AA 페인트).
*/
void QCPPainter::setAntialiasing(bool enabled)
{
  setRenderHint(QPainter::Antialiasing, enabled);
  if (mIsAntialiasing != enabled)
  {
    mIsAntialiasing = enabled;
    if (!mModes.testFlag(pmVectorized)) // antialiasing half-pixel shift only needed for rasterized outputs
    {                                   // 래스터 화 된 출력에만 필요한 반 화소 시프트 앤티 엘리 어싱
      if (mIsAntialiasing)
        translate(0.5, 0.5);
      else
        translate(-0.5, -0.5);
    }
  }
}

/*!
  Sets the mode of the painter. This controls whether the painter shall adjust its
  fixes/workarounds optimized for certain output devices.
*/
/*!
  페인터의 모드를 설정합니다. 이 기능은 화가가
  특정 출력 장치에 최적화 된 수정 사항 / 문제 해결 방법.
*/
void QCPPainter::setModes(QCPPainter::PainterModes modes)
{
  mModes = modes;
}

/*!
  Sets the QPainter::NonCosmeticDefaultPen in Qt versions before Qt5 after beginning painting on \a
  device. This is necessary to get cosmetic pen consistency across Qt versions, because since Qt5,
  all pens are non-cosmetic by default, and in Qt4 this render hint must be set to get that
  behaviour.
  
  The Constructor \ref QCPPainter(QPaintDevice *device) which directly starts painting also sets
  the render hint as appropriate.
  
  \note this function hides the non-virtual base class implementation.
*/
/*!
  QPainter :: NonCosmeticDefaultPen을 그림을 시작한 후 Qt 버전에서 설정합니다.
  장치. 이것은 Qt 버전 전반에 걸쳐 화장품 펜의 일관성을 유지하는 데 필요합니다. 왜냐하면 Qt5,
  모든 펜은 기본적으로 비 외관 (non-cosmetic)이며, Qt4에서는이 렌더링 힌트를 설정해야합니다.
  행동.
  
  그림을 직접 시작하는 Constructor \ ref QCPPainter (QPaintDevice * 장치)도 설정합니다.
  적절한 힌트 힌트.
  
  이 함수는 비 가상 기본 클래스 구현을 숨 깁니다.
*/
bool QCPPainter::begin(QPaintDevice *device)
{
  bool result = QPainter::begin(device);
#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0) // before Qt5, default pens used to be cosmetic if NonCosmeticDefaultPen flag isn't set. So we set it to get consistency across Qt versions.
// Qt5 이전에는 NonCosmeticDefaultPen 플래그가 설정되지 않은 경우 기본 펜이 사용되었습니다. 그래서 우리는 Qt 버전간에 일관성을 유지하도록 설정했습니다.
  if (result)
    setRenderHint(QPainter::NonCosmeticDefaultPen);
#endif
  return result;
}

/*! \overload
  
  Sets the mode of the painter. This controls whether the painter shall adjust its
  fixes/workarounds optimized for certain output devices.
*/
/*! \초과 적재
  
  페인터의 모드를 설정합니다. 이 기능은 화가가
  특정 출력 장치에 최적화 된 수정 사항 / 문제 해결 방법.
*/
void QCPPainter::setMode(QCPPainter::PainterMode mode, bool enabled)
{
  if (!enabled && mModes.testFlag(mode))
    mModes &= ~mode;
  else if (enabled && !mModes.testFlag(mode))
    mModes |= mode;
}

/*!
  Saves the painter (see QPainter::save). Since QCPPainter adds some new internal state to
  QPainter, the save/restore functions are reimplemented to also save/restore those members.
  
  \note this function hides the non-virtual base class implementation.
  
  \see restore
*/
/*!
  painter를 저장합니다 (QPainter :: save 참고). QCPPainter는 새로운 내부 상태를 다음에 추가하기 때문에
  QPainter에서는 저장 / 복원 기능이 다시 구현되어 해당 멤버를 저장 / 복원합니다.
  
  이 함수는 비 가상 기본 클래스 구현을 숨 깁니다.
  
  \ 복원보기
*/
void QCPPainter::save()
{
  mAntialiasingStack.push(mIsAntialiasing);
  QPainter::save();
}

/*!
  Restores the painter (see QPainter::restore). Since QCPPainter adds some new internal state to
  QPainter, the save/restore functions are reimplemented to also save/restore those members.
  
  \note this function hides the non-virtual base class implementation.
  
  \see save
*/
/*!
  painter를 복원합니다 (QPainter :: restore 참조). QCPPainter는 새로운 내부 상태를 다음에 추가하기 때문에
  QPainter에서는 저장 / 복원 기능이 다시 구현되어 해당 멤버를 저장 / 복원합니다.
  
  이 함수는 비 가상 기본 클래스 구현을 숨 깁니다.
  
  \ 저장보기
*/
void QCPPainter::restore()
{
  if (!mAntialiasingStack.isEmpty())
    mIsAntialiasing = mAntialiasingStack.pop();
  else
    qDebug() << Q_FUNC_INFO << "Unbalanced save/restore";
  QPainter::restore();
}

/*!
  Changes the pen width to 1 if it currently is 0. This function is called in the \ref setPen
  overrides when the \ref pmNonCosmetic mode is set.
*/
/*!
  현재 0 인 경우 펜 너비를 1로 변경합니다.이 함수는 \ ref setPen
  \ ref pmNonCosmetic 모드가 설정되면 무시됩니다.
*/

void QCPPainter::makeNonCosmetic()
{
  if (qFuzzyIsNull(pen().widthF()))
  {
    QPen p = pen();
    p.setWidth(1);
    QPainter::setPen(p);
  }
}
/* end of 'src/painter.cpp' */
/* 'src / painter.cpp'의 끝 */


/* including file 'src/paintbuffer.cpp', size 18502                          */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 파일 'src / paintbuffer.cpp'포함, 크기 18502 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPAbstractPaintBuffer
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPAbstractPaintBuffer
  \brief The abstract base class for paint buffers, which define the rendering backend

  This abstract base class defines the basic interface that a paint buffer needs to provide in
  order to be usable by QCustomPlot.

  A paint buffer manages both a surface to draw onto, and the matching paint device. The size of
  the surface can be changed via \ref setSize. External classes (\ref QCustomPlot and \ref
  QCPLayer) request a painter via \ref startPainting and then perform the draw calls. Once the
  painting is complete, \ref donePainting is called, so the paint buffer implementation can do
  clean up if necessary. Before rendering a frame, each paint buffer is usually filled with a color
  using \ref clear (usually the color is \c Qt::transparent), to remove the contents of the
  previous frame.

  The simplest paint buffer implementation is \ref QCPPaintBufferPixmap which allows regular
  software rendering via the raster engine. Hardware accelerated rendering via pixel buffers and
  frame buffer objects is provided by \ref QCPPaintBufferGlPbuffer and \ref QCPPaintBufferGlFbo.
  They are used automatically if \ref QCustomPlot::setOpenGl is enabled.
*/
/*! \ class QCPAbstractPaintBuffer
  \ brief 렌더링 백엔드를 정의하는 페인트 버퍼의 추상 기본 클래스입니다.

  이 추상 기본 클래스는 페인트 버퍼가 제공해야하는 기본 인터페이스를 정의합니다.
  QCustomPlot에서 사용할 수 있도록 주문하십시오.

  페인트 버퍼는 그릴 표면과 일치하는 페인트 장치를 관리합니다. 의 크기
  표면은 \ ref setSize를 통해 변경할 수 있습니다. 외부 클래스 (\ ref QCustomPlot 및 \ ref
  QCPLayer) \ ref startPainting을 통해 화가에게 요청한 다음 draw 호출을 수행합니다. 일단
  페인팅이 완료되면 \ ref donePainting이 호출되므로 페인트 버퍼 구현으로 수행 할 수 있습니다.
  필요한 경우 정리하십시오. 프레임을 렌더링하기 전에 각 페인트 버퍼는 일반적으로 색상으로 채워집니다.
  \ ref clear (일반적으로 색상은 \ c Qt :: transparent)를 사용하여
  이전 프레임.

  가장 단순한 페인트 버퍼 구현은 \ ref QCPPaintBufferPixmap이다.
  래스터 엔진을 통한 소프트웨어 렌더링. 픽셀 버퍼를 통한 하드웨어 렌더링 가속화 및
  프레임 버퍼 오브젝트는 \ ref QCPPaintBufferGlPbuffer 및 \ ref QCPPaintBufferGlFbo에 의해 제공됩니다.
  \ ref QCustomPlot :: setOpenGl이 활성화되면 자동으로 사용됩니다.
*/

/* start documentation of pure virtual functions */
/* 순수 가상 함수의 시작 문서 */

/*! \fn virtual QCPPainter *QCPAbstractPaintBuffer::startPainting() = 0

  Returns a \ref QCPPainter which is ready to draw to this buffer. The ownership and thus the
  responsibility to delete the painter after the painting operations are complete is given to the
  caller of this method.

  Once you are done using the painter, delete the painter and call \ref donePainting.

  While a painter generated with this method is active, you must not call \ref setSize, \ref
  setDevicePixelRatio or \ref clear.

  This method may return 0, if a painter couldn't be activated on the buffer. This usually
  indicates a problem with the respective painting backend.
*/
/*! \ fn 가상 QCPPainter * QCPAbstractPaintBuffer :: startPainting () = 0

  이 버퍼에 그릴 준비가 된 \ ref QCPPainter를 반환합니다. 소유권과 따라서
  도장 작업이 완료된 후 화가를 삭제할 책임은
  이 메소드의 호출 원.

  화가를 사용하여 작업을 마쳤 으면 화가를 삭제하고 \ ref donePainting을 호출합니다.

  이 메서드로 생성 된 화가가 활성화되어있는 동안 \ ref setSize, \ ref를 호출하면 안됩니다.
  setDevicePixelRatio 또는 \ ref를 클리어합니다.

  이 메소드는, 버퍼로 화이 터를 액티브화할 수 없었던 경우는 0을 돌려줍니다. 보통이
  각각의 페인팅 백엔드에 문제가 있음을 나타냅니다.
*/

/*! \fn virtual void QCPAbstractPaintBuffer::draw(QCPPainter *painter) const = 0

  Draws the contents of this buffer with the provided \a painter. This is the method that is used
  to finally join all paint buffers and draw them onto the screen.
*/
/*! \ fn 가상 무효 QCPAbstractPaintBuffer :: draw (QCPPainter * painter) const = 0

  제공된 버퍼의 내용을 제공된 \ painter로 그립니다. 이것이 사용 된 방법입니다.
  마침내 모든 페인트 버퍼를 결합하여 화면에 그립니다.
*/

/*! \fn virtual void QCPAbstractPaintBuffer::clear(const QColor &color) = 0

  Fills the entire buffer with the provided \a color. To have an empty transparent buffer, use the
  named color \c Qt::transparent.

  This method must not be called if there is currently a painter (acquired with \ref startPainting)
  active.
*/
/*! \ fn 가상 무효 QCPAbstractPaintBuffer :: clear (const QColor & color) = 0

  제공된 버퍼로 전체 버퍼를 채 웁니다. 빈 투명 버퍼를 사용하려면
  명명 된 색상 \ c Qt :: 투명.

  이 메소드는 현재 화가 (\ ref startPainting으로 취득)가있는 경우에는 호출하지 말아주세요.
  유효한.
*/

/*! \fn virtual void QCPAbstractPaintBuffer::reallocateBuffer() = 0

  Reallocates the internal buffer with the currently configured size (\ref setSize) and device
  pixel ratio, if applicable (\ref setDevicePixelRatio). It is called as soon as any of those
  properties are changed on this paint buffer.

  \note Subclasses of \ref QCPAbstractPaintBuffer must call their reimplementation of this method
  in their constructor, to perform the first allocation (this can not be done by the base class
  because calling pure virtual methods in base class constructors is not possible).
*/
/*! \ fn 가상 무효 QCPAbstractPaintBuffer :: reallocateBuffer () = 0

  현재 구성된 크기 (\ ref setSize)와 장치로 내부 버퍼를 재 할당합니다.
  픽셀 비율 (해당되는 경우 \ ref setDevicePixelRatio). 그 중 하나라도 호출되면 바로 호출됩니다.
  속성은이 페인트 버퍼에서 변경됩니다.

  \ note \ ref QCPAbstractPaintBuffer의 서브 클래스는이 메소드의 재 구현을 호출해야합니다.
  생성자에서 첫 번째 할당을 수행합니다 (기본 클래스에서 수행 할 수 없음).
  왜냐하면 기본 클래스 생성자에서 순수 가상 메서드를 호출 할 수 없기 때문입니다.
*/

/* end documentation of pure virtual functions */
/* start documentation of inline functions */
/* 순수 가상 함수의 끝 문서 */
/* 인라인 함수의 시작 문서 */

/*! \fn virtual void QCPAbstractPaintBuffer::donePainting()

  If you have acquired a \ref QCPPainter to paint onto this paint buffer via \ref startPainting,
  call this method as soon as you are done with the painting operations and have deleted the
  painter.

  paint buffer subclasses may use this method to perform any type of cleanup that is necessary. The
  default implementation does nothing.
*/
/*! \ fn virtual void QCPAbstractPaintBuffer :: donePainting ()

  \ ref startPainting을 통해이 페인트 버퍼에 페인트하기 위해 \ ref QCPPainter를 얻은 경우,
  페인팅 작업을 완료하고 해당 작업을 삭제하면이 메서드를 호출하십시오.
  화가.

  페인트 버퍼 서브 클래스는이 메서드를 사용해, 필요한 클린 업 타입을 실행할 수 있습니다. 그만큼
  디폴트 구현은 아무것도하지 않습니다.
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */
/*!
  Creates a paint buffer and initializes it with the provided \a size and \a devicePixelRatio.

  Subclasses must call their \ref reallocateBuffer implementation in their respective constructors.
*/
/*!
  paint 버퍼를 작성해, 제공된 \ a 크기 및 \ a devicePixelRatio로 초기화합니다.

  서브 클래스는 각각의 생성자에서 \ ref reallocateBuffer 구현을 호출해야합니다.
*/
QCPAbstractPaintBuffer::QCPAbstractPaintBuffer(const QSize &size, double devicePixelRatio) :
  mSize(size),
  mDevicePixelRatio(devicePixelRatio),
  mInvalidated(true)
{
}

QCPAbstractPaintBuffer::~QCPAbstractPaintBuffer()
{
}

/*!
  Sets the paint buffer size.

  The buffer is reallocated (by calling \ref reallocateBuffer), so any painters that were obtained
  by \ref startPainting are invalidated and must not be used after calling this method.

  If \a size is already the current buffer size, this method does nothing.
*/
/*!
  paint 버퍼의 사이즈를 설정합니다.

  버퍼는 \ ref reallocateBuffer를 호출하여 재 할당되므로 획득 한 모든 페인터
  by \ ref startPainting은 무효화되므로이 메서드를 호출 한 후에 사용하면 안됩니다.

  \ a size가 이미 현재 버퍼 크기 인 경우이 메서드는 아무 작업도 수행하지 않습니다.
*/
void QCPAbstractPaintBuffer::setSize(const QSize &size)
{
  if (mSize != size)
  {
    mSize = size;
    reallocateBuffer();
  }
}

/*!
  Sets the invalidated flag to \a invalidated.

  This mechanism is used internally in conjunction with isolated replotting of \ref QCPLayer
  instances (in \ref QCPLayer::lmBuffered mode). If \ref QCPLayer::replot is called on a buffered
  layer, i.e. an isolated repaint of only that layer (and its dedicated paint buffer) is requested,
  QCustomPlot will decide depending on the invalidated flags of other paint buffers whether it also
  replots them, instead of only the layer on which the replot was called.

  The invalidated flag is set to true when \ref QCPLayer association has changed, i.e. if layers
  were added or removed from this buffer, or if they were reordered. It is set to false as soon as
  all associated \ref QCPLayer instances are drawn onto the buffer.

  Under normal circumstances, it is not necessary to manually call this method.
*/
/*!
  invalidated 플래그를 \ a로 설정합니다.

  이 메커니즘은 \ ref QCPLayer의 격리 된 재구성과 함께 내부적으로 사용됩니다.
  인스턴스 (\ ref QCPLayer :: lmBuffered 모드). \ ref QCPLayer :: replot이 버퍼에 호출되면
  즉, 그 레이어 (및 그것의 전용 페인트 버퍼)의 고립 된 페인트 만이 요구된다면,
  QCustomPlot은 다른 페인트 버퍼의 무효화 된 플래그에 따라 결정합니다.
  replot가 호출 된 레이어 대신에 replot을 다시 만듭니다.

  무효화 된 플래그는 \ ref QCPLayer 연관이 변경되면 true로 설정됩니다. 즉, 레이어
  이 버퍼로부터 추가 또는 삭제되었을 경우, 또는 순서가 변경되었을 경우 하자마자 false로 설정됩니다.
  관련된 모든 \ ref QCPLayer 인스턴스가 버퍼에 그려집니다.

  정상적인 상황에서는이 메서드를 수동으로 호출 할 필요가 없습니다.
*/
void QCPAbstractPaintBuffer::setInvalidated(bool invalidated)
{
  mInvalidated = invalidated;
}

/*!
  Sets the the device pixel ratio to \a ratio. This is useful to render on high-DPI output devices.
  The ratio is automatically set to the device pixel ratio used by the parent QCustomPlot instance.

  The buffer is reallocated (by calling \ref reallocateBuffer), so any painters that were obtained
  by \ref startPainting are invalidated and must not be used after calling this method.

  \note This method is only available for Qt versions 5.4 and higher.
*/
/*!
  장치의 픽셀 비율을 \ a 비율로 설정합니다. 이것은 높은 DPI 출력 장치에서 렌더링 할 때 유용합니다.
  비율은 부모 QCustomPlot 인스턴스에서 사용하는 장치 픽셀 비율로 자동 설정됩니다.

  버퍼는 \ ref reallocateBuffer를 호출하여 재 할당되므로 획득 한 모든 페인터
  by \ ref startPainting은 무효화되므로이 메서드를 호출 한 후에 사용하면 안됩니다.

  \ note이 방법은 Qt 버전 5.4 이상에서만 사용할 수 있습니다.
*/
void QCPAbstractPaintBuffer::setDevicePixelRatio(double ratio)
{
  if (!qFuzzyCompare(ratio, mDevicePixelRatio))
  {
#ifdef QCP_DEVICEPIXELRATIO_SUPPORTED
    mDevicePixelRatio = ratio;
    reallocateBuffer();
#else
    qDebug() << Q_FUNC_INFO << "Device pixel ratios not supported for Qt versions before 5.4";
    mDevicePixelRatio = 1.0;
#endif
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPPaintBufferPixmap
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPPaintBufferPixmap
  \brief A paint buffer based on QPixmap, using software raster rendering

  This paint buffer is the default and fall-back paint buffer which uses software rendering and
  QPixmap as internal buffer. It is used if \ref QCustomPlot::setOpenGl is false.
*/
/*! \ class QCPPaintBufferPixmap
  \ brief 소프트웨어 래스터 렌더링을 사용하는 QPixmap 기반의 페인트 버퍼

  이 페인트 버퍼는 소프트웨어 렌더링을 사용하는 기본 및 폴백 (fall-back) 페인트 버퍼이며
  내부 버퍼로 QPixmap. \ ref QCustomPlot :: setOpenGl이 false 인 경우에 사용됩니다.
*/

/*!
  Creates a pixmap paint buffer instancen with the specified \a size and \a devicePixelRatio, if
  applicable.
*/
/*!
  지정된 \ a 크기 및 \ a devicePixelRatio를 사용하여 pixmap 페인트 버퍼 instancen을 만듭니다. if
  응용할 수 있는.
*/
QCPPaintBufferPixmap::QCPPaintBufferPixmap(const QSize &size, double devicePixelRatio) :
  QCPAbstractPaintBuffer(size, devicePixelRatio)
{
  QCPPaintBufferPixmap::reallocateBuffer();
}

QCPPaintBufferPixmap::~QCPPaintBufferPixmap()
{
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPPainter *QCPPaintBufferPixmap::startPainting()
{
  QCPPainter *result = new QCPPainter(&mBuffer);
  result->setRenderHint(QPainter::HighQualityAntialiasing);
  return result;
}

/* inherits documentation from base class */
 /* 기본 클래스에서 문서를 상속받습니다. */
void QCPPaintBufferPixmap::draw(QCPPainter *painter) const
{
  if (painter && painter->isActive())
    painter->drawPixmap(0, 0, mBuffer);
  else
    qDebug() << Q_FUNC_INFO << "invalid or inactive painter passed";
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPPaintBufferPixmap::clear(const QColor &color)
{
  mBuffer.fill(color);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPPaintBufferPixmap::reallocateBuffer()
{
  setInvalidated();
  if (!qFuzzyCompare(1.0, mDevicePixelRatio))
  {
#ifdef QCP_DEVICEPIXELRATIO_SUPPORTED
    mBuffer = QPixmap(mSize*mDevicePixelRatio);
    mBuffer.setDevicePixelRatio(mDevicePixelRatio);
#else
    qDebug() << Q_FUNC_INFO << "Device pixel ratios not supported for Qt versions before 5.4";
    mDevicePixelRatio = 1.0;
    mBuffer = QPixmap(mSize);
#endif
  } else
  {
    mBuffer = QPixmap(mSize);
  }
}


#ifdef QCP_OPENGL_PBUFFER
////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPPaintBufferGlPbuffer
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPPaintBufferGlPbuffer
  \brief A paint buffer based on OpenGL pixel buffers, using hardware accelerated rendering

  This paint buffer is one of the OpenGL paint buffers which facilitate hardware accelerated plot
  rendering. It is based on OpenGL pixel buffers (pbuffer) and is used in Qt versions before 5.0.
  (See \ref QCPPaintBufferGlFbo used in newer Qt versions.)

  The OpenGL paint buffers are used if \ref QCustomPlot::setOpenGl is set to true, and if they are
  supported by the system.
*/

/*!
  Creates a \ref QCPPaintBufferGlPbuffer instance with the specified \a size and \a
  devicePixelRatio, if applicable.

  The parameter \a multisamples defines how many samples are used per pixel. Higher values thus
  result in higher quality antialiasing. If the specified \a multisamples value exceeds the
  capability of the graphics hardware, the highest supported multisampling is used.
*/
/*! \ class QCPPaintBufferGlPbuffer
  \ brief OpenGL 픽셀 버퍼 기반의 페인트 버퍼, 하드웨어 가속 렌더링 사용

  이 페인트 버퍼는 하드웨어 가속화 된 플롯을 용이하게하는 OpenGL 페인트 버퍼 중 하나입니다
  표현. OpenGL 픽셀 버퍼 (pbuffer)를 기반으로하며 5.0 이전의 Qt 버전에서 사용됩니다.
  (최신 Qt 버전에서 사용 된 \ ref QCPPaintBufferGlFbo를 참조하십시오.)

  \ ref QCustomPlot :: setOpenGl이 true로 설정된 경우 OpenGL 페인트 버퍼가 사용되며,
  시스템이 지원합니다.
* /

/ *!
  지정된 \ a 크기 및 \ a로 \ ref QCPPaintBufferGlPbuffer 인스턴스를 만듭니다.
  devicePixelRatio (해당하는 경우).

  매개 변수 \ a multisamples는 픽셀 당 사용되는 샘플의 수를 정의합니다. 따라서 더 높은 값
  더 높은 품질의 앤티 앨리어싱을 만듭니다. 지정된 \ a 복수 샘플 값이
  그래픽 하드웨어의 기능을 지원하는 가장 높은 멀티 샘플링이 사용됩니다.
*/
QCPPaintBufferGlPbuffer::QCPPaintBufferGlPbuffer(const QSize &size, double devicePixelRatio, int multisamples) :
  QCPAbstractPaintBuffer(size, devicePixelRatio),
  mGlPBuffer(0),
  mMultisamples(qMax(0, multisamples))
{
  QCPPaintBufferGlPbuffer::reallocateBuffer();
}

QCPPaintBufferGlPbuffer::~QCPPaintBufferGlPbuffer()
{
  if (mGlPBuffer)
    delete mGlPBuffer;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPPainter *QCPPaintBufferGlPbuffer::startPainting()
{
  if (!mGlPBuffer->isValid())
  {
    qDebug() << Q_FUNC_INFO << "OpenGL frame buffer object doesn't exist, reallocateBuffer was not called?";
    return 0;
  }
  
  QCPPainter *result = new QCPPainter(mGlPBuffer);
  result->setRenderHint(QPainter::HighQualityAntialiasing);
  return result;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPPaintBufferGlPbuffer::draw(QCPPainter *painter) const
{
  if (!painter || !painter->isActive())
  {
    qDebug() << Q_FUNC_INFO << "invalid or inactive painter passed";
    return;
  }
  if (!mGlPBuffer->isValid())
  {
    qDebug() << Q_FUNC_INFO << "OpenGL pbuffer isn't valid, reallocateBuffer was not called?";
    return;
  }
  painter->drawImage(0, 0, mGlPBuffer->toImage());
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPPaintBufferGlPbuffer::clear(const QColor &color)
{
  if (mGlPBuffer->isValid())
  {
    mGlPBuffer->makeCurrent();
    glClearColor(color.redF(), color.greenF(), color.blueF(), color.alphaF());
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    mGlPBuffer->doneCurrent();
  } else
    qDebug() << Q_FUNC_INFO << "OpenGL pbuffer invalid or context not current";
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPPaintBufferGlPbuffer::reallocateBuffer()
{
  if (mGlPBuffer)
    delete mGlPBuffer;
  
  QGLFormat format;
  format.setAlpha(true);
  format.setSamples(mMultisamples);
  mGlPBuffer = new QGLPixelBuffer(mSize, format);
}
#endif // QCP_OPENGL_PBUFFER


#ifdef QCP_OPENGL_FBO
////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPPaintBufferGlFbo
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPPaintBufferGlFbo
  \brief A paint buffer based on OpenGL frame buffers objects, using hardware accelerated rendering

  This paint buffer is one of the OpenGL paint buffers which facilitate hardware accelerated plot
  rendering. It is based on OpenGL frame buffer objects (fbo) and is used in Qt versions 5.0 and
  higher. (See \ref QCPPaintBufferGlPbuffer used in older Qt versions.)

  The OpenGL paint buffers are used if \ref QCustomPlot::setOpenGl is set to true, and if they are
  supported by the system.
*/
/*! \ class QCPPaintBufferGlFbo
  \ brief OpenGL 프레임 버퍼 객체를 기반으로 한 페인트 버퍼, 하드웨어 가속 렌더링 사용

  이 페인트 버퍼는 하드웨어 가속화 된 플롯을 용이하게하는 OpenGL 페인트 버퍼 중 하나입니다
  표현. OpenGL 프레임 버퍼 객체 (fbo)를 기반으로하며 Qt 버전 5.0 및
  더 높은. (구 Qt 버전에서 사용 된 \ ref QCPPaintBufferGlPbuffer를 참조하십시오.)

  \ ref QCustomPlot :: setOpenGl이 true로 설정된 경우 OpenGL 페인트 버퍼가 사용되며,
  시스템이 지원합니다.
*/

/*!
  Creates a \ref QCPPaintBufferGlFbo instance with the specified \a size and \a devicePixelRatio,
  if applicable.

  All frame buffer objects shall share one OpenGL context and paint device, which need to be set up
  externally and passed via \a glContext and \a glPaintDevice. The set-up is done in \ref
  QCustomPlot::setupOpenGl and the context and paint device are managed by the parent QCustomPlot
  instance.
*/
/*!
  지정된 \ a 크기 및 \ a devicePixelRatio를 사용하여 \ ref QCPPaintBufferGlFbo 인스턴스를 만듭니다.
  적용된다면.

  모든 프레임 버퍼 객체는 하나의 OpenGL 컨텍스트와 페인트 장치를 공유해야한다.
  외부 적으로 glContext와 glPaintDevice를 통해 전달된다. 설정은 \ ref에서 수행됩니다.
  QCustomPlot :: setupOpenGl 및 컨텍스트 및 페인트 장치는 부모 QCustomPlot에 의해 관리됩니다
  예.
*/
QCPPaintBufferGlFbo::QCPPaintBufferGlFbo(const QSize &size, double devicePixelRatio, QWeakPointer<QOpenGLContext> glContext, QWeakPointer<QOpenGLPaintDevice> glPaintDevice) :
  QCPAbstractPaintBuffer(size, devicePixelRatio),
  mGlContext(glContext),
  mGlPaintDevice(glPaintDevice),
  mGlFrameBuffer(0)
{
  QCPPaintBufferGlFbo::reallocateBuffer();
}

QCPPaintBufferGlFbo::~QCPPaintBufferGlFbo()
{
  if (mGlFrameBuffer)
    delete mGlFrameBuffer;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPPainter *QCPPaintBufferGlFbo::startPainting()
{
  if (mGlPaintDevice.isNull())
  {
    qDebug() << Q_FUNC_INFO << "OpenGL paint device doesn't exist";
    return 0;
  }
  if (!mGlFrameBuffer)
  {
    qDebug() << Q_FUNC_INFO << "OpenGL frame buffer object doesn't exist, reallocateBuffer was not called?";
    return 0;
  }
  
  if (QOpenGLContext::currentContext() != mGlContext.data())
    mGlContext.data()->makeCurrent(mGlContext.data()->surface());
  mGlFrameBuffer->bind();
  QCPPainter *result = new QCPPainter(mGlPaintDevice.data());
  result->setRenderHint(QPainter::HighQualityAntialiasing);
  return result;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPPaintBufferGlFbo::donePainting()
{
  if (mGlFrameBuffer && mGlFrameBuffer->isBound())
    mGlFrameBuffer->release();
  else
    qDebug() << Q_FUNC_INFO << "Either OpenGL frame buffer not valid or was not bound";
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPPaintBufferGlFbo::draw(QCPPainter *painter) const
{
  if (!painter || !painter->isActive())
  {
    qDebug() << Q_FUNC_INFO << "invalid or inactive painter passed";
    return;
  }
  if (!mGlFrameBuffer)
  {
    qDebug() << Q_FUNC_INFO << "OpenGL frame buffer object doesn't exist, reallocateBuffer was not called?";
    return;
  }
  painter->drawImage(0, 0, mGlFrameBuffer->toImage());
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPPaintBufferGlFbo::clear(const QColor &color)
{
  if (mGlContext.isNull())
  {
    qDebug() << Q_FUNC_INFO << "OpenGL context doesn't exist";
    return;
  }
  if (!mGlFrameBuffer)
  {
    qDebug() << Q_FUNC_INFO << "OpenGL frame buffer object doesn't exist, reallocateBuffer was not called?";
    return;
  }
  
  if (QOpenGLContext::currentContext() != mGlContext.data())
    mGlContext.data()->makeCurrent(mGlContext.data()->surface());
  mGlFrameBuffer->bind();
  glClearColor(color.redF(), color.greenF(), color.blueF(), color.alphaF());
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  mGlFrameBuffer->release();
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPPaintBufferGlFbo::reallocateBuffer()
{
  // release and delete possibly existing framebuffer:
  // 기존 프레임 버퍼를 해제하고 삭제합니다.
  if (mGlFrameBuffer)
  {
    if (mGlFrameBuffer->isBound())
      mGlFrameBuffer->release();
    delete mGlFrameBuffer;
    mGlFrameBuffer = 0;
  }
  
  if (mGlContext.isNull())
  {
    qDebug() << Q_FUNC_INFO << "OpenGL context doesn't exist";
    return;
  }
  if (mGlPaintDevice.isNull())
  {
    qDebug() << Q_FUNC_INFO << "OpenGL paint device doesn't exist";
    return;
  }
  
  // create new fbo with appropriate size:
  // 적절한 크기로 새 fbo를 만듭니다.
  mGlContext.data()->makeCurrent(mGlContext.data()->surface());
  QOpenGLFramebufferObjectFormat frameBufferFormat;
  frameBufferFormat.setSamples(mGlContext.data()->format().samples());
  frameBufferFormat.setAttachment(QOpenGLFramebufferObject::CombinedDepthStencil);
  mGlFrameBuffer = new QOpenGLFramebufferObject(mSize*mDevicePixelRatio, frameBufferFormat);
  if (mGlPaintDevice.data()->size() != mSize*mDevicePixelRatio)
    mGlPaintDevice.data()->setSize(mSize*mDevicePixelRatio);
#ifdef QCP_DEVICEPIXELRATIO_SUPPORTED
  mGlPaintDevice.data()->setDevicePixelRatio(mDevicePixelRatio);
#endif
}
#endif // QCP_OPENGL_FBO
/* end of 'src/paintbuffer.cpp' */


/* including file 'src/layer.cpp', size 37064                                */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / paintbuffer.cpp'의 끝 */


/* 파일 'src / layer.cpp'포함, 크기 37064 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPLayer
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPLayer
  \brief A layer that may contain objects, to control the rendering order

  The Layering system of QCustomPlot is the mechanism to control the rendering order of the
  elements inside the plot.

  It is based on the two classes QCPLayer and QCPLayerable. QCustomPlot holds an ordered list of
  one or more instances of QCPLayer (see QCustomPlot::addLayer, QCustomPlot::layer,
  QCustomPlot::moveLayer, etc.). When replotting, QCustomPlot goes through the list of layers
  bottom to top and successively draws the layerables of the layers into the paint buffer(s).

  A QCPLayer contains an ordered list of QCPLayerable instances. QCPLayerable is an abstract base
  class from which almost all visible objects derive, like axes, grids, graphs, items, etc.

  \section qcplayer-defaultlayers Default layers

  Initially, QCustomPlot has six layers: "background", "grid", "main", "axes", "legend" and
  "overlay" (in that order). On top is the "overlay" layer, which only contains the QCustomPlot's
  selection rect (\ref QCustomPlot::selectionRect). The next two layers "axes" and "legend" contain
  the default axes and legend, so they will be drawn above plottables. In the middle, there is the
  "main" layer. It is initially empty and set as the current layer (see
  QCustomPlot::setCurrentLayer). This means, all new plottables, items etc. are created on this
  layer by default. Then comes the "grid" layer which contains the QCPGrid instances (which belong
  tightly to QCPAxis, see \ref QCPAxis::grid). The Axis rect background shall be drawn behind
  everything else, thus the default QCPAxisRect instance is placed on the "background" layer. Of
  course, the layer affiliation of the individual objects can be changed as required (\ref
  QCPLayerable::setLayer).

  \section qcplayer-ordering Controlling the rendering order via layers

  Controlling the ordering of layerables in the plot is easy: Create a new layer in the position
  you want the layerable to be in, e.g. above "main", with \ref QCustomPlot::addLayer. Then set the
  current layer with \ref QCustomPlot::setCurrentLayer to that new layer and finally create the
  objects normally. They will be placed on the new layer automatically, due to the current layer
  setting. Alternatively you could have also ignored the current layer setting and just moved the
  objects with \ref QCPLayerable::setLayer to the desired layer after creating them.

  It is also possible to move whole layers. For example, If you want the grid to be shown in front
  of all plottables/items on the "main" layer, just move it above "main" with
  QCustomPlot::moveLayer.

  The rendering order within one layer is simply by order of creation or insertion. The item
  created last (or added last to the layer), is drawn on top of all other objects on that layer.

  When a layer is deleted, the objects on it are not deleted with it, but fall on the layer below
  the deleted layer, see QCustomPlot::removeLayer.

  \section qcplayer-buffering Replotting only a specific layer

  If the layer mode (\ref setMode) is set to \ref lmBuffered, you can replot only this specific
  layer by calling \ref replot. In certain situations this can provide better replot performance,
  compared with a full replot of all layers. Upon creation of a new layer, the layer mode is
  initialized to \ref lmLogical. The only layer that is set to \ref lmBuffered in a new \ref
  QCustomPlot instance is the "overlay" layer, containing the selection rect.
*/
/*! \ class QCPLayer
  \ brief 렌더링 순서를 제어하기 위해 객체를 포함 할 수있는 레이어

  QCustomPlot의 레이어링 시스템은 레이어의 렌더링 순서를 제어하는 ​​메커니즘입니다.
  줄거리 내부의 요소.

  QCPLayer와 QCPLayerable의 두 클래스를 기반으로합니다. QCustomPlot은 다음의 순서 목록을 보유합니다.
  하나 이상의 QCPLayer 인스턴스 (QCustomPlot :: addLayer, QCustomPlot :: layer,
  QCustomPlot :: moveLayer 등). 다시 칠할 때 QCustomPlot은 레이어 목록을 통과합니다.
  아래에서 위로 그리고 연속적으로 레이어의 계층을 페인트 버퍼에 그립니다.

  QCPLayer는 QCPLayerable 인스턴스의 정렬 된 목록을 포함합니다. QCPLayerable은 추상 기반입니다.
  그리드, 그래프, 항목 등과 같이 거의 모든 시각적 객체가 파생되는 클래스입니다.

  \ section qcplayer-defaultlayers 기본 레이어

  처음에는 QCustomPlot에 "배경", "그리드", "메인", "축", "범례"및
  "오버레이"(그 순서대로). 맨 위에는 QCustomPlot의 요소 만 들어있는 "오버레이"레이어가 있습니다.
  선택 rect (\ ref QCustomPlot :: selectionRect). 다음 두 개의 레이어 "축"및 "범례"에는
  기본 축과 범례는 플롯 테이블 위에 그려집니다. 중간에
  "메인"레이어. 처음에는 비어 있으며 현재 레이어로 설정됩니다 (
  QCustomPlot :: setCurrentLayer). 즉, 모든 새 플롯 테이블, 항목 등이 여기에 생성됩니다.
  기본적으로 레이어입니다. 그런 다음 QCPGrid 인스턴스가 포함 된 "그리드"
  QCPAxis와 밀접하게 관련되어있다. \ ref QCPAxis :: grid 참조). 축의 직사각형 배경이 뒤에 그려야한다.
  다른 모든 것, 따라서 기본 QCPAxisRect 인스턴스는 "배경"레이어에 배치됩니다. 의
  물론, 개별 객체의 계층 소속은 필요에 따라 변경할 수 있습니다 (\ ref
  QCPLayerable :: setLayer).

  \ section qcplayer-ordering 레이어를 통한 렌더링 순서 제어

  플롯에서 레이어 가능 항목의 순서 제어가 쉽습니다. 위치에 새 레이어 만들기
  layerable이 \ main QCustomPlot :: addLayer와 같이 "main"위에 있어야합니다. 그런 다음
  현재 레이어를 \ ref QCustomPlot :: setCurrentLayer로 새 레이어로 만들고 마지막으로
  일반적으로 개체. 현재 레이어로 인해 새 레이어에 자동으로 배치됩니다.
  환경. 또는 현재 레이어 설정을 무시하고
  \ ref QCPLayerable :: setLayer가있는 객체를 만든 후 원하는 레이어로 이동합니다.

  전체 레이어를 이동할 수도 있습니다. 예를 들어, 격자를 앞에 표시하려면
  "메인"레이어에있는 모든 플롯 테이블 / 항목 중 "메인"레이어 위로 이동하십시오.
  QCustomPlot :: moveLayer.

  한 레이어 내의 렌더링 순서는 단순히 생성 또는 삽입 순서에 의한 것입니다. 그 아이템
  마지막으로 생성 된 (또는 마지막으로 레이어에 추가 된) 객체는 해당 레이어의 다른 모든 객체 위에 그려집니다.

  레이어가 삭제되면 해당 레이어의 오브젝트는 삭제되지 않고 아래 레이어에 위치합니다.
  삭제 된 레이어는 QCustomPlot :: removeLayer를 참조하십시오.

  \ section qcplayer-buffering 특정 레이어 만 바꾸기

  레이어 모드 (\ ref setMode)가 \ ref lmBuffered로 설정된 경우이 특정
  \ ref replot을 호출하여 특정 상황에서 이것은 더 나은 replot 성능을 제공 할 수 있습니다.
  모든 레이어의 전체 복제본과 비교합니다. 새 레이어를 만들 때 레이어 모드는 다음과 같습니다.
  \ refLmLogical로 초기화됩니다. \ ref에 설정되어있는 유일한 레이어는 새로운 \ ref에 버퍼링됩니다.
  QCustomPlot 인스턴스는 선택 영역 rect가 포함 된 "오버레이"레이어입니다.
*/

/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */

/*! \fn QList<QCPLayerable*> QCPLayer::children() const
  
  Returns a list of all layerables on this layer. The order corresponds to the rendering order:
  layerables with higher indices are drawn above layerables with lower indices.
*/
/*! \ fn QList <QCPLayerable *> QCPLayer :: children () const
  
  이 레이어의 모든 레이어 가능 요소 목록을 반환합니다. 순서는 렌더링 순서에 해당합니다.
  더 높은 인덱스를 가진 레이어 가능 요소는 더 낮은 인덱스를 가진 계층 가능 요소 위에 그려집니다.
*/


/*! \fn int QCPLayer::index() const
  
  Returns the index this layer has in the QCustomPlot. The index is the integer number by which this layer can be
  accessed via \ref QCustomPlot::layer.
  
  Layers with higher indices will be drawn above layers with lower indices.
*/
/*! \ fn int QCPLayer :: index () const
  
  이 레이어가 QCustomPlot에 가지고있는 인덱스를 반환합니다. 색인은이 계층이 될 수있는 정수입니다.
  \ ref QCustomPlot :: layer를 통해 액세스 할 수 있습니다.
  
  더 높은 인덱스를 가진 레이어는 더 낮은 인덱스로 레이어 위에 그려집니다.
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */

/*!
  Creates a new QCPLayer instance.
  
  Normally you shouldn't directly instantiate layers, use \ref QCustomPlot::addLayer instead.
  
  \warning It is not checked that \a layerName is actually a unique layer name in \a parentPlot.
  This check is only performed by \ref QCustomPlot::addLayer.
*/
/*!
  새 QCPLayer 인스턴스를 만듭니다.
  
  일반적으로 직접 레이어를 인스턴스화해서는 안되며 \ ref QCustomPlot :: addLayer를 대신 사용하십시오.
  
  \ warning layerName이 실제로 parentPlot의 고유 한 레이어 이름인지 확인하지 않습니다.
  이 검사는 \ ref QCustomPlot :: addLayer에 의해서만 수행됩니다.
*/

QCPLayer::QCPLayer(QCustomPlot *parentPlot, const QString &layerName) :
  QObject(parentPlot),
  mParentPlot(parentPlot),
  mName(layerName),
  mIndex(-1),    // will be set to a proper value by the QCustomPlot layer creation function
  mVisible(true),// QCustomPlot 레이어 작성 기능에 의해 적절한 값으로 설정됩니다.
  mMode(lmLogical)
{
  // Note: no need to make sure layerName is unique, because layer
  // management is done with QCustomPlot functions.
  // 참고 : layerName이 고유하다는 것을 확인할 필요가 없습니다. 왜냐하면 layer
  // 관리는 QCustomPlot 함수로 수행됩니다.
}

QCPLayer::~QCPLayer()
{
  // If child layerables are still on this layer, detach them, so they don't try to reach back to this
  // then invalid layer once they get deleted/moved themselves. This only happens when layers are deleted
  // directly, like in the QCustomPlot destructor. (The regular layer removal procedure for the user is to
  // call QCustomPlot::removeLayer, which moves all layerables off this layer before deleting it.)
  // 하위 레이어가 여전히이 레이어에있는 경우 분리 할 수 ​​있으므로 다시이 레이어에 도달하려고하지 않습니다.
  // 일단 삭제되거나 이동되면 무효화 된 레이어. 이것은 레이어가 삭제 된 경우에만 발생합니다.
  // QCustomPlot 소멸자와 같이 직접적으로. (사용자를위한 일반 레이어 제거 절차는
  // QCustomPlot :: removeLayer를 호출하면 모든 레이어 가능 항목이 삭제되기 전에이 레이어에서 제거됩니다.)
  while (!mChildren.isEmpty())
    mChildren.last()->setLayer(0); // removes itself from mChildren via removeChild()
                                   // removeChild ()를 통해 mChildren에서 자신을 제거합니다.
  if (mParentPlot->currentLayer() == this)
    qDebug() << Q_FUNC_INFO << "The parent plot's mCurrentLayer will be a dangling pointer. Should have been set to a valid layer or 0 beforehand.";
}

/*!
  Sets whether this layer is visible or not. If \a visible is set to false, all layerables on this
  layer will be invisible.

  This function doesn't change the visibility property of the layerables (\ref
  QCPLayerable::setVisible), but the \ref QCPLayerable::realVisibility of each layerable takes the
  visibility of the parent layer into account.
*/
/*!
  이 레이어를 표시할지 여부를 설정합니다. \ visible이 false로 설정되면, 이것의 모든 layerable
  레이어가 보이지 않게됩니다.

  이 함수는 레이어 가능 요소의 가시성 속성을 변경하지 않습니다 (\ ref
  QCPLayerable :: setVisible), 각 레이어 가능 요소의 \ ref QCPLayerable :: realVisibility는
  상위 계층의 가시성을 고려합니다.
*/
void QCPLayer::setVisible(bool visible)
{
  mVisible = visible;
}

/*!
  Sets the rendering mode of this layer.

  If \a mode is set to \ref lmBuffered for a layer, it will be given a dedicated paint buffer by
  the parent QCustomPlot instance. This means it may be replotted individually by calling \ref
  QCPLayer::replot, without needing to replot all other layers.

  Layers which are set to \ref lmLogical (the default) are used only to define the rendering order
  and can't be replotted individually.

  Note that each layer which is set to \ref lmBuffered requires additional paint buffers for the
  layers below, above and for the layer itself. This increases the memory consumption and
  (slightly) decreases the repainting speed because multiple paint buffers need to be joined. So
  you should carefully choose which layers benefit from having their own paint buffer. A typical
  example would be a layer which contains certain layerables (e.g. items) that need to be changed
  and thus replotted regularly, while all other layerables on other layers stay static. By default,
  only the topmost layer called "overlay" is in mode \ref lmBuffered, and contains the selection
  rect.

  \see replot
*/
/*!
  이 레이어의 렌더링 모드를 설정합니다.

  \ a 모드가 레이어에 대해 \ ref lmBuffered로 설정된 경우에는 다음과 같은 전용 페인트 버퍼가 제공됩니다.
  상위 QCustomPlot 인스턴스 이것은 \ ref를 호출하여 개별적으로 재구성 될 수 있음을 의미합니다.
  다른 모든 레이어를 다시 칠할 필요없이 QCPLayer :: replot.

  \ ref lmLogical (기본값)으로 설정된 레이어는 렌더링 순서를 정의하는 데에만 사용됩니다
  개별적으로 재 채취 할 수는 없습니다.

  \ ref lmBuffered로 설정된 각 레이어는
  아래, 위 및 레이어 자체에 대해 이것은 메모리 소비를 증가시키고
  (약간) 페인트 속도가 느려지므로 여러 페인트 버퍼를 조인해야합니다. 그래서
  당신은주의 깊게 자신의 페인트 버퍼를 갖는 것이 유리한 레이어를 선택해야한다. 전형적인
  예는 변경해야 할 특정 레이어 가능 요소 (예 : 항목)를 포함하는 레이어입니다.
  다른 레이어의 다른 모든 레이어 가능 항목은 고정 된 상태로 유지됩니다. 기본적으로,
  "overlay"라고 불리는 최상위 레이어 만이 \ ref lmBuffered 모드에 있고 선택 항목을 포함합니다
  rect.

  \ 복제본보기
*/
void QCPLayer::setMode(QCPLayer::LayerMode mode)
{
  if (mMode != mode)
  {
    mMode = mode;
    if (!mPaintBuffer.isNull())
      mPaintBuffer.data()->setInvalidated();
  }
}

/*! \internal

  Draws the contents of this layer with the provided \a painter.

  \see replot, drawToPaintBuffer
*/
/*! \내부의

  제공된 화가를 사용하여이 레이어의 내용을 그립니다.

  \ replot, drawToPaintBuffer를 보아라.
*/
void QCPLayer::draw(QCPPainter *painter)
{
  foreach (QCPLayerable *child, mChildren)
  {
    if (child->realVisibility())
    {
      painter->save();
      painter->setClipRect(child->clipRect().translated(0, -1));
      child->applyDefaultAntialiasingHint(painter);
      child->draw(painter);
      painter->restore();
    }
  }
}

/*! \internal

  Draws the contents of this layer into the paint buffer which is associated with this layer. The
  association is established by the parent QCustomPlot, which manages all paint buffers (see \ref
  QCustomPlot::setupPaintBuffers).

  \see draw
*/
/*! \내부의

  이 레이어의 내용을이 레이어와 연결된 페인트 버퍼에 그립니다. 그만큼
  연관은 모든 페인트 버퍼를 관리하는 상위 QCustomPlot에 의해 설정됩니다 (\ ref 참조).
  QCustomPlot :: setupPaintBuffers).

  \ 그림 그리기
*/
void QCPLayer::drawToPaintBuffer()
{
  if (!mPaintBuffer.isNull())
  {
    if (QCPPainter *painter = mPaintBuffer.data()->startPainting())
    {
      if (painter->isActive())
        draw(painter);
      else
        qDebug() << Q_FUNC_INFO << "paint buffer returned inactive painter";
      delete painter;
      mPaintBuffer.data()->donePainting();
    } else
      qDebug() << Q_FUNC_INFO << "paint buffer returned zero painter";
  } else
    qDebug() << Q_FUNC_INFO << "no valid paint buffer associated with this layer";
}

/*!
  If the layer mode (\ref setMode) is set to \ref lmBuffered, this method allows replotting only
  the layerables on this specific layer, without the need to replot all other layers (as a call to
  \ref QCustomPlot::replot would do).

  If the layer mode is \ref lmLogical however, this method simply calls \ref QCustomPlot::replot on
  the parent QCustomPlot instance.

  QCustomPlot also makes sure to replot all layers instead of only this one, if the layer ordering
  has changed since the last full replot and the other paint buffers were thus invalidated.

  \see draw
*/
/*!
  레이어 모드 (\ ref setMode)가 \ ref lmBuffered로 설정된 경우이 메서드는 다시 채우기 만 허용합니다.
  이 특정 레이어의 레이어 가능 요소는 다른 모든 레이어를 다시 칠할 필요가 없습니다 (
  \ ref QCustomPlot :: replot).

  그러나 레이어 모드가 \ ref lmLogical 인 경우이 메서드는 단순히 \ ref QCustomPlot :: replot on을 호출합니다.
  상위 QCustomPlot 인스턴스

  QCustomPlot은 레이어 순서 지정이 모든 레이어를이 레이어 만 복제하지 않도록합니다.
  마지막 전체 복제본 이후 변경되었고 다른 페인트 버퍼는 무효화되었습니다.

  \ 그림 그리기
*/
void QCPLayer::replot()
{
  if (mMode == lmBuffered && !mParentPlot->hasInvalidatedPaintBuffers())
  {
    if (!mPaintBuffer.isNull())
    {
      mPaintBuffer.data()->clear(Qt::transparent);
      drawToPaintBuffer();
      mPaintBuffer.data()->setInvalidated(false);
      mParentPlot->update();
    } else
      qDebug() << Q_FUNC_INFO << "no valid paint buffer associated with this layer";
  } else if (mMode == lmLogical)
    mParentPlot->replot();
}

/*! \internal
  
  Adds the \a layerable to the list of this layer. If \a prepend is set to true, the layerable will
  be prepended to the list, i.e. be drawn beneath the other layerables already in the list.
  
  This function does not change the \a mLayer member of \a layerable to this layer. (Use
  QCPLayerable::setLayer to change the layer of an object, not this function.)
  
  \see removeChild
*/
/*! \내부의
  
  이 레이어 목록에 레이어 가능 요소를 추가합니다. \ a prepend가 true로 설정되면 레이어 가능 요소는
  리스트에 이미 추가되어있다. 즉, 이미리스트에있는 다른 레이어 가능 요소 아래에 그려진다.
  
  이 함수는이 레이어에 \ 레이어 멤버를 변경하지 않습니다. (용도
  QCPLayerable :: setLayer를 사용하면이 함수가 아니라 객체의 레이어를 변경할 수 있습니다.
  
  \ see removeChild
*/
void QCPLayer::addChild(QCPLayerable *layerable, bool prepend)
{
  if (!mChildren.contains(layerable))
  {
    if (prepend)
      mChildren.prepend(layerable);
    else
      mChildren.append(layerable);
    if (!mPaintBuffer.isNull())
      mPaintBuffer.data()->setInvalidated();
  } else
    qDebug() << Q_FUNC_INFO << "layerable is already child of this layer" << reinterpret_cast<quintptr>(layerable);
}

/*! \internal
  
  Removes the \a layerable from the list of this layer.
  
  This function does not change the \a mLayer member of \a layerable. (Use QCPLayerable::setLayer
  to change the layer of an object, not this function.)
  
  \see addChild
*/
/*! \내부의
  
  이 레이어 목록에서 레이어 가능 요소를 제거합니다.
  
  이 함수는 \ layerable의 mLayer 멤버를 변경하지 않습니다. (QCPLayerable :: setLayer 사용
  이 함수가 아니라 객체의 레이어를 변경합니다.)
  
  \ see addChild
*/
void QCPLayer::removeChild(QCPLayerable *layerable)
{
  if (mChildren.removeOne(layerable))
  {
    if (!mPaintBuffer.isNull())
      mPaintBuffer.data()->setInvalidated();
  } else
    qDebug() << Q_FUNC_INFO << "layerable is not child of this layer" << reinterpret_cast<quintptr>(layerable);
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPLayerable
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPLayerable
  \brief Base class for all drawable objects
  
  This is the abstract base class most visible objects derive from, e.g. plottables, axes, grid
  etc.

  Every layerable is on a layer (QCPLayer) which allows controlling the rendering order by stacking
  the layers accordingly.
  
  For details about the layering mechanism, see the QCPLayer documentation.
*/
/*! \ class QCPLayerable
  \ brief 모든 그리기 가능 객체의 기본 클래스
  
  이것은 가장 많이 보이는 객체 (예 : plottables, axes, grid)를 파생시키는 추상 기본 클래스입니다.
  기타

  모든 레이어 가능 요소는 레이어 (QCPLayer)에있어 레이어를 스태킹하여 렌더링 순서를 제어 할 수 있습니다.
  그에 따라 레이어.
  
  레이어 메커니즘에 대한 자세한 내용은 QCPLayer 설명서를 참조하십시오.
*/

/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */

/*! \fn QCPLayerable *QCPLayerable::parentLayerable() const
 
  Returns the parent layerable of this layerable. The parent layerable is used to provide
  visibility hierarchies in conjunction with the method \ref realVisibility. This way, layerables
  only get drawn if their parent layerables are visible, too.
  
  Note that a parent layerable is not necessarily also the QObject parent for memory management.
  Further, a layerable doesn't always have a parent layerable, so this function may return 0.
  
  A parent layerable is set implicitly when placed inside layout elements and doesn't need to be
  set manually by the user.
*/
/*! \ fn QCPLayerable * QCPLayerable :: parentLayerable () const
 
  이 계층화 가능 객체의 부모 layerable을 리턴합니다. 부모 레이어 가능은
  \ ref realVisibility 메서드와 함께 가시성 계층 구조. 이 방법은 layerables
  부모 레이어를 볼 수있는 경우에만 그려집니다.
  
  부모 레이어는 메모리 관리를위한 QObject 부모 일 필요는 없습니다.
  또한 레이어 가능 요소는 항상 부모 레이어를 가질 수있는 것은 아니므로이 함수는 0을 반환 할 수 있습니다.
  
  부모 레이어는 레이아웃 요소 안에 배치 될 때 암시 적으로 설정되며 반드시 필요하지는 않습니다.
  사용자가 수동으로 설정합니다.
*/

/* end documentation of inline functions */
/* start documentation of pure virtual functions */
/* 인라인 함수의 끝 문서화 */
/* 순수 가상 함수의 시작 문서*/

/*! \fn virtual void QCPLayerable::applyDefaultAntialiasingHint(QCPPainter *painter) const = 0
  \internal
  
  This function applies the default antialiasing setting to the specified \a painter, using the
  function \ref applyAntialiasingHint. It is the antialiasing state the painter is put in, when
  \ref draw is called on the layerable. If the layerable has multiple entities whose antialiasing
  setting may be specified individually, this function should set the antialiasing state of the
  most prominent entity. In this case however, the \ref draw function usually calls the specialized
  versions of this function before drawing each entity, effectively overriding the setting of the
  default antialiasing hint.
  
  <b>First example:</b> QCPGraph has multiple entities that have an antialiasing setting: The graph
  line, fills and scatters. Those can be configured via QCPGraph::setAntialiased,
  QCPGraph::setAntialiasedFill and QCPGraph::setAntialiasedScatters. Consequently, there isn't only
  the QCPGraph::applyDefaultAntialiasingHint function (which corresponds to the graph line's
  antialiasing), but specialized ones like QCPGraph::applyFillAntialiasingHint and
  QCPGraph::applyScattersAntialiasingHint. So before drawing one of those entities, QCPGraph::draw
  calls the respective specialized applyAntialiasingHint function.
  
  <b>Second example:</b> QCPItemLine consists only of a line so there is only one antialiasing
  setting which can be controlled with QCPItemLine::setAntialiased. (This function is inherited by
  all layerables. The specialized functions, as seen on QCPGraph, must be added explicitly to the
  respective layerable subclass.) Consequently it only has the normal
  QCPItemLine::applyDefaultAntialiasingHint. The \ref QCPItemLine::draw function doesn't need to
  care about setting any antialiasing states, because the default antialiasing hint is already set
  on the painter when the \ref draw function is called, and that's the state it wants to draw the
  line with.
*/
/*! \ fn 가상 무효 QCPLayerable :: applyDefaultAntialiasingHint (QCPPainter * painter) const = 0
  \내부의
  
  이 함수는 지정된 앤티 앨리어싱 설정을 지정한 \ painter에 적용합니다.
  함수 \ ref applyAntialiasingHint입니다. 화가가 넣은 에일리어싱 상태입니다.
  layerable에 \ ref draw가 호출됩니다. 계층화 가능 항목에 앤티 앨리어싱이있는 여러 엔터티가있는 경우
  설정을 개별적으로 지정할 수 있습니다.이 함수는
  가장 눈에 띄는 존재. 그러나이 경우 \ ref draw 함수는 일반적으로 특수 함수를 호출합니다.
  각 엔티티를 그리기 전에이 함수의 버전을 사용하여 효과적으로
  기본 안티 앨리어싱 힌트.
  
  <b> 첫 번째 예 : </ b> QCPGraph에는 앤티 엘리 어싱 설정이있는 여러 항목이 있습니다. 그래프
  라인, 채우기 및 분산. 이것들은 QCPGraph :: setAntialiased,
  QCPGraph :: setAntialiasedFill 및 QCPGraph :: setAntialiasedScatters. 결과적으로,
  QCPGraph :: applyDefaultAntialiasingHint 함수 (그래프 라인의
  안티 앨리어싱), QCPGraph :: applyFillAntialiasingHint 및
  QCPGraph :: applyScattersAntialiasingHint. 그래서 엔티티 중 하나를 그리기 전에 QCPGraph :: draw
  각각의 특수한 applyAntialiasingHint 함수를 호출합니다.
  
  <b> 두 번째 예 : </ b> QCPItemLine은 한 줄로 구성되어 있으므로 하나의 앤티 앨리어싱 만 있습니다.
  설정은 QCPItemLine :: setAntialiased로 제어 할 수 있습니다. (이 함수는
  모든 layerable. 특수 기능은 QCPGraph에서 볼 수 있듯이 명시 적으로
  각각의 레이어 가능 하위 클래스). 따라서 정상적인
  QCPItemLine :: applyDefaultAntialiasingHint. \ ref QCPItemLine :: draw 함수는 필요하지 않습니다.
  기본 안티 앨리어싱 힌트가 이미 설정되어 있으므로 앤티 엘리 어싱 상태를 설정하는 데 신경을 써야합니다.
  화가가 \ ref draw 함수가 호출 될 때, 그 상태가 그리기를 원한다.
  라인.
*/

/*! \fn virtual void QCPLayerable::draw(QCPPainter *painter) const = 0
  \internal
  
  This function draws the layerable with the specified \a painter. It is only called by
  QCustomPlot, if the layerable is visible (\ref setVisible).
  
  Before this function is called, the painter's antialiasing state is set via \ref
  applyDefaultAntialiasingHint, see the documentation there. Further, the clipping rectangle was
  set to \ref clipRect.
*/
/*! \ fn 가상 무효 QCPLayerable :: draw (QCPPainter * painter) const = 0
  \내부의
  
  이 함수는 지정된 \ a 페인터로 레이어 가능 요소를 그립니다. 그것은에 의해서만 불린다.
  QCablePlot, 레이어 가능이 표시되면 (\ ref setVisible).
  
  이 함수가 호출되기 전에 화가의 앤티 엘리 어싱 상태는 \ ref를 통해 설정됩니다
  applyDefaultAntialiasingHint를 참조하십시오. 또한, 클리핑 직사각형은
  \ ref clipRect로 설정합니다.
*/

/* end documentation of pure virtual functions */
/* start documentation of signals */
/* 순수 가상 함수의 끝 문서 */
/* 신호의 문서화를 시작한다. */

/*! \fn void QCPLayerable::layerChanged(QCPLayer *newLayer);
  
  This signal is emitted when the layer of this layerable changes, i.e. this layerable is moved to
  a different layer.
  
  \see setLayer
*/
/*! \ fn void QCPLayerable :: layerChanged (QCPLayer * newLayer);
  
  이 레이어 가능 레이어가 변경되면이 신호가 방출됩니다. 즉이 레이어 가능 요소는
  다른 레이어입니다.
  
  \ see setLayer
*/

/* end documentation of signals */
/* 신호의 끝 문서 */

/*!
  Creates a new QCPLayerable instance.
  
  Since QCPLayerable is an abstract base class, it can't be instantiated directly. Use one of the
  derived classes.
  
  If \a plot is provided, it automatically places itself on the layer named \a targetLayer. If \a
  targetLayer is an empty string, it places itself on the current layer of the plot (see \ref
  QCustomPlot::setCurrentLayer).
  
  It is possible to provide 0 as \a plot. In that case, you should assign a parent plot at a later
  time with \ref initializeParentPlot.
  
  The layerable's parent layerable is set to \a parentLayerable, if provided. Direct layerable
  parents are mainly used to control visibility in a hierarchy of layerables. This means a
  layerable is only drawn, if all its ancestor layerables are also visible. Note that \a
  parentLayerable does not become the QObject-parent (for memory management) of this layerable, \a
  plot does. It is not uncommon to set the QObject-parent to something else in the constructors of
  QCPLayerable subclasses, to guarantee a working destruction hierarchy.
*/
/*!
  새 QCPLayerable 인스턴스를 만듭니다.
  
  QCPLayerable은 추상 기본 클래스이므로 직접 인스턴스화 할 수 없습니다. 다음 중 하나를 사용하십시오.
  파생 클래스.
  
  플롯이 제공되면 \ a targetLayer라는 레이어에 자동으로 배치됩니다. 만약
  targetLayer는 빈 문자열이며, 플롯의 현재 레이어에 배치됩니다 (\ ref 참조).
  QCustomPlot :: setCurrentLayer).
  
  \ 0 플롯으로 0을 제공 할 수 있습니다. 이 경우 나중에 부모 모 음을 지정해야합니다
  \ ref initializeParentPlot을 사용하여 시간을 지정하십시오.
  
  계층화 가능 계층의 계층 가능 계층은 \ a parentLayerable (제공된 경우)로 설정됩니다. 직접 레이어 가능
  부모는 주로 레이어 가능 계층의 가시성을 제어하는 ​​데 사용됩니다. 이것은
  layerable은 해당 조상 계층을 모두 볼 수있는 경우에만 그려집니다. \ a
  parentLayerable은이 레이어 가능 요소의 QObject-parent (메모리 관리 용)가되지 않습니다. \ a
  음모가 않습니다. QObject-parent를 생성자의 다른 것으로 설정하는 것은 드문 일이 아닙니다.
  QCPLayerable 하위 클래스는 작동중인 파괴 계층 구조를 보장합니다.
*/
QCPLayerable::QCPLayerable(QCustomPlot *plot, QString targetLayer, QCPLayerable *parentLayerable) :
  QObject(plot),
  mVisible(true),
  mParentPlot(plot),
  mParentLayerable(parentLayerable),
  mLayer(0),
  mAntialiased(true)
{
  if (mParentPlot)
  {
    if (targetLayer.isEmpty())
      setLayer(mParentPlot->currentLayer());
    else if (!setLayer(targetLayer))
      qDebug() << Q_FUNC_INFO << "setting QCPlayerable initial layer to" << targetLayer << "failed.";
  }
}

QCPLayerable::~QCPLayerable()
{
  if (mLayer)
  {
    mLayer->removeChild(this);
    mLayer = 0;
  }
}

/*!
  Sets the visibility of this layerable object. If an object is not visible, it will not be drawn
  on the QCustomPlot surface, and user interaction with it (e.g. click and selection) is not
  possible.
*/
/*!
  이 계층화 가능한 객체의 가시성을 설정합니다. 오브젝트가 보이지 않으면 그려지지 않습니다.
  QCustomPlot 표면에서 사용자 상호 작용 (예 : 클릭 및 선택)이
  가능한.
*/
void QCPLayerable::setVisible(bool on)
{
  mVisible = on;
}

/*!
  Sets the \a layer of this layerable object. The object will be placed on top of the other objects
  already on \a layer.
  
  If \a layer is 0, this layerable will not be on any layer and thus not appear in the plot (or
  interact/receive events).
  
  Returns true if the layer of this layerable was successfully changed to \a layer.
*/
/*!
  이 레이어 가능 객체의 레이어를 설정합니다. 개체가 다른 개체 위에 놓입니다.
  이미 레이어에.
  
  \ layer가 0이면,이 layerable은 어떤 레이어에도 없으므로 플롯 (또는
  상호 작용 / 이벤트 수신).
  
  이 레이어 가능 레이어가 레이어로 성공적으로 변경되면 true를 반환합니다.
*/

bool QCPLayerable::setLayer(QCPLayer *layer)
{
  return moveToLayer(layer, false);
}

/*! \overload
  Sets the layer of this layerable object by name
  
  Returns true on success, i.e. if \a layerName is a valid layer name.
*/
/*! \초과 적재
  이 계층화 가능 객체의 레이어를 이름으로 설정합니다.
  
  성공하면 true를 반환합니다. 즉, layerName이 유효한 레이어 이름 인 경우를 반환합니다.
*/

bool QCPLayerable::setLayer(const QString &layerName)
{
  if (!mParentPlot)
  {
    qDebug() << Q_FUNC_INFO << "no parent QCustomPlot set";
    return false;
  }
  if (QCPLayer *layer = mParentPlot->layer(layerName))
  {
    return setLayer(layer);
  } else
  {
    qDebug() << Q_FUNC_INFO << "there is no layer with name" << layerName;
    return false;
  }
}

/*!
  Sets whether this object will be drawn antialiased or not.
  
  Note that antialiasing settings may be overridden by QCustomPlot::setAntialiasedElements and
  QCustomPlot::setNotAntialiasedElements.
*/
/*!
  이 객체가 에일 리어 징 제거되는지 여부를 설정합니다.
  
  안티 앨리어싱 설정은 QCustomPlot :: setAntialiasedElements 및
  QCustomPlot :: setNotAntialiasedElements.
*/
void QCPLayerable::setAntialiased(bool enabled)
{
  mAntialiased = enabled;
}

/*!
  Returns whether this layerable is visible, taking the visibility of the layerable parent and the
  visibility of this layerable's layer into account. This is the method that is consulted to decide
  whether a layerable shall be drawn or not.
  
  If this layerable has a direct layerable parent (usually set via hierarchies implemented in
  subclasses, like in the case of \ref QCPLayoutElement), this function returns true only if this
  layerable has its visibility set to true and the parent layerable's \ref realVisibility returns
  true.
*/
/*!
  이 계층화 가능 객체가 표시되는지 여부를 반환하고 계층화 가능 상위 객체와
  이 레이어 가능 레이어의 가시성 결정할 때 상담하는 방법입니다.
  레이어 가능 여부가 그려지는지 여부.
  
  이 레이어 가능 요소에 직접 레이어 가능 부모가있는 경우 (일반적으로
  \ ref QCPLayoutElement의 경우처럼 하위 클래스),이 함수는 this가
  layerable은 가시성을 true로 설정하고 부모 레이어 가능 요소의 \ ref는 realVisibility를 반환합니다.
  참된.
*/
bool QCPLayerable::realVisibility() const
{
  return mVisible && (!mLayer || mLayer->visible()) && (!mParentLayerable || mParentLayerable.data()->realVisibility());
}

/*!
  This function is used to decide whether a click hits a layerable object or not.

  \a pos is a point in pixel coordinates on the QCustomPlot surface. This function returns the
  shortest pixel distance of this point to the object. If the object is either invisible or the
  distance couldn't be determined, -1.0 is returned. Further, if \a onlySelectable is true and the
  object is not selectable, -1.0 is returned, too.

  If the object is represented not by single lines but by an area like a \ref QCPItemText or the
  bars of a \ref QCPBars plottable, a click inside the area should also be considered a hit. In
  these cases this function thus returns a constant value greater zero but still below the parent
  plot's selection tolerance. (typically the selectionTolerance multiplied by 0.99).
  
  Providing a constant value for area objects allows selecting line objects even when they are
  obscured by such area objects, by clicking close to the lines (i.e. closer than
  0.99*selectionTolerance).
  
  The actual setting of the selection state is not done by this function. This is handled by the
  parent QCustomPlot when the mouseReleaseEvent occurs, and the finally selected object is notified
  via the \ref selectEvent/\ref deselectEvent methods.
  
  \a details is an optional output parameter. Every layerable subclass may place any information
  in \a details. This information will be passed to \ref selectEvent when the parent QCustomPlot
  decides on the basis of this selectTest call, that the object was successfully selected. The
  subsequent call to \ref selectEvent will carry the \a details. This is useful for multi-part
  objects (like QCPAxis). This way, a possibly complex calculation to decide which part was clicked
  is only done once in \ref selectTest. The result (i.e. the actually clicked part) can then be
  placed in \a details. So in the subsequent \ref selectEvent, the decision which part was
  selected doesn't have to be done a second time for a single selection operation.
  
  You may pass 0 as \a details to indicate that you are not interested in those selection details.
  
  \see selectEvent, deselectEvent, mousePressEvent, wheelEvent, QCustomPlot::setInteractions
*/
/*!
  이 함수는 클릭이 레이어 가능 객체에 도달하는지 여부를 결정하는 데 사용됩니다.

  \ a pos는 QCustomPlot 표면의 픽셀 좌표 지점입니다. 이 함수는
  이 점에서 물체까지의 가장 짧은 픽셀 거리. 오브젝트가 보이지 않거나
  거리를 결정할 수 없으면 -1.0이 반환됩니다. 또한 \ a onlySelectable이 true이고
  개체를 선택할 수 없으면 -1.0이 반환됩니다.

  객체가 한 줄로 표시되지 않고 \ ref QCPItemText 또는
  \ ref QCPBars plottable의 막대, 영역 안의 클릭 또한 히트로 간주되어야합니다. 에서
  이 경우이 함수는 0보다 큰 상수 값을 반환하지만 여전히 부모 아래에 있습니다.
  플롯의 선택 공차. (일반적으로 selectionTolerance에 0.99를 곱한 값).
  
  영역 객체에 대한 일정한 값을 제공하면 선 객체를 선택할 때조차도 객체를 선택할 수 있습니다.
  이러한 영역 객체에 의해 가려 지거나, 선 가까이를 클릭하여 (즉,
  0.99 * selectionTolerance).
  
  선택 상태의 실제 설정은이 기능으로 수행되지 않습니다. 이것은
  mouseReleaseEvent가 발생하면 부모 QCustomPlot, 마지막으로 선택한 객체에 통지됩니다.
  \ ref selectEvent / \ ref deselectEvent 메소드를 통해.
  
  \ details는 선택적 출력 매개 변수입니다. 모든 계층화 할 수있는 서브 클래스는
  \ 세부 사항에. 이 정보는 상위 QCustomPlot이 \ ref selectEvent에 전달 될 때 \ ref selectEvent로 전달됩니다.
  이 selectTest 호출을 기반으로 객체가 성공적으로 선택되었음을 결정합니다. 그만큼
  \ ref selectEvent에 대한 후속 호출은 \ a 세부 사항을 전달합니다. 멀티 파트에 유용합니다.
  객체 (예 : QCPAxis). 이렇게하면 클릭 한 부분을 결정할 수있는 복잡한 계산이 가능합니다.
  \ ref selectTest에서 한 번만 수행됩니다. 그 결과 (실제로 클릭 된 부분)는 다음과 같이 될 수 있습니다.
  세부 사항에 배치. 따라서 이후의 \ ref selectEvent에서 어떤 부분이
  단일 선택 작업에 ​​대해 두 번 선택하지 않아도됩니다.
  
  \ n 세부 정보로 0을 전달하여 해당 선택 세부 정보에 관심이 없음을 나타낼 수 있습니다.
  
  \ selectEvent, deselectEvent, mousePressEvent, wheelEvent, QCustomPlot :: setInteractions를 참조하십시오.
*/
double QCPLayerable::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  Q_UNUSED(pos)
  Q_UNUSED(onlySelectable)
  Q_UNUSED(details)
  return -1.0;
}

/*! \internal
  
  Sets the parent plot of this layerable. Use this function once to set the parent plot if you have
  passed 0 in the constructor. It can not be used to move a layerable from one QCustomPlot to
  another one.
  
  Note that, unlike when passing a non-null parent plot in the constructor, this function does not
  make \a parentPlot the QObject-parent of this layerable. If you want this, call
  QObject::setParent(\a parentPlot) in addition to this function.
  
  Further, you will probably want to set a layer (\ref setLayer) after calling this function, to
  make the layerable appear on the QCustomPlot.
  
  The parent plot change will be propagated to subclasses via a call to \ref parentPlotInitialized
  so they can react accordingly (e.g. also initialize the parent plot of child layerables, like
  QCPLayout does).
*/
/*! \내부의
  
  이 layerable의 부모 플롯을 설정합니다. 보유하고있는 경우이 함수를 한 번 사용하여 부모 플롯을 설정합니다.
  생성자에서 0을 전달했습니다. 하나의 QCustomPlot에서 다른 레이어로 레이어를 이동하는 데 사용할 수 없습니다.
  다른 것.
  
  생성자에 null이 아닌 부모 플롯을 전달할 때와 달리이 함수는
  이 Layerable의 QObject-parent를 \ parentPlot으로 만듭니다. 이걸 원한다면
  이 함수 외에 QObject :: setParent (\ parentPlot).
  
  또한,이 함수를 호출 한 후에 레이어 (\ ref setLayer)를 설정하는 것이 좋습니다.
  QCustomPlot에 레이어 가능을 표시합니다.
  
  상위 플롯 변경은 \ ref parentPlotInitialized를 호출하여 하위 클래스로 전파됩니다.
  그래서 그들은 그에 따라 반응 할 수 있습니다 (예 : 자식 계층 가능 계층의 부모 플롯을 초기화합니다.
  QCPLayout 않습니다.
*/
void QCPLayerable::initializeParentPlot(QCustomPlot *parentPlot)
{
  if (mParentPlot)
  {
    qDebug() << Q_FUNC_INFO << "called with mParentPlot already initialized";
    return;
  }
  
  if (!parentPlot)
    qDebug() << Q_FUNC_INFO << "called with parentPlot zero";
  
  mParentPlot = parentPlot;
  parentPlotInitialized(mParentPlot);
}

/*! \internal
  
  Sets the parent layerable of this layerable to \a parentLayerable. Note that \a parentLayerable does not
  become the QObject-parent (for memory management) of this layerable.
  
  The parent layerable has influence on the return value of the \ref realVisibility method. Only
  layerables with a fully visible parent tree will return true for \ref realVisibility, and thus be
  drawn.
  
  \see realVisibility
*/
/*! \내부의
  
  이 layerable의 부모 layerable를 \ parentLayerable로 설정합니다. \ a parentLayerable은
  이 layerable의 QObject-parent (메모리 관리 용)가됩니다.
  
  부모 레이어는 \ ref realVisibility 메소드의 반환 값에 영향을 미칩니다. 만
  완전히 보이는 부모 트리를 가진 layerable은 \ ref realVisibility를 위해 참을 리턴 할 것이고 따라서
  그어진.
  
  \ see realVisibility
*/
void QCPLayerable::setParentLayerable(QCPLayerable *parentLayerable)
{
  mParentLayerable = parentLayerable;
}

/*! \internal
  
  Moves this layerable object to \a layer. If \a prepend is true, this object will be prepended to
  the new layer's list, i.e. it will be drawn below the objects already on the layer. If it is
  false, the object will be appended.
  
  Returns true on success, i.e. if \a layer is a valid layer.
*/
/*! \내부의
  
  이 레이어 가능 객체를 레이어로 이동합니다. \ a prepend가 참이면이 객체는에 추가됩니다
  새 레이어의 목록, 즉 레이어에 이미있는 객체 아래에 그려집니다. 그것이있는 경우
  false이면 객체가 추가됩니다.
  
  성공하면 true를 반환하고, 즉 레이어가 유효한 레이어 인 경우를 반환합니다.
*/
bool QCPLayerable::moveToLayer(QCPLayer *layer, bool prepend)
{
  if (layer && !mParentPlot)
  {
    qDebug() << Q_FUNC_INFO << "no parent QCustomPlot set";
    return false;
  }
  if (layer && layer->parentPlot() != mParentPlot)
  {
    qDebug() << Q_FUNC_INFO << "layer" << layer->name() << "is not in same QCustomPlot as this layerable";
    return false;
  }
  
  QCPLayer *oldLayer = mLayer;
  if (mLayer)
    mLayer->removeChild(this);
  mLayer = layer;
  if (mLayer)
    mLayer->addChild(this, prepend);
  if (mLayer != oldLayer)
    emit layerChanged(mLayer);
  return true;
}

/*! \internal

  Sets the QCPainter::setAntialiasing state on the provided \a painter, depending on the \a
  localAntialiased value as well as the overrides \ref QCustomPlot::setAntialiasedElements and \ref
  QCustomPlot::setNotAntialiasedElements. Which override enum this function takes into account is
  controlled via \a overrideElement.
*/
/*! \내부의

  \ A painter로 QCPainter :: setAntialiasing 상태를 설정합니다.
  localAntialiased 값 및 재정의 \ ref QCustomPlot :: setAntialiasedElements 및 \ ref
  QCustomPlot :: setNotAntialiasedElements. 이 함수가 사용하는 enum을 재정의하는 것은
  \ overrideElement를 통해 제어됩니다.
*/
void QCPLayerable::applyAntialiasingHint(QCPPainter *painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const
{
  if (mParentPlot && mParentPlot->notAntialiasedElements().testFlag(overrideElement))
    painter->setAntialiasing(false);
  else if (mParentPlot && mParentPlot->antialiasedElements().testFlag(overrideElement))
    painter->setAntialiasing(true);
  else
    painter->setAntialiasing(localAntialiased);
}

/*! \internal

  This function is called by \ref initializeParentPlot, to allow subclasses to react on the setting
  of a parent plot. This is the case when 0 was passed as parent plot in the constructor, and the
  parent plot is set at a later time.
  
  For example, QCPLayoutElement/QCPLayout hierarchies may be created independently of any
  QCustomPlot at first. When they are then added to a layout inside the QCustomPlot, the top level
  element of the hierarchy gets its parent plot initialized with \ref initializeParentPlot. To
  propagate the parent plot to all the children of the hierarchy, the top level element then uses
  this function to pass the parent plot on to its child elements.
  
  The default implementation does nothing.
  
  \see initializeParentPlot
*/
/*! \내부의

  이 함수는 \ ref initializeParentPlot에 의해 호출되어 서브 클래스가 설정에서 반응하도록 허용합니다.
  부모 음모의 0이 생성자에서 부모 플롯으로 전달 된 경우이며
  상위 도면은 나중에 설정됩니다.
  
  예를 들어, QCPLayoutElement / QCPLayout 계층 구조는
  처음에는 QCustomPlot입니다. 그런 다음 QCustomPlot 내부의 레이아웃에 추가되면 최상위 레벨
  계층 구조의 요소는 \ ref initializeParentPlot으로 초기화되는 부모 모눈을 가져옵니다. 에
  부모 플롯을 계층 구조의 모든 자식으로 전파하면 최상위 요소가 다음을 사용합니다.
  이 함수는 부모 플롯을 자식 요소에 전달합니다.
  
  디폴트의 ​​구현은 아무것도 실시하지 않습니다.
  
  \ see initializeParentPlot
*/
void QCPLayerable::parentPlotInitialized(QCustomPlot *parentPlot)
{
   Q_UNUSED(parentPlot)
}

/*! \internal

  Returns the selection category this layerable shall belong to. The selection category is used in
  conjunction with \ref QCustomPlot::setInteractions to control which objects are selectable and
  which aren't.
  
  Subclasses that don't fit any of the normal \ref QCP::Interaction values can use \ref
  QCP::iSelectOther. This is what the default implementation returns.
  
  \see QCustomPlot::setInteractions
*/
/*! \내부의

  이 계층화 가능 요소가 속하는 선택 카테고리를 리턴합니다. 선택 카테고리는에서 사용됩니다.
  \ ref QCustomPlot :: setInteractions와 함께 사용하여 선택할 수있는 개체를 제어하고
  그렇지 않습니다.
  
  정상적인 \ ref QCP :: Interaction 값에 맞지 않는 서브 클래스는 \ ref를 사용할 수 있습니다.
  QCP :: iSelect 기타. 이것이 기본 구현이 반환하는 것입니다.
  
  \ QCustomPlot :: setInteractions를 참조하십시오.
*/
QCP::Interaction QCPLayerable::selectionCategory() const
{
  return QCP::iSelectOther;
}

/*! \internal
  
  Returns the clipping rectangle of this layerable object. By default, this is the viewport of the
  parent QCustomPlot. Specific subclasses may reimplement this function to provide different
  clipping rects.
  
  The returned clipping rect is set on the painter before the draw function of the respective
  object is called.
*/
/*! \내부의
  
  이 계층화 가능한 객체의 클리핑 사각형을 반환합니다. 기본적으로 이것은 뷰포트의
  상위 QCustomPlot. 특정의 서브 클래스는이 함수를 재 구현해 다른
  직장을 클리핑.
  
  돌려 주어지는 클리핑 rect는, 각각의 paint 함수가 draw하기 전에 painter로 설정됩니다.
  개체가 호출됩니다.
*/
QRect QCPLayerable::clipRect() const
{
  if (mParentPlot)
    return mParentPlot->viewport();
  else
    return QRect();
}

/*! \internal
  
  This event is called when the layerable shall be selected, as a consequence of a click by the
  user. Subclasses should react to it by setting their selection state appropriately. The default
  implementation does nothing.
  
  \a event is the mouse event that caused the selection. \a additive indicates, whether the user
  was holding the multi-select-modifier while performing the selection (see \ref
  QCustomPlot::setMultiSelectModifier). if \a additive is true, the selection state must be toggled
  (i.e. become selected when unselected and unselected when selected).
  
  Every selectEvent is preceded by a call to \ref selectTest, which has returned positively (i.e.
  returned a value greater than 0 and less than the selection tolerance of the parent QCustomPlot).
  The \a details data you output from \ref selectTest is fed back via \a details here. You may
  use it to transport any kind of information from the selectTest to the possibly subsequent
  selectEvent. Usually \a details is used to transfer which part was clicked, if it is a layerable
  that has multiple individually selectable parts (like QCPAxis). This way selectEvent doesn't need
  to do the calculation again to find out which part was actually clicked.
  
  \a selectionStateChanged is an output parameter. If the pointer is non-null, this function must
  set the value either to true or false, depending on whether the selection state of this layerable
  was actually changed. For layerables that only are selectable as a whole and not in parts, this
  is simple: if \a additive is true, \a selectionStateChanged must also be set to true, because the
  selection toggles. If \a additive is false, \a selectionStateChanged is only set to true, if the
  layerable was previously unselected and now is switched to the selected state.
  
  \see selectTest, deselectEvent
*/
/*! \내부의
  
  이 이벤트는 layerable이 클릭 될 때 호출됩니다.
  사용자. 서브 클래스는 선택 상태를 적절히 설정해, 그것에 반응해야합니다. 기본값은
  구현은 아무 것도하지 않습니다.
  
  \ a event는 선택을 유발 한 마우스 이벤트입니다. \ 추가 사항은 사용자가
  선택을 수행하는 동안 다중 선택 수정 기호를 누르고있었습니다 (\ ref 참조).
  QCustomPlot :: setMultiSelectModifier)를 호출합니다. \ additive가 true 인 경우 선택 상태를 전환해야합니다.
  (즉, 선택되지 않은 경우 선택되고 선택되면 선택되지 않음).
  
  모든 selectEvent 앞에는 \ ref selectTest에 대한 호출이 있으며, 이는 긍정적으로 반환됩니다 (즉,
  0보다 크고 상위 QCustomPlot의 선택 공차보다 작은 값을 반환했습니다.
  \ ref selectTest에서 출력 한 \ a 세부 데이터는 여기 \ 세부 정보를 통해 피드백됩니다. 당신은 할 수있다
  selectTest에서 가능한 후속으로 모든 종류의 정보를 전송하는 데 사용하십시오.
  selectEvent. 일반적으로 \ 세부 사항은 레이어가있는 경우 클릭 한 부분을 전송하는 데 사용됩니다.
  (QCPAxis와 같은) 개별적으로 선택할 수있는 부품이 여러 개 있습니다. 이 방법은 selectEvent가 필요하지 않습니다.
  계산을 다시 수행하여 실제로 클릭 된 부분을 찾습니다.
  
  \ selectionStateChanged는 출력 매개 변수입니다. 포인터가 null이 아닌 경우이 함수는
  이 layerable의 선택 상태에 따라 값을 true 또는 false로 설정합니다.
  실제로 변경되었습니다. 부분품이 아닌 전체적으로 선택 가능한 레이어 가능 제품의 경우
  간단합니다. \ additive가 true 인 경우 \ a selectionStateChanged도 true로 설정해야합니다.
  선택 토글. \ additive가 false의 경우, \ ​​a selectionStateChanged는 true로 설정됩니다.
  layerable은 이전에 선택되지 않았으며 이제는 선택된 상태로 전환됩니다.
  
  \ select test, selectelect 이벤트 참조
*/
void QCPLayerable::selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)
{
  Q_UNUSED(event)
  Q_UNUSED(additive)
  Q_UNUSED(details)
  Q_UNUSED(selectionStateChanged)
}

/*! \internal
  
  This event is called when the layerable shall be deselected, either as consequence of a user
  interaction or a call to \ref QCustomPlot::deselectAll. Subclasses should react to it by
  unsetting their selection appropriately.
  
  just as in \ref selectEvent, the output parameter \a selectionStateChanged (if non-null), must
  return true or false when the selection state of this layerable has changed or not changed,
  respectively.
  
  \see selectTest, selectEvent
*/
/*! \내부의
  
  이 이벤트는 레이어 결과가 사용자의 선택에 따라 선택 해제 될 때 호출됩니다.
  상호 작용 또는 \ ref QCustomPlot :: deselectAll에 대한 호출 서브 클래스는
  선택을 적절하게 설정 해제합니다.
  
  \ ref selectEvent와 마찬가지로 출력 매개 변수 \ a selectionStateChanged (null이 아닌 경우),
  이 레이어 가능 요소의 선택 상태가 변경되었거나 변경되지 않은 경우 true 또는 false를 반환하고,
  각기.
  
  \ select test, selectEvent를 참조하십시오.
*/
void QCPLayerable::deselectEvent(bool *selectionStateChanged)
{
  Q_UNUSED(selectionStateChanged)
}

/*!
  This event gets called when the user presses a mouse button while the cursor is over the
  layerable. Whether a cursor is over the layerable is decided by a preceding call to \ref
  selectTest.

  The current pixel position of the cursor on the QCustomPlot widget is accessible via \c
  event->pos(). The parameter \a details contains layerable-specific details about the hit, which
  were generated in the previous call to \ref selectTest. For example, One-dimensional plottables
  like \ref QCPGraph or \ref QCPBars convey the clicked data point in the \a details parameter, as
  \ref QCPDataSelection packed as QVariant. Multi-part objects convey the specific \c
  SelectablePart that was hit (e.g. \ref QCPAxis::SelectablePart in the case of axes).

  QCustomPlot uses an event propagation system that works the same as Qt's system. If your
  layerable doesn't reimplement the \ref mousePressEvent or explicitly calls \c event->ignore() in
  its reimplementation, the event will be propagated to the next layerable in the stacking order.

  Once a layerable has accepted the \ref mousePressEvent, it is considered the mouse grabber and
  will receive all following calls to \ref mouseMoveEvent or \ref mouseReleaseEvent for this mouse
  interaction (a "mouse interaction" in this context ends with the release).

  The default implementation does nothing except explicitly ignoring the event with \c
  event->ignore().

  \see mouseMoveEvent, mouseReleaseEvent, mouseDoubleClickEvent, wheelEvent
*/
/*!
  이 이벤트는 커서가 마우스 버튼을 누른 상태에서 사용자가 마우스 버튼을 누르면 호출됩니다.
  레이어 가능. 커서가 계층화 가능 여부를 결정하는 것은 앞의 \ ref 호출로 결정됩니다.
  selectTest.

  QCustomPlot 위젯에있는 커서의 현재 픽셀 위치는 \ c를 통해 액세스 할 수 있습니다.
  event-> pos (). 매개 변수 \ 세부 정보에는 적중 관련 세부 정보가 포함되어 있습니다.
  \ ref selectTest에 대한 이전 호출에서 생성되었습니다. 예를 들어, 1 차원 Plotables
  \ ref QCPGraph 또는 \ ref QCPBars는 클릭 한 데이터 포인트를 \ details 매개 변수로 전달합니다.
  \ ref QVariant로 묶인 QCPDataSelection. 멀티 파트 오브젝트는 특정 \ c를 전달합니다.
  적중 된 SelectablePart (예 : 축의 경우 \ ref QCPAxis :: SelectablePart).

  QCustomPlot은 Qt 시스템과 동일한 방식으로 작동하는 이벤트 전파 시스템을 사용합니다. 귀하의
  layerable은 \ ref mousePressEvent를 다시 구현하지 않거나 명시 적으로 \ c event-> ignore ()를 호출합니다.
  이벤트가 스태킹 순서로 다음 레이어 가능으로 전파됩니다.

  layerable이 \ ref mousePressEvent를 수락하면 마우스 그래버로 간주되고
  이 마우스에 대해 \ ref mouseMoveEvent 또는 \ ref mouseReleaseEvent에 대한 모든 다음 호출을 수신합니다.
  상호 작용 (이 문맥에서 "마우스 상호 작용"은 릴리스로 끝납니다).

  기본 구현은 \ c를 사용하여 이벤트를 명시 적으로 무시하는 것 외에는 아무 것도하지 않습니다.
  event-> ignore ().

  \ see mouseMoveEvent, mouseReleaseEvent, mouseDoubleClickEvent, wheelEvent
*/
void QCPLayerable::mousePressEvent(QMouseEvent *event, const QVariant &details)
{
  Q_UNUSED(details)
  event->ignore();
}

/*!
  This event gets called when the user moves the mouse while holding a mouse button, after this
  layerable has become the mouse grabber by accepting the preceding \ref mousePressEvent.

  The current pixel position of the cursor on the QCustomPlot widget is accessible via \c
  event->pos(). The parameter \a startPos indicates the position where the initial \ref
  mousePressEvent occured, that started the mouse interaction.

  The default implementation does nothing.

  \see mousePressEvent, mouseReleaseEvent, mouseDoubleClickEvent, wheelEvent
*/
/*!
  이 이벤트는 사용자가 마우스 버튼을 누른 상태에서 마우스를 움직일 때 호출됩니다.
  layerable은 앞의 \ ref mousePressEvent를 받아 들여 마우스 그래버가되었습니다.

  QCustomPlot 위젯에있는 커서의 현재 픽셀 위치는 \ c를 통해 액세스 할 수 있습니다.
  event-> pos (). \ a startPos 매개 변수는 초기 \ ref가있는 위치를 나타냅니다.
  마우스 조작을 시작한 mousePressEvent가 발생했습니다.

  디폴트의 ​​구현은 아무것도 실시하지 않습니다.

  \ see mousePressEvent, mouseReleaseEvent, mouseDoubleClickEvent, wheelEvent를 참조하십시오.
*/
void QCPLayerable::mouseMoveEvent(QMouseEvent *event, const QPointF &startPos)
{
  Q_UNUSED(startPos)
  event->ignore();
}

/*!
  This event gets called when the user releases the mouse button, after this layerable has become
  the mouse grabber by accepting the preceding \ref mousePressEvent.

  The current pixel position of the cursor on the QCustomPlot widget is accessible via \c
  event->pos(). The parameter \a startPos indicates the position where the initial \ref
  mousePressEvent occured, that started the mouse interaction.

  The default implementation does nothing.

  \see mousePressEvent, mouseMoveEvent, mouseDoubleClickEvent, wheelEvent
*/
/*!
  이 레이어 가능 요소가 된 후 사용자가 마우스 단추를 놓을 때이 이벤트가 호출됩니다.
  앞의 \ ref mousePressEvent를 받아들이면 마우스 그래버가됩니다.

  QCustomPlot 위젯에있는 커서의 현재 픽셀 위치는 \ c를 통해 액세스 할 수 있습니다.
  event-> pos (). \ a startPos 매개 변수는 초기 \ ref가있는 위치를 나타냅니다.
  마우스 조작을 시작한 mousePressEvent가 발생했습니다.

  디폴트의 ​​구현은 아무것도 실시하지 않습니다.

  \ see mousePressEvent, mouseMoveEvent, mouseDoubleClickEvent, wheelEvent
*/
void QCPLayerable::mouseReleaseEvent(QMouseEvent *event, const QPointF &startPos)
{
  Q_UNUSED(startPos)
  event->ignore();
}

/*!
  This event gets called when the user presses the mouse button a second time in a double-click,
  while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a
  preceding call to \ref selectTest.

  The \ref mouseDoubleClickEvent is called instead of the second \ref mousePressEvent. So in the
  case of a double-click, the event succession is
  <i>pressEvent &ndash; releaseEvent &ndash; doubleClickEvent &ndash; releaseEvent</i>.

  The current pixel position of the cursor on the QCustomPlot widget is accessible via \c
  event->pos(). The parameter \a details contains layerable-specific details about the hit, which
  were generated in the previous call to \ref selectTest. For example, One-dimensional plottables
  like \ref QCPGraph or \ref QCPBars convey the clicked data point in the \a details parameter, as
  \ref QCPDataSelection packed as QVariant. Multi-part objects convey the specific \c
  SelectablePart that was hit (e.g. \ref QCPAxis::SelectablePart in the case of axes).

  Similarly to \ref mousePressEvent, once a layerable has accepted the \ref mouseDoubleClickEvent,
  it is considered the mouse grabber and will receive all following calls to \ref mouseMoveEvent
  and \ref mouseReleaseEvent for this mouse interaction (a "mouse interaction" in this context ends
  with the release).

  The default implementation does nothing except explicitly ignoring the event with \c
  event->ignore().

  \see mousePressEvent, mouseMoveEvent, mouseReleaseEvent, wheelEvent
*/

/*!
  이 이벤트는, 유저가 더블 클릭으로 2 번 마우스 버튼을 눌렀을 때에 불려갑니다.
  커서가 레이어 가능 위에있는 동안 커서가 레이어 가능 여부를 결정하는 것은
  \ ref selectTest에 대한 선행 호출.

  \ ref mouseDoubleClickEvent가 두 번째 \ ref mousePressEvent 대신 호출됩니다. 그래서
  두 번 클릭의 경우, 이벤트 연속은 다음과 같습니다.
  <i> pressEvent & ndash; releaseEvent & ndash; doubleClickEvent & ndash; releaseEvent </ i>.

  QCustomPlot 위젯에있는 커서의 현재 픽셀 위치는 \ c를 통해 액세스 할 수 있습니다.
  event-> pos (). 매개 변수 \ 세부 정보에는 적중 관련 세부 정보가 포함되어 있습니다.
  \ ref selectTest에 대한 이전 호출에서 생성되었습니다. 예를 들어, 1 차원 Plotables
  \ ref QCPGraph 또는 \ ref QCPBars는 클릭 한 데이터 포인트를 \ details 매개 변수로 전달합니다.
  \ ref QVariant로 묶인 QCPDataSelection. 멀티 파트 오브젝트는 특정 \ c를 전달합니다.
  적중 된 SelectablePart (예 : 축의 경우 \ ref QCPAxis :: SelectablePart).

  \ ref mousePressEvent와 마찬가지로, 레이어가 \ ref mouseDoubleClickEvent를 수락하면,
  그것은 마우스 그래버로 간주되며 \ ref mouseMoveEvent에 대한 모든 다음 호출을 수신합니다.
  및이 마우스 상호 작용을위한 \ ref mouseReleaseEvent ( "마우스 상호 작용"이 끝납니다.
  릴리스와 함께).

  기본 구현은 \ c로 이벤트를 명시 적으로 무시하는 것을 제외하고는 아무 것도하지 않습니다.
  event-> ignore ().

  \ see mousePressEvent, mouseMoveEvent, mouseReleaseEvent, wheelEvent를 참조하십시오.
*/
void QCPLayerable::mouseDoubleClickEvent(QMouseEvent *event, const QVariant &details)
{
  Q_UNUSED(details)
  event->ignore();
}

/*!
  This event gets called when the user turns the mouse scroll wheel while the cursor is over the
  layerable. Whether a cursor is over the layerable is decided by a preceding call to \ref
  selectTest.

  The current pixel position of the cursor on the QCustomPlot widget is accessible via \c
  event->pos().

  The \c event->delta() indicates how far the mouse wheel was turned, which is usually +/- 120 for
  single rotation steps. However, if the mouse wheel is turned rapidly, multiple steps may
  accumulate to one event, making \c event->delta() larger. On the other hand, if the wheel has
  very smooth steps or none at all, the delta may be smaller.

  The default implementation does nothing.

  \see mousePressEvent, mouseMoveEvent, mouseReleaseEvent, mouseDoubleClickEvent
*/
/*!
  이 이벤트는 커서가 스크롤 막대 위에있는 동안 사용자가 마우스 스크롤 휠을 돌리면 호출됩니다.
  레이어 가능. 커서가 계층화 가능 여부를 결정하는 것은 앞의 \ ref 호출로 결정됩니다.
  selectTest.

  QCustomPlot 위젯에있는 커서의 현재 픽셀 위치는 \ c를 통해 액세스 할 수 있습니다.
  event-> pos ().

  \ c 이벤트 -> 델타 ()는 마우스 휠이 얼마나 멀리 돌았는지 가리키며, 일반적으로 +/- 120입니다.
  단일 회전 단계. 그러나 마우스 휠을 빠르게 돌리면 여러 단계가
  하나의 이벤트에 누적되어 \ c event-> delta ()가 더 커집니다. 반면에 바퀴가
  매우 매끄러운 단계 또는 전혀 없음, 델타가 더 작을 수 있습니다.

  디폴트의 ​​구현은 아무것도 실시하지 않습니다.

  \ see mousePressEvent, mouseMoveEvent, mouseReleaseEvent, mouseDoubleClickEvent를 참조하십시오.
*/
void QCPLayerable::wheelEvent(QWheelEvent *event)
{
  event->ignore();
}
/* end of 'src/layer.cpp' */


/* including file 'src/axis/range.cpp', size 12221                           */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / layer.cpp'의 끝 */


/* 파일 'src / axis / range.cpp', 크기 12221 포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPRange
////////////////////////////////////////////////////////////////////////////////////////////////////
/*! \class QCPRange
  \brief Represents the range an axis is encompassing.
  
  contains a \a lower and \a upper double value and provides convenience input, output and
  modification functions.
  
  \see QCPAxis::setRange
*/
/*! \ class QCPRange
  \ brief 축이 포함하는 범위를 나타냅니다.
  
  lower와 \ a upper double 값을 포함하며, 입력, 출력 및
  수정 기능.
  
  \ see QCPAxis :: setRange
*/

/* start of documentation of inline functions */
/* 인라인 함수의 문서화 시작 */

/*! \fn double QCPRange::size() const

  Returns the size of the range, i.e. \a upper-\a lower
*/
/*! \ fn double QCPRange :: size () const

  범위의 사이즈를 돌려줍니다. 즉, \ a upper - \ lower
*/
/*! \fn double QCPRange::center() const

  Returns the center of the range, i.e. (\a upper+\a lower)*0.5
*/
/*! \ fn double QCPRange :: center () const

  범위의 중심을 반환합니다. 즉, (\ a upper + \ a lower) * 0.5
*/

/*! \fn void QCPRange::normalize()

  Makes sure \a lower is numerically smaller than \a upper. If this is not the case, the values are
  swapped.
*/
/*! \ fn void QCPRange :: normalize ()

  \ a lower가 \ a upper보다 수치 적으로 작도록하십시오. 그렇지 않은 경우 값은 다음과 같습니다.
  바꿔 치기했다.
*/

/*! \fn bool QCPRange::contains(double value) const

  Returns true when \a value lies within or exactly on the borders of the range.
*/
/*! \ fn bool QCPRange :: contains (double 값) const

  \ a 값이 범위의 테두리 안에 있거나 정확하게있을 때 true를 반환합니다.
*/

/*! \fn QCPRange &QCPRange::operator+=(const double& value)

  Adds \a value to both boundaries of the range.
*/
/*! \ fn QCPRange 및 QCPRange :: operator + = (const double 및 value)

  범위의 양쪽 경계에 \ a 값을 추가합니다.
*/

/*! \fn QCPRange &QCPRange::operator-=(const double& value)

  Subtracts \a value from both boundaries of the range.
*/
/*! \ fn QCPRange & QCPRange :: operator - = (const double & value)

  범위의 두 경계에서 \ a 값을 뺍니다.
*/

/*! \fn QCPRange &QCPRange::operator*=(const double& value)

  Multiplies both boundaries of the range by \a value.
*/
/*! \ fn QCPRange 및 QCPRange :: operator * = (const double 및 value)

  범위의 두 경계를 모두 \ a 값만큼 곱합니다.
*/

/*! \fn QCPRange &QCPRange::operator/=(const double& value)

  Divides both boundaries of the range by \a value.
*/

/*! \ fn QCPRange 및 QCPRange :: operator / = (const double 및 value)

  범위의 두 경계를 \ a 값으로 나눕니다.
*/

/* end of documentation of inline functions */
/* 인라인 함수의 문서 끝 */

/*!
  Minimum range size (\a upper - \a lower) the range changing functions will accept. Smaller
  intervals would cause errors due to the 11-bit exponent of double precision numbers,
  corresponding to a minimum magnitude of roughly 1e-308.

  \warning Do not use this constant to indicate "arbitrarily small" values in plotting logic (as
  values that will appear in the plot)! It is intended only as a bound to compare against, e.g. to
  prevent axis ranges from obtaining underflowing ranges.

  \see validRange, maxRange
*/
/*!
  범위 변경 기능이 허용하는 최소 범위 크기 (\ a upper - \ a lower). 더 작은
  간격은 배정도 숫자의 11 비트 지수로 인해 오류를 일으키고,
  대략 1e-308의 최소 크기에 해당합니다.

  \ 경고이 상수를 사용하여 플로팅 논리에서 "임의로 작은"값을 표시하지 마십시오.
  플롯에 나타날 값)! 비교 대상은 예를 들어
  축 범위가 언더 플로 범위를 벗어나는 것을 방지합니다.

  \ see validRange, maxRange
*/
const double QCPRange::minRange = 1e-280;

/*!
  Maximum values (negative and positive) the range will accept in range-changing functions.
  Larger absolute values would cause errors due to the 11-bit exponent of double precision numbers,
  corresponding to a maximum magnitude of roughly 1e308.

  \warning Do not use this constant to indicate "arbitrarily large" values in plotting logic (as
  values that will appear in the plot)! It is intended only as a bound to compare against, e.g. to
  prevent axis ranges from obtaining overflowing ranges.

  \see validRange, minRange
*/
/*!
  범위 변경 기능에서 범위가 허용 할 최대 값 (음수 및 양수)입니다.
  절대 값이 클수록 11 비트 지수의 배정도 숫자로 인해 오류가 발생하며,
  대략 1e308의 최대 크기에 해당합니다.

  \ warning이 상수를 사용하여 플로팅 논리에서 "임의로 큰"값을 표시하지 마십시오 (
  플롯에 나타날 값)! 비교 대상은 예를 들어
  축 범위가 범람 범위를 벗어나는 것을 방지합니다.

  \ see validRange, minRange
*/
const double QCPRange::maxRange = 1e250;

/*!
  Constructs a range with \a lower and \a upper set to zero.
*/
/*!
  \ a를 lower로, \ a를 제로로 설정해 범위를 구축합니다.
*/
QCPRange::QCPRange() :
  lower(0),
  upper(0)
{
}

/*! \overload

  Constructs a range with the specified \a lower and \a upper values.

  The resulting range will be normalized (see \ref normalize), so if \a lower is not numerically
  smaller than \a upper, they will be swapped.
*/
/*! \초과 적재

  지정된 \ a를 하위로, \ a를 상위로하여 범위를 구성합니다.

  결과 범위는 정규화됩니다 (\ ref normalize 참조). 따라서 \ lower가 숫자가 아닌 경우
  \ a upper보다 작 으면 스왑됩니다.
*/
QCPRange::QCPRange(double lower, double upper) :
  lower(lower),
  upper(upper)
{
  normalize();
}

/*! \overload

  Expands this range such that \a otherRange is contained in the new range. It is assumed that both
  this range and \a otherRange are normalized (see \ref normalize).

  If this range contains NaN as lower or upper bound, it will be replaced by the respective bound
  of \a otherRange.

  If \a otherRange is already inside the current range, this function does nothing.

  \see expanded
*/
/*! \초과 적재

  \ a otherRange가 새 범위에 포함되도록이 범위를 확장합니다. 둘 다
  이 범위와 \ a otherRange는 정규화됩니다 (\ ref normalize 참조).

  이 범위에 NaN가 하한 또는 상한으로서 포함되는 경우는, 각각의 경계로 옮겨 놓을 수 있습니다.
  of \ a otherRange.

  \ otherRange가 이미 현재 범위 안에 있으면이 함수는 아무 것도 수행하지 않습니다.

  \ 확장보기
*/
void QCPRange::expand(const QCPRange &otherRange)
{
  if (lower > otherRange.lower || qIsNaN(lower))
    lower = otherRange.lower;
  if (upper < otherRange.upper || qIsNaN(upper))
    upper = otherRange.upper;
}

/*! \overload

  Expands this range such that \a includeCoord is contained in the new range. It is assumed that
  this range is normalized (see \ref normalize).

  If this range contains NaN as lower or upper bound, the respective bound will be set to \a
  includeCoord.

  If \a includeCoord is already inside the current range, this function does nothing.

  \see expand
*/
/*! \초과 적재

  \ a includeCoord가 새 범위에 포함되도록이 범위를 확장합니다. 그것은
  이 범위는 정규화됩니다 (\ ref normalize 참조).

  이 범위에 NaN가 하한 또는 상한으로서 포함되어있는 경우, 각 경계는 \ a
  includeCoord.

  \ includeCoord가 이미 현재 범위 안에 있으면이 함수는 아무 것도 수행하지 않습니다.

  \ 확대보기
*/
void QCPRange::expand(double includeCoord)
{
  if (lower > includeCoord || qIsNaN(lower))
    lower = includeCoord;
  if (upper < includeCoord || qIsNaN(upper))
    upper = includeCoord;
}


/*! \overload

  Returns an expanded range that contains this and \a otherRange. It is assumed that both this
  range and \a otherRange are normalized (see \ref normalize).

  If this range contains NaN as lower or upper bound, the returned range's bound will be taken from
  \a otherRange.

  \see expand
*/
/*! \초과 적재

  this와 \ a otherRange가 포함 된 확장 된 범위를 반환합니다. 이 두 가지
  range와 \ a otherRange는 정규화됩니다 (\ ref normalize 참조).

  이 범위에 NaN가 하한 또는 상한으로서 포함되는 경우, 반환되는 범위의 경계는
  \ a otherRange.

  \ 확대보기
*/
QCPRange QCPRange::expanded(const QCPRange &otherRange) const
{
  QCPRange result = *this;
  result.expand(otherRange);
  return result;
}

/*! \overload

  Returns an expanded range that includes the specified \a includeCoord. It is assumed that this
  range is normalized (see \ref normalize).

  If this range contains NaN as lower or upper bound, the returned range's bound will be set to \a
  includeCoord.

  \see expand
*/
/*! \초과 적재

  지정된 \ a includeCoord가 포함 된 확장 된 범위를 반환합니다. 이
  범위가 정규화됩니다 (\ ref normalize 참조).

  이 범위에 NaN가 하한 또는 상한으로서 포함되어있는 경우, 반환되는 범위의 경계는 \ a
  includeCoord.

  \ 확대보기
*/
QCPRange QCPRange::expanded(double includeCoord) const
{
  QCPRange result = *this;
  result.expand(includeCoord);
  return result;
}

/*!
  Returns this range, possibly modified to not exceed the bounds provided as \a lowerBound and \a
  upperBound. If possible, the size of the current range is preserved in the process.
  
  If the range shall only be bounded at the lower side, you can set \a upperBound to \ref
  QCPRange::maxRange. If it shall only be bounded at the upper side, set \a lowerBound to -\ref
  QCPRange::maxRange.
*/

/*!
  이 범위를 돌려줍니다. lowerBound와 \ a로서 제공되는 경계를 초과하지 않게 변경됩니다
  upperBound. 가능한 경우 현재 범위의 크기가 프로세스에서 보존됩니다.
  
  범위가 하측에서만 제한되는 경우, \ ​​upperBound를 \ ref로 설정할 수 있습니다
  QCPRange :: maxRange. 위쪽에서만 경계가있을 경우 \ lowerBound를 - \ ref로 설정합니다.
  QCPRange :: maxRange.
*/
QCPRange QCPRange::bounded(double lowerBound, double upperBound) const
{
  if (lowerBound > upperBound)
    qSwap(lowerBound, upperBound);
  
  QCPRange result(lower, upper);
  if (result.lower < lowerBound)
  {
    result.lower = lowerBound;
    result.upper = lowerBound + size();
    if (result.upper > upperBound || qFuzzyCompare(size(), upperBound-lowerBound))
      result.upper = upperBound;
  } else if (result.upper > upperBound)
  {
    result.upper = upperBound;
    result.lower = upperBound - size();
    if (result.lower < lowerBound || qFuzzyCompare(size(), upperBound-lowerBound))
      result.lower = lowerBound;
  }
  
  return result;
}

/*!
  Returns a sanitized version of the range. Sanitized means for logarithmic scales, that
  the range won't span the positive and negative sign domain, i.e. contain zero. Further
  \a lower will always be numerically smaller (or equal) to \a upper.
  
  If the original range does span positive and negative sign domains or contains zero,
  the returned range will try to approximate the original range as good as possible.
  If the positive interval of the original range is wider than the negative interval, the
  returned range will only contain the positive interval, with lower bound set to \a rangeFac or
  \a rangeFac *\a upper, whichever is closer to zero. Same procedure is used if the negative interval
  is wider than the positive interval, this time by changing the \a upper bound.
*/
/*!
  범위의 새 니타 이징 된 버전을 반환합니다. 위생 처리 된 대수 저울
  범위는 양수 및 음수 부호 도메인을 스팬하지 않으며, 즉 0을 포함합니다. 더욱이
  \ a lower는 항상 upper보다 수치 적으로 작거나 같습니다.
  
  원래 범위가 양수 및 음수 표지 도메인에 걸쳐 있거나 0을 포함하면,
  반환 된 범위는 원래 범위를 가능한 한 양호하게 근사하려고 시도합니다.
  원래 범위의 양의 간격이 음의 간격보다 넓은 경우
  반환 된 범위에는 양수 간격 만 포함되며 범위는 \ a rangeFac 또는
  \ a rangeFac * \ a upper 중 가장 가까운 값. 음의 간격 인 경우 동일한 절차가 사용됩니다.
  이번에는 \ a 상한을 변경하여 양의 간격보다 넓습니다.
*/
QCPRange QCPRange::sanitizedForLogScale() const
{
  double rangeFac = 1e-3;
  QCPRange sanitizedRange(lower, upper);
  sanitizedRange.normalize();
  // can't have range spanning negative and positive values in log plot, so change range to fix it
  //if (qFuzzyCompare(sanitizedRange.lower+1, 1) && !qFuzzyCompare(sanitizedRange.upper+1, 1))
  // 로그 플롯에서 음수 및 양수 값 범위를 가질 수 없으므로 범위를 변경하여 수정하십시오.
  // if (qFuzzyCompare (sanitizedRange.lower + 1, 1) &&! qFuzzyCompare (sanitizedRange.upper + 1, 1))
  if (sanitizedRange.lower == 0.0 && sanitizedRange.upper != 0.0)
  {
    // case lower is 0
    // case lower는 0입니다.
    if (rangeFac < sanitizedRange.upper*rangeFac)
      sanitizedRange.lower = rangeFac;
    else
      sanitizedRange.lower = sanitizedRange.upper*rangeFac;
  } //else if (!qFuzzyCompare(lower+1, 1) && qFuzzyCompare(upper+1, 1))
    // else if (! qFuzzyCompare (lower + 1, 1) && qFuzzyCompare (upper + 1, 1))
  else if (sanitizedRange.lower != 0.0 && sanitizedRange.upper == 0.0)
  {
    // case upper is 0
    // 대문자는 0입니다.
    if (-rangeFac > sanitizedRange.lower*rangeFac)
      sanitizedRange.upper = -rangeFac;
    else
      sanitizedRange.upper = sanitizedRange.lower*rangeFac;
  } else if (sanitizedRange.lower < 0 && sanitizedRange.upper > 0)
  {
    // find out whether negative or positive interval is wider to decide which sign domain will be chosen
    // 어느 부호 영역이 선택 될지를 결정하기 위해 음수 또는 양의 간격이 더 넓은 지 알아 내라.
    if (-sanitizedRange.lower > sanitizedRange.upper)
    {
      // negative is wider, do same as in case upper is 0
      // 음수가 더 넓 으면 upper가 0 일 때와 동일하게 처리합니다
      if (-rangeFac > sanitizedRange.lower*rangeFac)
        sanitizedRange.upper = -rangeFac;
      else
        sanitizedRange.upper = sanitizedRange.lower*rangeFac;
    } else
    {
      // positive is wider, do same as in case lower is 0
      // 양수가 더 깁니다. lower가 0 일 때와 같습니다.
      if (rangeFac < sanitizedRange.upper*rangeFac)
        sanitizedRange.lower = rangeFac;
      else
        sanitizedRange.lower = sanitizedRange.upper*rangeFac;
    }
  }
  // due to normalization, case lower>0 && upper<0 should never occur, because that implies upper<lower
  // 정규화로 인해 lower> 0 && upper <0은 결코 발생하지 않아야합니다. 왜냐하면 upper <lower를 의미하기 때문입니다.
  return sanitizedRange;
}

/*!
  Returns a sanitized version of the range. Sanitized means for linear scales, that
  \a lower will always be numerically smaller (or equal) to \a upper.
*/
/*!
  범위의 새 니타 이징 된 버전을 반환합니다. 위생 처리 된 선형 눈금을 의미합니다.
  \ a lower는 항상 upper보다 수치 적으로 작거나 같습니다.
*/
QCPRange QCPRange::sanitizedForLinScale() const
{
  QCPRange sanitizedRange(lower, upper);
  sanitizedRange.normalize();
  return sanitizedRange;
}

/*!
  Checks, whether the specified range is within valid bounds, which are defined
  as QCPRange::maxRange and QCPRange::minRange.
  A valid range means:
  \li range bounds within -maxRange and maxRange
  \li range size above minRange
  \li range size below maxRange
*/
/*!
  지정된 범위가 정의 된 유효한 범위 내에 있는지 여부를 확인합니다.
  QCPRange :: maxRange 및 QCPRange :: minRange.
  유효한 범위는 다음을 의미합니다.
  \ li 범위 제한은 -maxRange 및 maxRange 범위 이내입니다.
  \ li range size from minRange
  \ li 범위 크기가 maxRange 이하입니다.
*/
bool QCPRange::validRange(double lower, double upper)
{
  return (lower > -maxRange &&
          upper < maxRange &&
          qAbs(lower-upper) > minRange &&
          qAbs(lower-upper) < maxRange &&
          !(lower > 0 && qIsInf(upper/lower)) &&
          !(upper < 0 && qIsInf(lower/upper)));
}

/*!
  \overload
  Checks, whether the specified range is within valid bounds, which are defined
  as QCPRange::maxRange and QCPRange::minRange.
  A valid range means:
  \li range bounds within -maxRange and maxRange
  \li range size above minRange
  \li range size below maxRange
*/
/*!
  \초과 적재
  지정된 범위가 정의 된 유효한 범위 내에 있는지 여부를 확인합니다.
  QCPRange :: maxRange 및 QCPRange :: minRange.
  유효한 범위는 다음을 의미합니다.
  \ li 범위 제한은 -maxRange 및 maxRange 범위 이내입니다.
  \ li range size from minRange
  \ li 범위 크기가 maxRange 이하입니다.
*/
bool QCPRange::validRange(const QCPRange &range)
{
  return (range.lower > -maxRange &&
          range.upper < maxRange &&
          qAbs(range.lower-range.upper) > minRange &&
          qAbs(range.lower-range.upper) < maxRange &&
          !(range.lower > 0 && qIsInf(range.upper/range.lower)) &&
          !(range.upper < 0 && qIsInf(range.lower/range.upper)));
}
/* end of 'src/axis/range.cpp' */


/* including file 'src/selection.cpp', size 21906                            */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / axis / range.cpp'의 끝 */


/* 파일 'src / selection.cpp', 크기 21906 포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPDataRange
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPDataRange
  \brief Describes a data range given by begin and end index
  
  QCPDataRange holds two integers describing the begin (\ref setBegin) and end (\ref setEnd) index
  of a contiguous set of data points. The end index points to the data point above the last data point that's part of
  the data range, similarly to the nomenclature used in standard iterators.
  
  Data Ranges are not bound to a certain plottable, thus they can be freely exchanged, created and
  modified. If a non-contiguous data set shall be described, the class \ref QCPDataSelection is
  used, which holds and manages multiple instances of \ref QCPDataRange. In most situations, \ref
  QCPDataSelection is thus used.
  
  Both \ref QCPDataRange and \ref QCPDataSelection offer convenience methods to work with them,
  e.g. \ref bounded, \ref expanded, \ref intersects, \ref intersection, \ref adjusted, \ref
  contains. Further, addition and subtraction operators (defined in \ref QCPDataSelection) can be
  used to join/subtract data ranges and data selections (or mixtures), to retrieve a corresponding
  \ref QCPDataSelection.
  
  %QCustomPlot's \ref dataselection "data selection mechanism" is based on \ref QCPDataSelection and
  QCPDataRange.
  
  \note Do not confuse \ref QCPDataRange with \ref QCPRange. A \ref QCPRange describes an interval
  in floating point plot coordinates, e.g. the current axis range.
*/
/*! \ class QCPDataRange
  \ brief 시작 및 끝 인덱스로 지정된 데이터 범위를 설명합니다.
  
  QCPDataRange는 begin (\ ref setBegin) 및 end (\ ref setEnd) 인덱스를 설명하는 두 개의 정수를 포함합니다.
  인접한 데이터 요소 세트의 끝 인덱스는 마지막 데이터 포인트 위에있는 데이터 포인트를 가리 킵니다.
  표준 iterator에서 사용 된 명명법과 유사하게 데이터 범위.
  
  데이터 범위는 특정 플롯 테이블에 바인딩되지 않으므로 자유롭게 교환, 생성 및
  수정 됨. 불연속적인 데이터 집합이 기술되어야한다면, \ ref QCPDataSelection 클래스는
  used는 \ ref QCPDataRange의 여러 인스턴스를 보유하고 관리합니다. 대부분의 상황에서 \ ref
  따라서 QCPDataSelection이 사용됩니다.
  
  \ ref QCPDataRange와 \ ref QCPDataSelection은 둘 다 작업하기 편리한 방법을 제공하지만,
  \ ref 경계, \ ref 확장, \ ref 교차, \ ref 교차, \ ref 조정, \ ref
  포함. 또한, 덧셈과 뺄셈 연산자 (\ ref QCPDataSelection에 정의 됨)가 될 수 있습니다
  데이터 범위 및 데이터 선택 (또는 혼합) 조인 / 뺄셈에 사용되며,
  \ ref QCPDataSelection입니다.
  
  % QCustomPlot의 \ ref dataselection "데이터 선택 메커니즘"은 \ ref QCPDataSelection을 기반으로하며
  QCPDataRange.
  
  \ note \ ref QCPDataRange와 \ ref QCPRange를 혼동하지 마십시오. \ ref QCPRange는 간격을 나타냅니다.
  부동 소수점 플롯 좌표 (예 : 현재 축 범위).
*/

/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */

/*! \fn int QCPDataRange::size() const
  
  Returns the number of data points described by this data range. This is equal to the end index
  minus the begin index.
  
  \see length
*/
/*! \ fn int QCPDataRange :: size () const
  
  이 데이터 범위로 기술되는 데이터 포인트의 수를 돌려줍니다. 이것은 최종 색인과 같습니다.
  시작 인덱스를 뺀 값.
  
  \ 길이보기
*/

/*! \fn int QCPDataRange::length() const
  
  Returns the number of data points described by this data range. Equivalent to \ref size.
*/
/*! \ fn int QCPDataRange :: length () const
  
  이 데이터 범위로 기술되는 데이터 포인트의 수를 돌려줍니다. \ ref 크기와 같습니다.
*/

/*! \fn void QCPDataRange::setBegin(int begin)
  
  Sets the begin of this data range. The \a begin index points to the first data point that is part
  of the data range.
  
  No checks or corrections are made to ensure the resulting range is valid (\ref isValid).
  
  \see setEnd
*/
/*! \ fn void QCPDataRange :: setBegin (int begin)
  
  이 데이터 범위의 시작을 설정합니다. 시작 인덱스는 부분 인 첫 번째 데이터 포인트를 가리 킵니다.
  데이터 범위의
  
  결과 범위가 유효한지 확인하거나 수정하지 않습니다 (\ ref isValid).
  
  \ setEnd를 참조하십시오.
*/ 

/*! \fn void QCPDataRange::setEnd(int end)
  
  Sets the end of this data range. The \a end index points to the data point just above the last
  data point that is part of the data range.
  
  No checks or corrections are made to ensure the resulting range is valid (\ref isValid).
  
  \see setBegin
*/
/*! \ fn void QCPDataRange :: setEnd (int end)
  
  이 데이터 범위의 끝을 설정합니다. \ a 끝 인덱스는 마지막 위치 바로 위의 데이터 지점을 가리 킵니다.
  데이터 범위의 일부인 데이터 요소.
  
  결과 범위가 유효한지 확인하거나 수정하지 않습니다 (\ ref isValid).
  
  \ see setBegin
*/

/*! \fn bool QCPDataRange::isValid() const
  
  Returns whether this range is valid. A valid range has a begin index greater or equal to 0, and
  an end index greater or equal to the begin index.
  
  \note Invalid ranges should be avoided and are never the result of any of QCustomPlot's methods
  (unless they are themselves fed with invalid ranges). Do not pass invalid ranges to QCustomPlot's
  methods. The invalid range is not inherently prevented in QCPDataRange, to allow temporary
  invalid begin/end values while manipulating the range. An invalid range is not necessarily empty
  (\ref isEmpty), since its \ref length can be negative and thus non-zero.
*/
/*! \ fn bool QCPDataRange :: isValid () const
  
  이 범위가 유효한가 어떤가를 리턴합니다. 유효한 범위의 시작 색인은 0보다 크거나 같습니다.
  종료 인덱스보다 크거나 같은 종료 인덱스.
  
  \ note 잘못된 범위는 피해야하며 결코 QCustomPlot의 메서드 중 하나의 결과가 아닙니다.
  (그들 자신이 유효하지 않은 범위를 먹여주지 않는 한). QCustomPlot에 잘못된 범위를 전달하지 마십시오.
  행동 양식. 유효하지 않은 범위는 QCPDataRange에서 본질적으로 방지되지 않으므로 임시
  범위를 조작하는 동안 유효하지 않은 시작 / 끝 값 잘못된 범위가 반드시 비어있는 것은 아닙니다.
  (\ ref isEmpty), 그 \ ref 길이는 음수가 될 수 있기 때문에 0이 아니다.
*/

/*! \fn bool QCPDataRange::isEmpty() const
  
  Returns whether this range is empty, i.e. whether its begin index equals its end index.
  
  \see size, length
*/
/*! \ fn bool QCPDataRange :: isEmpty () const
  
  이 범위가 하늘인지, 즉 개시 인덱스가 종료 인덱스와 동일한 지 어떤지를 리턴합니다.
  
  \ 크기, 길이보기
*/

/*! \fn QCPDataRange QCPDataRange::adjusted(int changeBegin, int changeEnd) const
  
  Returns a data range where \a changeBegin and \a changeEnd were added to the begin and end
  indices, respectively.
*/
/*! \ fn QCPataRange QCPDataRange :: adjusted (int changeBegin, int changeEnd) const
  
  \ a changeBegin 및 \ changeEnd가 begin 및 end에 추가 된 데이터 범위를 반환합니다.
  색인.
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */

/*!
  Creates an empty QCPDataRange, with begin and end set to 0.
*/
/*!
  begin 및 end가 0으로 설정된 빈 QCPDataRange를 만듭니다.
*/
QCPDataRange::QCPDataRange() :
  mBegin(0),
  mEnd(0)
{
}

/*!
  Creates a QCPDataRange, initialized with the specified \a begin and \a end.
  
  No checks or corrections are made to ensure the resulting range is valid (\ref isValid).
*/
/*!
  지정된 \ a begin 및 \ a end로 초기화 된 QCPDataRange를 작성합니다.
  
  결과 범위가 유효한지 확인하거나 수정하지 않습니다 (\ ref isValid).
*/
QCPDataRange::QCPDataRange(int begin, int end) :
  mBegin(begin),
  mEnd(end)
{
}

/*!
  Returns a data range that matches this data range, except that parts exceeding \a other are
  excluded.
  
  This method is very similar to \ref intersection, with one distinction: If this range and the \a
  other range share no intersection, the returned data range will be empty with begin and end set
  to the respective boundary side of \a other, at which this range is residing. (\ref intersection
  would just return a range with begin and end set to 0.)
*/
/*!
  이 데이터 범위와 일치하는 데이터 범위를 반환합니다. 단, \ a 이외의 부분은
  제외.
  
  이 방법은 \ ref 교차로와 매우 유사합니다. 단 하나의 구별이 있습니다.이 범위와 \ a
  다른 범위 공유는 교차 없음, 반환 된 데이터 범위는 시작과 끝 집합이 비어있을 것입니다.
  이 범위가 상주하고있는 다른 경계면까지. (\ ref 교차점
  begin과 end가 0으로 설정된 범위를 반환합니다.)
*/
QCPDataRange QCPDataRange::bounded(const QCPDataRange &other) const
{
  QCPDataRange result(intersection(other));
  if (result.isEmpty()) // no intersection, preserve respective bounding side of otherRange as both begin and end of return value
// 교차점이 없으면 반환 값의 시작과 끝 모두로 otherRange의 각 경계면을 유지합니다.
  {
    if (mEnd <= other.mBegin)
      result = QCPDataRange(other.mBegin, other.mBegin);
    else
      result = QCPDataRange(other.mEnd, other.mEnd);
  }
  return result;
}

/*!
  Returns a data range that contains both this data range as well as \a other.
*/
/*!
  이 데이터 범위와 \a other를 모두 포함하는 데이터 범위를 반환합니다.
*/
QCPDataRange QCPDataRange::expanded(const QCPDataRange &other) const
{
  return QCPDataRange(qMin(mBegin, other.mBegin), qMax(mEnd, other.mEnd));
}

/*!
  Returns the data range which is contained in both this data range and \a other.
  
  This method is very similar to \ref bounded, with one distinction: If this range and the \a other
  range share no intersection, the returned data range will be empty with begin and end set to 0.
  (\ref bounded would return a range with begin and end set to one of the boundaries of \a other,
  depending on which side this range is on.)
  
  \see QCPDataSelection::intersection
*/
/*!
  이 데이터 범위와 \ a other에 포함 된 데이터 범위를 반환합니다.
  
  이 방법은 \ ref bound와 매우 흡사합니다. 하나의 차이점이 있습니다 :이 범위와 \ a other
  range는 교차를 공유하지 않고 반환 된 데이터 범위는 begin과 end를 0으로 설정하여 비어있게됩니다.
  (\ ref bounded는 begin과 end가 \ a other의 경계 중 하나로 설정된 범위를 반환합니다.
  이 범위가 어느쪽에 있는지에 따라 다릅니다.)
  
  \ see QCPDataSelection :: intersection
*/
QCPDataRange QCPDataRange::intersection(const QCPDataRange &other) const
{
  QCPDataRange result(qMax(mBegin, other.mBegin), qMin(mEnd, other.mEnd));
  if (result.isValid())
    return result;
  else
    return QCPDataRange();
}

/*!
  Returns whether this data range and \a other share common data points.
  
  \see intersection, contains
*/
/*!
  이 데이터 범위와 다른 데이터 요소가 공통 데이터 포인트를 공유하는지 여부를 반환합니다.
  
  \ 교차로를보고, 다음을 포함합니다.
*/
bool QCPDataRange::intersects(const QCPDataRange &other) const
{
   return !( (mBegin > other.mBegin && mBegin >= other.mEnd) ||
             (mEnd <= other.mBegin && mEnd < other.mEnd) );
}

/*!
  Returns whether all data points described by this data range are also in \a other.
  
  \see intersects
*/
/*!
  이 데이터 범위로 기술 된 모든 데이터 포인트가 \ a에서도 존재할지 어떨지를 돌려줍니다.
  
  \ 교차로보기
*/
bool QCPDataRange::contains(const QCPDataRange &other) const
{
  return mBegin <= other.mBegin && mEnd >= other.mEnd;
}



////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPDataSelection
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPDataSelection
  \brief Describes a data set by holding multiple QCPDataRange instances
  
  QCPDataSelection manages multiple instances of QCPDataRange in order to represent any (possibly
  disjoint) set of data selection.
  
  The data selection can be modified with addition and subtraction operators which take
  QCPDataSelection and QCPDataRange instances, as well as methods such as \ref addDataRange and
  \ref clear. Read access is provided by \ref dataRange, \ref dataRanges, \ref dataRangeCount, etc.
  
  The method \ref simplify is used to join directly adjacent or even overlapping QCPDataRange
  instances. QCPDataSelection automatically simplifies when using the addition/subtraction
  operators. The only case when \ref simplify is left to the user, is when calling \ref
  addDataRange, with the parameter \a simplify explicitly set to false. This is useful if many data
  ranges will be added to the selection successively and the overhead for simplifying after each
  iteration shall be avoided. In this case, you should make sure to call \ref simplify after
  completing the operation.
  
  Use \ref enforceType to bring the data selection into a state complying with the constraints for
  selections defined in \ref QCP::SelectionType.
  
  %QCustomPlot's \ref dataselection "data selection mechanism" is based on QCPDataSelection and
  QCPDataRange.
  
  \section qcpdataselection-iterating Iterating over a data selection
  
  As an example, the following code snippet calculates the average value of a graph's data
  \ref QCPAbstractPlottable::selection "selection":
  
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpdataselection-iterating-1
  
*/
/*! \ class QCPDataSelection
  \ brief 여러 QCPDataRange 인스턴스를 보유하여 데이터 세트를 설명합니다.
  
  QCPDataSelection은 QCPDataRange의 여러 인스턴스를 관리하여
  분리 된) 데이터 선택 세트.
  
  데이터 선택은 더하기 및 빼기 연산자를 사용하여 수정할 수 있습니다.
  QCPDataSelection 및 QCPDataRange 인스턴스는 물론 \ ref addDataRange 및
  \ ref를 지우십시오. 읽기 액세스는 \ ref dataRange, \ ref dataRanges, \ ref dataRangeCount 등에서 제공됩니다.
  
  \ ref simplify 메서드는 인접한 또는 심지어 중복되는 QCPDataRange에 직접 조인하는 데 사용됩니다.
  인스턴스. QCPDataSelection은 덧셈 / 뺄셈을 사용할 때 자동으로 단순화합니다.
  연산자. \ ref 단순화가 사용자에게 맡겨진 유일한 경우는 \ ref를 호출 할 때입니다.
  \ a 매개 변수가있는 addDataRange는 명시 적으로 false로 설정된 단순화됩니다. 이것은 많은 데이터
  범위가 선택 항목에 연속적으로 추가되고 각각 이후의 단순화를위한 오버 헤드
  반복은 피해야한다. 이 경우 \ ref simplify를 호출해야합니다.
  작업을 완료합니다.
  
  \ ref enforceType을 사용하여 데이터 선택을 다음 제약 조건을 준수하는 상태로 만듭니다.
  \ ref QCP :: SelectionType에 정의 된 선택 사항.
  
  % QCustomPlot의 \ ref dataselection "데이터 선택 메커니즘"은 QCPDataSelection을 기반으로하며
  QCPDataRange.
  
  \ section qcpdataselection-iterating 데이터 선택 반복
  
  예를 들어, 다음 코드 스 니펫은 그래프 데이터의 평균값을 계산합니다
  \ ref QCPAbstractPlottable :: selection "selection":
  
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpdataselection-iterating-1
  
*/

/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */

/*! \fn int QCPDataSelection::dataRangeCount() const
  
  Returns the number of ranges that make up the data selection. The ranges can be accessed by \ref
  dataRange via their index.
  
  \see dataRange, dataPointCount
*/
/*! \ fn int QCPDataSelection :: dataRangeCount () const
  
  데이터 선택을 구성하는 범위의 수를 돌려줍니다. 범위는 \ ref로 액세스 할 수 있습니다.
  dataRange를 인덱스를 통해 가져옵니다.
  
  \ 참조 데이터 범위, dataPointCount
*/


/*! \fn QList<QCPDataRange> QCPDataSelection::dataRanges() const
  
  Returns all data ranges that make up the data selection. If the data selection is simplified (the
  usual state of the selection, see \ref simplify), the ranges are sorted by ascending data point
  index.
  
  \see dataRange
*/
/*! \ fn QList <QCPDataRange> QCPDataSelection :: dataRanges () const
  
  데이터 선택을 구성하는 모든 데이터 범위를 반환합니다. 데이터 선택이 단순화되면 (
  선택의 일반적인 상태, \ ref simplify 참조), 범위는 오름차순 데이터 포인트로 정렬됩니다
  색인.
  
  \ see dataRange
*/

/*! \fn bool QCPDataSelection::isEmpty() const
  
  Returns true if there are no data ranges, and thus no data points, in this QCPDataSelection
  instance.
  
  \see dataRangeCount
*/
/*! \ fn bool QCPDataSelection :: isEmpty () const
  
  이 QCPDataSelection에 데이터 범위가없고 데이터 포인트가없는 경우 true를 반환합니다.
  예.
  
  \ see dataRangeCount
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */

/*!
  Creates an empty QCPDataSelection.
*/
/*!
  빈 QCPDataSelection을 만듭니다.
*/
QCPDataSelection::QCPDataSelection()
{
}

/*!
  Creates a QCPDataSelection containing the provided \a range.
*/
/*!
  제공된 \ a 범위를 포함하는 QCPDataSelection을 작성합니다.
*/
QCPDataSelection::QCPDataSelection(const QCPDataRange &range)
{
  mDataRanges.append(range);
}

/*!
  Returns true if this selection is identical (contains the same data ranges with the same begin
  and end indices) to \a other.

  Note that both data selections must be in simplified state (the usual state of the selection, see
  \ref simplify) for this operator to return correct results.
*/
/*!
  이 선택이 동일하면 true를 반환합니다 (동일한 begin
  끝 인덱스)를 \ a로 설정합니다.

  두 데이터 선택 모두 단순화 된 상태 여야합니다 (선택의 일반적인 상태,
  \ ref simplify) 올바른 결과를 반환합니다.
*/
bool QCPDataSelection::operator==(const QCPDataSelection &other) const
{
  if (mDataRanges.size() != other.mDataRanges.size())
    return false;
  for (int i=0; i<mDataRanges.size(); ++i)
  {
    if (mDataRanges.at(i) != other.mDataRanges.at(i))
      return false;
  }
  return true;
}

/*!
  Adds the data selection of \a other to this data selection, and then simplifies this data
  selection (see \ref simplify).
*/
/*!
  \ a의 데이터 선택을이 데이터 선택에 추가 한 다음이 데이터를 단순화합니다.
  선택 (\ ref 단순화 참조).
*/
QCPDataSelection &QCPDataSelection::operator+=(const QCPDataSelection &other)
{
  mDataRanges << other.mDataRanges;
  simplify();
  return *this;
}

/*!
  Adds the data range \a other to this data selection, and then simplifies this data selection (see
  \ref simplify).
*/
/*!
  이 데이터 선택에 데이터 범위 \ a를 추가 한 다음이 데이터 선택을 단순화합니다 (
  \ ref 단순화).
*/
QCPDataSelection &QCPDataSelection::operator+=(const QCPDataRange &other)
{
  addDataRange(other);
  return *this;
}

/*!
  Removes all data point indices that are described by \a other from this data selection.
*/
/*!
  이 데이터 선택에서 \ a에 의해 기술 된 모든 데이터 요소 인덱스를 제거합니다.
*/
QCPDataSelection &QCPDataSelection::operator-=(const QCPDataSelection &other)
{
  for (int i=0; i<other.dataRangeCount(); ++i)
    *this -= other.dataRange(i);
  
  return *this;
}

/*!
  Removes all data point indices that are described by \a other from this data selection.
*/
/*!
  이 데이터 선택에서 \ a에 의해 기술 된 모든 데이터 요소 인덱스를 제거합니다.
*/
QCPDataSelection &QCPDataSelection::operator-=(const QCPDataRange &other)
{
  if (other.isEmpty() || isEmpty())
    return *this;
  
  simplify();
  int i=0;
  while (i < mDataRanges.size())
  {
    const int thisBegin = mDataRanges.at(i).begin();
    const int thisEnd = mDataRanges.at(i).end();
    if (thisBegin >= other.end())
      break; // since data ranges are sorted after the simplify() call, no ranges which contain other will come after this
// 데이터 범위는 simplify () 호출 후에 정렬되므로 다른 항목을 포함하는 범위는이 뒤에옵니다
    
    if (thisEnd > other.begin()) // ranges which don't fulfill this are entirely before other and can be ignored
    {                            //이 작업을 수행하지 않는 범위는 완전히 다른 것보다 앞에 있으므로 무시할 수 있습니다.
      if (thisBegin >= other.begin()) // range leading segment is encompassed
      {                               // 범위 선도 세그먼트가 포함됩니다.
        if (thisEnd <= other.end()) // range fully encompassed, remove completely
        {                           // 범위가 완전히 포함되고 완전히 제거됩니다.
          mDataRanges.removeAt(i);
          continue;
        } else // only leading segment is encompassed, trim accordingly
               // 선두 세그먼트 만 둘러싸여, 그에 따라 트림합니다
          mDataRanges[i].setBegin(other.end());
      } else // leading segment is not encompassed
      {      // 선두 세그먼트는 포함되지 않습니다.
        if (thisEnd <= other.end()) // only trailing segment is encompassed, trim accordingly
        {                           // 꼬리 인 세그먼트 만 포함되고 그에 따라 트림됩니다.
          mDataRanges[i].setEnd(other.begin());
        } else // other lies inside this range, so split range
        {      // 다른 범위가이 범위 안에 있으므로 범위가 분할됩니다.
          mDataRanges[i].setEnd(other.begin());
          mDataRanges.insert(i+1, QCPDataRange(other.end(), thisEnd));
          break; // since data ranges are sorted (and don't overlap) after simplify() call, we're done here
        }        // simplify () 호출 후 데이터 범위가 정렬되고 겹치지 않으므로 여기서 완료됩니다.
      }
    }
    ++i;
  }
  
  return *this;
}

/*!
  Returns the total number of data points contained in all data ranges that make up this data
  selection.
*/
/*!
  이 데이터를 구성하는 모든 데이터 범위에 포함 된 데이터 요소의 총 수를 반환합니다.
  선택.
*/
int QCPDataSelection::dataPointCount() const
{
  int result = 0;
  for (int i=0; i<mDataRanges.size(); ++i)
    result += mDataRanges.at(i).length();
  return result;
}

/*!
  Returns the data range with the specified \a index.
  
  If the data selection is simplified (the usual state of the selection, see \ref simplify), the
  ranges are sorted by ascending data point index.
  
  \see dataRangeCount
*/
/*!
  지정된 \ a 인덱스가있는 데이터 범위를 반환합니다.
  
  데이터 선택이 단순화되면 (선택의 일반적인 상태는 \ ref simplify를 참조하십시오),
  범위는 오름차순 데이터 요소 인덱스로 정렬됩니다.
  
  \ see dataRangeCount
*/
QCPDataRange QCPDataSelection::dataRange(int index) const
{
  if (index >= 0 && index < mDataRanges.size())
  {
    return mDataRanges.at(index);
  } else
  {
    qDebug() << Q_FUNC_INFO << "index out of range:" << index;
    return QCPDataRange();
  }
}

/*!
  Returns a \ref QCPDataRange which spans the entire data selection, including possible
  intermediate segments which are not part of the original data selection.
*/
/*!
  가능한 모든 데이터를 포함하는 \ ref QCPDataRange를 반환합니다.
  원래 데이터 선택의 일부가 아닌 중간 세그먼트.
*/
QCPDataRange QCPDataSelection::span() const
{
  if (isEmpty())
    return QCPDataRange();
  else
    return QCPDataRange(mDataRanges.first().begin(), mDataRanges.last().end());
}

/*!
  Adds the given \a dataRange to this data selection. This is equivalent to the += operator but
  allows disabling immediate simplification by setting \a simplify to false. This can improve
  performance if adding a very large amount of data ranges successively. In this case, make sure to
  call \ref simplify manually, after the operation.
*/
/*!
  주어진 \ dataRange를이 데이터 선택에 추가합니다. 이것은 + = 연산자와 동일하지만
  \ a simplify를 false로 설정하여 즉각적인 단순화를 비활성화 할 수 있습니다. 이것은 향상시킬 수있다.
  매우 많은 양의 데이터 범위를 연속적으로 추가하면 성능이 저하됩니다. 이 경우
  \ ref를 호출하면 조작 후 수동으로 단순화됩니다.
*/
void QCPDataSelection::addDataRange(const QCPDataRange &dataRange, bool simplify)
{
  mDataRanges.append(dataRange);
  if (simplify)
    this->simplify();
}

/*!
  Removes all data ranges. The data selection then contains no data points.
  
  \ref isEmpty
*/
/*!
  모든 데이터 범위를 제거합니다. 그런 다음 데이터 선택에 데이터 점이 없습니다.
  
  \ ref isEmpty
*/
void QCPDataSelection::clear()
{
  mDataRanges.clear();
}

/*!
  Sorts all data ranges by range begin index in ascending order, and then joins directly adjacent
  or overlapping ranges. This can reduce the number of individual data ranges in the selection, and
  prevents possible double-counting when iterating over the data points held by the data ranges.

  This method is automatically called when using the addition/subtraction operators. The only case
  when \ref simplify is left to the user, is when calling \ref addDataRange, with the parameter \a
  simplify explicitly set to false.
*/
/*!
  범위에 따라 모든 데이터 범위를 오름차순으로 정렬 한 다음 바로 인접한 항목에 조인합니다.
  또는 겹치는 범위. 이렇게하면 선택 영역에서 개별 데이터 범위의 수를 줄일 수 있습니다.
  데이터 범위가 보유하는 데이터 요소를 반복 할 때 가능한 이중 계산을 방지합니다.

  이 메서드는 더하기 / 빼기 연산자를 사용할 때 자동으로 호출됩니다. 유일한 경우
  \ ref 단순화가 사용자에게 남았을 때 \ ref addDataRange를 호출 할 때 매개 변수 \ a를 사용합니다.
  명시 적으로 false로 설정하면 단순화됩니다.
*/
void QCPDataSelection::simplify()
{
  // remove any empty ranges:
  // 빈 범위를 모두 제거합니다.
  for (int i=mDataRanges.size()-1; i>=0; --i)
  {
    if (mDataRanges.at(i).isEmpty())
      mDataRanges.removeAt(i);
  }
  if (mDataRanges.isEmpty())
    return;
  
  // sort ranges by starting value, ascending:
  // 시작 값, 오름차순으로 범위 정렬 :
  std::sort(mDataRanges.begin(), mDataRanges.end(), lessThanDataRangeBegin);
  
  // join overlapping/contiguous ranges:
  // 겹치거나 연속하는 범위에 가입 :
  int i = 1;
  while (i < mDataRanges.size())
  {
    if (mDataRanges.at(i-1).end() >= mDataRanges.at(i).begin()) // range i overlaps/joins with i-1, so expand range i-1 appropriately and remove range i from list
// 범위 i는 i-1과 겹치거나 조인되므로 범위 i-1을 적절히 확장하고 범위 i를 제거합니다 (범위가 i-1 인 경우). 목록에서
    {
      mDataRanges[i-1].setEnd(qMax(mDataRanges.at(i-1).end(), mDataRanges.at(i).end()));
      mDataRanges.removeAt(i);
    } else
      ++i;
  }
}

/*!
  Makes sure this data selection conforms to the specified \a type selection type. Before the type
  is enforced, \ref simplify is called.
  
  Depending on \a type, enforcing means adding new data points that were previously not part of the
  selection, or removing data points from the selection. If the current selection already conforms
  to \a type, the data selection is not changed.
  
  \see QCP::SelectionType
*/
/*!
  이 데이터 선택이 지정된 \ a 유형 선택 유형을 따르는 지 확인합니다. 유형 전에
  \ ref 단순화가 호출됩니다.
  
  \ a 유형에 따라 시행은 이전에 해당 데이터 요소의 일부가 아닌 새 데이터 요소를 추가하는 것을 의미합니다.
  선택 또는 제거 할 수 있습니다. 현재 선택 항목이 이미 준수하는 경우
  to \ a type의 경우 데이터 선택이 변경되지 않습니다.
  
  \ see QCP :: SelectionType
*/
void QCPDataSelection::enforceType(QCP::SelectionType type)
{
  simplify();
  switch (type)
  {
    case QCP::stNone:
    {
      mDataRanges.clear();
      break;
    }
    case QCP::stWhole:
    {
      // whole selection isn't defined by data range, so don't change anything (is handled in plottable methods)
      // 전체 선택은 데이터 범위에 의해 정의되지 않으므로 아무 것도 변경하지 마십시오 (plottable 메서드로 처리됩니다)
      break;
    }
    case QCP::stSingleData:
    {
      // reduce all data ranges to the single first data point:
      // 모든 데이터 범위를 단일 첫 번째 데이터 지점으로 줄입니다.
      if (!mDataRanges.isEmpty())
      {
        if (mDataRanges.size() > 1)
          mDataRanges = QList<QCPDataRange>() << mDataRanges.first();
        if (mDataRanges.first().length() > 1)
          mDataRanges.first().setEnd(mDataRanges.first().begin()+1);
      }
      break;
    }
    case QCP::stDataRange:
    {
      mDataRanges = QList<QCPDataRange>() << span();
      break;
    }
    case QCP::stMultipleDataRanges:
    {
      // this is the selection type that allows all concievable combinations of ranges, so do nothing
      // 이것은 concordable range의 모든 조합을 허용하는 선택 유형이므로 아무 것도하지 않습니다.
      break;
    }
  }
}

/*!
  Returns true if the data selection \a other is contained entirely in this data selection, i.e.
  all data point indices that are in \a other are also in this data selection.
  
  \see QCPDataRange::contains
*/
/*!
  데이터 선택 \ a other가이 데이터 선택 영역에 완전히 포함되어 있으면 true를 반환합니다. 즉
  다른 데이터 포인트 인덱스도이 데이터 선택에 있습니다.
  
  \ see QCPDataRange :: contains
*/
bool QCPDataSelection::contains(const QCPDataSelection &other) const
{
  if (other.isEmpty()) return false;
  
  int otherIndex = 0;
  int thisIndex = 0;
  while (thisIndex < mDataRanges.size() && otherIndex < other.mDataRanges.size())
  {
    if (mDataRanges.at(thisIndex).contains(other.mDataRanges.at(otherIndex)))
      ++otherIndex;
    else
      ++thisIndex;
  }
  return thisIndex < mDataRanges.size(); // if thisIndex ran all the way to the end to find a containing range for the current otherIndex, other is not contained in this
// 현재 otherIndex의 포함 범위를 찾기 위해 thisIndex가 끝까지 실행 된 경우 other에 포함되지 않습니다.
}

/*!
  Returns a data selection containing the points which are both in this data selection and in the
  data range \a other.

  A common use case is to limit an unknown data selection to the valid range of a data container,
  using \ref QCPDataContainer::dataRange as \a other. One can then safely iterate over the returned
  data selection without exceeding the data container's bounds.
*/
/*!
  이 데이터 선택 영역과 선택 영역 모두에있는 점을 포함하는 데이터 선택 물을 반환합니다.
  데이터 범위 \ 기타.

  일반적인 사용 사례는 알 수없는 데이터 선택을 데이터 컨테이너의 유효한 범위로 제한하는 것입니다.
  \ ref QCPDataContainer :: dataRange를 \ 기타로 사용합니다. 그런 다음 반환 된 항목을 안전하게 반복 할 수 있습니다.
  데이터 컨테이너의 범위를 초과하지 않고 데이터를 선택할 수 있습니다.
*/
QCPDataSelection QCPDataSelection::intersection(const QCPDataRange &other) const
{
  QCPDataSelection result;
  for (int i=0; i<mDataRanges.size(); ++i)
    result.addDataRange(mDataRanges.at(i).intersection(other), false);
  result.simplify();
  return result;
}

/*!
  Returns a data selection containing the points which are both in this data selection and in the
  data selection \a other.
*/
/*!
  이 데이터 선택 영역과 선택 영역 모두에있는 점을 포함하는 데이터 선택 물을 반환합니다.
  데이터 선택 \ 기타.
*/
QCPDataSelection QCPDataSelection::intersection(const QCPDataSelection &other) const
{
  QCPDataSelection result;
  for (int i=0; i<other.dataRangeCount(); ++i)
    result += intersection(other.dataRange(i));
  result.simplify();
  return result;
}

/*!
  Returns a data selection which is the exact inverse of this data selection, with \a outerRange
  defining the base range on which to invert. If \a outerRange is smaller than the \ref span of
  this data selection, it is expanded accordingly.

  For example, this method can be used to retrieve all unselected segments by setting \a outerRange
  to the full data range of the plottable, and calling this method on a data selection holding the
  selected segments.
*/
/*!
  이 데이터 선택과 정확히 반대의 데이터 선택을 리턴합니다. \ a outerRange
  반전시킬 기준 범위를 정의합니다. \ a outerRange가 \ ref span보다 작 으면
  이 데이터 선택, 그에 따라 확장됩니다.

  예를 들어,이 메소드는 \ a outerRange를 설정하여 선택되지 않은 모든 세그먼트를 검색하는 데 사용할 수 있습니다.
  플롯 테이블의 전체 데이터 범위에 적용하고이 메소드를
  선택한 세그먼트.
*/
QCPDataSelection QCPDataSelection::inverse(const QCPDataRange &outerRange) const
{
  if (isEmpty())
    return QCPDataSelection(outerRange);
  QCPDataRange fullRange = outerRange.expanded(span());
  
  QCPDataSelection result;
  // first unselected segment:
  // 첫 번째 선택되지 않은 세그먼트 :
  if (mDataRanges.first().begin() != fullRange.begin())
    result.addDataRange(QCPDataRange(fullRange.begin(), mDataRanges.first().begin()), false);
  // intermediate unselected segments:
  // 중간 미확인 세그먼트 :
  for (int i=1; i<mDataRanges.size(); ++i)
    result.addDataRange(QCPDataRange(mDataRanges.at(i-1).end(), mDataRanges.at(i).begin()), false);
  // last unselected segment:
  // 마지막으로 선택되지 않은 세그먼트:
  if (mDataRanges.last().end() != fullRange.end())
    result.addDataRange(QCPDataRange(mDataRanges.last().end(), fullRange.end()), false);
  result.simplify();
  return result;
}
/* end of 'src/selection.cpp' */
/* 'src / selection.cpp'의 끝 */

/* including file 'src/selectionrect.cpp', size 9224                         */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 파일 'src / selectionrect.cpp'포함, 크기 9224 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPSelectionRect
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPSelectionRect
  \brief Provides rect/rubber-band data selection and range zoom interaction
  
  QCPSelectionRect is used by QCustomPlot when the \ref QCustomPlot::setSelectionRectMode is not
  \ref QCP::srmNone. When the user drags the mouse across the plot, the current selection rect
  instance (\ref QCustomPlot::setSelectionRect) is forwarded these events and makes sure an
  according rect shape is drawn. At the begin, during, and after completion of the interaction, it
  emits the corresponding signals \ref started, \ref changed, \ref canceled, and \ref accepted.
  
  The QCustomPlot instance connects own slots to the current selection rect instance, in order to
  react to an accepted selection rect interaction accordingly.
  
  \ref isActive can be used to check whether the selection rect is currently active. An ongoing
  selection interaction can be cancelled programmatically via calling \ref cancel at any time.
  
  The appearance of the selection rect can be controlled via \ref setPen and \ref setBrush.

  If you wish to provide custom behaviour, e.g. a different visual representation of the selection
  rect (\ref QCPSelectionRect::draw), you can subclass QCPSelectionRect and pass an instance of
  your subclass to \ref QCustomPlot::setSelectionRect.
*/
/*! \ class QCPSelectionRect
  \ brief rect / rubber-band 데이터 선택 및 범위 확대 / 축소 상호 작용을 제공합니다.
  
  QCPSelectionRect는 \ QC QCustomPlot :: setSelectionRectMode가 없을 때 QCustomPlot에 의해 사용됩니다.
  \ ref QCP :: srmNone. 사용자가 플롯에서 마우스를 드래그하면 현재 선택 항목 rect
  인스턴스 (\ ref QCustomPlot :: setSelectionRect)는 이러한 이벤트를 전달하고
  rect 모양에 따라 그려집니다. 상호 작용의 시작, 중간 및 완료시,
  \ ref가 시작되고 \ ref가 변경되고 \ ref가 취소되고 \ ref가 수락됩니다.
  
  QCustomPlot 인스턴스는 자체 슬롯을 현재 선택 rect 인스턴스에 연결하여
  그에 따라 수용된 선택 직사각형 상호 작용에 반응한다.
  
  \ ref isActive는 selection rect가 현재 활성화되어 있는지 확인하는 데 사용할 수 있습니다. 진행중인
  선택 인터랙션은 언제든지 \ ref cancel을 호출하여 프로그래밍 방식으로 취소 할 수 있습니다.
  
  선택 rect의 모양은 \ ref setPen 및 \ ref setBrush를 통해 제어 할 수 있습니다.

  사용자 정의 동작 (예 : 선택 영역의 다른 시각적 표현)을 제공하려는 경우
  rect (\ ref QCPSelectionRect :: draw)를 사용하면 QCPSelectionRect를 서브 클래스화할 수 있고
  하위 클래스를 \ ref QCustomPlot :: setSelectionRect에 추가하십시오.
*/

/* start of documentation of inline functions */
/* 인라인 함수의 문서화 시작 */

/*! \fn bool QCPSelectionRect::isActive() const
   
  Returns true if there is currently a selection going on, i.e. the user has started dragging a
  selection rect, but hasn't released the mouse button yet.
    
  \see cancel
*/
/*! \ fn bool QCPSelectionRect :: isActive () const
   
  현재 선택 범위가 존재하는 경우, 즉 유저가 a를 드래그하기 시작한 경우는 true를 돌려줍니다.
  마우스를 아직 놓지 않았습니다.
    
  \ 취소보기
*/

/* end of documentation of inline functions */
/* start documentation of signals */
/* 인라인 함수의 문서 끝 */
/* 신호의 문서화를 시작한다. */

/*! \fn void QCPSelectionRect::started(QMouseEvent *event);
   
  This signal is emitted when a selection rect interaction was initiated, i.e. the user just
  started dragging the selection rect with the mouse.
*/
/*! \ fn void QCPSelectionRect :: started (QMouseEvent * event);
   
  선택 신호 상호 작용이 시작되면이 신호가 방출됩니다. 즉 사용자는
  마우스로 선택 영역을 드래그하기 시작했습니다.
*/

/*! \fn void QCPSelectionRect::changed(const QRect &rect, QMouseEvent *event);
  
  This signal is emitted while the selection rect interaction is ongoing and the \a rect has
  changed its size due to the user moving the mouse.
  
  Note that \a rect may have a negative width or height, if the selection is being dragged to the
  upper or left side of the selection rect origin.
*/
/*! \ fn void QCPSelectionRect :: changed (const QRect & rect, QMouseEvent * event);
  
  선택 신호 상호 작용이 진행 중이고 \ a rect에있는 동안이 신호가 방출됩니다.
  사용자가 마우스를 움직이면 크기가 변경되었습니다.
  
  선택 영역이 드래그되어있는 경우 \ a rect의 너비 또는 높이가 음수가 될 수 있습니다.
  선택 사항 직사각형의 왼쪽 위 또는 왼쪽.
*/

/*! \fn void QCPSelectionRect::canceled(const QRect &rect, QInputEvent *event);
  
  This signal is emitted when the selection interaction was cancelled. Note that \a event is 0 if
  the selection interaction was cancelled programmatically, by a call to \ref cancel.
  
  The user may cancel the selection interaction by pressing the escape key. In this case, \a event
  holds the respective input event.
  
  Note that \a rect may have a negative width or height, if the selection is being dragged to the
  upper or left side of the selection rect origin.
*/
/*! \ fn void QCPSelectionRect :: canceled (const QRect & rect, QInputEvent * event);
  
  선택 상호 작용이 취소되면이 신호가 방출됩니다. \ a 이벤트는 0입니다.
  선택 상호 작용은 \ ref cancel을 호출하여 프로그래밍 방식으로 취소되었습니다.
  
  사용자는 이스케이프 키를 눌러 선택 상호 작용을 취소 할 수 있습니다. 이 경우 \ a 이벤트
  각각의 입력 이벤트를 보유합니다.
  
  선택 영역이 드래그되어있는 경우 \ a rect의 너비 또는 높이가 음수가 될 수 있습니다.
  선택 사항 직사각형의 왼쪽 위 또는 왼쪽.
*/

/*! \fn void QCPSelectionRect::accepted(const QRect &rect, QMouseEvent *event);
  
  This signal is emitted when the selection interaction was completed by the user releasing the
  mouse button.
    
  Note that \a rect may have a negative width or height, if the selection is being dragged to the
  upper or left side of the selection rect origin.
*/
/*! \ fn void QCPSelectionRect :: accepted (const QRect & rect, QMouseEvent * event);
  
  사용자가 선택 상호 작용을 완료하면이 신호가 방출됩니다.
  마우스 버튼.
    
  선택 영역이 드래그되어있는 경우 \ a rect의 너비 또는 높이가 음수가 될 수 있습니다.
  선택 사항 직사각형의 왼쪽 위 또는 왼쪽.
*/

/* end documentation of signals */
/* 신호의 끝 문서 */

/*!
  Creates a new QCPSelectionRect instance. To make QCustomPlot use the selection rect instance,
  pass it to \ref QCustomPlot::setSelectionRect. \a parentPlot should be set to the same
  QCustomPlot widget.
*/
/*!
  새 QCPSelectionRect 인스턴스를 만듭니다. QCustomPlot이 selection rect 인스턴스를 사용하게하려면,
  \ ref QCustomPlot :: setSelectionRect로 전달하십시오. \ parentPlot은 같은 것으로 설정되어야합니다.
  QCustomPlot 위젯.
*/
QCPSelectionRect::QCPSelectionRect(QCustomPlot *parentPlot) :
  QCPLayerable(parentPlot),
  mPen(QBrush(Qt::gray), 0, Qt::DashLine),
  mBrush(Qt::NoBrush),
  mActive(false)
{
}

QCPSelectionRect::~QCPSelectionRect()
{
  cancel();
}

/*!
  A convenience function which returns the coordinate range of the provided \a axis, that this
  selection rect currently encompasses.
*/
/*!
  제공된 \ a 축의 좌표 범위를 반환하는 편리한 함수입니다.
  선택 영역은 현재 포함됩니다.
*/
QCPRange QCPSelectionRect::range(const QCPAxis *axis) const
{
  if (axis)
  {
    if (axis->orientation() == Qt::Horizontal)
      return QCPRange(axis->pixelToCoord(mRect.left()), axis->pixelToCoord(mRect.left()+mRect.width()));
    else
      return QCPRange(axis->pixelToCoord(mRect.top()+mRect.height()), axis->pixelToCoord(mRect.top()));
  } else
  {
    qDebug() << Q_FUNC_INFO << "called with axis zero";
    return QCPRange();
  }
}

/*!
  Sets the pen that will be used to draw the selection rect outline.
  
  \see setBrush
*/
/*!
  선택 항목 개요를 그리는 데 사용할 펜을 설정합니다.
  
  \ setBrush를 참조하십시오.
*/
void QCPSelectionRect::setPen(const QPen &pen)
{
  mPen = pen;
}

/*!
  Sets the brush that will be used to fill the selection rect. By default the selection rect is not
  filled, i.e. \a brush is <tt>Qt::NoBrush</tt>.
  
  \see setPen
*/
/*!
  선택 사항 rect를 채우는 데 사용할 브러쉬를 설정합니다. 기본적으로 선택 항목은 없습니다.
  즉, 브러시는 <tt> Qt :: NoBrush </ tt>입니다.
  
  \ see setPen
*/
void QCPSelectionRect::setBrush(const QBrush &brush)
{
  mBrush = brush;
}

/*!
  If there is currently a selection interaction going on (\ref isActive), the interaction is
  canceled. The selection rect will emit the \ref canceled signal.
*/
/*!
  현재 선택 상호 작용이 진행중인 경우 (\ ref isActive) 상호 작용은 다음과 같습니다.
  취소 된. 선택 영역은 \ ref cancelled 신호를 방출합니다.
*/
void QCPSelectionRect::cancel()
{
  if (mActive)
  {
    mActive = false;
    emit canceled(mRect, 0);
  }
}

/*! \internal
  
  This method is called by QCustomPlot to indicate that a selection rect interaction was initiated.
  The default implementation sets the selection rect to active, initializes the selection rect
  geometry and emits the \ref started signal.
*/
/*! \내부의
  
  이 메서드는 QCustomPlot에 의해 호출되어 선택 항목 상호 작용이 시작되었음을 나타냅니다.
  디폴트의 ​​구현은 선택 구석을 액티브하게 설정해, 선택 항목 rect를 초기화합니다.
  기하학을 시작하고 \ ref 시작 신호를 내 보냅니다.
*/
void QCPSelectionRect::startSelection(QMouseEvent *event)
{
  mActive = true;
  mRect = QRect(event->pos(), event->pos());
  emit started(event);
}

/*! \internal
  
  This method is called by QCustomPlot to indicate that an ongoing selection rect interaction needs
  to update its geometry. The default implementation updates the rect and emits the \ref changed
  signal.
*/
/*! \내부의
  
  이 메서드는 QCustomPlot에 의해 호출되어 진행중인 선택 영역 상호 작용이 필요함을 나타냅니다
  그 지오메트리를 갱신한다. 기본 구현은 rect를 업데이트하고 \ ref를 변경합니다.
  신호.
*/
void QCPSelectionRect::moveSelection(QMouseEvent *event)
{
  mRect.setBottomRight(event->pos());
  emit changed(mRect, event);
  layer()->replot();
}

/*! \internal
  
  This method is called by QCustomPlot to indicate that an ongoing selection rect interaction has
  finished by the user releasing the mouse button. The default implementation deactivates the
  selection rect and emits the \ref accepted signal.
*/
/*! \내부의
  
  이 메서드는 QCustomPlot에 의해 호출되어 진행중인 선택 영역 상호 작용에
  사용자가 마우스 버튼을 놓는 것으로 끝난다. 기본 구현은
  선택 rect 및 \ ref 수락 신호를 내 보냅니다.
*/
void QCPSelectionRect::endSelection(QMouseEvent *event)
{
  mRect.setBottomRight(event->pos());
  mActive = false;
  emit accepted(mRect, event);
}

/*! \internal
  
  This method is called by QCustomPlot when a key has been pressed by the user while the selection
  rect interaction is active. The default implementation allows to \ref cancel the interaction by
  hitting the escape key.
*/
/*! \내부의
  
  이 메서드는 사용자가 키를 누른 상태에서 QCustomPlot에 의해 호출됩니다.
  rect 상호 작용이 활성화됩니다. 기본 구현을 통해 상호 작용을 \ ref로 취소 할 수 있습니다.
  이스케이프 키를 친다.
*/
void QCPSelectionRect::keyPressEvent(QKeyEvent *event)
{
  if (event->key() == Qt::Key_Escape && mActive)
  {
    mActive = false;
    emit canceled(mRect, event);
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPSelectionRect::applyDefaultAntialiasingHint(QCPPainter *painter) const
{
  applyAntialiasingHint(painter, mAntialiased, QCP::aeOther);
}

/*! \internal
  
  If the selection rect is active (\ref isActive), draws the selection rect defined by \a mRect.
  
  \seebaseclassmethod
*/
/*! \내부의
  
  선택 rect가 활성화되어 있으면 (\ ref isActive) \ mRect에 의해 정의 된 선택 rect를 그립니다.
  
  \ seebaseclassmethod
*/
void QCPSelectionRect::draw(QCPPainter *painter)
{
  if (mActive)
  {
    painter->setPen(mPen);
    painter->setBrush(mBrush);
    painter->drawRect(mRect);
  }
}
/* end of 'src/selectionrect.cpp' */
/* 'src / selectionrect.cpp'의 끝 */


/* including file 'src/layout.cpp', size 79064                               */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 파일 'src / layout.cpp', 크기 79064 포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPMarginGroup
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPMarginGroup
  \brief A margin group allows synchronization of margin sides if working with multiple layout elements.
  
  QCPMarginGroup allows you to tie a margin side of two or more layout elements together, such that
  they will all have the same size, based on the largest required margin in the group.
  
  \n
  \image html QCPMarginGroup.png "Demonstration of QCPMarginGroup"
  \n
  
  In certain situations it is desirable that margins at specific sides are synchronized across
  layout elements. For example, if one QCPAxisRect is below another one in a grid layout, it will
  provide a cleaner look to the user if the left and right margins of the two axis rects are of the
  same size. The left axis of the top axis rect will then be at the same horizontal position as the
  left axis of the lower axis rect, making them appear aligned. The same applies for the right
  axes. This is what QCPMarginGroup makes possible.
  
  To add/remove a specific side of a layout element to/from a margin group, use the \ref
  QCPLayoutElement::setMarginGroup method. To completely break apart the margin group, either call
  \ref clear, or just delete the margin group.
  
  \section QCPMarginGroup-example Example
  
  First create a margin group:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpmargingroup-creation-1
  Then set this group on the layout element sides:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpmargingroup-creation-2
  Here, we've used the first two axis rects of the plot and synchronized their left margins with
  each other and their right margins with each other.
*/
/*! \ class QCPMarginGroup
  \ brief 여백 그룹을 사용하면 여러 레이아웃 요소로 작업 할 때 여백면을 동기화 할 수 있습니다.
  
  QCPMarginGroup을 사용하면 두 개 이상의 레이아웃 요소의 여백면을 함께 묶을 수 있습니다.
  그룹에서 필요한 최대 마진을 기준으로 모두 동일한 크기를 갖습니다.
  
  \엔
  \ image html QCPMarginGroup.png "QCPMarginGroup 데모"
  \엔
  
  특정 상황에서 특정 측면의 여백이 전체적으로 동기화되는 것이 바람직합니다
  레이아웃 요소. 예를 들어, 하나의 QCPAxisRect가 격자 레이아웃의 다른 QCPAxisRect보다 낮 으면
  두 개의 축 rect의 왼쪽 및 오른쪽 여백이
  같은 사이즈. 상단 축 rect의 왼쪽 축은 다음과 같은 수평 위치에 있습니다.
  아래 축 rect의 왼쪽 축. 권리는 동일하게 적용됩니다.
  축. 이것은 QCPMarginGroup이 가능하게하는 것입니다.
  
  여백 그룹에 /에서 레이아웃 요소의 특정면을 추가 / 제거하려면 \ ref
  QCPLayoutElement :: setMarginGroup 메소드. 여백 그룹을 완전히 분리하려면 전화
  \ ref를 지우거나 여백 그룹을 삭제하면됩니다.
  
  \ section QCPMarginGroup-example 예제
  
  먼저 여백 그룹을 만듭니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpmargingroup-creation-1
  그런 다음 레이아웃 요소 측면에서이 그룹을 설정하십시오.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpmargingroup-creation-2
  여기서는 플롯의 처음 두 축 rect를 사용하고 왼쪽 여백을
  서로와 그들의 오른쪽 여백을 서로 비교합니다.
*/

/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */
/*! \fn QList<QCPLayoutElement*> QCPMarginGroup::elements(QCP::MarginSide side) const
  
  Returns a list of all layout elements that have their margin \a side associated with this margin
  group.
*/
/*! \ fn QList <QCPLayoutElement *> QCPMarginGroup :: elements (QCP :: 마진 사이드 쪽) const
  
  이 마진과 관련된 여백을 갖는 모든 레이아웃 요소의 목록을 반환합니다.
  그룹.
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */

/*!
  Creates a new QCPMarginGroup instance in \a parentPlot.
*/
/*!
  \ parentPlot에 새 QCPMarginGroup 인스턴스를 만듭니다.
*/
QCPMarginGroup::QCPMarginGroup(QCustomPlot *parentPlot) :
  QObject(parentPlot),
  mParentPlot(parentPlot)
{
  mChildren.insert(QCP::msLeft, QList<QCPLayoutElement*>());
  mChildren.insert(QCP::msRight, QList<QCPLayoutElement*>());
  mChildren.insert(QCP::msTop, QList<QCPLayoutElement*>());
  mChildren.insert(QCP::msBottom, QList<QCPLayoutElement*>());
}

QCPMarginGroup::~QCPMarginGroup()
{
  clear();
}

/*!
  Returns whether this margin group is empty. If this function returns true, no layout elements use
  this margin group to synchronize margin sides.
*/
/*!
  이 마진 그룹이 비 었는지를 반환합니다. 이 함수가 true를 반환하면 레이아웃 요소를 사용하지 않습니다.
  이 여백 그룹은 여백면을 동기화합니다.
*/
bool QCPMarginGroup::isEmpty() const
{
  QHashIterator<QCP::MarginSide, QList<QCPLayoutElement*> > it(mChildren);
  while (it.hasNext())
  {
    it.next();
    if (!it.value().isEmpty())
      return false;
  }
  return true;
}

/*!
  Clears this margin group. The synchronization of the margin sides that use this margin group is
  lifted and they will use their individual margin sizes again.
*/
/*!
  이 여백 그룹을 지 웁니다. 이 여백 그룹을 사용하는 여백 쪽의 동기화는 다음과 같습니다.
  해제되고 개별적인 여백 크기가 다시 사용됩니다.
*/
void QCPMarginGroup::clear()
{
  // make all children remove themselves from this margin group:
  // 모든 아이들이이 여백 그룹에서 자신을 제거하도록합니다 :
  QHashIterator<QCP::MarginSide, QList<QCPLayoutElement*> > it(mChildren);
  while (it.hasNext())
  {
    it.next();
    const QList<QCPLayoutElement*> elements = it.value();
    for (int i=elements.size()-1; i>=0; --i)
      elements.at(i)->setMarginGroup(it.key(), 0); // removes itself from mChildren via removeChild
  }                                                // removeChild를 통해 mChildren에서 자신을 제거한다.
}

/*! \internal
  
  Returns the synchronized common margin for \a side. This is the margin value that will be used by
  the layout element on the respective side, if it is part of this margin group.
  
  The common margin is calculated by requesting the automatic margin (\ref
  QCPLayoutElement::calculateAutoMargin) of each element associated with \a side in this margin
  group, and choosing the largest returned value. (QCPLayoutElement::minimumMargins is taken into
  account, too.)
*/
/*! \내부의
  
  \ a 측의 동기 공통 마진을 돌려줍니다. 이 값은에 의해 사용될 여백 값입니다.
  이 마진 그룹의 일부인 경우 각면의 레이아웃 요소.
  
  공통 마진은 자동 마진 (\ ref
  QCPLayoutElement :: calculateAutoMargin)이 마진에있는 \ a와 연결된 각 요소
  그룹을 선택하고 가장 큰 반환 값을 선택하십시오. (QCPLayoutElement :: minimumMargins는
  계정도
*/
int QCPMarginGroup::commonMargin(QCP::MarginSide side) const
{
  // query all automatic margins of the layout elements in this margin group side and find maximum:
  //이 여백 그룹 측면의 레이아웃 요소에 대한 자동 여백을 모두 쿼리하고 최대 값을 찾습니다.
  int result = 0;
  const QList<QCPLayoutElement*> elements = mChildren.value(side);
  for (int i=0; i<elements.size(); ++i)
  {
    if (!elements.at(i)->autoMargins().testFlag(side))
      continue;
    int m = qMax(elements.at(i)->calculateAutoMargin(side), QCP::getMarginValue(elements.at(i)->minimumMargins(), side));
    if (m > result)
      result = m;
  }
  return result;
}

/*! \internal
  
  Adds \a element to the internal list of child elements, for the margin \a side.
  
  This function does not modify the margin group property of \a element.
*/
/*! \내부의
  
  여백 \ a쪽에 대해 \ a 요소를 자식 요소의 내부 목록에 추가합니다.
  
  이 함수는 \ a 요소의 여백 그룹 특성을 수정하지 않습니다.
*/
void QCPMarginGroup::addChild(QCP::MarginSide side, QCPLayoutElement *element)
{
  if (!mChildren[side].contains(element))
    mChildren[side].append(element);
  else
    qDebug() << Q_FUNC_INFO << "element is already child of this margin group side" << reinterpret_cast<quintptr>(element);
}

/*! \internal
  
  Removes \a element from the internal list of child elements, for the margin \a side.
  
  This function does not modify the margin group property of \a element.
*/
/*! \내부의
  
  여백 \ a쪽에 대해 자식 요소의 내부 목록에서 \ a 요소를 제거합니다.
  
  이 함수는 \ a 요소의 여백 그룹 특성을 수정하지 않습니다.
*/
void QCPMarginGroup::removeChild(QCP::MarginSide side, QCPLayoutElement *element)
{
  if (!mChildren[side].removeOne(element))
    qDebug() << Q_FUNC_INFO << "element is not child of this margin group side" << reinterpret_cast<quintptr>(element);
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPLayoutElement
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPLayoutElement
  \brief The abstract base class for all objects that form \ref thelayoutsystem "the layout system".
  
  This is an abstract base class. As such, it can't be instantiated directly, rather use one of its subclasses.
  
  A Layout element is a rectangular object which can be placed in layouts. It has an outer rect
  (QCPLayoutElement::outerRect) and an inner rect (\ref QCPLayoutElement::rect). The difference
  between outer and inner rect is called its margin. The margin can either be set to automatic or
  manual (\ref setAutoMargins) on a per-side basis. If a side is set to manual, that margin can be
  set explicitly with \ref setMargins and will stay fixed at that value. If it's set to automatic,
  the layout element subclass will control the value itself (via \ref calculateAutoMargin).
  
  Layout elements can be placed in layouts (base class QCPLayout) like QCPLayoutGrid. The top level
  layout is reachable via \ref QCustomPlot::plotLayout, and is a \ref QCPLayoutGrid. Since \ref
  QCPLayout itself derives from \ref QCPLayoutElement, layouts can be nested.
  
  Thus in QCustomPlot one can divide layout elements into two categories: The ones that are
  invisible by themselves, because they don't draw anything. Their only purpose is to manage the
  position and size of other layout elements. This category of layout elements usually use
  QCPLayout as base class. Then there is the category of layout elements which actually draw
  something. For example, QCPAxisRect, QCPLegend and QCPTextElement are of this category. This does
  not necessarily mean that the latter category can't have child layout elements. QCPLegend for
  instance, actually derives from QCPLayoutGrid and the individual legend items are child layout
  elements in the grid layout.
*/
/*! \ class QCPLayoutElement
  \ brief thelayoutsystem "레이아웃 시스템"을 형성하는 모든 객체에 대한 추상 기본 클래스.
  
  이것은 추상 기본 클래스입니다. 따라서 인스턴스를 직접 인스턴스화 할 수 없으며 서브 클래스 중 하나를 사용하십시오.
  
  Layout 요소는 레이아웃에 배치 할 수있는 직사각형 개체입니다. 그것은 바깥 쪽 rect
  (QCPLayoutElement :: outerRect)와 내부 rect (\ ref QCPLayoutElement :: rect)가 있습니다. 차이점
  외부 및 내부 rect 사이의 마진이라고합니다. 여백은 자동 또는
  수동 (\ ref setAutoMargins)을면별로 제공합니다. 면이 수동으로 설정된 경우 해당 마진은
  \ ref setMargins를 명시 적으로 설정하면 그 값으로 고정됩니다. 자동으로 설정된 경우,
  레이아웃 요소 하위 클래스는 \ ref calculateAutoMargin을 통해 값 자체를 제어합니다.
  
  레이아웃 요소는 QCPLayoutGrid와 같은 레이아웃 (기본 클래스 QCPLayout)에 배치 할 수 있습니다. 최상위 레벨
  레이아웃은 \ ref QCustomPlot :: plotLayout을 통해 도달 할 수 있으며 \ ref QCPLayoutGrid입니다. \ ref 이후
  QCPLayout 자체는 \ ref QCPLayoutElement에서 파생되므로 레이아웃을 중첩 할 수 있습니다.
  
  따라서 QCustomPlot에서 레이아웃 요소를 두 가지 범주로 나눌 수 있습니다.
  그들은 무언가를 그리지 않기 때문에 스스로 보이지 않습니다. 그들의 유일한 목적은
  다른 레이아웃 요소의 위치 및 크기 레이아웃 요소의이 범주는 일반적으로
  QCPLayout을 기본 클래스로 사용합니다. 그런 다음 실제로 그리는 레이아웃 요소의 범주가 있습니다.
  어떤 것. 예를 들어 QCPAxisRect, QCPLegend 및 QCPTextElement는이 범주에 속합니다. 이것은
  반드시 후자의 카테고리가 자식 레이아웃 요소를 가질 수 없다는 것을 의미하지는 않습니다. QCPLegend for
  인스턴스는 실제로 QCPLayoutGrid에서 파생되며 개별 범례 항목은 자식 레이아웃입니다.
  격자 레이아웃의 요소.
*/

/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */

/*! \fn QCPLayout *QCPLayoutElement::layout() const
  
  Returns the parent layout of this layout element.
*/
/*! \ fn QCPLayout * QCPLayoutElement :: layout () const
  
  이 레이아웃 요소의 친 레이아웃을 돌려줍니다.
*/

/*! \fn QRect QCPLayoutElement::rect() const
  
  Returns the inner rect of this layout element. The inner rect is the outer rect (\ref outerRect, \ref
  setOuterRect) shrinked by the margins (\ref setMargins, \ref setAutoMargins).
  
  In some cases, the area between outer and inner rect is left blank. In other cases the margin
  area is used to display peripheral graphics while the main content is in the inner rect. This is
  where automatic margin calculation becomes interesting because it allows the layout element to
  adapt the margins to the peripheral graphics it wants to draw. For example, \ref QCPAxisRect
  draws the axis labels and tick labels in the margin area, thus needs to adjust the margins (if
  \ref setAutoMargins is enabled) according to the space required by the labels of the axes.
  
  \see outerRect
*/
/*! \ fn QRect QCPLayoutElement :: rect () const
  
  이 레이아웃 요소의 내부 Rect를 돌려줍니다. 안쪽 rect는 바깥 쪽 rect (\ ref outerRect, \ ref
  setOuterRect)는 여백만큼 축소됩니다 (\ ref setMargins, \ ref setAutoMargins).
  
  경우에 따라, 외부 및 내부 rect 사이의 영역은 공백으로 남습니다. 다른 경우 여백
  영역은 주 콘텐츠가 내부 rect에있는 동안 주변 그래픽을 표시하는 데 사용됩니다. 이것은
  자동 여백 계산은 레이아웃 요소가
  그리려는 주변 그래픽에 여백을 적용하십시오. 예를 들어, \ ref QCPAxisRect
  여백 영역에 축 레이블 및 눈금 레이블을 그립니다. 따라서 여백을 조정해야합니다 (if
  \ ref setAutoMargins는 축의 레이블에 필요한 공간에 따라 사용 가능).
  
  \ see outerRect
*/

/*! \fn QRect QCPLayoutElement::outerRect() const
  
  Returns the outer rect of this layout element. The outer rect is the inner rect expanded by the
  margins (\ref setMargins, \ref setAutoMargins). The outer rect is used (and set via \ref
  setOuterRect) by the parent \ref QCPLayout to control the size of this layout element.
  
  \see rect
*/
/*! \ fn QRect QCPLayoutElement :: outerRect () const
  
  이 레이아웃 요소의 외측 구형을 돌려줍니다. 바깥 쪽 rect는
  여백 (\ ref setMargins, \ ref setAutoMargins). 바깥 쪽 rect는 사용되며 (\ ref를 통해 설정됩니다.
  setOuterRect)를 부모 \ ref QCPLayout에 의해 사용하여이 레이아웃 요소의 크기를 제어합니다.
  
  \보기 rect
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */

/*!
  Creates an instance of QCPLayoutElement and sets default values.
*/
/*!
  QCPLayoutElement의 인스턴스를 만들고 기본값을 설정합니다.
*/
QCPLayoutElement::QCPLayoutElement(QCustomPlot *parentPlot) :
  QCPLayerable(parentPlot), // parenthood is changed as soon as layout element gets inserted into a layout (except for top level layout)
// qobject_cast는 레이아웃이 dtor에서 clear ()를 호출하는 것을 잊어 버리고이 dtor가 QObject dtor에 의해 호출 된 경우를 대비 한 방호책입니다
  mParentLayout(0),
  mMinimumSize(),
  mMaximumSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX),
  mSizeConstraintRect(scrInnerRect),
  mRect(0, 0, 0, 0),
  mOuterRect(0, 0, 0, 0),
  mMargins(0, 0, 0, 0),
  mMinimumMargins(0, 0, 0, 0),
  mAutoMargins(QCP::msAll)
{
}

QCPLayoutElement::~QCPLayoutElement()
{
  setMarginGroup(QCP::msAll, 0); // unregister at margin groups, if there are any 
  // unregister at layout:       // 여백 그룹에서 등록을 취소합니다.
  // 레이아웃에서 등록 취소 :
  if (qobject_cast<QCPLayout*>(mParentLayout)) // the qobject_cast is just a safeguard in case the layout forgets to call clear() in its dtor and this dtor is called by QObject dtor
 // qobject_cast는 레이아웃이 dtor에서 clear ()를 호출하는 것을 잊어 버리고이 dtor가 QObject dtor에 의해 호출 된 경우를 대비 한 방호책입니다
    mParentLayout->take(this);
}

/*!
  Sets the outer rect of this layout element. If the layout element is inside a layout, the layout
  sets the position and size of this layout element using this function.
  
  Calling this function externally has no effect, since the layout will overwrite any changes to
  the outer rect upon the next replot.
  
  The layout element will adapt its inner \ref rect by applying the margins inward to the outer rect.
  
  \see rect
*/
/*!
  이 레이아웃 요소의 외측 구석을 설정합니다. 레이아웃 엘리먼트가 레이아웃 내에 있다면, 레이아웃
  이 함수를 사용하여이 레이아웃 요소의 위치와 크기를 설정합니다.
  
  이 함수를 외부 적으로 호출해도 레이아웃은 변경 사항을 덮어 씁니다.
  다음 replot에 바깥 쪽 rect.
  
  레이아웃 요소는 바깥 쪽 rect에 안쪽 여백을 적용하여 inner \ ref rect를 조정합니다.
  
  \보기 rect
*/
void QCPLayoutElement::setOuterRect(const QRect &rect)
{
  if (mOuterRect != rect)
  {
    mOuterRect = rect;
    mRect = mOuterRect.adjusted(mMargins.left(), mMargins.top(), -mMargins.right(), -mMargins.bottom());
  }
}

/*!
  Sets the margins of this layout element. If \ref setAutoMargins is disabled for some or all
  sides, this function is used to manually set the margin on those sides. Sides that are still set
  to be handled automatically are ignored and may have any value in \a margins.
  
  The margin is the distance between the outer rect (controlled by the parent layout via \ref
  setOuterRect) and the inner \ref rect (which usually contains the main content of this layout
  element).
  
  \see setAutoMargins
*/
/*!
  이 레이아웃 요소의 여백을 설정합니다. \ ref setAutoMargins가 일부 또는 전체에 대해 사용 중지 된 경우
  이 기능은 수동으로 여백을 설정하는 데 사용됩니다. 여전히 설정된면
  자동으로 처리 될 수있는 값은 무시되며 \ 여백에 값이있을 수 있습니다.
  
  여백은 외부 rect (\ ref를 통해 부모 레이아웃에 의해 제어 됨) 사이의 거리입니다
  setOuterRect) 및 내부 \ ref rect (일반적으로이 레이아웃의 주요 내용이 포함되어 있음)
  요소).
  
  \ setAutoMargins를 참조하십시오.
*/

void QCPLayoutElement::setMargins(const QMargins &margins)
{
  if (mMargins != margins)
  {
    mMargins = margins;
    mRect = mOuterRect.adjusted(mMargins.left(), mMargins.top(), -mMargins.right(), -mMargins.bottom());
  }
}

/*!
  If \ref setAutoMargins is enabled on some or all margins, this function is used to provide
  minimum values for those margins.
  
  The minimum values are not enforced on margin sides that were set to be under manual control via
  \ref setAutoMargins.
  
  \see setAutoMargins
*/
/*!
  \ ref setAutoMargins가 일부 또는 모든 여백에서 활성화 된 경우이 함수를 사용하여
  그 마진에 대한 최소값.
  
  최소값은 다음을 통한 수동 제어하에 설정된 여백 측에 적용되지 않습니다.
  \ ref setAutoMargins.
  
  \ setAutoMargins를 참조하십시오.
*/
void QCPLayoutElement::setMinimumMargins(const QMargins &margins)
{
  if (mMinimumMargins != margins)
  {
    mMinimumMargins = margins;
  }
}

/*!
  Sets on which sides the margin shall be calculated automatically. If a side is calculated
  automatically, a minimum margin value may be provided with \ref setMinimumMargins. If a side is
  set to be controlled manually, the value may be specified with \ref setMargins.
  
  Margin sides that are under automatic control may participate in a \ref QCPMarginGroup (see \ref
  setMarginGroup), to synchronize (align) it with other layout elements in the plot.
  
  \see setMinimumMargins, setMargins, QCP::MarginSide
*/
/*!
  여백이 자동으로 계산되는면을 설정합니다. 측면 계산시
  자동으로 최소 여백 값을 \ ref setMinimumMargins와 함께 제공 할 수 있습니다. 한 쪽이
  수동으로 제어되도록 설정하면 \ ref setMargins로 값을 지정할 수 있습니다.
  
  자동 제어하에있는 여백면은 \ ref QCPMarginGroup에 참여할 수 있습니다 (\ ref 참조).
  setMarginGroup)을 사용하여 플롯의 다른 레이아웃 요소와 동기화 (정렬)합니다.
  
  \ setMinimumMargins, setMargins, QCP :: MarginSide를 참조하십시오.
*/
void QCPLayoutElement::setAutoMargins(QCP::MarginSides sides)
{
  mAutoMargins = sides;
}

/*!
  Sets the minimum size of this layout element. A parent layout tries to respect the \a size here
  by changing row/column sizes in the layout accordingly.
  
  If the parent layout size is not sufficient to satisfy all minimum size constraints of its child
  layout elements, the layout may set a size that is actually smaller than \a size. QCustomPlot
  propagates the layout's size constraints to the outside by setting its own minimum QWidget size
  accordingly, so violations of \a size should be exceptions.
  
  Whether this constraint applies to the inner or the outer rect can be specified with \ref
  setSizeConstraintRect (see \ref rect and \ref outerRect).
*/
/*!
  이 레이아웃 요소의 최소 크기를 설정합니다. 상위 레이아웃은 \ a 크기를 여기에서 존중합니다.
  그에 따라 레이아웃에서 행 / 열 크기를 변경합니다.
  
  부모 레이아웃 크기가 하위 요소의 모든 최소 크기 제약 조건을 충족시키기에 충분하지 않은 경우
  layout 요소를 사용하면 레이아웃은 실제로 크기보다 작은 크기를 설정할 수 있습니다. QCustomPlot
  자체 최소 QWidget 크기를 설정하여 레이아웃의 크기 제한을 외부에 전파합니다.
  따라서 \ a 크기의 위반은 예외가되어야합니다.
  
  이 제한이 내부 또는 외부 rect에 적용되는지 여부는 \ ref로 지정할 수 있습니다
  setSizeConstraintRect (\ ref rect 및 \ ref outerRect 참조).
*/
void QCPLayoutElement::setMinimumSize(const QSize &size)
{
  if (mMinimumSize != size)
  {
    mMinimumSize = size;
    if (mParentLayout)
      mParentLayout->sizeConstraintsChanged();
  }
}

/*! \overload
  
  Sets the minimum size of this layout element.
  
  Whether this constraint applies to the inner or the outer rect can be specified with \ref
  setSizeConstraintRect (see \ref rect and \ref outerRect).
*/
/*! \초과 적재
  
  이 레이아웃 요소의 최소 크기를 설정합니다.
  
  이 제한이 내부 또는 외부 rect에 적용되는지 여부는 \ ref로 지정할 수 있습니다
  setSizeConstraintRect (\ ref rect 및 \ ref outerRect 참조).
*/
void QCPLayoutElement::setMinimumSize(int width, int height)
{
  setMinimumSize(QSize(width, height));
}

/*!
  Sets the maximum size of this layout element. A parent layout tries to respect the \a size here
  by changing row/column sizes in the layout accordingly.
  
  Whether this constraint applies to the inner or the outer rect can be specified with \ref
  setSizeConstraintRect (see \ref rect and \ref outerRect).
*/
/*!
  이 레이아웃 요소의 최대 크기를 설정합니다. 상위 레이아웃은 \ a 크기를 여기에서 존중합니다.
  그에 따라 레이아웃에서 행 / 열 크기를 변경합니다.
  
  이 제한이 내부 또는 외부 rect에 적용되는지 여부는 \ ref로 지정할 수 있습니다
  setSizeConstraintRect (\ ref rect 및 \ ref outerRect 참조).
*/
void QCPLayoutElement::setMaximumSize(const QSize &size)
{
  if (mMaximumSize != size)
  {
    mMaximumSize = size;
    if (mParentLayout)
      mParentLayout->sizeConstraintsChanged();
  }
}

/*! \overload
  
  Sets the maximum size of this layout element.
  
  Whether this constraint applies to the inner or the outer rect can be specified with \ref
  setSizeConstraintRect (see \ref rect and \ref outerRect).
*/
/*! \초과 적재
  
  이 레이아웃 요소의 최대 크기를 설정합니다.
  
  이 제한이 내부 또는 외부 rect에 적용되는지 여부는 \ ref로 지정할 수 있습니다
  setSizeConstraintRect (\ ref rect 및 \ ref outerRect 참조).
*/
void QCPLayoutElement::setMaximumSize(int width, int height)
{
  setMaximumSize(QSize(width, height));
}

/*!
  Sets to which rect of a layout element the size constraints apply. Size constraints can be set
  via \ref setMinimumSize and \ref setMaximumSize.
  
  The outer rect (\ref outerRect) includes the margins (e.g. in the case of a QCPAxisRect the axis
  labels), whereas the inner rect (\ref rect) does not.
  
  \see setMinimumSize, setMaximumSize
*/
/*!
  크기 제한이 적용되는 레이아웃 요소의 rect를 설정합니다. 크기 제한을 설정할 수 있습니다.
  \ ref setMinimumSize 및 \ ref setMaximumSize를 통해.
  
  외부 rect (\ ref outerRect)는 여백을 포함합니다 (예 : QCPAxisRect 축의 경우
  레이블), 내부 rect (\ ref rect)는 그렇지 않습니다.
  
  \ setMinimumSize, setMaximumSize를 참조하십시오.
*/
void QCPLayoutElement::setSizeConstraintRect(SizeConstraintRect constraintRect)
{
  if (mSizeConstraintRect != constraintRect)
  {
    mSizeConstraintRect = constraintRect;
    if (mParentLayout)
      mParentLayout->sizeConstraintsChanged();
  }
}

/*!
  Sets the margin \a group of the specified margin \a sides.
  
  Margin groups allow synchronizing specified margins across layout elements, see the documentation
  of \ref QCPMarginGroup.
  
  To unset the margin group of \a sides, set \a group to 0.
  
  Note that margin groups only work for margin sides that are set to automatic (\ref
  setAutoMargins).
  
  \see QCP::MarginSide
*/
/*!
  지정된 여백과 \ a면의 여백 \ a 그룹을 설정합니다.
  
  여백 그룹을 사용하면 레이아웃 요소간에 지정된 여백을 동기화 할 수 있습니다. 문서를 참조하십시오.
  \ ref QCPMarginGroup의.
  
  \ a 변의 여백 그룹을 설정 해제하려면 \ a 그룹을 0으로 설정하십시오.
  
  여백 그룹은 자동 (\ ref
  setAutoMargins).
  
  \ QCP :: MarginSide 참조
*/
void QCPLayoutElement::setMarginGroup(QCP::MarginSides sides, QCPMarginGroup *group)
{
  QVector<QCP::MarginSide> sideVector;
  if (sides.testFlag(QCP::msLeft)) sideVector.append(QCP::msLeft);
  if (sides.testFlag(QCP::msRight)) sideVector.append(QCP::msRight);
  if (sides.testFlag(QCP::msTop)) sideVector.append(QCP::msTop);
  if (sides.testFlag(QCP::msBottom)) sideVector.append(QCP::msBottom);
  
  for (int i=0; i<sideVector.size(); ++i)
  {
    QCP::MarginSide side = sideVector.at(i);
    if (marginGroup(side) != group)
    {
      QCPMarginGroup *oldGroup = marginGroup(side);
      if (oldGroup) // unregister at old group
                    // 이전 그룹에서 등록 해제합니다.
        oldGroup->removeChild(side, this);
      
      if (!group) // if setting to 0, remove hash entry. Else set hash entry to new group and register there
      {           // 0으로 설정하면 해시 항목을 제거합니다. 다른 해시 항목을 새 그룹에 설정하고 등록하십시오.
        mMarginGroups.remove(side);
      } else // setting to a new group
      {      // 새 그룹으로 설정
        mMarginGroups[side] = group;
        group->addChild(side, this);
      }
    }
  }
}

/*!
  Updates the layout element and sub-elements. This function is automatically called before every
  replot by the parent layout element. It is called multiple times, once for every \ref
  UpdatePhase. The phases are run through in the order of the enum values. For details about what
  happens at the different phases, see the documentation of \ref UpdatePhase.
  
  Layout elements that have child elements should call the \ref update method of their child
  elements, and pass the current \a phase unchanged.
  
  The default implementation executes the automatic margin mechanism in the \ref upMargins phase.
  Subclasses should make sure to call the base class implementation.
*/
/*!
  레이아웃 요소와 하위 요소를 업데이트합니다. 이 함수는 매번 호출되기 전에 자동으로 호출됩니다.
  상위 레이아웃 엘리먼트에 의해 다시 배치된다. 그것은 여러 번 호출됩니다. \ ref마다 하나씩
  UpdatePhase. 단계는 열거 형 값의 순서로 실행됩니다. 무엇에 대한 자세한 내용은
  다른 단계에서 발생하면 \ ref UpdatePhase의 설명서를 참조하십시오.
  
  하위 요소가있는 레이아웃 요소는 하위 요소의 \ ref update 메서드를 호출해야합니다.
  요소를 제거하고 현재 \ a 단계를 변경하지 않고 전달합니다.
  
  기본 구현은 \ ref upMargins 단계에서 자동 여백 메커니즘을 실행합니다.
  서브 클래스는 반드시 기본 클래스 구현을 호출해야합니다.
*/
void QCPLayoutElement::update(UpdatePhase phase)
{
  if (phase == upMargins)
  {
    if (mAutoMargins != QCP::msNone)
    {
      // set the margins of this layout element according to automatic margin calculation, either directly or via a margin group:
 // 자동 여백 계산에 따라이 레이아웃 요소의 여백을 직접 또는 여백 그룹을 통해 설정합니다.
      QMargins newMargins = mMargins;
      QList<QCP::MarginSide> allMarginSides = QList<QCP::MarginSide>() << QCP::msLeft << QCP::msRight << QCP::msTop << QCP::msBottom;
      foreach (QCP::MarginSide side, allMarginSides)
      {
        if (mAutoMargins.testFlag(side)) // this side's margin shall be calculated automatically
        {                                //이면의 마진은 자동으로 계산됩니다
          if (mMarginGroups.contains(side))
            QCP::setMarginValue(newMargins, side, mMarginGroups[side]->commonMargin(side)); // this side is part of a margin group, so get the margin value from that group
 //이면은 여백 그룹의 일부이므로 해당 그룹에서 여백 값을 가져옵니다.
          else
            QCP::setMarginValue(newMargins, side, calculateAutoMargin(side)); // this side is not part of a group, so calculate the value directly
//이면은 그룹의 일부가 아니므로 값을 직접 계산하십시오.
          // apply minimum margin restrictions:
          // 최소 마진 제한 적용 :
          if (QCP::getMarginValue(newMargins, side) < QCP::getMarginValue(mMinimumMargins, side))
            QCP::setMarginValue(newMargins, side, QCP::getMarginValue(mMinimumMargins, side));
        }
      }
      setMargins(newMargins);
    }
  }
}

/*!
  Returns the suggested minimum size this layout element (the \ref outerRect) may be compressed to,
  if no manual minimum size is set.
  
  if a minimum size (\ref setMinimumSize) was not set manually, parent layouts use the returned size
  (usually indirectly through \ref QCPLayout::getFinalMinimumOuterSize) to determine the minimum
  allowed size of this layout element.

  A manual minimum size is considered set if it is non-zero.
  
  The default implementation simply returns the sum of the horizontal margins for the width and the
  sum of the vertical margins for the height. Reimplementations may use their detailed knowledge
  about the layout element's content to provide size hints.
*/
/*!
  이 레이아웃 요소 (\ ref outerRect)가 압축 가능한 최소 사이즈를 돌려줍니다.
  수동 최소 크기가 설정되지 않은 경우
  
  최소 크기 (\ ref setMinimumSize)가 수동으로 설정되지 않은 경우 부모 레이아웃은 반환 된 크기를 사용합니다.
  (일반적으로 \ ref QCPLayout :: getFinalMinimumOuterSize를 통해 간접적으로) 최소값을 결정합니다
  이 레이아웃 요소의 허용 크기.

  수동 최소 크기가 0이 아닌 경우 세트로 간주됩니다.
  
  디폴트의 ​​구현에서는, 폭과 높이의 수평 마진의 합계를 돌려줍니다.
  높이에 대한 수직 여백의 합. 재 구현은 그들의 상세한 지식을 사용할 수있다.
  크기 힌트를 제공하기 위해 layout 요소의 내용에 대해 설명합니다.
*/
QSize QCPLayoutElement::minimumOuterSizeHint() const
{
  return QSize(mMargins.left()+mMargins.right(), mMargins.top()+mMargins.bottom());
}

/*!
  Returns the suggested maximum size this layout element (the \ref outerRect) may be expanded to,
  if no manual maximum size is set.
  
  if a maximum size (\ref setMaximumSize) was not set manually, parent layouts use the returned
  size (usually indirectly through \ref QCPLayout::getFinalMaximumOuterSize) to determine the
  maximum allowed size of this layout element.

  A manual maximum size is considered set if it is smaller than Qt's \c QWIDGETSIZE_MAX.
  
  The default implementation simply returns \c QWIDGETSIZE_MAX for both width and height, implying
  no suggested maximum size. Reimplementations may use their detailed knowledge about the layout
  element's content to provide size hints.
*/
/*!
  이 레이아웃 요소 (\ ref outerRect)를 확장 할 수있는 제안 된 최대 크기를 리턴합니다.
  수동 최대 크기가 설정되지 않은 경우
  
  최대 크기 (\ ref setMaximumSize)가 수동으로 설정되지 않은 경우 부모 레이아웃은 반환 된
  size (일반적으로 \ ref QCPLayout :: getFinalMaximumOuterSize를 통해 간접적으로)
  이 레이아웃 요소의 최대 허용 크기입니다.

  수동 최대 크기는 Qt의 \ c QWIDGETSIZE_MAX보다 작 으면 설정된 것으로 간주됩니다.
  
  디폴트의 ​​구현은 폭과 높이의 양쪽 모두에 대해 \ c QWIDGETSIZE_MAX를 돌려 주어,
  제안 된 최대 크기가 없습니다. 재 구현은 레이아웃에 대한 상세한 지식을 사용할 수 있습니다
  요소의 내용으로 크기 힌트를 제공합니다.
*/
QSize QCPLayoutElement::maximumOuterSizeHint() const
{
  return QSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX);
}

/*!
  Returns a list of all child elements in this layout element. If \a recursive is true, all
  sub-child elements are included in the list, too.
  
  \warning There may be entries with value 0 in the returned list. (For example, QCPLayoutGrid may have
  empty cells which yield 0 at the respective index.)
*/
/*!
  이 레이아웃 요소 내의 모든 아이 요소의리스트를 돌려줍니다. 재귀가 참이라면 모두
  하위 하위 요소도 목록에 포함됩니다.
  
  \ warning 리턴 된 목록에 값이 0 인 항목이있을 수 있습니다. 예를 들어, QCPLayoutGrid는
  각각의 인덱스에서 0을 산출하는 빈 셀.)
*/
QList<QCPLayoutElement*> QCPLayoutElement::elements(bool recursive) const
{
  Q_UNUSED(recursive)
  return QList<QCPLayoutElement*>();
}

/*!
  Layout elements are sensitive to events inside their outer rect. If \a pos is within the outer
  rect, this method returns a value corresponding to 0.99 times the parent plot's selection
  tolerance. However, layout elements are not selectable by default. So if \a onlySelectable is
  true, -1.0 is returned.
  
  See \ref QCPLayerable::selectTest for a general explanation of this virtual method.
  
  QCPLayoutElement subclasses may reimplement this method to provide more specific selection test
  behaviour.
*/
/*!
  레이아웃 요소는 바깥 쪽 rect 안에있는 이벤트에 민감합니다. \ a pos가 바깥쪽에있는 경우
  rect 인 경우이 메소드는 부모 플롯의 선택 항목의 0.99 배에 해당하는 값을 반환합니다.
  공차. 그러나 레이아웃 요소는 기본적으로 선택할 수 없습니다. 따라서 \ a onlySelectable 인 경우
  true이면 -1.0이 반환됩니다.
  
  이 가상 메소드에 대한 일반적인 설명은 \ ref QCPLayerable :: selectTest를 참조하십시오.
  
  QCPLayoutElement 서브 클래스는이 메소드를 다시 구현하여 더 구체적인 선택 테스트를 제공 할 수 있습니다.
  행동.
*/
double QCPLayoutElement::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  Q_UNUSED(details)
  
  if (onlySelectable)
    return -1;
  
  if (QRectF(mOuterRect).contains(pos))
  {
    if (mParentPlot)
      return mParentPlot->selectionTolerance()*0.99;
    else
    {
      qDebug() << Q_FUNC_INFO << "parent plot not defined";
      return -1;
    }
  } else
    return -1;
}

/*! \internal
  
  propagates the parent plot initialization to all child elements, by calling \ref
  QCPLayerable::initializeParentPlot on them.
*/
/*! \내부의
  
  \ ref를 호출하여 부모 플롯 초기화를 모든 자식 요소로 전달합니다.
  그것들에 대한 QCPLayerable :: initializeParentPlot.
*/
void QCPLayoutElement::parentPlotInitialized(QCustomPlot *parentPlot)
{
  foreach (QCPLayoutElement* el, elements(false))
  {
    if (!el->parentPlot())
      el->initializeParentPlot(parentPlot);
  }
}

/*! \internal
  
  Returns the margin size for this \a side. It is used if automatic margins is enabled for this \a
  side (see \ref setAutoMargins). If a minimum margin was set with \ref setMinimumMargins, the
  returned value will not be smaller than the specified minimum margin.
  
  The default implementation just returns the respective manual margin (\ref setMargins) or the
  minimum margin, whichever is larger.
*/
/*! \내부의
  
  이 \ a의 마진 사이즈를 돌려줍니다. 이 여백에 대해 자동 여백을 사용하는 경우에 사용됩니다.
  (\ ref setAutoMargins 참조). \ ref setMinimumMargins를 사용하여 최소 여백을 설정하면
  반환 값은 지정된 최소 여백보다 작을 수 없습니다.
  
  디폴트의 ​​구현은, 각각의 수동 마진 (\ ref setMargins) 또는
  최소 여백 중 큰 쪽.
*/
int QCPLayoutElement::calculateAutoMargin(QCP::MarginSide side)
{
  return qMax(QCP::getMarginValue(mMargins, side), QCP::getMarginValue(mMinimumMargins, side));
}

/*! \internal
  
  This virtual method is called when this layout element was moved to a different QCPLayout, or
  when this layout element has changed its logical position (e.g. row and/or column) within the
  same QCPLayout. Subclasses may use this to react accordingly.
  
  Since this method is called after the completion of the move, you can access the new parent
  layout via \ref layout().
  
  The default implementation does nothing.
*/
/*! \내부의
  
  이 가상 메소드는이 레이아웃 요소가 다른 QCPLayout으로 이동되었을 때 호출됩니다.
  이 레이아웃 요소가 (예 : 행 및 / 또는 열) 논리 위치를
  동일한 QCPLayout. 서브 클래스는 이것을 사용해 적절하게 반응 할 수 있습니다.
  
  이 메서드는 이동이 완료된 후에 호출되므로 새 부모에 액세스 할 수 있습니다.
  \ ref layout ()을 통해 레이아웃.
  
  디폴트의 ​​구현은 아무것도 실시하지 않습니다.
*/
void QCPLayoutElement::layoutChanged()
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPLayout
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPLayout
  \brief The abstract base class for layouts
  
  This is an abstract base class for layout elements whose main purpose is to define the position
  and size of other child layout elements. In most cases, layouts don't draw anything themselves
  (but there are exceptions to this, e.g. QCPLegend).
  
  QCPLayout derives from QCPLayoutElement, and thus can itself be nested in other layouts.
  
  QCPLayout introduces a common interface for accessing and manipulating the child elements. Those
  functions are most notably \ref elementCount, \ref elementAt, \ref takeAt, \ref take, \ref
  simplify, \ref removeAt, \ref remove and \ref clear. Individual subclasses may add more functions
  to this interface which are more specialized to the form of the layout. For example, \ref
  QCPLayoutGrid adds functions that take row and column indices to access cells of the layout grid
  more conveniently.
  
  Since this is an abstract base class, you can't instantiate it directly. Rather use one of its
  subclasses like QCPLayoutGrid or QCPLayoutInset.
  
  For a general introduction to the layout system, see the dedicated documentation page \ref
  thelayoutsystem "The Layout System".
*/
/*! \ class QCPLayout
  \ brief 레이아웃의 추상 기본 클래스
  
  위치를 정의하는 것을 주요 목적으로하는 레이아웃 요소의 추상 기본 클래스입니다.
  및 다른 자식 레이아웃 요소의 크기. 대부분의 경우 레이아웃은 아무 것도 그려지지 않습니다.
  (그러나 예외는 있습니다 (예 : QCPLegend).
  
  QCPLayout은 QCPLayoutElement에서 파생되므로 다른 레이아웃에서도 중첩 될 수 있습니다.
  
  QCPLayout은 자식 요소를 액세스하고 조작하기위한 공통 인터페이스를 도입했습니다. 그
  함수는 특히 \ ref elementCount, \ ref elementAt, \ ref takeAt, \ ref take, \ ref
  단순화, \ ref 제거, \ ref 제거 및 \ ref 정리. 개별 서브 클래스는 더 많은 함수를 추가 할 수 있습니다.
  레이아웃의 형태에 더욱 특화된이 인터페이스에. 예를 들어, \ ref
  QCPLayoutGrid는 레이아웃 격자의 셀에 액세스하기 위해 행 및 열 인덱스를 사용하는 함수를 추가합니다.
  더 편리하게.
  
  이것은 추상적 인 기본 클래스이므로 직접 인스턴스를 생성 할 수 없습니다. 그 중 하나를 사용하십시오.
  QCPLayoutGrid 또는 QCPLayoutInset과 같은 하위 클래스
  
  레이아웃 시스템에 대한 일반적인 소개는 전용 문서 페이지 \ ref를 참조하십시오.
  레이아웃 시스템 "레이아웃 시스템".
*/

/* start documentation of pure virtual functions */
/* 순수 가상 함수의 시작 문서 */

/*! \fn virtual int QCPLayout::elementCount() const = 0
  
  Returns the number of elements/cells in the layout.
  
  \see elements, elementAt
*/
/*! \ fn 가상 int QCPLayout :: elementCount () const = 0
  
  레이아웃의 요소 수 또는 셀 수를 반환합니다.
  
  \ 요소, 요소 참조
*/

/*! \fn virtual QCPLayoutElement* QCPLayout::elementAt(int index) const = 0
  
  Returns the element in the cell with the given \a index. If \a index is invalid, returns 0.
  
  Note that even if \a index is valid, the respective cell may be empty in some layouts (e.g.
  QCPLayoutGrid), so this function may return 0 in those cases. You may use this function to check
  whether a cell is empty or not.
  
  \see elements, elementCount, takeAt
*/
/*! \ fn 가상 QCPLayoutElement * QCPLayout :: elementAt (int index) const = 0
  
  지정된 \ a 인덱스를 사용하여 셀의 요소를 반환합니다. \ index가 유효하지 않은 경우 0을 반환합니다.
  
  \ 인덱스가 유효하더라도 각 셀은 일부 레이아웃에서 비어있을 수 있습니다 (예 :
  QCPLayoutGrid),이 경우이 함수는 0을 반환 할 수 있습니다. 이 기능을 사용하여
  셀이 비 었는지 여부.
  
  \ 요소보기, elementCount, takeAt
*/

/*! \fn virtual QCPLayoutElement* QCPLayout::takeAt(int index) = 0
  
  Removes the element with the given \a index from the layout and returns it.
  
  If the \a index is invalid or the cell with that index is empty, returns 0.
  
  Note that some layouts don't remove the respective cell right away but leave an empty cell after
  successful removal of the layout element. To collapse empty cells, use \ref simplify.
  
  \see elementAt, take
*/
/*! \ fn 가상 QCPLayoutElement * QCPLayout :: takeAt (int 인덱스) = 0
  
  지정된 \ a 인덱스를 가지는 요소를 레이아웃으로부터 삭제 해, 그것을 돌려줍니다.
  
  \ a 인덱스가 유효하지 않거나 해당 인덱스가있는 셀이 비어 있으면 0을 반환합니다.
  
  일부 레이아웃에서는 각 셀을 즉시 제거하지 않고 나중에 빈 셀을 남겨 둡니다.
  레이아웃 요소가 성공적으로 제거되었습니다. 빈 셀을 접으려면 \ ref simplify를 사용하십시오.
  
  \ see elementAt, take
*/

/*! \fn virtual bool QCPLayout::take(QCPLayoutElement* element) = 0
  
  Removes the specified \a element from the layout and returns true on success.
  
  If the \a element isn't in this layout, returns false.
  
  Note that some layouts don't remove the respective cell right away but leave an empty cell after
  successful removal of the layout element. To collapse empty cells, use \ref simplify.
  
  \see takeAt
*/
/*! \ fn 가상 bool QCPLayout :: take (QCPLayoutElement * 요소) = 0
  
  레이아웃에서 지정된 \ a 요소를 제거하고 성공하면 true를 반환합니다.
  
  \ a 요소가이 레이아웃에 없으면 false를 반환합니다.
  
  일부 레이아웃에서는 각 셀을 즉시 제거하지 않고 나중에 빈 셀을 남겨 둡니다.
  레이아웃 요소가 성공적으로 제거되었습니다. 빈 셀을 접으려면 \ ref simplify를 사용하십시오.
  
  \ take 테이크 아웃
*/

/* end documentation of pure virtual functions */
/* 순수 가상 함수의 끝 문서 */

/*!
  Creates an instance of QCPLayout and sets default values. Note that since QCPLayout
  is an abstract base class, it can't be instantiated directly.
*/
/*!
  QCPLayout 인스턴스를 만들고 기본값을 설정합니다. QCPLayout
  추상 기본 클래스이므로 직접 인스턴스화 할 수 없습니다.
*/
QCPLayout::QCPLayout()
{
}

/*!
  If \a phase is \ref upLayout, calls \ref updateLayout, which subclasses may reimplement to
  reposition and resize their cells.
  
  Finally, the call is propagated down to all child \ref QCPLayoutElement "QCPLayoutElements".
  
  For details about this method and the update phases, see the documentation of \ref
  QCPLayoutElement::update.
*/
/*!
  \ a 위상이 \ ref upLayout 인 경우, \ ​​ref updateLayout를 호출합니다. 서브 클래스는 다음에 다시 구현할 수 있습니다.
  위치를 조정하고 셀의 크기를 조정하십시오.
  
  마지막으로, 호출은 모든 하위 \ ref QCPLayoutElement "QCPLayoutElements"로 전파됩니다.
  
  이 방법 및 업데이트 단계에 대한 자세한 내용은 \ ref의 설명서를 참조하십시오.
  QCPLayoutElement :: update.
*/
void QCPLayout::update(UpdatePhase phase)
{
  QCPLayoutElement::update(phase);
  
  // set child element rects according to layout:
  // 레이아웃에 따라 자식 요소 rect를 설정합니다.
  if (phase == upLayout)
    updateLayout();
  
  // propagate update call to child elements:
  // 하위 요소에 업데이트 호출 전파 :
  const int elCount = elementCount();
  for (int i=0; i<elCount; ++i)
  {
    if (QCPLayoutElement *el = elementAt(i))
      el->update(phase);
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QList<QCPLayoutElement*> QCPLayout::elements(bool recursive) const
{
  const int c = elementCount();
  QList<QCPLayoutElement*> result;
#if QT_VERSION >= QT_VERSION_CHECK(4, 7, 0)
  result.reserve(c);
#endif
  for (int i=0; i<c; ++i)
    result.append(elementAt(i));
  if (recursive)
  {
    for (int i=0; i<c; ++i)
    {
      if (result.at(i))
        result << result.at(i)->elements(recursive);
    }
  }
  return result;
}

/*!
  Simplifies the layout by collapsing empty cells. The exact behavior depends on subclasses, the
  default implementation does nothing.
  
  Not all layouts need simplification. For example, QCPLayoutInset doesn't use explicit
  simplification while QCPLayoutGrid does.
*/
/*!
  빈 셀을 접어서 레이아웃을 간소화합니다. 정확한 동작은 하위 클래스,
  디폴트 구현은 아무것도하지 않습니다.
  
  모든 레이아웃이 단순화가 필요한 것은 아닙니다. 예를 들어, QCPLayoutInset은 명시 적을 사용하지 않습니다.
  QCPLayoutGrid가 단순화하는 동안.
*/
void QCPLayout::simplify()
{
}

/*!
  Removes and deletes the element at the provided \a index. Returns true on success. If \a index is
  invalid or points to an empty cell, returns false.
  
  This function internally uses \ref takeAt to remove the element from the layout and then deletes
  the returned element. Note that some layouts don't remove the respective cell right away but leave an
  empty cell after successful removal of the layout element. To collapse empty cells, use \ref
  simplify.
  
  \see remove, takeAt
*/
/*!
  제공된 \ a 인덱스에서 요소를 제거하고 삭제합니다. 성공하면 true를 반환합니다. \ a 인덱스가
  유효하지 않거나 빈 셀을 가리키는 경우 false를 반환합니다.
  
  이 함수는 내부적으로 \ ref takeAt를 사용하여 레이아웃에서 요소를 제거한 다음 삭제합니다
  리턴 된 요소 일부 레이아웃에서는 각 셀을 즉시 제거하지 않고
  레이아웃 요소가 성공적으로 제거 된 후 빈 셀. 빈 셀을 접으려면 \ ref를 사용하십시오.
  단순화.
  
  \ see remove, takeAt
*/
bool QCPLayout::removeAt(int index)
{
  if (QCPLayoutElement *el = takeAt(index))
  {
    delete el;
    return true;
  } else
    return false;
}

/*!
  Removes and deletes the provided \a element. Returns true on success. If \a element is not in the
  layout, returns false.
  
  This function internally uses \ref takeAt to remove the element from the layout and then deletes
  the element. Note that some layouts don't remove the respective cell right away but leave an
  empty cell after successful removal of the layout element. To collapse empty cells, use \ref
  simplify.
  
  \see removeAt, take
*/
/*!
  제공된 \ a 요소를 제거하고 삭제합니다. 성공하면 true를 반환합니다. \ a 요소가
  레이아웃은 false를 반환합니다.
  
  이 함수는 내부적으로 \ ref takeAt를 사용하여 레이아웃에서 요소를 제거한 다음 삭제합니다
  요소. 일부 레이아웃에서는 각 셀을 즉시 제거하지 않고
  레이아웃 요소가 성공적으로 제거 된 후 빈 셀. 빈 셀을 접으려면 \ ref를 사용하십시오.
  단순화.
  
  \ see removeAt, take
*/
bool QCPLayout::remove(QCPLayoutElement *element)
{
  if (take(element))
  {
    delete element;
    return true;
  } else
    return false;
}

/*!
  Removes and deletes all layout elements in this layout. Finally calls \ref simplify to make sure
  all empty cells are collapsed.
  
  \see remove, removeAt
*/
/*!
  이 레이아웃의 모든 레이아웃 요소를 제거하고 삭제합니다. 마침내 \ ref를 호출하여 간단하게 확인합니다.
  모든 빈 셀이 축소됩니다.
  
  \ remove remove를 참조하십시오.
*/
void QCPLayout::clear()
{
  for (int i=elementCount()-1; i>=0; --i)
  {
    if (elementAt(i))
      removeAt(i);
  }
  simplify();
}

/*!
  Subclasses call this method to report changed (minimum/maximum) size constraints.
  
  If the parent of this layout is again a QCPLayout, forwards the call to the parent's \ref
  sizeConstraintsChanged. If the parent is a QWidget (i.e. is the \ref QCustomPlot::plotLayout of
  QCustomPlot), calls QWidget::updateGeometry, so if the QCustomPlot widget is inside a Qt QLayout,
  it may update itself and resize cells accordingly.
*/
/*!
  서브 클래스는이 메소드를 호출 해, 변경된 (최소 / 최대) 사이즈 제약을보고합니다.
  
  이 레이아웃의 부모가 다시 QCPLayout 인 경우 호출을 부모의 \ ref로 전달합니다.
  sizeConstraintsChanged. 부모가 QWidget 인 경우 (즉, \ ref QCustomPlot :: plotLayout of
  QCustomPlot)는 QWidget :: updateGeometry를 호출하므로 QCustomPlot 위젯이 Qt QLayout 내에있는 경우,
  그것은 자체를 업데이트하고 이에 따라 셀의 크기를 조정할 수 있습니다.
*/
void QCPLayout::sizeConstraintsChanged() const
{
  if (QWidget *w = qobject_cast<QWidget*>(parent()))
    w->updateGeometry();
  else if (QCPLayout *l = qobject_cast<QCPLayout*>(parent()))
    l->sizeConstraintsChanged();
}

/*! \internal
  
  Subclasses reimplement this method to update the position and sizes of the child elements/cells
  via calling their \ref QCPLayoutElement::setOuterRect. The default implementation does nothing.
  
  The geometry used as a reference is the inner \ref rect of this layout. Child elements should stay
  within that rect.
  
  \ref getSectionSizes may help with the reimplementation of this function.
  
  \see update
*/
/*! \내부의
  
  서브 클래스는이 메소드를 다시 구현하여 자식 요소 / 셀의 위치와 크기를 업데이트합니다.
  그들의 \ ref QCPLayoutElement :: setOuterRect 호출을 통해. 디폴트의 ​​구현은 아무것도 실시하지 않습니다.
  
  참조로 사용되는 지오메트리는이 레이아웃의 내부 \ ref rect입니다. 자식 요소가 있어야합니다.
  그 rect 내에서.
  
  \ ref getSectionSizes는이 함수의 재 구현을 도울 수 있습니다.
  
  \ 업데이트보기
*/
void QCPLayout::updateLayout()
{
}


/*! \internal
  
  Associates \a el with this layout. This is done by setting the \ref QCPLayoutElement::layout, the
  \ref QCPLayerable::parentLayerable and the QObject parent to this layout.
  
  Further, if \a el didn't previously have a parent plot, calls \ref
  QCPLayerable::initializeParentPlot on \a el to set the paret plot.
  
  This method is used by subclass specific methods that add elements to the layout. Note that this
  method only changes properties in \a el. The removal from the old layout and the insertion into
  the new layout must be done additionally.
*/
/*! \내부의
  
  이 레이아웃과 엘을 연결합니다. 이 작업은 \ ref QCPLayoutElement :: layout,
  \ ref QCPLayerable :: parentLayerable 및이 레이아웃에 대한 QObject 부모입니다.
  
  게다가, 이전에 부모 그림이없는 경우 \ ref를 호출합니다
  paret 플롯을 설정하려면 \ QCPLayerable :: initializeParentPlot을 사용하십시오.
  
  이 메소드는 레이아웃에 요소를 추가하는 특정 메소드를 서브 클래스로 사용하여 사용됩니다. 이 점에 유의하십시오.
  메서드는 \ a 엘의 속성 만 변경합니다. 이전 레이아웃에서 제거하고
  새 레이아웃을 추가로 수행해야합니다.
*/
void QCPLayout::adoptElement(QCPLayoutElement *el)
{
  if (el)
  {
    el->mParentLayout = this;
    el->setParentLayerable(this);
    el->setParent(this);
    if (!el->parentPlot())
      el->initializeParentPlot(mParentPlot);
    el->layoutChanged();
  } else
    qDebug() << Q_FUNC_INFO << "Null element passed";
}

/*! \internal
  
  Disassociates \a el from this layout. This is done by setting the \ref QCPLayoutElement::layout
  and the \ref QCPLayerable::parentLayerable to zero. The QObject parent is set to the parent
  QCustomPlot.
  
  This method is used by subclass specific methods that remove elements from the layout (e.g. \ref
  take or \ref takeAt). Note that this method only changes properties in \a el. The removal from
  the old layout must be done additionally.
*/
/*! \내부의
  
  이 레이아웃에서 \ a 엘을 분리합니다. 이 작업은 \ ref QCPLayoutElement :: layout을 설정하여 수행됩니다.
  \ ref QCPLayerable :: parentLayerable을 0으로 설정하십시오. QObject 부모가 부모로 설정됩니다.
  QCustomPlot.
  
  이 메소드는 레이아웃에서 요소를 제거하는 특정 메소드를 하위 클래스로 분류하는 데 사용됩니다 (예 : \ ref
  take 또는 \ ref takeAt). 이 메서드는 \ a 엘에서만 속성을 변경합니다. 에서 제거
  이전 레이아웃을 추가로 수행해야합니다.
*/
void QCPLayout::releaseElement(QCPLayoutElement *el)
{
  if (el)
  {
    el->mParentLayout = 0;
    el->setParentLayerable(0);
    el->setParent(mParentPlot);
    // Note: Don't initializeParentPlot(0) here, because layout element will stay in same parent plot
    // 참고 : 레이아웃 요소가 동일한 부모 플롯에 머물러 있기 때문에 initializeParentPlot (0)을하지 마십시오.
  } else
    qDebug() << Q_FUNC_INFO << "Null element passed";
}

/*! \internal
  
  This is a helper function for the implementation of \ref updateLayout in subclasses.
  
  It calculates the sizes of one-dimensional sections with provided constraints on maximum section
  sizes, minimum section sizes, relative stretch factors and the final total size of all sections.
  
  The QVector entries refer to the sections. Thus all QVectors must have the same size.
  
  \a maxSizes gives the maximum allowed size of each section. If there shall be no maximum size
  imposed, set all vector values to Qt's QWIDGETSIZE_MAX.
  
  \a minSizes gives the minimum allowed size of each section. If there shall be no minimum size
  imposed, set all vector values to zero. If the \a minSizes entries add up to a value greater than
  \a totalSize, sections will be scaled smaller than the proposed minimum sizes. (In other words,
  not exceeding the allowed total size is taken to be more important than not going below minimum
  section sizes.)
  
  \a stretchFactors give the relative proportions of the sections to each other. If all sections
  shall be scaled equally, set all values equal. If the first section shall be double the size of
  each individual other section, set the first number of \a stretchFactors to double the value of
  the other individual values (e.g. {2, 1, 1, 1}).
  
  \a totalSize is the value that the final section sizes will add up to. Due to rounding, the
  actual sum may differ slightly. If you want the section sizes to sum up to exactly that value,
  you could distribute the remaining difference on the sections.
  
  The return value is a QVector containing the section sizes.
*/
/*! \내부의
  
  이것은 서브 클래스에서 \ ref updateLayout 구현을위한 도우미 함수이다.
  
  최대 단면에 제공된 제약 조건을 사용하여 1 차원 단면의 크기를 계산합니다.
  크기, 최소 단면 크기, 상대 신축 요인 및 모든 단면의 최종 총 크기가 포함됩니다.
  
  QVector 항목은 섹션을 참조합니다. 따라서 모든 Q 벡터는 같은 크기 여야합니다.
  
  \ a maxSizes는 각 섹션의 최대 허용 크기를 나타냅니다. 최대 크기가 없을 경우
  부과 된 경우 모든 벡터 값을 Qt의 QWIDGETSIZE_MAX로 설정합니다.
  
  \ a minSizes는 각 섹션의 최소 허용 크기를 나타냅니다. 최소 크기가 없을 경우
  부과 된 경우 모든 벡터 값을 0으로 설정합니다. \ a minSizes 항목이 다음보다 큰 값을 더하는 경우
  \ totalSize이면 섹션은 제안 된 최소 크기보다 작게 조정됩니다. (다른 말로,
  허용 된 전체 크기를 초과하지 않는 것이 최소 미만이 아닌 것보다 중요합니다.
  섹션 크기.)
  
  \ stretchFactors는 섹션의 상대적인 비율을 서로 제공합니다. 모든 섹션
  모든 값을 동일하게 설정하십시오. 첫 번째 섹션의 크기가 두 배가되는 경우
  각각의 개별 다른 섹션은 \ stretchFactors의 첫 번째 숫자를 두 배로 설정합니다.
  다른 개별 값 (예 : {2, 1, 1, 1}).
  
  \ totalSize는 최종 섹션 크기가 합쳐지는 값입니다. 반올림으로 인해
  실제 합계는 약간 다를 수 있습니다. 섹션 크기가 정확히 해당 값의 합계가되도록하려면,
  섹션의 나머지 차이점을 배포 할 수 있습니다.
  
  리턴 값은 섹션 크기를 포함하는 QVector입니다.
*/
QVector<int> QCPLayout::getSectionSizes(QVector<int> maxSizes, QVector<int> minSizes, QVector<double> stretchFactors, int totalSize) const
{
  if (maxSizes.size() != minSizes.size() || minSizes.size() != stretchFactors.size())
  {
    qDebug() << Q_FUNC_INFO << "Passed vector sizes aren't equal:" << maxSizes << minSizes << stretchFactors;
    return QVector<int>();
  }
  if (stretchFactors.isEmpty())
    return QVector<int>();
  int sectionCount = stretchFactors.size();
  QVector<double> sectionSizes(sectionCount);
  // if provided total size is forced smaller than total minimum size, ignore minimum sizes (squeeze sections):
  // 제공된 총 크기가 전체 최소 크기보다 작 으면 최소 크기를 무시합니다 (squeeze 섹션).
  int minSizeSum = 0;
  for (int i=0; i<sectionCount; ++i)
    minSizeSum += minSizes.at(i);
  if (totalSize < minSizeSum)
  {
    // new stretch factors are minimum sizes and minimum sizes are set to zero:
    // 새로운 신축 요인은 최소 크기이고 최소 크기는 0으로 설정됩니다.
    for (int i=0; i<sectionCount; ++i)
    {
      stretchFactors[i] = minSizes.at(i);
      minSizes[i] = 0;
    }
  }
  
  QList<int> minimumLockedSections;
  QList<int> unfinishedSections;
  for (int i=0; i<sectionCount; ++i)
    unfinishedSections.append(i);
  double freeSize = totalSize;
  
  int outerIterations = 0;
  while (!unfinishedSections.isEmpty() && outerIterations < sectionCount*2) // the iteration check ist just a failsafe in case something really strange happens
// 반복 검사는 실제로 이상한 일이 생길 때를 대비 한 안전 장치가 아닙니다.
  {
    ++outerIterations;
    int innerIterations = 0;
    while (!unfinishedSections.isEmpty() && innerIterations < sectionCount*2) // the iteration check ist just a failsafe in case something really strange happens
// 반복 검사는 실제로 이상한 일이 생길 때를 대비해 안전 장치를 설정하지 않습니다.
    {
      ++innerIterations;
      // find section that hits its maximum next:
      // 최대 값을 구하는 섹션을 찾습니다.
      int nextId = -1;
      double nextMax = 1e12;
      for (int i=0; i<unfinishedSections.size(); ++i)
      {
        int secId = unfinishedSections.at(i);
        double hitsMaxAt = (maxSizes.at(secId)-sectionSizes.at(secId))/stretchFactors.at(secId);
        if (hitsMaxAt < nextMax)
        {
          nextMax = hitsMaxAt;
          nextId = secId;
        }
      }
// check if that maximum is actually within the bounds of the total size (i.e. can we stretch all remaining sections so far that the found section
// actually hits its maximum, without exceeding the total size when we add up all sections)
// 그 최대 값이 실제로 전체 크기의 범위 내에 있는지 확인하십시오 (즉, 발견 된 섹션이 남아있는 모든 나머지 섹션을 늘릴 수 있습니까?
// 모든 섹션을 추가 할 때 총 크기를 초과하지 않고 실제로 최대 값에 도달 함)
      double stretchFactorSum = 0;
      for (int i=0; i<unfinishedSections.size(); ++i)
        stretchFactorSum += stretchFactors.at(unfinishedSections.at(i));
      double nextMaxLimit = freeSize/stretchFactorSum;
      if (nextMax < nextMaxLimit)
 // next maximum is actually hit, move forward to that point and fix the size of that section
 // 다음 최대 값이 실제로 발생하면 해당 점으로 이동하여 해당 섹션의 크기를 고정합니다.
      {
        for (int i=0; i<unfinishedSections.size(); ++i)
        {
          sectionSizes[unfinishedSections.at(i)] += nextMax*stretchFactors.at(unfinishedSections.at(i)); // increment all sections
 // 모든 섹션을 증가시킵니다.
          freeSize -= nextMax*stretchFactors.at(unfinishedSections.at(i));
        }
        unfinishedSections.removeOne(nextId); // exclude the section that is now at maximum from further changes
                                              // 추가 변경 사항에서 현재 최대 섹션을 제외합니다.
      } else // next maximum isn't hit, just distribute rest of free space on remaining sections
      {      // 다음 최대 값이 히트되지 않습니다. 나머지 섹션에 여유 공간을 남겨 둡니다.
        for (int i=0; i<unfinishedSections.size(); ++i)
          sectionSizes[unfinishedSections.at(i)] += nextMaxLimit*stretchFactors.at(unfinishedSections.at(i));
 // increment all sections
 // 모든 섹션을 증가시킵니다.
        unfinishedSections.clear();
      }
    }
    if (innerIterations == sectionCount*2)
      qDebug() << Q_FUNC_INFO << "Exceeded maximum expected inner iteration count, layouting aborted. Input was:" << maxSizes << minSizes << stretchFactors << totalSize;
    
    // now check whether the resulting section sizes violate minimum restrictions:
    // 이제 결과 섹션 크기가 최소 제한을 위반하는지 확인합니다.
    bool foundMinimumViolation = false;
    for (int i=0; i<sectionSizes.size(); ++i)
    {
      if (minimumLockedSections.contains(i))
        continue;
      if (sectionSizes.at(i) < minSizes.at(i)) // section violates minimum
      {                                        // 섹션이 최소 위반
        sectionSizes[i] = minSizes.at(i); // set it to minimum
                                          // 최소값으로 설정하십시오.
        foundMinimumViolation = true;     // make sure we repeat the whole optimization process
        minimumLockedSections.append(i);  // 전체 최적화 프로세스를 반복하도록하십시오.
      }
    }
    if (foundMinimumViolation)
    {
      freeSize = totalSize;
      for (int i=0; i<sectionCount; ++i)
      {
        if (!minimumLockedSections.contains(i)) // only put sections that haven't hit their minimum back into the pool
          unfinishedSections.append(i);         // 최소값에 도달하지 않은 섹션 만 풀로 되돌립니다.
        else
          freeSize -= sectionSizes.at(i); // remove size of minimum locked sections from available space in next round
      }                                   // 다음 라운드에서 사용 가능한 공간에서 최소 잠긴 섹션의 크기를 제거합니다.
      // reset all section sizes to zero that are in unfinished sections (all others have been set to their minimum):
      // 미완성 섹션에있는 모든 섹션 크기를 0으로 재설정합니다 (다른 모든 섹션 크기는 최소로 설정 됨).
      for (int i=0; i<unfinishedSections.size(); ++i)
        sectionSizes[unfinishedSections.at(i)] = 0;
    }
  }
  if (outerIterations == sectionCount*2)
    qDebug() << Q_FUNC_INFO << "Exceeded maximum expected outer iteration count, layouting aborted. Input was:" << maxSizes << minSizes << stretchFactors << totalSize;
  
  QVector<int> result(sectionCount);
  for (int i=0; i<sectionCount; ++i)
    result[i] = qRound(sectionSizes.at(i));
  return result;
}

/*! \internal
  
  This is a helper function for the implementation of subclasses.
  
  It returns the minimum size that should finally be used for the outer rect of the passed layout
  element \a el.
  
  It takes into account whether a manual minimum size is set (\ref
  QCPLayoutElement::setMinimumSize), which size constraint is set (\ref
  QCPLayoutElement::setSizeConstraintRect), as well as the minimum size hint, if no manual minimum
  size was set (\ref QCPLayoutElement::minimumOuterSizeHint).
*/
/*! \내부의
  
  이것은 서브 클래스의 구현을위한 도우미 함수입니다.
  
  전달 된 레이아웃의 외부 rect에 대해 마지막으로 사용해야하는 최소 크기를 반환합니다.
  요소 \ 엘.
  
  수동 최소 크기가 설정되었는지 여부를 고려합니다 (\ ref
  QCPLayoutElement :: setMinimumSize), 크기 제한이 설정됩니다 (\ ref
  QCPLayoutElement :: setSizeConstraintRect), 최소 크기 힌트 (수동 최소값이없는 경우)
  크기가 설정되었습니다 (\ ref QCPLayoutElement :: minimumOuterSizeHint).
*/
QSize QCPLayout::getFinalMinimumOuterSize(const QCPLayoutElement *el)
{
  QSize minOuterHint = el->minimumOuterSizeHint();
  QSize minOuter = el->minimumSize(); // depending on sizeConstraitRect this might be with respect to inner rect, so possibly add margins in next four lines (preserving unset minimum of 0)
// sizeConstraitRect에 따라 내부 rect를 기준으로 할 수 있으므로 다음 4 줄에 여백을 추가 할 수 있습니다 (최소 0은 유지되지 않음).
  if (minOuter.width() > 0 && el->sizeConstraintRect() == QCPLayoutElement::scrInnerRect)
    minOuter.rwidth() += el->margins().left() + el->margins().right();
  if (minOuter.height() > 0 && el->sizeConstraintRect() == QCPLayoutElement::scrInnerRect)
    minOuter.rheight() += el->margins().top() + el->margins().bottom();
  
  return QSize(minOuter.width() > 0 ? minOuter.width() : minOuterHint.width(),
               minOuter.height() > 0 ? minOuter.height() : minOuterHint.height());;
}

/*! \internal
  
  This is a helper function for the implementation of subclasses.
  
  It returns the maximum size that should finally be used for the outer rect of the passed layout
  element \a el.
  
  It takes into account whether a manual maximum size is set (\ref
  QCPLayoutElement::setMaximumSize), which size constraint is set (\ref
  QCPLayoutElement::setSizeConstraintRect), as well as the maximum size hint, if no manual maximum
  size was set (\ref QCPLayoutElement::maximumOuterSizeHint).
*/
/*! \내부의
  
  이것은 서브 클래스의 구현을위한 도우미 함수입니다.
  
  전달 된 레이아웃의 외부 rect에 대해 최종적으로 사용해야하는 최대 크기를 반환합니다.
  요소 \ 엘.
  
  수동 최대 크기 설정 여부를 고려합니다 (\ ref
  QCPLayoutElement :: setMaximumSize), 크기 제한이 설정 됨 (\ ref
  QCPLayoutElement :: setSizeConstraintRect)뿐만 아니라 최대 크기 힌트 (수동 최대 값이없는 경우)
  크기가 설정되었습니다 (\ ref QCPLayoutElement :: maximumOuterSizeHint).
*/

QSize QCPLayout::getFinalMaximumOuterSize(const QCPLayoutElement *el)
{
  QSize maxOuterHint = el->maximumOuterSizeHint();
  QSize maxOuter = el->maximumSize(); // depending on sizeConstraitRect this might be with respect to inner rect, so possibly add margins in next four lines (preserving unset maximum of QWIDGETSIZE_MAX)
// sizeConstraitRect에 따라 내부 rect를 기준으로 할 수 있으므로 다음 네 줄에 여백을 추가 할 수 있습니다 (QWIDGETSIZE_MAX의 최대 값을 유지하지 않음)
  if (maxOuter.width() < QWIDGETSIZE_MAX && el->sizeConstraintRect() == QCPLayoutElement::scrInnerRect)
    maxOuter.rwidth() += el->margins().left() + el->margins().right();
  if (maxOuter.height() < QWIDGETSIZE_MAX && el->sizeConstraintRect() == QCPLayoutElement::scrInnerRect)
    maxOuter.rheight() += el->margins().top() + el->margins().bottom();
  
  return QSize(maxOuter.width() < QWIDGETSIZE_MAX ? maxOuter.width() : maxOuterHint.width(),
               maxOuter.height() < QWIDGETSIZE_MAX ? maxOuter.height() : maxOuterHint.height());
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPLayoutGrid
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPLayoutGrid
  \brief A layout that arranges child elements in a grid

  Elements are laid out in a grid with configurable stretch factors (\ref setColumnStretchFactor,
  \ref setRowStretchFactor) and spacing (\ref setColumnSpacing, \ref setRowSpacing).

  Elements can be added to cells via \ref addElement. The grid is expanded if the specified row or
  column doesn't exist yet. Whether a cell contains a valid layout element can be checked with \ref
  hasElement, that element can be retrieved with \ref element. If rows and columns that only have
  empty cells shall be removed, call \ref simplify. Removal of elements is either done by just
  adding the element to a different layout or by using the QCPLayout interface \ref take or \ref
  remove.

  If you use \ref addElement(QCPLayoutElement*) without explicit parameters for \a row and \a
  column, the grid layout will choose the position according to the current \ref setFillOrder and
  the wrapping (\ref setWrap).

  Row and column insertion can be performed with \ref insertRow and \ref insertColumn.
*/
/*! \ class QCPLayoutGrid
  \ brief 그리드에서 자식 요소를 정렬하는 레이아웃

  요소는 구성 가능한 스트레치 요소 (\ ref setColumnStretchFactor,
  \ ref setRowStretchFactor) 및 간격 (\ ref setColumnSpacing, \ ref setRowSpacing)을 지정합니다.

  요소는 \ ref addElement를 통해 셀에 추가 될 수 있습니다. 지정된 행 또는 행이있는 경우 모눈이 확장됩니다.
  열이 아직 존재하지 않습니다. 셀에 유효한 레이아웃 요소가 포함되어 있는지 여부는 \ ref로 확인할 수 있습니다.
  hasElement를 사용하면 해당 요소는 \ ref 요소로 검색 할 수 있습니다. 행과 열만있는 경우
  빈 셀을 제거하고, \ ref를 단순화하십시오. 요소 제거는
  요소를 다른 레이아웃에 추가하거나 QCPLayout 인터페이스 \ ref take 또는 \ ref를 사용하여
  풀다.

  \ a 행과 \ a에 대한 명시적인 매개 변수없이 \ ref addElement (QCPLayoutElement *)를 사용하면
  grid 레이아웃은 현재 \ ref에 따라 위치를 선택합니다. setFillOrder
  포장 (\ ref setWrap).

  \ ref insertRow 및 \ ref insertColumn을 사용하여 행 및 열 삽입을 수행 할 수 있습니다.
*/

/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */

/*! \fn int QCPLayoutGrid::rowCount() const

  Returns the number of rows in the layout.

  \see columnCount
*/
/*! \ fn int QCPLayoutGrid :: rowCount () const

  레이아웃의 행수를 돌려줍니다.

  \ 참조 columnCount
*/

/*! \fn int QCPLayoutGrid::columnCount() const

  Returns the number of columns in the layout.

  \see rowCount
*/
/*! \ fn int QCPLayoutGrid :: columnCount () const

  레이아웃의 렬수를 돌려줍니다.

  \ rowCount 표시
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */

/*!
  Creates an instance of QCPLayoutGrid and sets default values.
*/
/*!
  QCPLayoutGrid의 인스턴스를 만들고 기본값을 설정합니다.
*/
QCPLayoutGrid::QCPLayoutGrid() :
  mColumnSpacing(5),
  mRowSpacing(5),
  mWrap(0),
  mFillOrder(foRowsFirst)
{
}

QCPLayoutGrid::~QCPLayoutGrid()
{
  // clear all child layout elements. This is important because only the specific layouts know how
  // to handle removing elements (clear calls virtual removeAt method to do that).
  // 모든 자식 레이아웃 요소를 지 웁니다. 특정 레이아웃에서만 방법을 알고 있기 때문에 이것은 중요합니다.
  // 요소 제거를 처리하기 위해 (clear 호출 virtual removeAt 메서드를 사용하여).
  clear();
}

/*!
  Returns the element in the cell in \a row and \a column.
  
  Returns 0 if either the row/column is invalid or if the cell is empty. In those cases, a qDebug
  message is printed. To check whether a cell exists and isn't empty, use \ref hasElement.
  
  \see addElement, hasElement
*/
/*!
  \ a 행과 \ a 열에있는 셀의 요소를 반환합니다.
  
  행 / 열이 무효 인 경우, 또는 셀이 하늘의 경우는 0을 돌려줍니다. 이 경우 qDebug
  메시지가 인쇄됩니다. 셀이 있고 비어 있지 않은지 확인하려면 \ ref hasElement를 사용하십시오.
  
  \ addElement, hasElement를 참조하십시오.
*/
QCPLayoutElement *QCPLayoutGrid::element(int row, int column) const
{
  if (row >= 0 && row < mElements.size())
  {
    if (column >= 0 && column < mElements.first().size())
    {
      if (QCPLayoutElement *result = mElements.at(row).at(column))
        return result;
      else
        qDebug() << Q_FUNC_INFO << "Requested cell is empty. Row:" << row << "Column:" << column;
    } else
      qDebug() << Q_FUNC_INFO << "Invalid column. Row:" << row << "Column:" << column;
  } else
    qDebug() << Q_FUNC_INFO << "Invalid row. Row:" << row << "Column:" << column;
  return 0;
}


/*! \overload

  Adds the \a element to cell with \a row and \a column. If \a element is already in a layout, it
  is first removed from there. If \a row or \a column don't exist yet, the layout is expanded
  accordingly.

  Returns true if the element was added successfully, i.e. if the cell at \a row and \a column
  didn't already have an element.

  Use the overload of this method without explicit row/column index to place the element according
  to the configured fill order and wrapping settings.

  \see element, hasElement, take, remove
*/
/*! \초과 적재

  \ a 행과 \ a 열이있는 셀에 \ a 요소를 추가합니다. \ a 요소가 이미 레이아웃에있는 경우
  거기에서 먼저 제거됩니다. 행 또는 \ 열이 아직 존재하지 않으면 레이아웃이 확장됩니다.
  따라서.

  요소가 성공적으로 추가되면 true를 반환합니다. 즉, 행과 \ a 열에있는 셀
  이미 요소가 없습니다.

  명시적인 행 / 열 인덱스없이이 메서드의 오버로드를 사용하여 요소를 배치합니다.
  구성된 채우기 순서 및 래핑 설정에 적용됩니다.

  \ see 요소, hasElement, take, remove
*/
bool QCPLayoutGrid::addElement(int row, int column, QCPLayoutElement *element)
{
  if (!hasElement(row, column))
  {
    if (element && element->layout())  // remove from old layout first
      element->layout()->take(element); // 이전 레이아웃에서 먼저 제거합니다.
    expandTo(row+1, column+1);
    mElements[row][column] = element;
    if (element)
      adoptElement(element);
    return true;
  } else
    qDebug() << Q_FUNC_INFO << "There is already an element in the specified row/column:" << row << column;
  return false;
}

/*! \overload

  Adds the \a element to the next empty cell according to the current fill order (\ref
  setFillOrder) and wrapping (\ref setWrap). If \a element is already in a layout, it is first
  removed from there. If necessary, the layout is expanded to hold the new element.

  Returns true if the element was added successfully.

  \see setFillOrder, setWrap, element, hasElement, take, remove
*/
/*! \초과 적재

  현재 채우기 순서 (\ ref)에 따라 \ a 요소를 다음 빈 셀에 추가합니다.
  setFillOrder) 및 줄 바꿈 (\ ref setWrap). \ a 요소가 이미 레이아웃에있는 경우 첫 번째 요소입니다.
  거기에서 제거되었습니다. 필요한 경우 레이아웃이 확장되어 새 요소를 보유합니다.

  요소가 성공적으로 추가되면 true를 반환합니다.

  \ setFillOrder, setWrap, 요소, hasElement, take, remove를 참조하십시오.
*/
bool QCPLayoutGrid::addElement(QCPLayoutElement *element)
{
  int rowIndex = 0;
  int colIndex = 0;
  if (mFillOrder == foColumnsFirst)
  {
    while (hasElement(rowIndex, colIndex))
    {
      ++colIndex;
      if (colIndex >= mWrap && mWrap > 0)
      {
        colIndex = 0;
        ++rowIndex;
      }
    }
  } else
  {
    while (hasElement(rowIndex, colIndex))
    {
      ++rowIndex;
      if (rowIndex >= mWrap && mWrap > 0)
      {
        rowIndex = 0;
        ++colIndex;
      }
    }
  }
  return addElement(rowIndex, colIndex, element);
}

/*!
  Returns whether the cell at \a row and \a column exists and contains a valid element, i.e. isn't
  empty.
  
  \see element
*/
/*!
  \ a 행과 \ a 열의 셀이 존재 해, 유효한 요소를 가지고 있을지 어떨지를 돌려줍니다.
  빈.
  
  \ 요소보기
*/
bool QCPLayoutGrid::hasElement(int row, int column)
{
  if (row >= 0 && row < rowCount() && column >= 0 && column < columnCount())
    return mElements.at(row).at(column);
  else
    return false;
}

/*!
  Sets the stretch \a factor of \a column.
  
  Stretch factors control the relative sizes of rows and columns. Cells will not be resized beyond
  their minimum and maximum widths/heights, regardless of the stretch factor. (see \ref
  QCPLayoutElement::setMinimumSize, \ref QCPLayoutElement::setMaximumSize, \ref
  QCPLayoutElement::setSizeConstraintRect.)
  
  The default stretch factor of newly created rows/columns is 1.
  
  \see setColumnStretchFactors, setRowStretchFactor
*/
/*!
  \ a 열의 비율을 설정합니다.
  
  스트레치 요인은 행과 열의 상대적 크기를 제어합니다. 셀의 크기가 다시 조정되지 않습니다.
  최소 및 최대 너비 / 높이. (\ ref 참조
  QCPLayoutElement :: setMinimumSize, \ ref QCPLayoutElement :: setMaximumSize, \ ref
  QCPLayoutElement :: setSizeConstraintRect.)
  
  새로 작성된 행 / 열의 기본 늘림 인수는 1입니다.
  
  \ setColumnStretchFactors, setRowStretchFactor를 참조하십시오.
*/
void QCPLayoutGrid::setColumnStretchFactor(int column, double factor)
{
  if (column >= 0 && column < columnCount())
  {
    if (factor > 0)
      mColumnStretchFactors[column] = factor;
    else
      qDebug() << Q_FUNC_INFO << "Invalid stretch factor, must be positive:" << factor;
  } else
    qDebug() << Q_FUNC_INFO << "Invalid column:" << column;
}

/*!
  Sets the stretch \a factors of all columns. \a factors must have the size \ref columnCount.
  
  Stretch factors control the relative sizes of rows and columns. Cells will not be resized beyond
  their minimum and maximum widths/heights, regardless of the stretch factor. (see \ref
  QCPLayoutElement::setMinimumSize, \ref QCPLayoutElement::setMaximumSize, \ref
  QCPLayoutElement::setSizeConstraintRect.)
  
  The default stretch factor of newly created rows/columns is 1.
  
  \see setColumnStretchFactor, setRowStretchFactors
*/
/*!
  모든 열의 확대 / 축소 요인을 설정합니다. 요소는 \ ref columnCount 크기 여야합니다.
  
  스트레치 요인은 행과 열의 상대적 크기를 제어합니다. 셀의 크기가 다시 조정되지 않습니다.
  최소 및 최대 너비 / 높이. (\ ref 참조
  QCPLayoutElement :: setMinimumSize, \ ref QCPLayoutElement :: setMaximumSize, \ ref
  QCPLayoutElement :: setSizeConstraintRect.)
  
  새로 작성된 행 / 열의 기본 늘림 인수는 1입니다.
  
  \ setColumnStretchFactor, setRowStretchFactors를 참조하십시오.
*/
void QCPLayoutGrid::setColumnStretchFactors(const QList<double> &factors)
{
  if (factors.size() == mColumnStretchFactors.size())
  {
    mColumnStretchFactors = factors;
    for (int i=0; i<mColumnStretchFactors.size(); ++i)
    {
      if (mColumnStretchFactors.at(i) <= 0)
      {
        qDebug() << Q_FUNC_INFO << "Invalid stretch factor, must be positive:" << mColumnStretchFactors.at(i);
        mColumnStretchFactors[i] = 1;
      }
    }
  } else
    qDebug() << Q_FUNC_INFO << "Column count not equal to passed stretch factor count:" << factors;
}

/*!
  Sets the stretch \a factor of \a row.
  
  Stretch factors control the relative sizes of rows and columns. Cells will not be resized beyond
  their minimum and maximum widths/heights, regardless of the stretch factor. (see \ref
  QCPLayoutElement::setMinimumSize, \ref QCPLayoutElement::setMaximumSize, \ref
  QCPLayoutElement::setSizeConstraintRect.)
  
  The default stretch factor of newly created rows/columns is 1.
  
  \see setColumnStretchFactors, setRowStretchFactor
*/
/*!
  스트레치 \ a 행의 인수를 설정합니다.
  
  스트레치 요인은 행과 열의 상대적 크기를 제어합니다. 셀의 크기가 다시 조정되지 않습니다.
  최소 및 최대 너비 / 높이. (\ ref 참조
  QCPLayoutElement :: setMinimumSize, \ ref QCPLayoutElement :: setMaximumSize, \ ref
  QCPLayoutElement :: setSizeConstraintRect.)
  
  새로 작성된 행 / 열의 기본 늘림 인수는 1입니다.
  
  \ setColumnStretchFactors, setRowStretchFactor를 참조하십시오.
*/
void QCPLayoutGrid::setRowStretchFactor(int row, double factor)
{
  if (row >= 0 && row < rowCount())
  {
    if (factor > 0)
      mRowStretchFactors[row] = factor;
    else
      qDebug() << Q_FUNC_INFO << "Invalid stretch factor, must be positive:" << factor;
  } else
    qDebug() << Q_FUNC_INFO << "Invalid row:" << row;
}

/*!
  Sets the stretch \a factors of all rows. \a factors must have the size \ref rowCount.
  
  Stretch factors control the relative sizes of rows and columns. Cells will not be resized beyond
  their minimum and maximum widths/heights, regardless of the stretch factor. (see \ref
  QCPLayoutElement::setMinimumSize, \ref QCPLayoutElement::setMaximumSize, \ref
  QCPLayoutElement::setSizeConstraintRect.)
  
  The default stretch factor of newly created rows/columns is 1.
  
  \see setRowStretchFactor, setColumnStretchFactors
*/
/*!
  모든 행의 스트레치 팩터를 설정합니다. \ factor는 \ ref rowCount 크기 여야합니다.
  
  스트레치 요인은 행과 열의 상대적 크기를 제어합니다. 셀의 크기가 다시 조정되지 않습니다.
  최소 및 최대 너비 / 높이. (\ ref 참조
  QCPLayoutElement :: setMinimumSize, \ ref QCPLayoutElement :: setMaximumSize, \ ref
  QCPLayoutElement :: setSizeConstraintRect.)
  
  새로 작성된 행 / 열의 기본 늘림 인수는 1입니다.
  
  \ setRowStretchFactor, setColumnStretchFactors를 참조하십시오.
*/
void QCPLayoutGrid::setRowStretchFactors(const QList<double> &factors)
{
  if (factors.size() == mRowStretchFactors.size())
  {
    mRowStretchFactors = factors;
    for (int i=0; i<mRowStretchFactors.size(); ++i)
    {
      if (mRowStretchFactors.at(i) <= 0)
      {
        qDebug() << Q_FUNC_INFO << "Invalid stretch factor, must be positive:" << mRowStretchFactors.at(i);
        mRowStretchFactors[i] = 1;
      }
    }
  } else
    qDebug() << Q_FUNC_INFO << "Row count not equal to passed stretch factor count:" << factors;
}

/*!
  Sets the gap that is left blank between columns to \a pixels.
  
  \see setRowSpacing
*/
/*!
  열 사이에 공백으로 남겨둔 간격을 \ 픽셀로 설정합니다.
  
  \ setRowSpacing 참조
*/
void QCPLayoutGrid::setColumnSpacing(int pixels)
{
  mColumnSpacing = pixels;
}

/*!
  Sets the gap that is left blank between rows to \a pixels.
  
  \see setColumnSpacing
*/
/*!
  행간의 공백을 \ a 픽셀로 설정합니다.
  
  \ setColumnSpacing 참조
*/
void QCPLayoutGrid::setRowSpacing(int pixels)
{
  mRowSpacing = pixels;
}

/*!
  Sets the maximum number of columns or rows that are used, before new elements added with \ref
  addElement(QCPLayoutElement*) will start to fill the next row or column, respectively. It depends
  on \ref setFillOrder, whether rows or columns are wrapped.

  If \a count is set to zero, no wrapping will ever occur.
  
  If you wish to re-wrap the elements currently in the layout, call \ref setFillOrder with \a
  rearrange set to true (the actual fill order doesn't need to be changed for the rearranging to be
  done).

  Note that the method \ref addElement(int row, int column, QCPLayoutElement *element) with
  explicitly stated row and column is not subject to wrapping and can place elements even beyond
  the specified wrapping point.

  \see setFillOrder
*/
/*!
  \ ref로 새 요소를 추가하기 전에 사용되는 열 또는 행의 최대 수를 설정합니다.
  addElement (QCPLayoutElement *)는 각각 다음 행이나 열을 채우기 시작합니다. 그것은 달려있다.
  \ ref setFillOrder, 행 또는 열이 랩핑되었는지 여부.

  \ a count가 0으로 설정되면 랩핑이 일어나지 않습니다.
  
  현재 레이아웃에있는 요소를 다시 래핑하려면 \ ref setFillOrder를 \ a로 호출하십시오.
  재 배열을 true로 설정하십시오 (재 배열이 가능하도록 실제 채우기 순서를 변경할 필요가 없습니다).
  끝난).

  메소드 \ ref addElement (int row, int column, QCPLayoutElement * 요소)는
  명시 적으로 명시된 행과 열은 줄 바꿈의 대상이 아니며 요소를 넘어서 배치 할 수도 있습니다.
  지정된 랩핑 포인트

  \ setFillOrder를 참조하십시오.
*/
void QCPLayoutGrid::setWrap(int count)
{
  mWrap = qMax(0, count);
}

/*!
  Sets the filling order and wrapping behaviour that is used when adding new elements with the
  method \ref addElement(QCPLayoutElement*).

  The specified \a order defines whether rows or columns are filled first. Using \ref setWrap, you
  can control at which row/column count wrapping into the next column/row will occur. If you set it
  to zero, no wrapping will ever occur. Changing the fill order also changes the meaning of the
  linear index used e.g. in \ref elementAt and \ref takeAt.

  If you want to have all current elements arranged in the new order, set \a rearrange to true. The
  elements will be rearranged in a way that tries to preserve their linear index. However, empty
  cells are skipped during build-up of the new cell order, which shifts the succeeding element's
  index. The rearranging is performed even if the specified \a order is already the current fill
  order. Thus this method can be used to re-wrap the current elements.

  If \a rearrange is false, the current element arrangement is not changed, which means the
  linear indexes change (because the linear index is dependent on the fill order).

  Note that the method \ref addElement(int row, int column, QCPLayoutElement *element) with
  explicitly stated row and column is not subject to wrapping and can place elements even beyond
  the specified wrapping point.

  \see setWrap, addElement(QCPLayoutElement*)
*/
/*!
  새 요소를 추가 할 때 사용되는 채우기 순서 및 줄 바꿈 동작을 설정합니다.
  메서드 \ ref addElement (QCPLayoutElement *)입니다.

  지정된 \ a 순서는 행이나 열이 먼저 채워지는지 여부를 정의합니다. \ ref setWrap을 사용하면
  다음 열 / 행으로 줄 바꿈 / 열 수 래핑이 발생하는 시점을 제어 할 수 있습니다. 설정 한 경우
  0으로 설정하면 랩핑이 발생하지 않습니다. 채우기 순서를 변경하면
  linear index는 \ ref elementAt와 \ ref takeAt에서 사용된다.

  현재의 모든 요소를 ​​새로운 순서로 정렬하려면 \ 재 배열을 true로 설정하십시오. 그만큼
  요소는 선형 인덱스를 유지하려고하는 방식으로 재정렬됩니다. 그러나 비어 있음
  새로운 셀 순서를 빌드하는 동안 셀을 건너 뜁니다. 그러면 다음 요소의 셀 순서가 바뀝니다.
  색인. 지정된 정렬이 이미 현재 채우기 인 경우에도 재 배열이 수행됩니다.
  주문. 따라서이 메서드는 현재 요소를 다시 래핑하는 데 사용할 수 있습니다.

  \ rearrange가 false이면 현재 요소 배열이 변경되지 않습니다.
  선형 인덱스는 변경됩니다 (선형 인덱스는 채우기 순서에 따라 다르기 때문에).

  메소드 \ ref addElement (int row, int column, QCPLayoutElement * 요소)는
  명시 적으로 명시된 행과 열은 줄 바꿈의 대상이 아니며 요소를 넘어서 배치 할 수도 있습니다.
  지정된 랩핑 포인트

  \ setWrap, addElement (QCPLayoutElement *)를 참조하십시오.
*/
void QCPLayoutGrid::setFillOrder(FillOrder order, bool rearrange)
{
  // if rearranging, take all elements via linear index of old fill order:
  // 재배치하는 경우 이전 채우기 순서의 선형 색인을 통해 모든 요소를 ​​가져옵니다.
  const int elCount = elementCount();
  QVector<QCPLayoutElement*> tempElements;
  if (rearrange)
  {
    tempElements.reserve(elCount);
    for (int i=0; i<elCount; ++i)
    {
      if (elementAt(i))
        tempElements.append(takeAt(i));
    }
    simplify();
  }
  // change fill order as requested:
  // 요청대로 채우기 순서를 변경합니다.
  mFillOrder = order;
  // if rearranging, re-insert via linear index according to new fill order:
  // 재정렬하는 경우 새 채우기 순서에 따라 선형 인덱스를 통해 다시 삽입합니다.
  if (rearrange)
  {
    for (int i=0; i<tempElements.size(); ++i)
      addElement(tempElements.at(i));
  }
}

/*!
  Expands the layout to have \a newRowCount rows and \a newColumnCount columns. So the last valid
  row index will be \a newRowCount-1, the last valid column index will be \a newColumnCount-1.
  
  If the current column/row count is already larger or equal to \a newColumnCount/\a newRowCount,
  this function does nothing in that dimension.
  
  Newly created cells are empty, new rows and columns have the stretch factor 1.
  
  Note that upon a call to \ref addElement, the layout is expanded automatically to contain the
  specified row and column, using this function.
  
  \see simplify
*/
/*!
  \ newRowCount 행 및 \ newColumnCount 열을 갖도록 레이아웃을 확장합니다. 마지막 유효 기간
  행 인덱스는 \ newRowCount-1이되고, 마지막 유효한 열 인덱스는 \ newColumnCount-1이됩니다.
  
  현재의 열 / 행 수가 벌써 \ newColumnCount / \ newRowCount보다 크거나 같으면,
  이 함수는 해당 차원에서 아무 작업도 수행하지 않습니다.
  
  새로 생성 된 셀은 비어 있고, 새로운 행과 열에는 스트레치 요소 1이 있습니다.
  
  \ ref addElement를 호출하면 레이아웃이 자동으로 확장되어
  이 함수를 사용하여 지정된 행과 열을 반환합니다.
  
  \ 단순화하다.
*/
void QCPLayoutGrid::expandTo(int newRowCount, int newColumnCount)
{
  // add rows as necessary:
  // 필요에 따라 행을 추가하십시오.
  while (rowCount() < newRowCount)
  {
    mElements.append(QList<QCPLayoutElement*>());
    mRowStretchFactors.append(1);
  }
  // go through rows and expand columns as necessary:
  // 필요에 따라 행을 확장하고 열을 확장합니다.
  int newColCount = qMax(columnCount(), newColumnCount);
  for (int i=0; i<rowCount(); ++i)
  {
    while (mElements.at(i).size() < newColCount)
      mElements[i].append(0);
  }
  while (mColumnStretchFactors.size() < newColCount)
    mColumnStretchFactors.append(1);
}

/*!
  Inserts a new row with empty cells at the row index \a newIndex. Valid values for \a newIndex
  range from 0 (inserts a row at the top) to \a rowCount (appends a row at the bottom).
  
  \see insertColumn
*/
/*!
  행 인덱스 \ newIndex에 빈 셀이있는 새 행을 삽입합니다. \ a newIndex의 유효한 값
  범위는 0 (맨 위의 행 삽입)에서 \ a rowCount (맨 아래에 행 추가)입니다.
  
  \ see insertColumn
*/
void QCPLayoutGrid::insertRow(int newIndex)
{
  if (mElements.isEmpty() || mElements.first().isEmpty()) // if grid is completely empty, add first cell
  {                                                       // grid가 완전히 비어 있으면 첫 번째 셀을 추가합니다.
    expandTo(1, 1);
    return;
  }
  
  if (newIndex < 0)
    newIndex = 0;
  if (newIndex > rowCount())
    newIndex = rowCount();
  
  mRowStretchFactors.insert(newIndex, 1);
  QList<QCPLayoutElement*> newRow;
  for (int col=0; col<columnCount(); ++col)
    newRow.append((QCPLayoutElement*)0);
  mElements.insert(newIndex, newRow);
}

/*!
  Inserts a new column with empty cells at the column index \a newIndex. Valid values for \a
  newIndex range from 0 (inserts a column at the left) to \a columnCount (appends a column at the
  right).
  
  \see insertRow
*/
/*!
  열 인덱스 \ newIndex에 빈 셀이있는 새 열을 삽입합니다. \ a의 유효한 값
  newIndex의 범위는 0 (왼쪽의 열을 삽입)부터 \ a columnCount (열을
  권리).
  
  \ see insertRow
*/
void QCPLayoutGrid::insertColumn(int newIndex)
{
  if (mElements.isEmpty() || mElements.first().isEmpty()) // if grid is completely empty, add first cell
  {                                                       // grid가 완전히 비어 있으면 첫 번째 셀을 추가합니다.
    expandTo(1, 1);
    return;
  }
  
  if (newIndex < 0)
    newIndex = 0;
  if (newIndex > columnCount())
    newIndex = columnCount();
  
  mColumnStretchFactors.insert(newIndex, 1);
  for (int row=0; row<rowCount(); ++row)
    mElements[row].insert(newIndex, (QCPLayoutElement*)0);
}

/*!
  Converts the given \a row and \a column to the linear index used by some methods of \ref
  QCPLayoutGrid and \ref QCPLayout.

  The way the cells are indexed depends on \ref setFillOrder. If it is \ref foRowsFirst, the
  indices increase left to right and then top to bottom. If it is \ref foColumnsFirst, the indices
  increase top to bottom and then left to right.

  For the returned index to be valid, \a row and \a column must be valid indices themselves, i.e.
  greater or equal to zero and smaller than the current \ref rowCount/\ref columnCount.

  \see indexToRowCol
*/
/*!
  주어진 \ a 행과 \ column을 \ ref의 일부 메소드에서 사용하는 선형 인덱스로 변환합니다.
  QCPLayoutGrid 및 \ ref QCPLayout.

  셀의 색인 방법은 \ ref setFillOrder에 따라 다릅니다. \ ref foRowsFirst 인 경우
  색인은 왼쪽에서 오른쪽으로 증가하고 위에서 아래로 증가합니다. \ ref foColumnsFirst 인 경우, 인덱스
  위에서 아래로 증가한 다음 왼쪽에서 오른쪽으로 증가합니다.

  반환 된 인덱스가 유효하기 위해서는 \ a 행과 \ a 열이 유효한 인덱스가되어야합니다. 즉
  0보다 크거나 같고 현재 \ ref 행 개수 / \ ref columnCount보다 작습니다.

  \ see indexToRowCol
*/
int QCPLayoutGrid::rowColToIndex(int row, int column) const
{
  if (row >= 0 && row < rowCount())
  {
    if (column >= 0 && column < columnCount())
    {
      switch (mFillOrder)
      {
        case foRowsFirst: return column*rowCount() + row;
        case foColumnsFirst: return row*columnCount() + column;
      }
    } else
      qDebug() << Q_FUNC_INFO << "row index out of bounds:" << row;
  } else
    qDebug() << Q_FUNC_INFO << "column index out of bounds:" << column;
  return 0;
}

/*!
  Converts the linear index to row and column indices and writes the result to \a row and \a
  column.

  The way the cells are indexed depends on \ref setFillOrder. If it is \ref foRowsFirst, the
  indices increase left to right and then top to bottom. If it is \ref foColumnsFirst, the indices
  increase top to bottom and then left to right.

  If there are no cells (i.e. column or row count is zero), sets \a row and \a column to -1.

  For the retrieved \a row and \a column to be valid, the passed \a index must be valid itself,
  i.e. greater or equal to zero and smaller than the current \ref elementCount.

  \see rowColToIndex
*/
/*!
  선형 인덱스를 행 및 열 인덱스로 변환하고 결과를 \ a 행에 쓰고 \ a
  기둥.

  셀의 색인 방법은 \ ref setFillOrder에 따라 다릅니다. \ ref foRowsFirst 인 경우
  색인은 왼쪽에서 오른쪽으로 증가하고 위에서 아래로 증가합니다. \ ref foColumnsFirst 인 경우, 인덱스
  위에서 아래로 증가한 다음 왼쪽에서 오른쪽으로 증가합니다.

  셀이없는 경우 (즉, 열 또는 행 수가 0 인 경우) 행과 \ a 열을 -1로 설정합니다.

  검색된 \ a 행 및 \ 열이 유효하려면 전달 된 \ a 색인 자체가 유효해야하며,
  즉, 0보다 크거나 같고 현재 \ ref elementCount보다 작습니다.

  \ rowColToIndex를 참조하십시오.
*/
void QCPLayoutGrid::indexToRowCol(int index, int &row, int &column) const
{
  row = -1;
  column = -1;
  const int nCols = columnCount();
  const int nRows = rowCount();
  if (nCols == 0 || nRows == 0)
    return;
  if (index < 0 || index >= elementCount())
  {
    qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;
    return;
  }
  
  switch (mFillOrder)
  {
    case foRowsFirst:
    {
      column = index / nRows;
      row = index % nRows;
      break;
    }
    case foColumnsFirst:
    {
      row = index / nCols;
      column = index % nCols;
      break;
    }
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPLayoutGrid::updateLayout()
{
  QVector<int> minColWidths, minRowHeights, maxColWidths, maxRowHeights;
  getMinimumRowColSizes(&minColWidths, &minRowHeights);
  getMaximumRowColSizes(&maxColWidths, &maxRowHeights);
  
  int totalRowSpacing = (rowCount()-1) * mRowSpacing;
  int totalColSpacing = (columnCount()-1) * mColumnSpacing;
  QVector<int> colWidths = getSectionSizes(maxColWidths, minColWidths, mColumnStretchFactors.toVector(), mRect.width()-totalColSpacing);
  QVector<int> rowHeights = getSectionSizes(maxRowHeights, minRowHeights, mRowStretchFactors.toVector(), mRect.height()-totalRowSpacing);
  
  // go through cells and set rects accordingly:
  // 셀을 거치고 그에 따라 rect를 설정합니다.
  int yOffset = mRect.top();
  for (int row=0; row<rowCount(); ++row)
  {
    if (row > 0)
      yOffset += rowHeights.at(row-1)+mRowSpacing;
    int xOffset = mRect.left();
    for (int col=0; col<columnCount(); ++col)
    {
      if (col > 0)
        xOffset += colWidths.at(col-1)+mColumnSpacing;
      if (mElements.at(row).at(col))
        mElements.at(row).at(col)->setOuterRect(QRect(xOffset, yOffset, colWidths.at(col), rowHeights.at(row)));
    }
  }
}

/*!
  \seebaseclassmethod

  Note that the association of the linear \a index to the row/column based cells depends on the
  current setting of \ref setFillOrder.

  \see rowColToIndex
*/
/*!
  \ seebaseclassmethod

  행 / 열 기반 셀에 대한 선형 \ 인덱스의 연결은
  \ ref setFillOrder의 현재 설정.

  \ rowColToIndex를 참조하십시오.
*/
QCPLayoutElement *QCPLayoutGrid::elementAt(int index) const
{
  if (index >= 0 && index < elementCount())
  {
    int row, col;
    indexToRowCol(index, row, col);
    return mElements.at(row).at(col);
  } else
    return 0;
}

/*!
  \seebaseclassmethod

  Note that the association of the linear \a index to the row/column based cells depends on the
  current setting of \ref setFillOrder.

  \see rowColToIndex
*/
/*!
  \ seebaseclassmethod

  행 / 열 기반 셀에 대한 선형 \ 인덱스의 연결은
  \ ref setFillOrder의 현재 설정.

  \ rowColToIndex를 참조하십시오.
*/
QCPLayoutElement *QCPLayoutGrid::takeAt(int index)
{
  if (QCPLayoutElement *el = elementAt(index))
  {
    releaseElement(el);
    int row, col;
    indexToRowCol(index, row, col);
    mElements[row][col] = 0;
    return el;
  } else
  {
    qDebug() << Q_FUNC_INFO << "Attempt to take invalid index:" << index;
    return 0;
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
bool QCPLayoutGrid::take(QCPLayoutElement *element)
{
  if (element)
  {
    for (int i=0; i<elementCount(); ++i)
    {
      if (elementAt(i) == element)
      {
        takeAt(i);
        return true;
      }
    }
    qDebug() << Q_FUNC_INFO << "Element not in this layout, couldn't take";
  } else
    qDebug() << Q_FUNC_INFO << "Can't take null element";
  return false;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QList<QCPLayoutElement*> QCPLayoutGrid::elements(bool recursive) const
{
  QList<QCPLayoutElement*> result;
  const int elCount = elementCount();
#if QT_VERSION >= QT_VERSION_CHECK(4, 7, 0)
  result.reserve(elCount);
#endif
  for (int i=0; i<elCount; ++i)
    result.append(elementAt(i));
  if (recursive)
  {
    for (int i=0; i<elCount; ++i)
    {
      if (result.at(i))
        result << result.at(i)->elements(recursive);
    }
  }
  return result;
}

/*!
  Simplifies the layout by collapsing rows and columns which only contain empty cells.
*/
/*!
  빈 셀만 포함하는 행과 열을 축소하여 레이아웃을 간소화합니다.
*/
void QCPLayoutGrid::simplify()
{
  // remove rows with only empty cells:
  // 빈 셀만있는 행을 제거합니다.
  for (int row=rowCount()-1; row>=0; --row)
  {
    bool hasElements = false;
    for (int col=0; col<columnCount(); ++col)
    {
      if (mElements.at(row).at(col))
      {
        hasElements = true;
        break;
      }
    }
    if (!hasElements)
    {
      mRowStretchFactors.removeAt(row);
      mElements.removeAt(row);
      if (mElements.isEmpty()) // removed last element, also remove stretch factor (wouldn't happen below because also columnCount changed to 0 now)
// 마지막 요소를 제거하고 스트레치 요소도 제거합니다 (columnCount가 0으로 변경되었으므로 아래에서 발생하지 않음)
        mColumnStretchFactors.clear();
    }
  }
  
  // remove columns with only empty cells:
  // 빈 셀만 가진 열 제거 :
  for (int col=columnCount()-1; col>=0; --col)
  {
    bool hasElements = false;
    for (int row=0; row<rowCount(); ++row)
    {
      if (mElements.at(row).at(col))
      {
        hasElements = true;
        break;
      }
    }
    if (!hasElements)
    {
      mColumnStretchFactors.removeAt(col);
      for (int row=0; row<rowCount(); ++row)
        mElements[row].removeAt(col);
    }
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QSize QCPLayoutGrid::minimumOuterSizeHint() const
{
  QVector<int> minColWidths, minRowHeights;
  getMinimumRowColSizes(&minColWidths, &minRowHeights);
  QSize result(0, 0);
  for (int i=0; i<minColWidths.size(); ++i)
    result.rwidth() += minColWidths.at(i);
  for (int i=0; i<minRowHeights.size(); ++i)
    result.rheight() += minRowHeights.at(i);
  result.rwidth() += qMax(0, columnCount()-1) * mColumnSpacing;
  result.rheight() += qMax(0, rowCount()-1) * mRowSpacing;
  result.rwidth() += mMargins.left()+mMargins.right();
  result.rheight() += mMargins.top()+mMargins.bottom();
  return result;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QSize QCPLayoutGrid::maximumOuterSizeHint() const
{
  QVector<int> maxColWidths, maxRowHeights;
  getMaximumRowColSizes(&maxColWidths, &maxRowHeights);
  
  QSize result(0, 0);
  for (int i=0; i<maxColWidths.size(); ++i)
    result.setWidth(qMin(result.width()+maxColWidths.at(i), QWIDGETSIZE_MAX));
  for (int i=0; i<maxRowHeights.size(); ++i)
    result.setHeight(qMin(result.height()+maxRowHeights.at(i), QWIDGETSIZE_MAX));
  result.rwidth() += qMax(0, columnCount()-1) * mColumnSpacing;
  result.rheight() += qMax(0, rowCount()-1) * mRowSpacing;
  result.rwidth() += mMargins.left()+mMargins.right();
  result.rheight() += mMargins.top()+mMargins.bottom();
  if (result.height() > QWIDGETSIZE_MAX)
    result.setHeight(QWIDGETSIZE_MAX);
  if (result.width() > QWIDGETSIZE_MAX)
    result.setWidth(QWIDGETSIZE_MAX);
  return result;
}

/*! \internal
  
  Places the minimum column widths and row heights into \a minColWidths and \a minRowHeights
  respectively.
  
  The minimum height of a row is the largest minimum height of any element's outer rect in that
  row. The minimum width of a column is the largest minimum width of any element's outer rect in
  that column.
  
  This is a helper function for \ref updateLayout.
  
  \see getMaximumRowColSizes
*/
/*! \내부의
  
  최소 열 너비 및 행 높이를 \ a minColWidths 및 \ a minRowHeights에 배치합니다.
  각기.
  
  행의 최소 높이는 그 요소의 외부 요소 중 가장 큰 최소 높이입니다.
  열. 열의 최소 너비는 모든 요소의 바깥 쪽 구석 중 가장 큰 최소 너비입니다.
  그 열.
  
  \ ref updateLayout에 대한 도우미 함수입니다.
  
  \ see getMaximumRowColSizes
*/
void QCPLayoutGrid::getMinimumRowColSizes(QVector<int> *minColWidths, QVector<int> *minRowHeights) const
{
  *minColWidths = QVector<int>(columnCount(), 0);
  *minRowHeights = QVector<int>(rowCount(), 0);
  for (int row=0; row<rowCount(); ++row)
  {
    for (int col=0; col<columnCount(); ++col)
    {
      if (QCPLayoutElement *el = mElements.at(row).at(col))
      {
        QSize minSize = getFinalMinimumOuterSize(el);
        if (minColWidths->at(col) < minSize.width())
          (*minColWidths)[col] = minSize.width();
        if (minRowHeights->at(row) < minSize.height())
          (*minRowHeights)[row] = minSize.height();
      }
    }
  }
}

/*! \internal
  
  Places the maximum column widths and row heights into \a maxColWidths and \a maxRowHeights
  respectively.
  
  The maximum height of a row is the smallest maximum height of any element's outer rect in that
  row. The maximum width of a column is the smallest maximum width of any element's outer rect in
  that column.
  
  This is a helper function for \ref updateLayout.
  
  \see getMinimumRowColSizes
*/
/*! \내부의
  
  최대 열 너비와 행 높이를 \ a maxColWidths와 \ a maxRowHeights에 배치합니다.
  각기.
  
  행의 최대 높이는 모든 요소의 바깥 쪽 rect의 최소 높이입니다.
  열. 한 열의 최대 너비는 모든 요소의 바깥 쪽 rect의 최소 너비입니다.
  그 열.
  
  \ ref updateLayout에 대한 도우미 함수입니다.
  
  \ see getMinimumRowColSizes
*/
void QCPLayoutGrid::getMaximumRowColSizes(QVector<int> *maxColWidths, QVector<int> *maxRowHeights) const
{
  *maxColWidths = QVector<int>(columnCount(), QWIDGETSIZE_MAX);
  *maxRowHeights = QVector<int>(rowCount(), QWIDGETSIZE_MAX);
  for (int row=0; row<rowCount(); ++row)
  {
    for (int col=0; col<columnCount(); ++col)
    {
      if (QCPLayoutElement *el = mElements.at(row).at(col))
      {
        QSize maxSize = getFinalMaximumOuterSize(el);
        if (maxColWidths->at(col) > maxSize.width())
          (*maxColWidths)[col] = maxSize.width();
        if (maxRowHeights->at(row) > maxSize.height())
          (*maxRowHeights)[row] = maxSize.height();
      }
    }
  }
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPLayoutInset
////////////////////////////////////////////////////////////////////////////////////////////////////
/*! \class QCPLayoutInset
  \brief A layout that places child elements aligned to the border or arbitrarily positioned
  
  Elements are placed either aligned to the border or at arbitrary position in the area of the
  layout. Which placement applies is controlled with the \ref InsetPlacement (\ref
  setInsetPlacement).

  Elements are added via \ref addElement(QCPLayoutElement *element, Qt::Alignment alignment) or
  addElement(QCPLayoutElement *element, const QRectF &rect). If the first method is used, the inset
  placement will default to \ref ipBorderAligned and the element will be aligned according to the
  \a alignment parameter. The second method defaults to \ref ipFree and allows placing elements at
  arbitrary position and size, defined by \a rect.
  
  The alignment or rect can be set via \ref setInsetAlignment or \ref setInsetRect, respectively.
  
  This is the layout that every QCPAxisRect has as \ref QCPAxisRect::insetLayout.
*/
/*! \ class QCPLayoutInset
  \ brief 테두리에 정렬되거나 임의로 배치 된 자식 요소를 배치하는 레이아웃
  
  요소는 테두리에 정렬되거나 또는 테두리의 임의 위치에 배치됩니다.
  형세. 어떤 배치가 적용되는지는 \ ref InsetPlacement (\ ref
  setInsetPlacement).

  요소는 \ ref addElement (QCPLayoutElement * 요소, Qt :: 정렬 맞춤)를 통해 추가되거나
  addElement (QCPLayoutElement * 요소, const QRectF & rect). 첫 번째 방법을 사용하는 경우 삽입
  배치는 \ ref ipBorderAligned로 기본 설정되며 요소는
  \ 정렬 매개 변수. 두 번째 방법의 기본값은 \ ref ipFree이며,
  \ a rect로 정의되는 임의의 위치와 크기.
  
  정렬 또는 rect는 각각 \ ref setInsetAlignment 또는 \ ref setInsetRect를 통해 설정할 수 있습니다.
  
  이것은 모든 QCPAxisRect가 \ ref QCPAxisRect :: insetLayout으로 가지고있는 레이아웃입니다.
*/

/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */

/*! \fn virtual void QCPLayoutInset::simplify()
  
  The QCPInsetLayout does not need simplification since it can never have empty cells due to its
  linear index structure. This method does nothing.
*/
/*! \ fn 가상 무효 QCPLayoutInset :: simplify ()
  
  QCPInsetLayout은 단순화가 필요하지 않습니다.
  선형 인덱스 구조. 이 메서드는 아무 것도 수행하지 않습니다.
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */

/*!
  Creates an instance of QCPLayoutInset and sets default values.
*/
/*!
  QCPLayoutInset 인스턴스를 만들고 기본값을 설정합니다.
*/
QCPLayoutInset::QCPLayoutInset()
{
}

QCPLayoutInset::~QCPLayoutInset()
{
  // clear all child layout elements. This is important because only the specific layouts know how
  // to handle removing elements (clear calls virtual removeAt method to do that).
  // 모든 자식 레이아웃 요소를 지 웁니다. 특정 레이아웃에서만 방법을 알고 있기 때문에 이것은 중요합니다.
  // 요소 제거를 처리하기 위해 (clear 호출 virtual removeAt 메서드를 사용하여).
  clear();
}

/*!
  Returns the placement type of the element with the specified \a index.
*/
/*!
  지정된 \ a 인덱스가있는 요소의 배치 유형을 반환합니다.
*/
QCPLayoutInset::InsetPlacement QCPLayoutInset::insetPlacement(int index) const
{
  if (elementAt(index))
    return mInsetPlacement.at(index);
  else
  {
    qDebug() << Q_FUNC_INFO << "Invalid element index:" << index;
    return ipFree;
  }
}

/*!
  Returns the alignment of the element with the specified \a index. The alignment only has a
  meaning, if the inset placement (\ref setInsetPlacement) is \ref ipBorderAligned.
*/
/*!
  지정된 \ a 인덱스로 요소의 정렬을 반환합니다. 정렬에는
  인셋 배치 (\ ref setInsetPlacement)가 \ ref ipBorderAligned 인 경우를 의미합니다.
*/
Qt::Alignment QCPLayoutInset::insetAlignment(int index) const
{
  if (elementAt(index))
    return mInsetAlignment.at(index);
  else
  {
    qDebug() << Q_FUNC_INFO << "Invalid element index:" << index;
    return 0;
  }
}

/*!
  Returns the rect of the element with the specified \a index. The rect only has a
  meaning, if the inset placement (\ref setInsetPlacement) is \ref ipFree.
*/
/*!
  지정된 \ a 인덱스를 사용하여 요소의 rect를 반환합니다. rect에는
  인셋 배치 (\ ref setInsetPlacement)가 \ ref ipFree 인 경우를 의미합니다.
*/
QRectF QCPLayoutInset::insetRect(int index) const
{
  if (elementAt(index))
    return mInsetRect.at(index);
  else
  {
    qDebug() << Q_FUNC_INFO << "Invalid element index:" << index;
    return QRectF();
  }
}

/*!
  Sets the inset placement type of the element with the specified \a index to \a placement.
  
  \see InsetPlacement
*/
/*!
  지정된 \ a 인덱스를 사용하여 요소의 삽입 된 게재 위치 유형을 \ placement 위치로 설정합니다.
  
  \ InsetPlacement를 참조하십시오.
*/
void QCPLayoutInset::setInsetPlacement(int index, QCPLayoutInset::InsetPlacement placement)
{
  if (elementAt(index))
    mInsetPlacement[index] = placement;
  else
    qDebug() << Q_FUNC_INFO << "Invalid element index:" << index;
}

/*!
  If the inset placement (\ref setInsetPlacement) is \ref ipBorderAligned, this function
  is used to set the alignment of the element with the specified \a index to \a alignment.
  
  \a alignment is an or combination of the following alignment flags: Qt::AlignLeft,
  Qt::AlignHCenter, Qt::AlighRight, Qt::AlignTop, Qt::AlignVCenter, Qt::AlignBottom. Any other
  alignment flags will be ignored.
*/
/*!
  인 세트 배치 (\ ref setInsetPlacement)가 \ ref ipBorderAligned 인 경우이 함수는
  요소를 지정된 \ a 인덱스로 정렬하는 것을 \ a 정렬로 설정하는 데 사용됩니다.
  
  \ alignment는 다음 정렬 플래그 중 하나 또는 조합입니다 : Qt :: AlignLeft,
  Qt :: AlignHCenter, Qt :: AlighRight, Qt :: AlignTop, Qt :: AlignVCenter, Qt :: AlignBottom. 기타
  정렬 플래그는 무시됩니다.
*/
void QCPLayoutInset::setInsetAlignment(int index, Qt::Alignment alignment)
{
  if (elementAt(index))
    mInsetAlignment[index] = alignment;
  else
    qDebug() << Q_FUNC_INFO << "Invalid element index:" << index;
}

/*!
  If the inset placement (\ref setInsetPlacement) is \ref ipFree, this function is used to set the
  position and size of the element with the specified \a index to \a rect.
  
  \a rect is given in fractions of the whole inset layout rect. So an inset with rect (0, 0, 1, 1)
  will span the entire layout. An inset with rect (0.6, 0.1, 0.35, 0.35) will be in the top right
  corner of the layout, with 35% width and height of the parent layout.
  
  Note that the minimum and maximum sizes of the embedded element (\ref
  QCPLayoutElement::setMinimumSize, \ref QCPLayoutElement::setMaximumSize) are enforced.
*/
/*!
  삽입 배치 (\ ref setInsetPlacement)가 \ ref ipFree 인 경우이 함수를 사용하여
  지정된 \ a 인덱스를 가지는 요소의 위치와 크기를 \ rect에 지정합니다.
  
  \ rect는 전체 inset 레이아웃 rect의 분수로 주어집니다. 그래서 rect (0, 0, 1, 1)
  전체 레이아웃을 확장합니다. rect (0.6, 0.1, 0.35, 0.35)가있는 인세 트가 오른쪽 위에 있습니다.
  코너 레이아웃의 폭과 높이가 35 %입니다.
  
  삽입 된 요소의 최소 및 최대 크기 (\ ref
  QCPLayoutElement :: setMinimumSize, \ ref QCPLayoutElement :: setMaximumSize)가 적용됩니다.
*/
void QCPLayoutInset::setInsetRect(int index, const QRectF &rect)
{
  if (elementAt(index))
    mInsetRect[index] = rect;
  else
    qDebug() << Q_FUNC_INFO << "Invalid element index:" << index;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPLayoutInset::updateLayout()
{
  for (int i=0; i<mElements.size(); ++i)
  {
    QCPLayoutElement *el = mElements.at(i);
    QRect insetRect;
    QSize finalMinSize = getFinalMinimumOuterSize(el);
    QSize finalMaxSize = getFinalMaximumOuterSize(el);
    if (mInsetPlacement.at(i) == ipFree)
    {
      insetRect = QRect(rect().x()+rect().width()*mInsetRect.at(i).x(),
                        rect().y()+rect().height()*mInsetRect.at(i).y(),
                        rect().width()*mInsetRect.at(i).width(),
                        rect().height()*mInsetRect.at(i).height());
      if (insetRect.size().width() < finalMinSize.width())
        insetRect.setWidth(finalMinSize.width());
      if (insetRect.size().height() < finalMinSize.height())
        insetRect.setHeight(finalMinSize.height());
      if (insetRect.size().width() > finalMaxSize.width())
        insetRect.setWidth(finalMaxSize.width());
      if (insetRect.size().height() > finalMaxSize.height())
        insetRect.setHeight(finalMaxSize.height());
    } else if (mInsetPlacement.at(i) == ipBorderAligned)
    {
      insetRect.setSize(finalMinSize);
      Qt::Alignment al = mInsetAlignment.at(i);
      if (al.testFlag(Qt::AlignLeft)) insetRect.moveLeft(rect().x());
      else if (al.testFlag(Qt::AlignRight)) insetRect.moveRight(rect().x()+rect().width());
      else insetRect.moveLeft(rect().x()+rect().width()*0.5-finalMinSize.width()*0.5); 
      // default to Qt::AlignHCenter
      // Qt를 기본값으로 사용 : AlignHCenter
      if (al.testFlag(Qt::AlignTop)) insetRect.moveTop(rect().y());          
      else if (al.testFlag(Qt::AlignBottom)) insetRect.moveBottom(rect().y()+rect().height());
      else insetRect.moveTop(rect().y()+rect().height()*0.5-finalMinSize.height()*0.5); 
      // default to Qt::AlignVCenter
      // Qt를 기본값으로 사용 : AlignVCenter
    }
    mElements.at(i)->setOuterRect(insetRect);
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
int QCPLayoutInset::elementCount() const
{
  return mElements.size();
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPLayoutElement *QCPLayoutInset::elementAt(int index) const
{
  if (index >= 0 && index < mElements.size())
    return mElements.at(index);
  else
    return 0;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPLayoutElement *QCPLayoutInset::takeAt(int index)
{
  if (QCPLayoutElement *el = elementAt(index))
  {
    releaseElement(el);
    mElements.removeAt(index);
    mInsetPlacement.removeAt(index);
    mInsetAlignment.removeAt(index);
    mInsetRect.removeAt(index);
    return el;
  } else
  {
    qDebug() << Q_FUNC_INFO << "Attempt to take invalid index:" << index;
    return 0;
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
bool QCPLayoutInset::take(QCPLayoutElement *element)
{
  if (element)
  {
    for (int i=0; i<elementCount(); ++i)
    {
      if (elementAt(i) == element)
      {
        takeAt(i);
        return true;
      }
    }
    qDebug() << Q_FUNC_INFO << "Element not in this layout, couldn't take";
  } else
    qDebug() << Q_FUNC_INFO << "Can't take null element";
  return false;
}

/*!
  The inset layout is sensitive to events only at areas where its (visible) child elements are
  sensitive. If the selectTest method of any of the child elements returns a positive number for \a
  pos, this method returns a value corresponding to 0.99 times the parent plot's selection
  tolerance. The inset layout is not selectable itself by default. So if \a onlySelectable is true,
  -1.0 is returned.
  
  See \ref QCPLayerable::selectTest for a general explanation of this virtual method.
*/
/*!
  인세 트 레이아웃은 (보이는) 자식 요소가있는 영역에서만 이벤트에 민감합니다
  민감한. 자식 요소의 selectTest 메서드가 \ a에 양수를 반환하면
  pos 인 경우이 메소드는 부모 플롯의 선택 항목의 0.99 배에 해당하는 값을 반환합니다.
  공차. 인세 트 레이아웃은 기본적으로 선택할 수 없습니다. 그러므로 \ a onlySelectable이 참이면,
  -1.0이 리턴됩니다.
  
  이 가상 메소드에 대한 일반적인 설명은 \ ref QCPLayerable :: selectTest를 참조하십시오.
*/
double QCPLayoutInset::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  Q_UNUSED(details)
  if (onlySelectable)
    return -1;
  
  for (int i=0; i<mElements.size(); ++i)
  {
    // inset layout shall only return positive selectTest, if actually an inset object is at pos
    // else it would block the entire underlying QCPAxisRect with its surface.
    // 인셋 레이아웃은 실제로 인셋 객체가 pos에있는 경우에만 양의 selectTest를 반환합니다.
    // 그렇지 않으면 표면이있는 전체 QCPAxisRect를 차단합니다.
    if (mElements.at(i)->realVisibility() && mElements.at(i)->selectTest(pos, onlySelectable) >= 0)
      return mParentPlot->selectionTolerance()*0.99;
  }
  return -1;
}

/*!
  Adds the specified \a element to the layout as an inset aligned at the border (\ref
  setInsetAlignment is initialized with \ref ipBorderAligned). The alignment is set to \a
  alignment.
  
  \a alignment is an or combination of the following alignment flags: Qt::AlignLeft,
  Qt::AlignHCenter, Qt::AlighRight, Qt::AlignTop, Qt::AlignVCenter, Qt::AlignBottom. Any other
  alignment flags will be ignored.
  
  \see addElement(QCPLayoutElement *element, const QRectF &rect)
*/
/*!
  지정된 \ a 요소를 테두리에 정렬 된 인셋으로 레이아웃에 추가합니다 (\ ref
  setInsetAlignment는 \ ref ipBorderAligned로 초기화됩니다. 정렬은 \ a로 설정됩니다.
  조정.
  
  \ alignment는 다음 정렬 플래그 중 하나 또는 조합입니다 : Qt :: AlignLeft,
  Qt :: AlignHCenter, Qt :: AlighRight, Qt :: AlignTop, Qt :: AlignVCenter, Qt :: AlignBottom. 기타
  정렬 플래그는 무시됩니다.
  
  \ 참조 addElement (QCPLayoutElement * 요소, const QRectF & rect)
*/
void QCPLayoutInset::addElement(QCPLayoutElement *element, Qt::Alignment alignment)
{
  if (element)
  {
    if (element->layout()) // remove from old layout first
                           // 이전 레이아웃에서 먼저 제거합니다.
      element->layout()->take(element);
    mElements.append(element);
    mInsetPlacement.append(ipBorderAligned);
    mInsetAlignment.append(alignment);
    mInsetRect.append(QRectF(0.6, 0.6, 0.4, 0.4));
    adoptElement(element);
  } else
    qDebug() << Q_FUNC_INFO << "Can't add null element";
}

/*!
  Adds the specified \a element to the layout as an inset with free positioning/sizing (\ref
  setInsetAlignment is initialized with \ref ipFree). The position and size is set to \a
  rect.
  
  \a rect is given in fractions of the whole inset layout rect. So an inset with rect (0, 0, 1, 1)
  will span the entire layout. An inset with rect (0.6, 0.1, 0.35, 0.35) will be in the top right
  corner of the layout, with 35% width and height of the parent layout.
  
  \see addElement(QCPLayoutElement *element, Qt::Alignment alignment)
*/
/*!
  지정된 \ a 요소를 레이아웃에 삽입하고 위치 / 크기를 자유롭게 삽입합니다 (\ ref
  setInsetAlignment는 \ ref ipFree로 초기화됩니다.) 위치와 크기는 \ a로 설정됩니다.
  rect.
  
  \ rect는 전체 inset 레이아웃 rect의 분수로 주어집니다. 그래서 rect (0, 0, 1, 1)
  전체 레이아웃을 확장합니다. rect (0.6, 0.1, 0.35, 0.35)가있는 인세 트가 오른쪽 위에 있습니다.
  코너 레이아웃의 폭과 높이가 35 %입니다.
  
  \ addElement (QCPLayoutElement * 요소, Qt :: 정렬 맞춤) 참조
*/
void QCPLayoutInset::addElement(QCPLayoutElement *element, const QRectF &rect)
{
  if (element)
  {
    if (element->layout()) // remove from old layout first
                           // 이전 레이아웃에서 먼저 제거합니다.
      element->layout()->take(element);
    mElements.append(element);
    mInsetPlacement.append(ipFree);
    mInsetAlignment.append(Qt::AlignRight|Qt::AlignTop);
    mInsetRect.append(rect);
    adoptElement(element);
  } else
    qDebug() << Q_FUNC_INFO << "Can't add null element";
}
/* end of 'src/layout.cpp' */


/* including file 'src/lineending.cpp', size 11536                           */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / layout.cpp'의 끝 */


/* 파일 'src / lineending.cpp'포함, 크기 11536 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPLineEnding
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPLineEnding
  \brief Handles the different ending decorations for line-like items
  
  \image html QCPLineEnding.png "The various ending styles currently supported"
  
  For every ending a line-like item has, an instance of this class exists. For example, QCPItemLine
  has two endings which can be set with QCPItemLine::setHead and QCPItemLine::setTail.
 
  The styles themselves are defined via the enum QCPLineEnding::EndingStyle. Most decorations can
  be modified regarding width and length, see \ref setWidth and \ref setLength. The direction of
  the ending decoration (e.g. direction an arrow is pointing) is controlled by the line-like item.
  For example, when both endings of a QCPItemLine are set to be arrows, they will point to opposite
  directions, e.g. "outward". This can be changed by \ref setInverted, which would make the
  respective arrow point inward.
  
  Note that due to the overloaded QCPLineEnding constructor, you may directly specify a
  QCPLineEnding::EndingStyle where actually a QCPLineEnding is expected, e.g.
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcplineending-sethead
*/
/*! \ class QCPLineEnding
  \ brief 줄 모양 항목의 다른 끝 장식을 처리합니다.
  
  \ image html QCPLineEnding.png "현재 지원되는 다양한 종료 스타일"
  
  라인과 같은 항목이 끝날 때마다이 클래스의 인스턴스가 존재합니다. 예를 들어, QCPItemLine
  QCPItemLine :: setHead 및 QCPItemLine :: setTail을 사용하여 설정할 수있는 두 개의 엔딩이 있습니다.
 
  스타일 자체는 QCPLineEnding :: EndingStyle 열거 형을 통해 정의됩니다. 대부분의 장식품은
  width와 length에 관해서는 \ ref setWidth와 \ ref setLength를 참조하십시오. 방향
  끝 장식 (예 : 화살표가 가리키는 방향)은 선 같은 항목에 의해 제어됩니다.
  예를 들어, QCPItemLine의 양쪽 엔딩이 화살표로 설정되면, 반대 방향
  방향. 예 : "바깥". 이것은 \ ref setInverted에 의해 변경 될 수 있습니다.
  각각의 화살표가 안쪽으로 향하게한다.
  
  오버로드 된 QCPLineEnding 생성자로 인해 직접적으로
  QCPLineEnding :: EndingStyle 실제로 QCPLineEnding이 예상됩니다. 예 :
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcplineending-sethead
*/

/*!
  Creates a QCPLineEnding instance with default values (style \ref esNone).
*/
/*!
  기본값 (스타일 \ ref esNone)을 사용하여 QCPLineEnding 인스턴스를 만듭니다.
*/
QCPLineEnding::QCPLineEnding() :
  mStyle(esNone),
  mWidth(8),
  mLength(10),
  mInverted(false)
{
}

/*!
  Creates a QCPLineEnding instance with the specified values.
*/
/*!
  지정된 값으로 QCPLineEnding 인스턴스를 만듭니다.
*/
QCPLineEnding::QCPLineEnding(QCPLineEnding::EndingStyle style, double width, double length, bool inverted) :
  mStyle(style),
  mWidth(width),
  mLength(length),
  mInverted(inverted)
{
}

/*!
  Sets the style of the ending decoration.
*/
/*!
  끝 장식의 스타일을 설정합니다.
*/
void QCPLineEnding::setStyle(QCPLineEnding::EndingStyle style)
{
  mStyle = style;
}

/*!
  Sets the width of the ending decoration, if the style supports it. On arrows, for example, the
  width defines the size perpendicular to the arrow's pointing direction.
  
  \see setLength
*/
/*!
  스타일이 지원하는 경우, 장식의 폭을 설정합니다. 화살표에서 예를 들어,
  너비는 화살표의 방향에 수직 인 크기를 정의합니다.
  
  \ setLength를 참조하십시오.
*/
void QCPLineEnding::setWidth(double width)
{
  mWidth = width;
}

/*!
  Sets the length of the ending decoration, if the style supports it. On arrows, for example, the
  length defines the size in pointing direction.
  
  \see setWidth
*/
/*!
  스타일이 지원하는 경우 장식의 길이를 설정합니다. 화살표에서 예를 들어,
  길이는 포인팅 방향의 크기를 정의합니다.
  
  \ 참조 setWidth
*/
void QCPLineEnding::setLength(double length)
{
  mLength = length;
}

/*!
  Sets whether the ending decoration shall be inverted. For example, an arrow decoration will point
  inward when \a inverted is set to true.

  Note that also the \a width direction is inverted. For symmetrical ending styles like arrows or
  discs, this doesn't make a difference. However, asymmetric styles like \ref esHalfBar are
  affected by it, which can be used to control to which side the half bar points to.
*/
/*!
  끝 장식을 뒤집을 지 여부를 설정합니다. 예를 들어, 화살표 장식은
  \ inverted가 true로 설정되면 안쪽으로.

  \ a 너비 방향도 바뀌 었음에 유의하십시오. 대칭 인 끝 스타일 (예 : 화살표 또는
  디스크, 이것은 차이를 만들지 않습니다. 그러나 \ ref esHalfBar와 같은 비대칭 스타일은 다음과 같습니다.
  반쪽 막대가 어느 쪽을 가리키는 지 제어하는 ​​데 사용할 수있는 영향을받습니다.
*/
void QCPLineEnding::setInverted(bool inverted)
{
  mInverted = inverted;
}

/*! \internal
  
  Returns the maximum pixel radius the ending decoration might cover, starting from the position
  the decoration is drawn at (typically a line ending/\ref QCPItemPosition of an item).
  
  This is relevant for clipping. Only omit painting of the decoration when the position where the
  decoration is supposed to be drawn is farther away from the clipping rect than the returned
  distance.
*/
/*! \내부의
  
  끝 장식이 덮을 수있는 최대 픽셀 반경을 위치에서 시작하여 반환합니다.
  장식이 그려집니다 (일반적으로 항목의 줄 끝 / \ ref QCPItemPosition).
  
  이는 자르기와 관련이 있습니다. 장식의 그림을 생략하면
  장식은 끌기 직사각형에서 멀리 떨어져 있습니다.
  거리.
*/
double QCPLineEnding::boundingDistance() const
{
  switch (mStyle)
  {
    case esNone:
      return 0;
      
    case esFlatArrow:
    case esSpikeArrow:
    case esLineArrow:
    case esSkewedBar:
      return qSqrt(mWidth*mWidth+mLength*mLength); // items that have width and length
                                                   // 너비와 길이가있는 항목
    case esDisc:
    case esSquare:
    case esDiamond:
    case esBar:
    case esHalfBar:
      return mWidth*1.42; // items that only have a width -> width*sqrt(2)
                          // 너비 만있는 항목 -> width * sqrt (2)

  }
  return 0;
}

/*!
  Starting from the origin of this line ending (which is style specific), returns the length
  covered by the line ending symbol, in backward direction.
  
  For example, the \ref esSpikeArrow has a shorter real length than a \ref esFlatArrow, even if
  both have the same \ref setLength value, because the spike arrow has an inward curved back, which
  reduces the length along its center axis (the drawing origin for arrows is at the tip).
  
  This function is used for precise, style specific placement of line endings, for example in
  QCPAxes.
*/
/*!
  이 줄 끝 (스타일에 따라 다름)의 원점에서 시작하여 길이
  줄 끝 기호에 의해 덮여, 역방향으로.
  
  예를 들어 \ ref esSpikeArrow는 \ ref esFlatArrow보다 실제 길이가 짧습니다.
  스파이크 화살표가 안쪽으로 휘어진 뒤가 있기 때문에 둘 다 동일한 \ ref setLength 값을 갖습니다.
  중심 축을 따라 길이를 줄입니다 (화살표의 그림 원점은 팁에 있습니다).
  
  이 함수는 라인 앤티의 정확한 스타일 지정을 위해 사용됩니다.
  QCPAxes.
*/
double QCPLineEnding::realLength() const
{
  switch (mStyle)
  {
    case esNone:
    case esLineArrow:
    case esSkewedBar:
    case esBar:
    case esHalfBar:
      return 0;
      
    case esFlatArrow:
      return mLength;
      
    case esDisc:
    case esSquare:
    case esDiamond:
      return mWidth*0.5;
      
    case esSpikeArrow:
      return mLength*0.8;
  }
  return 0;
}

/*! \internal
  
  Draws the line ending with the specified \a painter at the position \a pos. The direction of the
  line ending is controlled with \a dir.
*/
/*! \내부의
  
  지정한 \ a 페인터로 끝나는 행을 \ pos의 위치에 그립니다. 그 방향은
  줄 끝은 \ a dir로 제어됩니다.
*/
void QCPLineEnding::draw(QCPPainter *painter, const QCPVector2D &pos, const QCPVector2D &dir) const
{
  if (mStyle == esNone)
    return;
  
  QCPVector2D lengthVec = dir.normalized() * mLength*(mInverted ? -1 : 1);
  if (lengthVec.isNull())
    lengthVec = QCPVector2D(1, 0);
  QCPVector2D widthVec = dir.normalized().perpendicular() * mWidth*0.5*(mInverted ? -1 : 1);
  
  QPen penBackup = painter->pen();
  QBrush brushBackup = painter->brush();
  QPen miterPen = penBackup;
  miterPen.setJoinStyle(Qt::MiterJoin); // to make arrow heads spikey
                                        // 화살촉을 spikey로 만든다.
  QBrush brush(painter->pen().color(), Qt::SolidPattern);
  switch (mStyle)
  {
    case esNone: break;
    case esFlatArrow:
    {
      QPointF points[3] = {pos.toPointF(),
                           (pos-lengthVec+widthVec).toPointF(),
                           (pos-lengthVec-widthVec).toPointF()
                          };
      painter->setPen(miterPen);
      painter->setBrush(brush);
      painter->drawConvexPolygon(points, 3);
      painter->setBrush(brushBackup);
      painter->setPen(penBackup);
      break;
    }
    case esSpikeArrow:
    {
      QPointF points[4] = {pos.toPointF(),
                           (pos-lengthVec+widthVec).toPointF(),
                           (pos-lengthVec*0.8).toPointF(),
                           (pos-lengthVec-widthVec).toPointF()
                          };
      painter->setPen(miterPen);
      painter->setBrush(brush);
      painter->drawConvexPolygon(points, 4);
      painter->setBrush(brushBackup);
      painter->setPen(penBackup);
      break;
    }
    case esLineArrow:
    {
      QPointF points[3] = {(pos-lengthVec+widthVec).toPointF(),
                           pos.toPointF(),
                           (pos-lengthVec-widthVec).toPointF()
                          };
      painter->setPen(miterPen);
      painter->drawPolyline(points, 3);
      painter->setPen(penBackup);
      break;
    }
    case esDisc:
    {
      painter->setBrush(brush);
      painter->drawEllipse(pos.toPointF(),  mWidth*0.5, mWidth*0.5);
      painter->setBrush(brushBackup);
      break;
    }
    case esSquare:
    {
      QCPVector2D widthVecPerp = widthVec.perpendicular();
      QPointF points[4] = {(pos-widthVecPerp+widthVec).toPointF(),
                           (pos-widthVecPerp-widthVec).toPointF(),
                           (pos+widthVecPerp-widthVec).toPointF(),
                           (pos+widthVecPerp+widthVec).toPointF()
                          };
      painter->setPen(miterPen);
      painter->setBrush(brush);
      painter->drawConvexPolygon(points, 4);
      painter->setBrush(brushBackup);
      painter->setPen(penBackup);
      break;
    }
    case esDiamond:
    {
      QCPVector2D widthVecPerp = widthVec.perpendicular();
      QPointF points[4] = {(pos-widthVecPerp).toPointF(),
                           (pos-widthVec).toPointF(),
                           (pos+widthVecPerp).toPointF(),
                           (pos+widthVec).toPointF()
                          };
      painter->setPen(miterPen);
      painter->setBrush(brush);
      painter->drawConvexPolygon(points, 4);
      painter->setBrush(brushBackup);
      painter->setPen(penBackup);
      break;
    }
    case esBar:
    {
      painter->drawLine((pos+widthVec).toPointF(), (pos-widthVec).toPointF());
      break;
    }
    case esHalfBar:
    {
      painter->drawLine((pos+widthVec).toPointF(), pos.toPointF());
      break;
    }
    case esSkewedBar:
    {
      if (qFuzzyIsNull(painter->pen().widthF()) && !painter->modes().testFlag(QCPPainter::pmNonCosmetic))
      {
        // if drawing with cosmetic pen (perfectly thin stroke, happens only in vector exports), draw bar exactly on tip of line
// 코스메틱 펜으로 그림을 그리는 경우 (완벽하게가는 선, 벡터 내보내기에서만 발생), 선의 끝 부분에 막대를 정확하게 그립니다
        painter->drawLine((pos+widthVec+lengthVec*0.2*(mInverted?-1:1)).toPointF(),
                          (pos-widthVec-lengthVec*0.2*(mInverted?-1:1)).toPointF());
      } else
      {
        // if drawing with thick (non-cosmetic) pen, shift bar a little in line direction to prevent line from sticking through bar slightly
// 두꺼운 (비 화장품) 펜을 사용하여 그림을 그릴 경우 라인이 바에서 약간 튀어 나오지 않도록 줄 바꿈을 조금씩 이동하십시오
        painter->drawLine((pos+widthVec+lengthVec*0.2*(mInverted?-1:1)+dir.normalized()*qMax(1.0f, (float)painter->pen().widthF())*0.5f).toPointF(),
                          (pos-widthVec-lengthVec*0.2*(mInverted?-1:1)+dir.normalized()*qMax(1.0f, (float)painter->pen().widthF())*0.5f).toPointF());
      }
      break;
    }
  }
}

/*! \internal
  \overload
  
  Draws the line ending. The direction is controlled with the \a angle parameter in radians.
*/
/*! \내부의
  \초과 적재
  
  줄 끝을 그립니다. 방향은 라디안 단위의 각도 매개 변수로 제어됩니다.
*/
void QCPLineEnding::draw(QCPPainter *painter, const QCPVector2D &pos, double angle) const
{
  draw(painter, pos, QCPVector2D(qCos(angle), qSin(angle)));
}
/* end of 'src/lineending.cpp' */


/* including file 'src/axis/axisticker.cpp', size 18664                      */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / lineending.cpp'의 끝 */


/* 'src / axis / axisticker.cpp'파일 포함, 크기 18664 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPAxisTicker
////////////////////////////////////////////////////////////////////////////////////////////////////
/*! \class QCPAxisTicker
  \brief The base class tick generator used by QCPAxis to create tick positions and tick labels
  
  Each QCPAxis has an internal QCPAxisTicker (or a subclass) in order to generate tick positions
  and tick labels for the current axis range. The ticker of an axis can be set via \ref
  QCPAxis::setTicker. Since that method takes a <tt>QSharedPointer<QCPAxisTicker></tt>, multiple
  axes can share the same ticker instance.
  
  This base class generates normal tick coordinates and numeric labels for linear axes. It picks a
  reasonable tick step (the separation between ticks) which results in readable tick labels. The
  number of ticks that should be approximately generated can be set via \ref setTickCount.
  Depending on the current tick step strategy (\ref setTickStepStrategy), the algorithm either
  sacrifices readability to better match the specified tick count (\ref
  QCPAxisTicker::tssMeetTickCount) or relaxes the tick count in favor of better tick steps (\ref
  QCPAxisTicker::tssReadability), which is the default.
  
  The following more specialized axis ticker subclasses are available, see details in the
  respective class documentation:
  
  <center>
  <table>
  <tr><td style="text-align:right; padding: 0 1em">QCPAxisTickerFixed</td><td>\image html axisticker-fixed.png</td></tr>
  <tr><td style="text-align:right; padding: 0 1em">QCPAxisTickerLog</td><td>\image html axisticker-log.png</td></tr>
  <tr><td style="text-align:right; padding: 0 1em">QCPAxisTickerPi</td><td>\image html axisticker-pi.png</td></tr>
  <tr><td style="text-align:right; padding: 0 1em">QCPAxisTickerText</td><td>\image html axisticker-text.png</td></tr>
  <tr><td style="text-align:right; padding: 0 1em">QCPAxisTickerDateTime</td><td>\image html axisticker-datetime.png</td></tr>
  <tr><td style="text-align:right; padding: 0 1em">QCPAxisTickerTime</td><td>\image html axisticker-time.png
    \image html axisticker-time2.png</td></tr>
  </table>
  </center>
  
  \section axisticker-subclassing Creating own axis tickers
  
  Creating own axis tickers can be achieved very easily by sublassing QCPAxisTicker and
  reimplementing some or all of the available virtual methods.

  In the simplest case you might wish to just generate different tick steps than the other tickers,
  so you only reimplement the method \ref getTickStep. If you additionally want control over the
  string that will be shown as tick label, reimplement \ref getTickLabel.
  
  If you wish to have complete control, you can generate the tick vectors and tick label vectors
  yourself by reimplementing \ref createTickVector and \ref createLabelVector. The default
  implementations use the previously mentioned virtual methods \ref getTickStep and \ref
  getTickLabel, but your reimplementations don't necessarily need to do so. For example in the case
  of unequal tick steps, the method \ref getTickStep loses its usefulness and can be ignored.
  
  The sub tick count between major ticks can be controlled with \ref getSubTickCount. Full sub tick
  placement control is obtained by reimplementing \ref createSubTickVector.
  
  See the documentation of all these virtual methods in QCPAxisTicker for detailed information
  about the parameters and expected return values.
*/
/*! \ class QCPAxisTicker
  \ brief QCPAxis가 틱 위치와 틱 레이블을 작성하는 데 사용하는 기본 클래스 틱 생성기
  
  각 QCPAxis에는 틱 위치를 생성하기위한 내부 QCPAxisTicker (또는 서브 클래스)가 있습니다.
  현재 축 범위에 대한 눈금 레이블. 축의 티커는 \ ref를 통해 설정할 수 있습니다.
  QCPAxis :: setTicker. 이 메소드는 <tt> QSharedPointer <QCPAxisTicker> </ tt>를 취하기 때문에,
  축은 동일한 티커 인스턴스를 공유 할 수 있습니다.
  
  이 기본 클래스는 일반 눈금 좌표 및 선형 축의 숫자 레이블을 생성합니다. 그것은
  합리적인 틱 단계 (틱 사이의 분리)는 읽을 수있는 틱 레이블을 만듭니다. 그만큼
  대략 생성되어야하는 틱의 수는 \ ref setTickCount를 통해 설정 될 수 있습니다.
  현재 틱 스텝 전략 (\ ref setTickStepStrategy)에 따라 알고리즘은
  지정된 틱 수와 더 잘 일치하도록 가독성을 희생합니다 (\ ref
  QCPAxisTicker :: tssMeetTickCount) 또는 더 나은 틱 단계를 위해 틱 수를 완화합니다 (\ ref
  QCPAxisTicker :: tssReadability)가 기본값입니다.
  
  다음과 같은보다 전문화 된 축 티커 하위 클래스를 사용할 수 있습니다.
  각 클래스 문서 :
  
  <center>
  <table>
  <td style = "text-align : right; 패딩 : 0 1em"> QCPAxisTickerFixed </ td> <td> \ image html axisticker-fixed.png </ td> </ tr>
  <td style = "text-align : right; 패딩 : 0 1em"> QCPAxisTickerLog </ td> \ image html axisticker-log.png </ td> </ tr>
  <td style = "text-align : right; 패딩 : 0 1em"> QCPAxisTickerPi </ td> \ image html axisticker-pi.png </ td> </ tr>
  <td style = "text-align : right; 패딩 : 0 1em"> QCPAxisTickerText </ td> \ image html axisticker-text.png </ td> </ tr>
  <td style = "text-align : right; 패딩 : 0 1em"> QCPAxisTickerDateTime </ td> <td> \ image html axisticker-datetime.png </ td> </ tr>
  <tr> <td style = "text-align : right; 패딩 : 0 1em"> QCPAxisTickerTime </ td> <td> \ image html axisticker-time.png
    \ image html axisticker-time2.png </ td> </ tr>
  </ table>
  </ center>
  
  \ section axisticker-subclassing 자체 축 시세표 만들기
  
  QCPAxisTicker를 서브 래이함으로써 자신의 축 티커를 쉽게 생성 할 수 있습니다.
  사용 가능한 가상 메소드의 일부 또는 전부를 다시 구현합니다.

  가장 단순한 경우에는 다른 시세 표시기와는 다른 진드기 단계를 생성하는 것이 좋습니다.
  그래서 당신은 \ ref getTickStep 메소드 만 재 구현한다. 추가로
  문자열을 틱 레이블로 표시하고 \ ref getTickLabel을 다시 구현하십시오.
  
  완전한 제어권을 원할 경우, 틱 벡터와 틱 레이블 벡터를 생성 할 수 있습니다
  \ ref createTickVector 및 \ ref createLabelVector를 다시 구현하여 자신을 만듭니다. 기본값은
  구현은 위에서 언급 한 가상 메소드를 사용합니다. \ ref getTickStep과 \ ref
  getTickLabel,하지만 당신의 reimplementations 반드시 그렇게 할 필요가 없습니다. 예를 들어
  동일하지 않은 틱 단계의 경우 \ ref getTickStep 메서드는 유용성을 잃어 버리고 무시할 수 있습니다.
  
  주요 틱 간의 하위 틱 수는 \ ref getSubTickCount로 제어 할 수 있습니다. 전체 하위 틱
  배치 제어는 \ ref createSubTickVector를 다시 구현하여 얻을 수 있습니다.
  
  자세한 정보는 QCPAxisTicker의 모든 가상 메소드 문서를 참조하십시오.
  매개 변수 및 예상되는 반환 값에 대해 설명합니다.
*/

/*!
  Constructs the ticker and sets reasonable default values. Axis tickers are commonly created
  managed by a QSharedPointer, which then can be passed to QCPAxis::setTicker.
*/
/*!
  티커를 구축해, 적절한 기본값을 설정합니다. 축 시세는 일반적으로 만들어집니다
  QSharedPointer에 의해 관리되며, QSharedPointer는 QCPAxis :: setTicker로 전달 될 수 있습니다.
*/
QCPAxisTicker::QCPAxisTicker() :
  mTickStepStrategy(tssReadability),
  mTickCount(5),
  mTickOrigin(0)
{
}

QCPAxisTicker::~QCPAxisTicker()
{
  
}

/*!
  Sets which strategy the axis ticker follows when choosing the size of the tick step. For the
  available strategies, see \ref TickStepStrategy.
*/
 /*!
  틱 단계의 크기를 선택할 때 축 티커가 따르는 전략을 설정합니다. 그
  사용 가능한 전략은 \ ref TickStepStrategy를 참조하십시오.
*/
void QCPAxisTicker::setTickStepStrategy(QCPAxisTicker::TickStepStrategy strategy)
{
  mTickStepStrategy = strategy;
}

/*!
  Sets how many ticks this ticker shall aim to generate across the axis range. Note that \a count
  is not guaranteed to be matched exactly, as generating readable tick intervals may conflict with
  the requested number of ticks.

  Whether the readability has priority over meeting the requested \a count can be specified with
  \ref setTickStepStrategy.
*/
/*!
  이 티커가 축 범위를 개입시켜 생성하는 것을 목표로하는 틱의 수를 설정합니다. \ a 개수에주의하십시오.
  읽을 수있는 눈금 간격을 생성 하는 것이
  요구 된 틱의 수.

  가독성이 요청 된 회의 수보다 우선 순위를 가졌는지 여부는 다음과 같이 지정할 수 있습니다.
  \ ref setTickStepStrategy.
*/
void QCPAxisTicker::setTickCount(int count)
{
  if (count > 0)
    mTickCount = count;
  else
    qDebug() << Q_FUNC_INFO << "tick count must be greater than zero:" << count;
}

/*!
  Sets the mathematical coordinate (or "offset") of the zeroth tick. This tick coordinate is just a
  concept and doesn't need to be inside the currently visible axis range.
  
  By default \a origin is zero, which for example yields ticks {-5, 0, 5, 10, 15,...} when the tick
  step is five. If \a origin is now set to 1 instead, the correspondingly generated ticks would be
  {-4, 1, 6, 11, 16,...}.
*/
/*!
  0 번째 눈금의 수학 좌표 (또는 "오프셋")를 설정합니다. 이 틱 좌표는
  개념이며 현재 보이는 축 범위 안에있을 필요는 없습니다.
  
  기본적으로 \ 원점은 0입니다. 예를 들어 틱이 {-5, 0, 5, 10, 15, ...}
  단계는 5입니다. 원점이 이제 1로 설정되면, 그에 따라 생성 된 틱은
  {-4, 1, 6, 11, 16, ...}.
*/
void QCPAxisTicker::setTickOrigin(double origin)
{
  mTickOrigin = origin;
}

/*!
  This is the method called by QCPAxis in order to actually generate tick coordinates (\a ticks),
  tick label strings (\a tickLabels) and sub tick coordinates (\a subTicks).
  
  The ticks are generated for the specified \a range. The generated labels typically follow the
  specified \a locale, \a formatChar and number \a precision, however this might be different (or
  even irrelevant) for certain QCPAxisTicker subclasses.
  
  The output parameter \a ticks is filled with the generated tick positions in axis coordinates.
  The output parameters \a subTicks and \a tickLabels are optional (set them to 0 if not needed)
  and are respectively filled with sub tick coordinates, and tick label strings belonging to \a
  ticks by index.
*/
/*!
  실제로 틱 좌표 (틱)를 생성하기 위해 QCPAxis에 의해 호출되는 메소드입니다.
  눈금 레이블 문자열 (\ a tickLabels) 및 하위 눈금 좌표 (\ a subTicks).
  
  틱은 지정된 \ a 범위에 대해 생성됩니다. 생성 된 레이블은 일반적으로
  \ a 로케일, formatChar, number \ a의 정밀도를 지정할 수 있습니다 만, 이것은 다른 경우가 있습니다 (또는
  심지어 무의미한) 특정 QCPAxisTicker 하위 클래스.
  
  출력 매개 변수 인 tick은 축 좌표에서 생성 된 tick 위치로 채워집니다.
  출력 매개 변수 \ a subTicks 및 \ a tickLabels는 선택 사항입니다 (필요하지 않으면 0으로 설정).
  서브 틱 좌표로 각각 채워지고, \ a에 속하는 틱 레이블 문자열
  색인별로 틱.
*/
void QCPAxisTicker::generate(const QCPRange &range, const QLocale &locale, QChar formatChar, int precision, QVector<double> &ticks, QVector<double> *subTicks, QVector<QString> *tickLabels)
{
  // generate (major) ticks:
  // (주) 진드기를 생성합니다.
  double tickStep = getTickStep(range);
  ticks = createTickVector(tickStep, range);
  trimTicks(range, ticks, true);
// trim ticks to visible range plus one outer tick on each side (incase a subclass createTickVector creates more)
// 눈금을 표시된 범위에 더한 다음 각면에 하나씩 바깥 쪽 눈금을 매 깁니다 (createTickVector create more)
  
  // generate sub ticks between major ticks:
  // 주요 틱 사이에 하위 틱을 생성합니다.
  if (subTicks)
  {
    if (ticks.size() > 0)
    {
      *subTicks = createSubTickVector(getSubTickCount(tickStep), ticks);
      trimTicks(range, *subTicks, false);
    } else
      *subTicks = QVector<double>();
  }
  
  // finally trim also outliers (no further clipping happens in axis drawing):
  // 마지막으로 아웃 라이어를 다듬습니다 (축 드로잉에서 클리핑이 더 이상 발생하지 않음).
  trimTicks(range, ticks, false);
  // generate labels for visible ticks if requested:
  // 요청 된 경우 표시되는 틱에 대한 레이블을 생성합니다.
  if (tickLabels)
    *tickLabels = createLabelVector(ticks, locale, formatChar, precision);
}

/*! \internal
  
  Takes the entire currently visible axis range and returns a sensible tick step in
  order to provide readable tick labels as well as a reasonable number of tick counts (see \ref
  setTickCount, \ref setTickStepStrategy).
  
  If a QCPAxisTicker subclass only wants a different tick step behaviour than the default
  implementation, it should reimplement this method. See \ref cleanMantissa for a possible helper
  function.
*/
/*! \내부의
  
  현재 보이는 축 범위 전체를 가져 와서 눈에 띄는 틱 단계를 반환합니다.
  읽을 수있는 틱 레이블과 합리적인 수의 틱 수를 제공하기 위해서 (\ ref
  setTickCount, \ ref setTickStepStrategy).
  
  QCPAxisTicker 서브 클래스가 디폴트와 다른 틱 스텝 동작만을 원하면
  구현시이 메서드를 다시 구현해야합니다. 가능한 도우미를 보려면 \ ref cleanMantissa를 참조하십시오.
  기능.
*/
double QCPAxisTicker::getTickStep(const QCPRange &range)
{
  double exactStep = range.size()/(double)(mTickCount+1e-10);
 // mTickCount ticks on average, the small addition is to prevent jitter on exact integers
 // 평균 mTickCount 틱, 작은 추가는 정확한 정수에서 지터를 방지하는 것입니다.
  return cleanMantissa(exactStep);
}

/*! \internal
  
  Takes the \a tickStep, i.e. the distance between two consecutive ticks, and returns
  an appropriate number of sub ticks for that specific tick step.
  
  Note that a returned sub tick count of e.g. 4 will split each tick interval into 5 sections.
*/
/*! \내부의
  
  틱 스텝을 취합니다. 즉, 두 개의 연속적인 틱 사이의 거리를 반환합니다.
  해당 틱 단계에 대한 적절한 하위 틱 수입니다.
  
  예를 들어 4의 반환 된 하위 틱 계수는 각 눈금 간격을 5 개의 섹션으로 나눕니다.
*/
int QCPAxisTicker::getSubTickCount(double tickStep)
{
  int result = 1; // default to 1, if no proper value can be found
                  // 적절한 값을 찾을 수없는 경우 기본값은 1입니다.
  
  // separate integer and fractional part of mantissa:
  // 가수의 정수 부분과 분수 부분을 분리합니다.
  double epsilon = 0.01;
  double intPartf;
  int intPart;
  double fracPart = modf(getMantissa(tickStep), &intPartf);
  intPart = intPartf;
  
  // handle cases with (almost) integer mantissa:
  // (거의) 정수 가수를 가지는 케이스를 처리한다 :
  if (fracPart < epsilon || 1.0-fracPart < epsilon)
  {
    if (1.0-fracPart < epsilon)
      ++intPart;
    switch (intPart)
    {
      case 1: result = 4; break; // 1.0 -> 0.2 substep
      case 2: result = 3; break; // 2.0 -> 0.5 substep
      case 3: result = 2; break; // 3.0 -> 1.0 substep
      case 4: result = 3; break; // 4.0 -> 1.0 substep
      case 5: result = 4; break; // 5.0 -> 1.0 substep
      case 6: result = 2; break; // 6.0 -> 2.0 substep
      case 7: result = 6; break; // 7.0 -> 1.0 substep
      case 8: result = 3; break; // 8.0 -> 2.0 substep
      case 9: result = 2; break; // 9.0 -> 3.0 substep
    }
  } else
  {
    // handle cases with significantly fractional mantissa:
    if (qAbs(fracPart-0.5) < epsilon) // *.5 mantissa
    {
      switch (intPart)
      {
        case 1: result = 2; break; // 1.5 -> 0.5 substep
        case 2: result = 4; break; // 2.5 -> 0.5 substep
        case 3: result = 4; break; // 3.5 -> 0.7 substep
        case 4: result = 2; break; // 4.5 -> 1.5 substep
        case 5: result = 4; break; // 5.5 -> 1.1 substep (won't occur with default getTickStep from here on)
        case 6: result = 4; break; // 6.5 -> 1.3 substep  (여기에서 기본 getTickStep이 발생하지 않음)
        case 7: result = 2; break; // 7.5 -> 2.5 substep
        case 8: result = 4; break; // 8.5 -> 1.7 substep
        case 9: result = 4; break; // 9.5 -> 1.9 substep
      }
    }
    // if mantissa fraction isn't 0.0 or 0.5, don't bother finding good sub tick marks, leave default
    // 가수가 0.0 또는 0.5가 아닌 경우, 좋은 하위 눈금을 찾는 것을 괴롭히지 말고, 기본값을 그대로 두십시오.
  }
  
  return result;
}

/*! \internal
  
  This method returns the tick label string as it should be printed under the \a tick coordinate.
  If a textual number is returned, it should respect the provided \a locale, \a formatChar and \a
  precision.
  
  If the returned value contains exponentials of the form "2e5" and beautifully typeset powers is
  enabled in the QCPAxis number format (\ref QCPAxis::setNumberFormat), the exponential part will
  be formatted accordingly using multiplication symbol and superscript during rendering of the
  label automatically.
*/
/*! \내부의
  
  이 메소드는, 눈금의 좌표에 따라, 눈금의 label 캐릭터 라인을 돌려줍니다.
  문자 번호가 반환되면 제공된 \ a 로캘, \ a formatChar 및 \ a를 준수해야합니다.
  정도.
  
  반환 된 값에 "2e5"형식의 지수가 포함되어 있고 아름답게 조판 세트의 힘이있는 경우
  QCPAxis 숫자 형식 (\ ref QCPAxis :: setNumberFormat)으로 활성화 된 경우 지수 부분은
  따라서 렌더링시 증분 기호와 위 첨자를 사용하여 서식을 지정해야합니다.
  자동으로 레이블.
*/
QString QCPAxisTicker::getTickLabel(double tick, const QLocale &locale, QChar formatChar, int precision)
{
  return locale.toString(tick, formatChar.toLatin1(), precision);
}

/*! \internal
  
  Returns a vector containing all coordinates of sub ticks that should be drawn. It generates \a
  subTickCount sub ticks between each tick pair given in \a ticks.
  
  If a QCPAxisTicker subclass needs maximal control over the generated sub ticks, it should
  reimplement this method. Depending on the purpose of the subclass it doesn't necessarily need to
  base its result on \a subTickCount or \a ticks.
*/
/*! \내부의
  
  draw되는 서브 틱의 좌표를 모두 포함한 벡터를 리턴합니다. \ a를 생성합니다.
  subTickCount는, 틱 단위로 지정된 각 틱 쌍의 하위 틱입니다.
  
  QCPAxisTicker 하위 클래스가 생성 된 하위 틱에 대해 최대한의 제어가 필요한 경우
  이 메소드를 다시 구현하십시오. 서브 클래스의 목적에 따라서 반드시 필요한 것은 아닙니다.
  그 결과를 \ a subTickCount 또는 \ a 틱에 기초합니다.
*/
QVector<double> QCPAxisTicker::createSubTickVector(int subTickCount, const QVector<double> &ticks)
{
  QVector<double> result;
  if (subTickCount <= 0 || ticks.size() < 2)
    return result;
  
  result.reserve((ticks.size()-1)*subTickCount);
  for (int i=1; i<ticks.size(); ++i)
  {
    double subTickStep = (ticks.at(i)-ticks.at(i-1))/(double)(subTickCount+1);
    for (int k=1; k<=subTickCount; ++k)
      result.append(ticks.at(i-1) + k*subTickStep);
  }
  return result;
}

/*! \internal
  
  Returns a vector containing all coordinates of ticks that should be drawn. The default
  implementation generates ticks with a spacing of \a tickStep (mathematically starting at the tick
  step origin, see \ref setTickOrigin) distributed over the passed \a range.
  
  In order for the axis ticker to generate proper sub ticks, it is necessary that the first and
  last tick coordinates returned by this method are just below/above the provided \a range.
  Otherwise the outer intervals won't contain any sub ticks.
  
  If a QCPAxisTicker subclass needs maximal control over the generated ticks, it should reimplement
  this method. Depending on the purpose of the subclass it doesn't necessarily need to base its
  result on \a tickStep, e.g. when the ticks are spaced unequally like in the case of
  QCPAxisTickerLog.
*/
/*! \내부의
  
  draw되는 틱의 좌표를 모두 포함한 벡터를 리턴합니다. 기본값은
  구현은 틱 스텝 간격을 가진 틱을 생성합니다 (틱에서 수학적으로 시작합니다).
  스텝 원점, \ ref setTickOrigin 참조).
  
  축 티커가 적절한 하위 틱을 생성하려면 첫 번째 및
  이 메소드로 반환 된 마지막 틱 좌표는 제공된 \ a 범위 바로 아래 / 위에 있습니다.
  그렇지 않으면 외부 구간에 하위 틱이 포함되지 않습니다.
  
  QCPAxisTicker 서브 클래스가 생성 된 틱에 대해 최대의 제어를 필요로하는 경우, 재 구현해야합니다
  이 방법. 서브 클래스의 목적에 따라서, 서브 클래스의 기본으로 할 필요는 없습니다.
  tickstep의 결과, 예를 들어 틱의 간격이 같지 않은 경우
  QCPAxisTickerLog.
*/
QVector<double> QCPAxisTicker::createTickVector(double tickStep, const QCPRange &range)
{
  QVector<double> result;
  // Generate tick positions according to tickStep:
  // tickStep에 따라 틱 위치를 생성합니다.
  qint64 firstStep = floor((range.lower-mTickOrigin)/tickStep);
  // do not use qFloor here, or we'll lose 64 bit precision
  // 여기서 qFloor를 사용하지 마십시오. 그렇지 않으면 64 비트 정밀도가 손실됩니다.
  qint64 lastStep = ceil((range.upper-mTickOrigin)/tickStep);
  // do not use qCeil here, or we'll lose 64 bit precision
  // 여기서 qCeil을 사용하지 마십시오. 그렇지 않으면 64 비트 정밀도가 손실됩니다.
  int tickcount = lastStep-firstStep+1;
  if (tickcount < 0) tickcount = 0;
  result.resize(tickcount);
  for (int i=0; i<tickcount; ++i)
    result[i] = mTickOrigin + (firstStep+i)*tickStep;
  return result;
}

/*! \internal
  
  Returns a vector containing all tick label strings corresponding to the tick coordinates provided
  in \a ticks. The default implementation calls \ref getTickLabel to generate the respective
  strings.
  
  It is possible but uncommon for QCPAxisTicker subclasses to reimplement this method, as
  reimplementing \ref getTickLabel often achieves the intended result easier.
*/
/*! \내부의
  
  제공된 틱 좌표에 해당하는 모든 틱 레이블 문자열을 포함하는 벡터를 반환합니다.
  \ 틱. 기본 구현에서는 \ ref getTickLabel을 호출하여 각각의
  문자열.
  
  QCPAxisTicker 서브 클래스가이 메소드를 다시 구현하는 것은 드문 일이지만
  reimplementing \ ref getTickLabel은 종종 의도 한 결과를 더 쉽게 얻는다.
*/
QVector<QString> QCPAxisTicker::createLabelVector(const QVector<double> &ticks, const QLocale &locale, QChar formatChar, int precision)
{
  QVector<QString> result;
  result.reserve(ticks.size());
  for (int i=0; i<ticks.size(); ++i)
    result.append(getTickLabel(ticks.at(i), locale, formatChar, precision));
  return result;
}

/*! \internal
  
  Removes tick coordinates from \a ticks which lie outside the specified \a range. If \a
  keepOneOutlier is true, it preserves one tick just outside the range on both sides, if present.
  
  The passed \a ticks must be sorted in ascending order.
*/
/*! \내부의
  
  지정된 \ a 범위 밖에있는 틱에서 틱 좌표를 제거합니다. 만약
  keepOneOutlier가 true 인 경우 양쪽 범위의 바깥쪽에 하나의 진드기가 있으면 그대로 유지합니다 (있는 경우).
  
  전달 된 틱은 오름차순으로 정렬되어야합니다.
*/
void QCPAxisTicker::trimTicks(const QCPRange &range, QVector<double> &ticks, bool keepOneOutlier) const
{
  bool lowFound = false;
  bool highFound = false;
  int lowIndex = 0;
  int highIndex = -1;
  
  for (int i=0; i < ticks.size(); ++i)
  {
    if (ticks.at(i) >= range.lower)
    {
      lowFound = true;
      lowIndex = i;
      break;
    }
  }
  for (int i=ticks.size()-1; i >= 0; --i)
  {
    if (ticks.at(i) <= range.upper)
    {
      highFound = true;
      highIndex = i;
      break;
    }
  }
  
  if (highFound && lowFound)
  {
    int trimFront = qMax(0, lowIndex-(keepOneOutlier ? 1 : 0));
    int trimBack = qMax(0, ticks.size()-(keepOneOutlier ? 2 : 1)-highIndex);
    if (trimFront > 0 || trimBack > 0)
      ticks = ticks.mid(trimFront, ticks.size()-trimFront-trimBack);
  } else // all ticks are either all below or all above the range
         // 모든 틱은 범위 아래 또는 모두 위에 있습니다.
    ticks.clear();
}

/*! \internal
  
  Returns the coordinate contained in \a candidates which is closest to the provided \a target.
  
  This method assumes \a candidates is not empty and sorted in ascending order.
*/
/*! \내부의
  
  제공된 \ a 대상에 가장 가까운 후보에 포함 된 좌표를 반환합니다.
  
  이 방법은 후보가 비어 있지 않고 오름차순으로 정렬되어 있다고 가정합니다.
*/
double QCPAxisTicker::pickClosest(double target, const QVector<double> &candidates) const
{
  if (candidates.size() == 1)
    return candidates.first();
  QVector<double>::const_iterator it = std::lower_bound(candidates.constBegin(), candidates.constEnd(), target);
  if (it == candidates.constEnd())
    return *(it-1);
  else if (it == candidates.constBegin())
    return *it;
  else
    return target-*(it-1) < *it-target ? *(it-1) : *it;
}

/*! \internal
  
  Returns the decimal mantissa of \a input. Optionally, if \a magnitude is not set to zero, it also
  returns the magnitude of \a input as a power of 10.
  
  For example, an input of 142.6 will return a mantissa of 1.426 and a magnitude of 100.
*/
/*! \내부의
  
  \ a 입력의 소수 가수를 반환합니다. 선택적으로, 크기가 0으로 설정되지 않은 경우
  \ a 입력의 크기를 10의 거듭 제곱으로 반환합니다.
  
  예를 들어, 142.6의 입력은 1.426의 가수와 100의 크기를 반환합니다.
*/
double QCPAxisTicker::getMantissa(double input, double *magnitude) const
{
  const double mag = qPow(10.0, qFloor(qLn(input)/qLn(10.0)));
  if (magnitude) *magnitude = mag;
  return input/mag;
}

/*! \internal
  
  Returns a number that is close to \a input but has a clean, easier human readable mantissa. How
  strongly the mantissa is altered, and thus how strong the result deviates from the original \a
  input, depends on the current tick step strategy (see \ref setTickStepStrategy).
*/
/*! \내부의
  
  \ a 입력에 가깝지만 사람이 읽을 수있는 깨끗하고 읽기 쉬운 가수가있는 숫자를 반환합니다. 방법
  강하게 가수가 변경되고 결과가 원래의 \ a에서 얼마나 빗나가게되는지
  입력은 현재 틱 스텝 전략 (\ ref setTickStepStrategy 참조)에 따라 다릅니다.
*/
double QCPAxisTicker::cleanMantissa(double input) const
{
  double magnitude;
  const double mantissa = getMantissa(input, &magnitude);
  switch (mTickStepStrategy)
  {
    case tssReadability:
    {
      return pickClosest(mantissa, QVector<double>() << 1.0 << 2.0 << 2.5 << 5.0 << 10.0)*magnitude;
    }
    case tssMeetTickCount:
    {
      // this gives effectively a mantissa of 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 6.0, 8.0, 10.0
      // 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 6.0, 8.0, 10.0의 가수를 효과적으로 준다.
      if (mantissa <= 5.0)
        return (int)(mantissa*2)/2.0*magnitude; // round digit after decimal point to 0.5
                                                // 소수점 이하의 자릿수를 0.5로 반올림합니다.
      else
        return (int)(mantissa/2.0)*2.0*magnitude; // round to first digit in multiples of 2
                                                  // 2의 배수로 첫 번째 숫자로 반올림합니다.
    }
  }
  return input;
}
/* end of 'src/axis/axisticker.cpp' */


/* including file 'src/axis/axistickerdatetime.cpp', size 14443              */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / axis / axisticker.cpp'의 끝 */


/* 파일 'src / axis / axistickerdatetime.cpp', 크기 14443 포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPAxisTickerDateTime
////////////////////////////////////////////////////////////////////////////////////////////////////
/*! \class QCPAxisTickerDateTime
  \brief Specialized axis ticker for calendar dates and times as axis ticks
  
  \image html axisticker-datetime.png
  
  This QCPAxisTicker subclass generates ticks that correspond to real calendar dates and times. The
  plot axis coordinate is interpreted as Unix Time, so seconds since Epoch (January 1, 1970, 00:00
  UTC). This is also used for example by QDateTime in the <tt>toTime_t()/setTime_t()</tt> methods
  with a precision of one second. Since Qt 4.7, millisecond accuracy can be obtained from QDateTime
  by using <tt>QDateTime::fromMSecsSinceEpoch()/1000.0</tt>. The static methods \ref dateTimeToKey
  and \ref keyToDateTime conveniently perform this conversion achieving a precision of one
  millisecond on all Qt versions.
  
  The format of the date/time display in the tick labels is controlled with \ref setDateTimeFormat.
  If a different time spec (time zone) shall be used, see \ref setDateTimeSpec.
  
  This ticker produces unequal tick spacing in order to provide intuitive date and time-of-day
  ticks. For example, if the axis range spans a few years such that there is one tick per year,
  ticks will be positioned on 1. January of every year. This is intuitive but, due to leap years,
  will result in slightly unequal tick intervals (visually unnoticeable). The same can be seen in
  the image above: even though the number of days varies month by month, this ticker generates
  ticks on the same day of each month.
  
  If you would like to change the date/time that is used as a (mathematical) starting date for the
  ticks, use the \ref setTickOrigin(const QDateTime &origin) method overload, which takes a
  QDateTime. If you pass 15. July, 9:45 to this method, the yearly ticks will end up on 15. July at
  9:45 of every year.
  
  The ticker can be created and assigned to an axis like this:
  \snippet documentation/doc-image-generator/mainwindow.cpp axistickerdatetime-creation
  
  \note If you rather wish to display relative times in terms of days, hours, minutes, seconds and
  milliseconds, and are not interested in the intricacies of real calendar dates with months and
  (leap) years, have a look at QCPAxisTickerTime instead.
*/
/*! \ class QCPAxisTickerDateTime
  \ brief 달력의 날짜와 시간을 축 틱으로 전문화 한 축 티커
  
  \ image html axisticker-datetime.png
  
  이 QCPAxisTicker 서브 클래스는 실제 달력 날짜와 시간에 해당하는 틱을 생성합니다. 그만큼
  플롯 축 좌표는 Unix 시간으로 해석되므로 Epoch 이후의 초 (1970 년 1 월 1 일 00:00
  UTC). 이것은 또한 <tt> toTime_t () / setTime_t () </ tt> 메소드의 QDateTime에 의해 사용됩니다
  1 초의 정밀도. Qt 4.7부터 QDateTime에서 밀리 초의 정확도를 얻을 수 있습니다.
  <tt> QDateTime :: fromMSecsSinceEpoch () / 1000.0 </ tt>을 사용하면됩니다. 정적 메서드 \ ref dateTimeToKey
  \ ref keyToDateTime은이 변환을 편리하게 수행하여 하나의 정밀도를 얻습니다.
  모든 Qt 버전에서 밀리 초.
  
  틱 레이블의 날짜 / 시간 표시 형식은 \ ref setDateTimeFormat로 제어됩니다.
  다른 시간 스펙 (시간대)이 사용되면 \ ref setDateTimeSpec을 참조하십시오.
  
  이 시세 표시기는 직관적 인 날짜와 시간을 제공하기 위해 똑같은 눈금 간격을 만듭니다.
  틱. 예를 들어 축 범위가 몇 년에 걸쳐 1 년에 1 회의 틱이있는 경우,
  진드기는 매년 1 월 1 일에 배치됩니다. 이것은 직관적이지만, 윤년으로 인해,
  약간 불균등 한 눈금 간격 (시각적으로 눈에 띄지 않음)이 발생합니다. 에서 볼 수있다.
  위의 이미지 : 매월 날짜가 다르지만이 시세 표시로 인해
  매달 같은 날에 똑딱 거린다.
  
  (수학적) 시작 날짜로 사용되는 날짜 / 시간을 변경하려면
  진드기는 \ ref setTickOrigin (const QDateTime & origin) 메소드 오버로드를 사용합니다.
  QDateTime. 이 방법에 7 월 15 일, 9시 45 분을 통과하면 연간 틱은 15 일에 끝납니다.
  매년 9시 45 분.
  
  티커는 다음과 같이 축에 생성되고 지정 될 수 있습니다 :
  \ snippet documentation / doc-image-generator / mainwindow.cpp axistickerdatetime-creation
  
  \ note 상대 시간을 일, 시간, 분, 초 및 시간 단위로 표시하려는 경우
  밀리 세컨드이며 실제 달력 날짜의 복잡한 점에 대해서는 관심이 없습니다.
  (도약) 년 대신 QCPAxisTickerTime을 살펴보십시오.
*/

/*!
  Constructs the ticker and sets reasonable default values. Axis tickers are commonly created
  managed by a QSharedPointer, which then can be passed to QCPAxis::setTicker.
*/
/*!
  티커를 구축해, 적절한 기본값을 설정합니다. 축 시세는 일반적으로 만들어집니다
  QSharedPointer에 의해 관리되며, QSharedPointer는 QCPAxis :: setTicker로 전달 될 수 있습니다.
*/
QCPAxisTickerDateTime::QCPAxisTickerDateTime() :
  mDateTimeFormat(QLatin1String("hh:mm:ss\ndd.MM.yy")),
  mDateTimeSpec(Qt::LocalTime),
  mDateStrategy(dsNone)
{
  setTickCount(4);
}

/*!
  Sets the format in which dates and times are displayed as tick labels. For details about the \a
  format string, see the documentation of QDateTime::toString().
  
  Newlines can be inserted with "\n".
  
  \see setDateTimeSpec
*/
/*!
  날짜와 시간이 눈금 레이블로 표시되는 형식을 설정합니다. \ a에 대한 자세한 내용은
  형식 문자열에 대해서는 QDateTime :: toString ()의 설명서를 참조하십시오.
  
  개행 문자는 "\ n"과 함께 삽입 할 수 있습니다.
  
  \ setDateTimeSpec 참조
*/
void QCPAxisTickerDateTime::setDateTimeFormat(const QString &format)
{
  mDateTimeFormat = format;
}

/*!
  Sets the time spec that is used for creating the tick labels from corresponding dates/times.

  The default value of QDateTime objects (and also QCPAxisTickerDateTime) is
  <tt>Qt::LocalTime</tt>. However, if the date time values passed to QCustomPlot (e.g. in the form
  of axis ranges or keys of a plottable) are given in the UTC spec, set \a spec to <tt>Qt::UTC</tt>
  to get the correct axis labels.
  
  \see setDateTimeFormat
*/
/*!
  해당 날짜 / 시간에서 눈금 레이블을 만드는 데 사용되는 시간 사양을 설정합니다.

  QDateTime 개체의 기본값 (및 QCPAxisTickerDateTime)은 다음과 같습니다.
  <tt> Qt :: LocalTime </ tt>. 그러나 QCustomPlot에 날짜 시간 값이 전달 된 경우 (예 :
  축 범위 또는 플롯 테이블의 키)가 UTC 사양에 주어지면 \ spec을 <tt> Qt :: UTC </ tt>로 설정하십시오.
  올바른 축 레이블을 가져옵니다.
  
  \ setDateTimeFormat 참조
*/
void QCPAxisTickerDateTime::setDateTimeSpec(Qt::TimeSpec spec)
{
  mDateTimeSpec = spec;
}

/*!
  Sets the tick origin (see \ref QCPAxisTicker::setTickOrigin) in seconds since Epoch (1. Jan 1970,
  00:00 UTC). For the date time ticker it might be more intuitive to use the overload which
  directly takes a QDateTime, see \ref setTickOrigin(const QDateTime &origin).
  
  This is useful to define the month/day/time recurring at greater tick interval steps. For
  example, If you pass 15. July, 9:45 to this method and the tick interval happens to be one tick
  per year, the ticks will end up on 15. July at 9:45 of every year.
*/
/*!
  Epoch 이후 초 단위로 틱 기점을 설정합니다 (\ ref QCPAxisTicker :: setTickOrigin 참조). (1970 년 1 월 1 일,
  00:00 UTC). 날짜 시간 표시기의 경우에는 과부하를 사용하는 것이 더 직관적 일 수 있습니다.
  직접적으로 QDateTime을 취합니다. \ ref setTickOrigin (const QDateTime & origin)을 참조하십시오.
  
  이는 더 큰 눈금 간격 단계에서 반복되는 월 / 일 / 시간을 정의하는 데 유용합니다. 에 대한
  예를 들어,이 메소드에 7 월 15 일, 9시 45 분을 전달하고 틱 간격이 1 틱일 경우
  1 년마다, 진드기는 15 일에 끝날 것입니다. 매년 7 월 45 일에 7:45.
*/
void QCPAxisTickerDateTime::setTickOrigin(double origin)
{
  QCPAxisTicker::setTickOrigin(origin);
}

/*!
  Sets the tick origin (see \ref QCPAxisTicker::setTickOrigin) as a QDateTime \a origin.
  
  This is useful to define the month/day/time recurring at greater tick interval steps. For
  example, If you pass 15. July, 9:45 to this method and the tick interval happens to be one tick
  per year, the ticks will end up on 15. July at 9:45 of every year.
*/
/*!
  틱의 원점을 설정합니다 (\ ref QCPAxisTicker :: setTickOrigin 참조).
  
  이는 더 큰 눈금 간격 단계에서 반복되는 월 / 일 / 시간을 정의하는 데 유용합니다. 에 대한
  예를 들어,이 메소드에 7 월 15 일, 9시 45 분을 전달하고 틱 간격이 1 틱일 경우
  1 년마다, 진드기는 15 일에 끝날 것입니다. 매년 7 월 45 일에 7:45.
*/
void QCPAxisTickerDateTime::setTickOrigin(const QDateTime &origin)
{
  setTickOrigin(dateTimeToKey(origin));
}

/*! \internal
  
  Returns a sensible tick step with intervals appropriate for a date-time-display, such as weekly,
  monthly, bi-monthly, etc.
  
  Note that this tick step isn't used exactly when generating the tick vector in \ref
  createTickVector, but only as a guiding value requiring some correction for each individual tick
  interval. Otherwise this would lead to unintuitive date displays, e.g. jumping between first day
  in the month to the last day in the previous month from tick to tick, due to the non-uniform
  length of months. The same problem arises with leap years.
  
  \seebaseclassmethod
*/
/*! \내부의
  
  주간, 월간, 주간 등의 날짜 시간 표시에 적합한 간격으로 현명한 틱 단계를 반환합니다.
  월별, 격월, 기타
  
  이 틱 단계는 \ ref에서 틱 벡터를 생성 할 때 정확하게 사용되지 않습니다.
  createTickVector를 사용하지만 각 틱마다 약간의 수정이 필요한 안내 값으로 만 사용하십시오
  간격. 그렇지 않으면 이것은 직관적이지 않은 날짜 표시로 이어집니다. 예를 들어 첫날
  지난 달의 마지막 날부터 틱에서 틱까지의 비 균일 성 때문에
  길이. 윤년과 같은 문제가 발생합니다.
  
  \ seebaseclassmethod
*/
double QCPAxisTickerDateTime::getTickStep(const QCPRange &range)
{
  double result = range.size()/(double)(mTickCount+1e-10);
 // mTickCount ticks on average, the small addition is to prevent jitter on exact integers
 // 평균 mTickCount 틱, 작은 추가는 정확한 정수에서 지터를 방지하는 것입니다.
  
  mDateStrategy = dsNone;
  if (result < 1)
 // ideal tick step is below 1 second -> use normal clean mantissa algorithm in units of seconds
 // 이상적인 틱 스텝이 1 초 미만이면 - 일반 클린 가수 알고리즘을 초 단위로 사용하십시오
  {
    result = cleanMantissa(result);
  } else if (result < 86400*30.4375*12) // below a year
                                        // 1 년 미만
  {
    result = pickClosest(result, QVector<double>()
                             << 1 << 2.5 << 5 << 10 << 15 << 30 << 60 << 2.5*60 << 5*60 << 10*60 << 15*60 << 30*60 << 60*60 // second, minute, hour range // 초, 분, 시간 범위
                             << 3600*2 << 3600*3 << 3600*6 << 3600*12 << 3600*24 // hour to day range // 시간 범위
                             << 86400*2 << 86400*5 << 86400*7 << 86400*14 << 86400*30.4375 << 86400*30.4375*2 << 86400*30.4375*3 << 86400*30.4375*6 << 86400*30.4375*12);
 // day, week, month range (avg. days per month includes leap years)
 // 일, 주, 월 범위 (월 평균 일수에는 윤년이 포함됨)
    if (result > 86400*30.4375-1) // month tick intervals or larger // 월 눈금 간격 이상
      mDateStrategy = dsUniformDayInMonth;
    else if (result > 3600*24-1) // day tick intervals or larger    // day tick 간격 이상
      mDateStrategy = dsUniformTimeInDay;
  } else // more than a year, go back to normal clean mantissa algorithm but in units of years
         // 1 년 이상, 일반 깨끗한 가수 알고리즘으로 돌아가지만 단위는 년
  {
    const double secondsPerYear = 86400*30.4375*12;  // average including leap years
                                                     // 윤년 포함 평균
    result = cleanMantissa(result/secondsPerYear)*secondsPerYear;
    mDateStrategy = dsUniformDayInMonth;
  }
  return result;
}

/*! \internal
  
  Returns a sensible sub tick count with intervals appropriate for a date-time-display, such as weekly,
  monthly, bi-monthly, etc.
  
  \seebaseclassmethod
*/

/*! \내부의
  
  주간, 주말 및 월간 시간대와 같이 날짜 시간 표시에 적합한 간격으로 적절한 하위 틱 수를 반환합니다.
  월별, 격월, 기타
  
  \ seebaseclassmethod
*/
int QCPAxisTickerDateTime::getSubTickCount(double tickStep)
{
  int result = QCPAxisTicker::getSubTickCount(tickStep);
  switch (qRound(tickStep))
 // hand chosen subticks for specific minute/hour/day/week/month range (as specified in getTickStep)
 // 특정 분 / 시간 / 일 / 주 / 월 범위 (getTickStep에 지정된대로)에 대해 선택한 하위를 넘겨줍니다.
  {
    case 5*60: result = 4; break;
    case 10*60: result = 1; break;
    case 15*60: result = 2; break;
    case 30*60: result = 1; break;
    case 60*60: result = 3; break;
    case 3600*2: result = 3; break;
    case 3600*3: result = 2; break;
    case 3600*6: result = 1; break;
    case 3600*12: result = 3; break;
    case 3600*24: result = 3; break;
    case 86400*2: result = 1; break;
    case 86400*5: result = 4; break;
    case 86400*7: result = 6; break;
    case 86400*14: result = 1; break;
    case (int)(86400*30.4375+0.5): result = 3; break;
    case (int)(86400*30.4375*2+0.5): result = 1; break;
    case (int)(86400*30.4375*3+0.5): result = 2; break;
    case (int)(86400*30.4375*6+0.5): result = 5; break;
    case (int)(86400*30.4375*12+0.5): result = 3; break;
  }
  return result;
}

/*! \internal
  
  Generates a date/time tick label for tick coordinate \a tick, based on the currently set format
  (\ref setDateTimeFormat) and time spec (\ref setDateTimeSpec).
  
  \seebaseclassmethod
*/
/*! \내부의
  
  현재 설정된 형식을 기준으로 틱 좌표 \ tick의 날짜 / 시간 눈금 레이블을 생성합니다.
  (\ ref setDateTimeFormat) 및 시간 스펙 (\ ref setDateTimeSpec).
  
  \ seebaseclassmethod
*/
QString QCPAxisTickerDateTime::getTickLabel(double tick, const QLocale &locale, QChar formatChar, int precision)
{
  Q_UNUSED(precision)
  Q_UNUSED(formatChar)
  return locale.toString(keyToDateTime(tick).toTimeSpec(mDateTimeSpec), mDateTimeFormat);
}

/*! \internal
  
  Uses the passed \a tickStep as a guiding value and applies corrections in order to obtain
  non-uniform tick intervals but intuitive tick labels, e.g. falling on the same day of each month.
  
  \seebaseclassmethod
*/
/*! \내부의
  
  전달 된 \ TickStep을 안내 값으로 사용하고 수정 사항을 적용하여
  비 균등 틱 간격이지만 직감적 틱 레이블 (예 : 매월 같은 날).
  
  \ seebaseclassmethod
*/
QVector<double> QCPAxisTickerDateTime::createTickVector(double tickStep, const QCPRange &range)
{
  QVector<double> result = QCPAxisTicker::createTickVector(tickStep, range);
  if (!result.isEmpty())
  {
    if (mDateStrategy == dsUniformTimeInDay)
    {
      QDateTime uniformDateTime = keyToDateTime(mTickOrigin);
 // the time of this datetime will be set for all other ticks, if possible
 //이 datetime의 시간은 가능한 경우 다른 모든 틱에 대해 설정됩니다.
      QDateTime tickDateTime;
      for (int i=0; i<result.size(); ++i)
      {
        tickDateTime = keyToDateTime(result.at(i));
        tickDateTime.setTime(uniformDateTime.time());
        result[i] = dateTimeToKey(tickDateTime);
      }
    } else if (mDateStrategy == dsUniformDayInMonth)
    {
      QDateTime uniformDateTime = keyToDateTime(mTickOrigin);
 // this day (in month) and time will be set for all other ticks, if possible
 //  가능하면이 틱 (월)과 시간이 다른 모든 틱에 설정됩니다. 
      QDateTime tickDateTime;
      for (int i=0; i<result.size(); ++i)
      {
        tickDateTime = keyToDateTime(result.at(i));
        tickDateTime.setTime(uniformDateTime.time());
        int thisUniformDay = uniformDateTime.date().day() <= tickDateTime.date().daysInMonth() ? uniformDateTime.date().day() : tickDateTime.date().daysInMonth(); // don't exceed month (e.g. try to set day 31 in February)
                                              // 월을 초과하지 마십시오 (예 : 2 월 31 일을 설정하려고 시도).
        if (thisUniformDay-tickDateTime.date().day() < -15) 
// with leap years involved, date month may jump backwards or forwards, and needs to be corrected before setting day
// 윤년이 포함 된 경우 날짜 월이 앞뒤로 이동할 수 있으므로 일을 설정하기 전에 수정해야합니다.
          tickDateTime = tickDateTime.addMonths(1);
        else if (thisUniformDay-tickDateTime.date().day() > 15)
// with leap years involved, date month may jump backwards or forwards, and needs to be corrected before setting day
// 윤년이 포함 된 경우 날짜 월이 앞뒤로 이동할 수 있으므로 일을 설정하기 전에 수정해야합니다.
          tickDateTime = tickDateTime.addMonths(-1);
        tickDateTime.setDate(QDate(tickDateTime.date().year(), tickDateTime.date().month(), thisUniformDay));
        result[i] = dateTimeToKey(tickDateTime);
      }
    }
  }
  return result;
}

/*!
  A convenience method which turns \a key (in seconds since Epoch 1. Jan 1970, 00:00 UTC) into a
  QDateTime object. This can be used to turn axis coordinates to actual QDateTimes.
  
  The accuracy achieved by this method is one millisecond, irrespective of the used Qt version (it
  works around the lack of a QDateTime::fromMSecsSinceEpoch in Qt 4.6)
  
  \see dateTimeToKey
*/
/*!
  열쇠를 변환하는 편리한 메소드입니다 (1970 년 1 월 1 일 00 시부 터 초 단위).
  QDateTime 객체. 이것은 축 좌표를 실제 QDateTimes로 바꾸는 데 사용할 수 있습니다.
  
  이 방법으로 얻은 정확도는 사용 된 Qt 버전과 관계없이 1 밀리 초입니다 (
  Qt 4.6에서 QDateTime :: fromMSecsSinceEpoch가 부족한 경우 작동합니다.
  
  \ see dateTimeToKey
*/
QDateTime QCPAxisTickerDateTime::keyToDateTime(double key)
{
# if QT_VERSION < QT_VERSION_CHECK(4, 7, 0)
  return QDateTime::fromTime_t(key).addMSecs((key-(qint64)key)*1000);
# else
  return QDateTime::fromMSecsSinceEpoch(key*1000.0);
# endif
}

/*! \overload
  
  A convenience method which turns a QDateTime object into a double value that corresponds to
  seconds since Epoch (1. Jan 1970, 00:00 UTC). This is the format used as axis coordinates by
  QCPAxisTickerDateTime.
  
  The accuracy achieved by this method is one millisecond, irrespective of the used Qt version (it
  works around the lack of a QDateTime::toMSecsSinceEpoch in Qt 4.6)
  
  \see keyToDateTime
*/
/*! \초과 적재
  
  QDateTime 객체를 double 값으로 변환하는 편리한 메서드입니다.
  Epoch 이후 초 (1970 년 1 월 1 일 00:00 UTC). 이것은 축 좌표로 사용되는 형식입니다.
  QCPAxisTickerDateTime.
  
  이 방법으로 얻은 정확도는 사용 된 Qt 버전과 관계없이 1 밀리 초입니다 (
  Qt 4.6에서 QDateTime :: toMSecsSinceEpoch가 부족한 경우 작동합니다.
  
  \ see keyToDateTime
*/
double QCPAxisTickerDateTime::dateTimeToKey(const QDateTime dateTime)
{
# if QT_VERSION < QT_VERSION_CHECK(4, 7, 0)
  return dateTime.toTime_t()+dateTime.time().msec()/1000.0;
# else
  return dateTime.toMSecsSinceEpoch()/1000.0;
# endif
}

/*! \overload
  
  A convenience method which turns a QDate object into a double value that corresponds to
  seconds since Epoch (1. Jan 1970, 00:00 UTC). This is the format used as axis coordinates by
  QCPAxisTickerDateTime.
  
  \see keyToDateTime
*/
/*! \초과 적재
  
  QDate 객체를 double 값으로 변환하는 편리한 메소드입니다.
  Epoch 이후 초 (1970 년 1 월 1 일 00:00 UTC). 이것은 축 좌표로 사용되는 형식입니다.
  QCPAxisTickerDateTime.
  
  \ see keyToDateTime
*/
double QCPAxisTickerDateTime::dateTimeToKey(const QDate date)
{
# if QT_VERSION < QT_VERSION_CHECK(4, 7, 0)
  return QDateTime(date).toTime_t();
# else
  return QDateTime(date).toMSecsSinceEpoch()/1000.0;
# endif
}
/* end of 'src/axis/axistickerdatetime.cpp' */


/* including file 'src/axis/axistickertime.cpp', size 11747                  */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / axis / axistickerdatetime.cpp'의 끝 */


/* 'src / axis / axistickertime.cpp'파일 포함, 크기 11747 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPAxisTickerTime
////////////////////////////////////////////////////////////////////////////////////////////////////
/*! \class QCPAxisTickerTime
  \brief Specialized axis ticker for time spans in units of milliseconds to days
  
  \image html axisticker-time.png
  
  This QCPAxisTicker subclass generates ticks that corresponds to time intervals.
  
  The format of the time display in the tick labels is controlled with \ref setTimeFormat and \ref
  setFieldWidth. The time coordinate is in the unit of seconds with respect to the time coordinate
  zero. Unlike with QCPAxisTickerDateTime, the ticks don't correspond to a specific calendar date
  and time.
  
  The time can be displayed in milliseconds, seconds, minutes, hours and days. Depending on the
  largest available unit in the format specified with \ref setTimeFormat, any time spans above will
  be carried in that largest unit. So for example if the format string is "%m:%s" and a tick at
  coordinate value 7815 (being 2 hours, 10 minutes and 15 seconds) is created, the resulting tick
  label will show "130:15" (130 minutes, 15 seconds). If the format string is "%h:%m:%s", the hour
  unit will be used and the label will thus be "02:10:15". Negative times with respect to the axis
  zero will carry a leading minus sign.
  
  The ticker can be created and assigned to an axis like this:
  \snippet documentation/doc-image-generator/mainwindow.cpp axistickertime-creation
  
  Here is an example of a time axis providing time information in days, hours and minutes. Due to
  the axis range spanning a few days and the wanted tick count (\ref setTickCount), the ticker
  decided to use tick steps of 12 hours:
  
  \image html axisticker-time2.png
  
  The format string for this example is
  \snippet documentation/doc-image-generator/mainwindow.cpp axistickertime-creation-2
  
  \note If you rather wish to display calendar dates and times, have a look at QCPAxisTickerDateTime
  instead.
*/
/*! \ class QCPAxisTickerTime
  \ brief 밀리 초 단위의 시간 범위에 대한 특수화 된 축 티커
  
  \ image html axisticker-time.png
  
  이 QCPAxisTicker 서브 클래스는 시간 간격에 해당하는 틱을 생성합니다.
  
  틱 레이블의 시간 표시 형식은 \ ref setTimeFormat 및 \ ref로 제어됩니다
  setFieldWidth. 시간 좌표는 시간 좌표에 대한 초 단위입니다.
  제로. QCPAxisTickerDateTime과 달리 틱은 특정 달력 날짜와 일치하지 않습니다.
  시간.
  
  시간은 밀리 초, 초, 분, 시간 및 일로 표시 할 수 있습니다. 에 따라
  \ ref setTimeFormat으로 지정된 형식에서 가장 큰 사용 가능한 단위입니다. 위의 시간 범위는
  그 가장 큰 단위로 옮겨 져야한다. 예를 들어 형식 문자열이 "% m : % s"이고에서 틱이
  좌표 값 7815 (2 시간 10 분 15 초)가 생성되면 결과 틱
  레이블에 "130 : 15"(130 분, 15 초)가 표시됩니다. 형식 문자열이 "% h : % m : % s"이면, 시간
  단위가 사용되며 레이블은 "02:10:15"가됩니다. 축에 대한 음수
  0은 선행 마이너스 기호를 나타냅니다.
  
  티커는 다음과 같이 축에 생성되고 지정 될 수 있습니다 :
  \ snippet documentation / doc-image-generator / mainwindow.cpp axistickertime-creation
  
  다음은 일,시 및 분 단위로 시간 정보를 제공하는 시간 축의 예입니다. 때문에
  며칠 동안의 축 범위와 원하는 틱 수 (\ ref setTickCount), 티커
  12 시간의 틱 단계를 사용하기로 결정했습니다.
  
  \ image html axisticker-time2.png
  
  이 예제의 형식 문자열은 다음과 같습니다.
  \ snippet documentation / doc-image-generator / mainwindow.cpp axistickertime-creation-2
  
  \ note 일정 날짜와 시간을 표시하려면 QCPAxisTickerDateTime을보십시오.
  대신.
*/

/*!
  Constructs the ticker and sets reasonable default values. Axis tickers are commonly created
  managed by a QSharedPointer, which then can be passed to QCPAxis::setTicker.
*/
/*!
  티커를 구축해, 적절한 기본값을 설정합니다. 축 시세는 일반적으로 만들어집니다
  QSharedPointer에 의해 관리되며, QSharedPointer는 QCPAxis :: setTicker로 전달 될 수 있습니다.
*/
QCPAxisTickerTime::QCPAxisTickerTime() :
  mTimeFormat(QLatin1String("%h:%m:%s")),
  mSmallestUnit(tuSeconds),
  mBiggestUnit(tuHours)
{
  setTickCount(4);
  mFieldWidth[tuMilliseconds] = 3;
  mFieldWidth[tuSeconds] = 2;
  mFieldWidth[tuMinutes] = 2;
  mFieldWidth[tuHours] = 2;
  mFieldWidth[tuDays] = 1;
  
  mFormatPattern[tuMilliseconds] = QLatin1String("%z");
  mFormatPattern[tuSeconds] = QLatin1String("%s");
  mFormatPattern[tuMinutes] = QLatin1String("%m");
  mFormatPattern[tuHours] = QLatin1String("%h");
  mFormatPattern[tuDays] = QLatin1String("%d");
}

/*!
  Sets the format that will be used to display time in the tick labels.
  
  The available patterns are:
  - %%z for milliseconds
  - %%s for seconds
  - %%m for minutes
  - %%h for hours
  - %%d for days
  
  The field width (zero padding) can be controlled for each unit with \ref setFieldWidth.
  
  The largest unit that appears in \a format will carry all the remaining time of a certain tick
  coordinate, even if it overflows the natural limit of the unit. For example, if %%m is the
  largest unit it might become larger than 59 in order to consume larger time values. If on the
  other hand %%h is available, the minutes will wrap around to zero after 59 and the time will
  carry to the hour digit.
*/
/*!
  눈금 레이블에 시간을 표시하는 데 사용할 형식을 설정합니다.
  
  사용 가능한 패턴은 다음과 같습니다.
  - 밀리 초 동안 %% z
  - 초 동안 %% s
  - 분 동안 %% m
  - 시간 %% h
  - 일 동안 %% d
  
  필드 너비 (제로 패딩)는 \ ref setFieldWidth를 사용하여 각 장치에 대해 제어 할 수 있습니다.
  
  \ a 형식으로 나타나는 가장 큰 단위는 특정 틱의 남은 시간을 모두 소진합니다.
  좌표가 단위의 자연 한도를 초과하더라도 예를 들어, %% m이
  가장 큰 단위는 더 큰 시간 값을 소비하기 위해 59보다 커질 수 있습니다. 에
  다른 손 %% h을 사용할 수있는 경우, 분은 59 후에 0으로 랩되고 시간은
  시간 자리로 나옵니다.
*/
void QCPAxisTickerTime::setTimeFormat(const QString &format)
{
  mTimeFormat = format;
  
  // determine smallest and biggest unit in format, to optimize unit replacement and allow biggest
  // unit to consume remaining time of a tick value and grow beyond its modulo (e.g. min > 59)
  // 형식에서 가장 작고 가장 큰 단위를 결정하고, 단위 대체를 최적화하고 최대 허용
  // 단위는 틱 값의 남은 시간을 소비하고 모듈로를 초과하여 증가합니다 (예 : min> 59)
  mSmallestUnit = tuMilliseconds;
  mBiggestUnit = tuMilliseconds;
  bool hasSmallest = false;
  for (int i = tuMilliseconds; i <= tuDays; ++i)
  {
    TimeUnit unit = static_cast<TimeUnit>(i);
    if (mTimeFormat.contains(mFormatPattern.value(unit)))
    {
      if (!hasSmallest)
      {
        mSmallestUnit = unit;
        hasSmallest = true;
      }
      mBiggestUnit = unit;
    }
  }
}

/*!
  Sets the field widh of the specified \a unit to be \a width digits, when displayed in the tick
  label. If the number for the specific unit is shorter than \a width, it will be padded with an
  according number of zeros to the left in order to reach the field width.
  
  \see setTimeFormat
*/
/*!
  틱으로 표시 될 때 \ a 단위의 필드 widh를 \ width 너비로 설정합니다.
  상표. 특정 단위의 숫자가 \ a 너비보다 짧으면
  필드 너비에 도달하기 위해 왼쪽에있는 0의 숫자에 따라.
  
  \ see setTimeFormat
*/
void QCPAxisTickerTime::setFieldWidth(QCPAxisTickerTime::TimeUnit unit, int width)
{
  mFieldWidth[unit] = qMax(width, 1);
}

/*! \internal

  Returns the tick step appropriate for time displays, depending on the provided \a range and the
  smallest available time unit in the current format (\ref setTimeFormat). For example if the unit
  of seconds isn't available in the format, this method will not generate steps (like 2.5 minutes)
  that require sub-minute precision to be displayed correctly.
  
  \seebaseclassmethod
*/
/*! \내부의

  제공된 \ a 범위에 따라 시간 표시에 적합한 눈금 단계를 반환합니다.
  현재 형식 (\ ref setTimeFormat)에서 사용 가능한 가장 작은 시간 단위. 예를 들어, 장치
  초를 형식으로 사용할 수없는 경우이 방법은 단계를 생성하지 않습니다 (예 : 2.5 분).
  분 단위 정밀도가 올바르게 표시되어야합니다.
  
  \ seebaseclassmethod
*/
double QCPAxisTickerTime::getTickStep(const QCPRange &range)
{
  double result = range.size()/(double)(mTickCount+1e-10); 
// mTickCount ticks on average, the small addition is to prevent jitter on exact integers
// 평균 mTickCount 틱, 작은 추가는 정확한 정수에서 지터를 방지하는 것입니다.
  
  if (result < 1) 
// ideal tick step is below 1 second -> use normal clean mantissa algorithm in units of seconds
// 이상적인 틱 스텝이 1 초 미만이면 - 일반 클린 가수 알고리즘을 초 단위로 사용하십시오
  {
    if (mSmallestUnit == tuMilliseconds)
      result = qMax(cleanMantissa(result), 0.001); // smallest tick step is 1 millisecond
                                                   // 가장 작은 틱 단계는 1 밀리 초입니다.
    else 
// have no milliseconds available in format, so stick with 1 second tickstep
// 형식으로 사용할 수있는 밀리 초가 없으므로 1 초 틱 스텝으로 고정하십시오.
      result = 1.0;
  } else if (result < 3600*24) // below a day
  {
    // the filling of availableSteps seems a bit contorted but it fills in a sorted fashion and thus saves a post-fill sorting run
  // availableSteps의 채우기가 다소 뒤틀린 것처럼 보이지만 정렬 된 방식으로 채워 지므로 포스트 채우기 정렬 실행이 저장됩니다.
    QVector<double> availableSteps;
    // seconds range:
    // 초 범위 :
    if (mSmallestUnit <= tuSeconds)
      availableSteps << 1;
    if (mSmallestUnit == tuMilliseconds)
      availableSteps << 2.5; // only allow half second steps if milliseconds are there to display it
                             // 밀리 세컨드 만 표시하면 반 초 단위 만 허용합니다.
    else if (mSmallestUnit == tuSeconds)
      availableSteps << 2;
    if (mSmallestUnit <= tuSeconds)
      availableSteps << 5 << 10 << 15 << 30;
    // minutes range:
    // 분 범위 :
    if (mSmallestUnit <= tuMinutes)
      availableSteps << 1*60;
    if (mSmallestUnit <= tuSeconds)
      availableSteps << 2.5*60; // only allow half minute steps if seconds are there to display it
                                // 초를 표시하려면 30 분 단계 만 허용합니다.
    else if (mSmallestUnit == tuMinutes)
      availableSteps << 2*60;
    if (mSmallestUnit <= tuMinutes)
      availableSteps << 5*60 << 10*60 << 15*60 << 30*60;
    // hours range:
    // 시간 범위 :
    if (mSmallestUnit <= tuHours)
      availableSteps << 1*3600 << 2*3600 << 3*3600 << 6*3600 << 12*3600 << 24*3600;
    // pick available step that is most appropriate to approximate ideal step:
    // 이상적인 단계를 근사화하는 데 가장 적합한 단계를 선택하십시오.
    result = pickClosest(result, availableSteps);
  } else // more than a day, go back to normal clean mantissa algorithm but in units of days
  {      // 하루 이상, 일반 깨끗한 가수 알고리즘으로 돌아가지만 단위는 일 단위입니다.
    const double secondsPerDay = 3600*24;
    result = cleanMantissa(result/secondsPerDay)*secondsPerDay;
  }
  return result;
}

/*! \internal

  Returns the sub tick count appropriate for the provided \a tickStep and time displays.
  
  \seebaseclassmethod
*/
/*! \내부의

  제공된 tickstep 및 시간 표시에 적합한 하위 틱 수를 반환합니다.
  
  \ seebaseclassmethod
*/
int QCPAxisTickerTime::getSubTickCount(double tickStep)
{
  int result = QCPAxisTicker::getSubTickCount(tickStep);
  switch (qRound(tickStep)) // hand chosen subticks for specific minute/hour/day range (as specified in getTickStep)
                            // 특정 분 / 시간 / 일 범위 (getTickStep에 지정된대로)에 대해 선택한 하위 집합을 넘깁니다.
  {
    case 5*60: result = 4; break;
    case 10*60: result = 1; break;
    case 15*60: result = 2; break;
    case 30*60: result = 1; break;
    case 60*60: result = 3; break;
    case 3600*2: result = 3; break;
    case 3600*3: result = 2; break;
    case 3600*6: result = 1; break;
    case 3600*12: result = 3; break;
    case 3600*24: result = 3; break;
  }
  return result;
}

/*! \internal
  
  Returns the tick label corresponding to the provided \a tick and the configured format and field
  widths (\ref setTimeFormat, \ref setFieldWidth).
  
  \seebaseclassmethod
*/
/*! \내부의
  
  제공된 \ a 눈금 및 구성된 형식 및 필드에 해당하는 눈금 레이블을 반환합니다.
  너비 (\ ref setTimeFormat, \ ref setFieldWidth).
  
  \ seebaseclassmethod
*/
QString QCPAxisTickerTime::getTickLabel(double tick, const QLocale &locale, QChar formatChar, int precision)
{
  Q_UNUSED(precision)
  Q_UNUSED(formatChar)
  Q_UNUSED(locale)
  bool negative = tick < 0;
  if (negative) tick *= -1;
  double values[tuDays+1]; 
// contains the msec/sec/min/... value with its respective modulo (e.g. minute 0..59)
// 각 모듈로 (예 : 분 0..59) msec / sec / min / ... 값을 포함합니다.
  double restValues[tuDays+1];
// contains the msec/sec/min/... value as if it's the largest available unit and thus consumes the remaining time
// 가능한 가장 큰 단위 인 것처럼 msec / sec / min / ... 값을 포함하여 나머지 시간을 소비합니다.
  restValues[tuMilliseconds] = tick*1000;
  values[tuMilliseconds] = modf(restValues[tuMilliseconds]/1000, &restValues[tuSeconds])*1000;
  values[tuSeconds] = modf(restValues[tuSeconds]/60, &restValues[tuMinutes])*60;
  values[tuMinutes] = modf(restValues[tuMinutes]/60, &restValues[tuHours])*60;
  values[tuHours] = modf(restValues[tuHours]/24, &restValues[tuDays])*24;
  // no need to set values[tuDays] because days are always a rest value (there is no higher unit so it consumes all remaining time)
// 요일은 항상 나머지 값이기 때문에 [tuDays] 값을 설정할 필요가 없습니다 (더 높은 단위가 없으므로 나머지 시간은 모두 소비합니다)
  
  QString result = mTimeFormat;
  for (int i = mSmallestUnit; i <= mBiggestUnit; ++i)
  {
    TimeUnit iUnit = static_cast<TimeUnit>(i);
    replaceUnit(result, iUnit, qRound(iUnit == mBiggestUnit ? restValues[iUnit] : values[iUnit]));
  }
  if (negative)
    result.prepend(QLatin1Char('-'));
  return result;
}

/*! \internal
  
  Replaces all occurrences of the format pattern belonging to \a unit in \a text with the specified
  \a value, using the field width as specified with \ref setFieldWidth for the \a unit.
*/
/*! \내부의
  
  \ 텍스트의 \ 유닛에 속하는 서식 패턴의 모든 항목을 지정된 텍스트로 대체합니다.
  \ a 단위에 대해 \ ref setFieldWidth로 지정된대로 필드 폭을 사용하는 \ a 값.
*/
void QCPAxisTickerTime::replaceUnit(QString &text, QCPAxisTickerTime::TimeUnit unit, int value) const
{
  QString valueStr = QString::number(value);
  while (valueStr.size() < mFieldWidth.value(unit))
    valueStr.prepend(QLatin1Char('0'));
  
  text.replace(mFormatPattern.value(unit), valueStr);
}
/* end of 'src/axis/axistickertime.cpp' */


/* including file 'src/axis/axistickerfixed.cpp', size 5583                  */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / axis / axistickertime.cpp'의 끝 */


/* 파일 'src / axis / axistickerfixed.cpp', 크기 5583 포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPAxisTickerFixed
////////////////////////////////////////////////////////////////////////////////////////////////////
/*! \class QCPAxisTickerFixed
  \brief Specialized axis ticker with a fixed tick step
  
  \image html axisticker-fixed.png
  
  This QCPAxisTicker subclass generates ticks with a fixed tick step set with \ref setTickStep. It
  is also possible to allow integer multiples and integer powers of the specified tick step with
  \ref setScaleStrategy.
  
  A typical application of this ticker is to make an axis only display integers, by setting the
  tick step of the ticker to 1.0 and the scale strategy to \ref ssMultiples.
  
  Another case is when a certain number has a special meaning and axis ticks should only appear at
  multiples of that value. In this case you might also want to consider \ref QCPAxisTickerPi
  because despite the name it is not limited to only pi symbols/values.
  
  The ticker can be created and assigned to an axis like this:
  \snippet documentation/doc-image-generator/mainwindow.cpp axistickerfixed-creation
*/
/*! \ class QCPAxisTickerFixed
  \ brief 고정 된 틱 스텝을 가진 전문화 된 축 티커
  
  \ image html axisticker-fixed.png
  
  이 QCPAxisTicker 하위 클래스는 \ ref setTickStep으로 고정 된 틱 단계로 틱을 생성합니다. 그것
  지정된 틱 단계의 정수 배수와 정수 배수를
  \ ref setScaleStrategy.
  
  이 시세 표시기의 일반적인 응용 프로그램은 축을
  티커의 1.0 단계로의 눈금 단계와 \ ref ssMultiples에 대한 척도 전략.
  
  또 다른 경우는 특정 숫자가 특별한 의미를 가지며 축 틱이
  그 값의 배수. 이 경우 \ ref QCPAxisTickerPi를 고려할 수도 있습니다.
  이름에도 불구하고 pi 기호 / 값에만 국한되지 않기 때문입니다.
  
  티커는 다음과 같이 축에 생성되고 지정 될 수 있습니다 :
  \ snippet documentation / doc-image-generator / mainwindow.cpp axistickerfixed-creation
*/

/*!
  Constructs the ticker and sets reasonable default values. Axis tickers are commonly created
  managed by a QSharedPointer, which then can be passed to QCPAxis::setTicker.
*/
/*!
  티커를 구축해, 적절한 기본값을 설정합니다. 축 시세는 일반적으로 만들어집니다
  QSharedPointer에 의해 관리되며, QSharedPointer는 QCPAxis :: setTicker로 전달 될 수 있습니다.
*/
QCPAxisTickerFixed::QCPAxisTickerFixed() :
  mTickStep(1.0),
  mScaleStrategy(ssNone)
{
}

/*!
  Sets the fixed tick interval to \a step.
  
  The axis ticker will only use this tick step when generating axis ticks. This might cause a very
  high tick density and overlapping labels if the axis range is zoomed out. Using \ref
  setScaleStrategy it is possible to relax the fixed step and also allow multiples or powers of \a
  step. This will enable the ticker to reduce the number of ticks to a reasonable amount (see \ref
  setTickCount).
*/
/*!
  고정 눈금 간격을 \ a 단계로 설정합니다.
  
  축 티커는 축 틱을 생성 할 때만이 틱 단계를 사용합니다. 이로 인해
  높은 틱 밀도 및 축 범위가 축소 된 경우 레이블이 겹칩니다. \ ref 사용
  setScaleStrategy 고정 된 단계를 완화하고 \ a의 배수 또는 배율을 허용 할 수 있습니다.
  단계. 그러면 티커가 틱의 수를 합리적인 금액으로 줄일 수 있습니다 (\ ref 참조).
  setTickCount).
*/
void QCPAxisTickerFixed::setTickStep(double step)
{
  if (step > 0)
    mTickStep = step;
  else
    qDebug() << Q_FUNC_INFO << "tick step must be greater than zero:" << step;
}

/*!
  Sets whether the specified tick step (\ref setTickStep) is absolutely fixed or whether
  modifications may be applied to it before calculating the finally used tick step, such as
  permitting multiples or powers. See \ref ScaleStrategy for details.
  
  The default strategy is \ref ssNone, which means the tick step is absolutely fixed.
*/
/*!
  지정된 눈금 단계 (\ ref setTickStep)가 절대적으로 고정되어 있는지 여부를 설정합니다.
  마지막으로 사용 된 틱 스텝을 계산하기 전에 수정을 적용 할 수 있습니다.
  배수 또는 권한을 허용합니다. 자세한 내용은 \ ref ScaleStrategy를 참조하십시오.
  
  기본 전략은 \ ref ssNone입니다. 이는 틱 단계가 절대적으로 고정되어 있음을 의미합니다.
*/
void QCPAxisTickerFixed::setScaleStrategy(QCPAxisTickerFixed::ScaleStrategy strategy)
{
  mScaleStrategy = strategy;
}

/*! \internal
  
  Determines the actually used tick step from the specified tick step and scale strategy (\ref
  setTickStep, \ref setScaleStrategy).
  
  This method either returns the specified tick step exactly, or, if the scale strategy is not \ref
  ssNone, a modification of it to allow varying the number of ticks in the current axis range.
  
  \seebaseclassmethod
*/
/*! \내부의
  
  지정된 틱 스텝 및 스케일 전략에서 실제로 사용 된 틱 스텝을 결정합니다 (\ ref
  setTickStep, \ ref setScaleStrategy).
  
  이 메서드는 지정된 틱 스텝을 정확하게 반환하거나 스케일 전략이 \ ref가 아니면
  ssNone, 현재 축 범위의 틱 수를 변경할 수 있도록 수정 한 것입니다.
  
  \ seebaseclassmethod
*/
double QCPAxisTickerFixed::getTickStep(const QCPRange &range)
{
  switch (mScaleStrategy)
  {
    case ssNone:
    {
      return mTickStep;
    }
    case ssMultiples:
    {
      double exactStep = range.size()/(double)(mTickCount+1e-10); 
// mTickCount ticks on average, the small addition is to prevent jitter on exact integers
// 평균 mTickCount 틱, 작은 추가는 정확한 정수에서 지터를 방지하는 것입니다.
      if (exactStep < mTickStep)
        return mTickStep;
      else
        return (qint64)(cleanMantissa(exactStep/mTickStep)+0.5)*mTickStep;
    }
    case ssPowers:
    {
      double exactStep = range.size()/(double)(mTickCount+1e-10); 
// mTickCount ticks on average, the small addition is to prevent jitter on exact integers
// 평균 mTickCount 틱, 작은 추가는 정확한 정수에서 지터를 방지하는 것입니다.
      return qPow(mTickStep, (int)(qLn(exactStep)/qLn(mTickStep)+0.5));
    }
  }
  return mTickStep;
}
/* end of 'src/axis/axistickerfixed.cpp' */


/* including file 'src/axis/axistickertext.cpp', size 8653                   */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / axis / axistickerfixed.cpp'의 끝 */


/* 파일 'src / axis / axistickertext.cpp', 크기 8653 포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPAxisTickerText
////////////////////////////////////////////////////////////////////////////////////////////////////
/*! \class QCPAxisTickerText
  \brief Specialized axis ticker which allows arbitrary labels at specified coordinates
  
  \image html axisticker-text.png
  
  This QCPAxisTicker subclass generates ticks which can be directly specified by the user as
  coordinates and associated strings. They can be passed as a whole with \ref setTicks or one at a
  time with \ref addTick. Alternatively you can directly access the internal storage via \ref ticks
  and modify the tick/label data there.
  
  This is useful for cases where the axis represents categories rather than numerical values.
  
  If you are updating the ticks of this ticker regularly and in a dynamic fasion (e.g. dependent on
  the axis range), it is a sign that you should probably create an own ticker by subclassing
  QCPAxisTicker, instead of using this one.
  
  The ticker can be created and assigned to an axis like this:
  \snippet documentation/doc-image-generator/mainwindow.cpp axistickertext-creation
*/
/*! \ class QCPAxisTickerText
  \ brief 지정된 좌표에서 임의의 레이블을 허용하는 특수한 축 티커
  
  \ image html axisticker-text.png
  
  이 QCPAxisTicker 서브 클래스는 사용자가 직접 지정할 수있는 틱을 생성합니다.
  좌표 및 연관된 문자열. 그것들은 \ ref setTicks 또는 \ ref setTicks를 사용하여 전체적으로 전달 될 수 있습니다.
  \ ref addTick을 사용하여 시간을 지정하십시오. 또는 \ ref 틱을 통해 내부 저장소에 직접 액세스 할 수 있습니다.
  거기서 진드기 / 라벨 데이터를 수정하십시오.
  
  축이 숫자 값이 아닌 범주를 나타내는 경우에 유용합니다.
  
  이 시세 표시기의 틱을 정기적으로 그리고 동적 인 fasion에서 업데이트하는 경우 (예 :
  축 범위), 서브 클래 싱을 통해 자체 티커를 만들어야한다는 신호입니다
  QCPAxisTicker를 사용하십시오.
  
  티커는 다음과 같이 축에 생성되고 지정 될 수 있습니다 :
  \ snippet documentation / doc-image-generator / mainwindow.cpp axistickertext-creation
*/


/* start of documentation of inline functions */
/* 인라인 함수의 문서화 시작 */

/*! \fn QMap<double, QString> &QCPAxisTickerText::ticks()
  
  Returns a non-const reference to the internal map which stores the tick coordinates and their
  labels.

  You can access the map directly in order to add, remove or manipulate ticks, as an alternative to
  using the methods provided by QCPAxisTickerText, such as \ref setTicks and \ref addTick.
*/
/*! \ fn QMap <double, QString> & QCPAxisTickerText :: ticks ()
  
  틱 좌표를 저장하는 내부 맵에 대한 비 const 레퍼런스를 리턴합니다.
  레이블.

  진드기를 추가, 제거 또는 조작하기 위해 맵에 직접 액세스 할 수 있습니다.
  \ ref setTicks 및 \ ref addTick과 같이 QCPAxisTickerText에서 제공하는 메서드를 사용합니다.
*/

/* end of documentation of inline functions */
/* 인라인 함수의 문서 끝 */

/*!
  Constructs the ticker and sets reasonable default values. Axis tickers are commonly created
  managed by a QSharedPointer, which then can be passed to QCPAxis::setTicker.
*/
/*!
  티커를 구축해, 적절한 기본값을 설정합니다. 축 시세는 일반적으로 만들어집니다
  QSharedPointer에 의해 관리되며, QSharedPointer는 QCPAxis :: setTicker로 전달 될 수 있습니다.
*/
QCPAxisTickerText::QCPAxisTickerText() :
  mSubTickCount(0)
{
}

/*! \overload
  
  Sets the ticks that shall appear on the axis. The map key of \a ticks corresponds to the axis
  coordinate, and the map value is the string that will appear as tick label.
  
  An alternative to manipulate ticks is to directly access the internal storage with the \ref ticks
  getter.
  
  \see addTicks, addTick, clear
*/
/*! \초과 적재
  
  축에 표시 할 틱을 설정합니다. \ tick의 맵 키는 축에 해당합니다.
  좌표이며, 맵 값은 눈금 레이블로 표시 될. 자열입니다.
  
  진드기를 조작하는 대신 \ ref 틱을 사용하여 내부 저장소에 직접 액세스 할 수 있습니다
  얻는 사람.
  
  \ addTicks, addTick, clear를 참조하십시오.
*/
void QCPAxisTickerText::setTicks(const QMap<double, QString> &ticks)
{
  mTicks = ticks;
}

/*! \overload
  
  Sets the ticks that shall appear on the axis. The entries of \a positions correspond to the axis
  coordinates, and the entries of \a labels are the respective strings that will appear as tick
  labels.
  
  \see addTicks, addTick, clear
*/
/*! \초과 적재
  
  축에 표시 할 틱을 설정합니다. \ a 위치의 항목은 축에 해당합니다.
  좌표 및 \ l 레이블 항목은 틱으로 나타날 각 문자열입니다.
  레이블.
  
  \ addTicks, addTick, clear를 참조하십시오.
*/
void QCPAxisTickerText::setTicks(const QVector<double> &positions, const QVector<QString> labels)
{
  clear();
  addTicks(positions, labels);
}

/*!
  Sets the number of sub ticks that shall appear between ticks. For QCPAxisTickerText, there is no
  automatic sub tick count calculation. So if sub ticks are needed, they must be configured with this
  method.
*/
/*!
  틱 사이에 나타날 하위 틱의 수를 설정합니다. QCPAxisTickerText의 경우,
  자동 하위 틱 수 계산. 따라서 하위 틱이 필요한 경우이 틱을 사용하여 구성해야합니다.
  방법.
*/
void QCPAxisTickerText::setSubTickCount(int subTicks)
{
  if (subTicks >= 0)
    mSubTickCount = subTicks;
  else
    qDebug() << Q_FUNC_INFO << "sub tick count can't be negative:" << subTicks;
}

/*!
  Clears all ticks.
  
  An alternative to manipulate ticks is to directly access the internal storage with the \ref ticks
  getter.
  
  \see setTicks, addTicks, addTick
*/
/*!
  모든 틱을 지 웁니다.
  
  진드기를 조작하는 대신 \ ref 틱을 사용하여 내부 저장소에 직접 액세스 할 수 있습니다
  얻는 사람.
  
  \ setTicks, addTicks, addTick을 참조하십시오.
*/
void QCPAxisTickerText::clear()
{
  mTicks.clear();
}

/*!
  Adds a single tick to the axis at the given axis coordinate \a position, with the provided tick \a
  label.
  
  \see addTicks, setTicks, clear
*/
/*!
  지정된 축 좌표 \ a 위치에서 축에 단일 눈금을 추가하고 제공된 눈금으로 \ a를 추가합니다.
  상표.
  
  \ addTicks, setTicks, clear를 참조하십시오.
*/
void QCPAxisTickerText::addTick(double position, QString label)
{
  mTicks.insert(position, label);
}

/*! \overload
  
  Adds the provided \a ticks to the ones already existing. The map key of \a ticks corresponds to
  the axis coordinate, and the map value is the string that will appear as tick label.
  
  An alternative to manipulate ticks is to directly access the internal storage with the \ref ticks
  getter.
  
  \see addTick, setTicks, clear
*/
/*! \초과 적재
  
  제공된 \ a 틱을 이미 존재하는 틱에 추가합니다. \ tick의 맵 키는 다음에 해당합니다.
  축 좌표 및 맵 값은 눈금 레이블로 표시 될 문자열입니다.
  
  진드기를 조작하는 대신 \ ref 틱을 사용하여 내부 저장소에 직접 액세스 할 수 있습니다
  얻는 사람.
  
  \ addTick, setTicks, clear를 참조하십시오.
*/
void QCPAxisTickerText::addTicks(const QMap<double, QString> &ticks)
{
  mTicks.unite(ticks);
}

/*! \overload
  
  Adds the provided ticks to the ones already existing. The entries of \a positions correspond to
  the axis coordinates, and the entries of \a labels are the respective strings that will appear as
  tick labels.
  
  An alternative to manipulate ticks is to directly access the internal storage with the \ref ticks
  getter.
  
  \see addTick, setTicks, clear
*/
/*! \초과 적재
  
  제공된 틱을 이미 존재하는 틱에 추가합니다. \ a 위치의 항목은 다음에 해당합니다.
  축 좌표 및 \ label의 항목은 다음과 같이 나타날 각 문자열입니다.
  눈금 레이블.
  
  진드기를 조작하는 대신 \ ref 틱을 사용하여 내부 저장소에 직접 액세스 할 수 있습니다
  얻는 사람.
  
  \ addTick, setTicks, clear를 참조하십시오.
*/
void QCPAxisTickerText::addTicks(const QVector<double> &positions, const QVector<QString> &labels)
{
  if (positions.size() != labels.size())
    qDebug() << Q_FUNC_INFO << "passed unequal length vectors for positions and labels:" << positions.size() << labels.size();
  int n = qMin(positions.size(), labels.size());
  for (int i=0; i<n; ++i)
    mTicks.insert(positions.at(i), labels.at(i));
}

/*!
  Since the tick coordinates are provided externally, this method implementation does nothing.
  
  \seebaseclassmethod
*/
/*!
  눈금 좌표는 외부 적으로 제공되기 때문에이 메서드 구현은 아무 것도 수행하지 않습니다.
  
  \ seebaseclassmethod
*/
double QCPAxisTickerText::getTickStep(const QCPRange &range)
{
  // text axis ticker has manual tick positions, so doesn't need this method
  // 텍스트 축 티커에는 수동 틱 위치가 있으므로이 메서드가 필요하지 않습니다.
  Q_UNUSED(range)
  return 1.0;
}

/*!
  Returns the sub tick count that was configured with \ref setSubTickCount.
  
  \seebaseclassmethod
*/
/*!
  \ ref setSubTickCount로 구성된 하위 틱 수를 반환합니다.
  
  \ seebaseclassmethod
*/
int QCPAxisTickerText::getSubTickCount(double tickStep)
{
  Q_UNUSED(tickStep)
  return mSubTickCount;
}

/*!
  Returns the tick label which corresponds to the key \a tick in the internal tick storage. Since
  the labels are provided externally, \a locale, \a formatChar, and \a precision are ignored.
  
  \seebaseclassmethod
*/
/*!
  내부 틱 기억 장치의 키에 해당하는 눈금 레이블을 리턴합니다. 이후
  레이블은 외부 적으로 제공되며 \ a 로켈, \ a formatChar 및 \ a 정밀도는 무시됩니다.
  
  \ seebaseclassmethod
*/
QString QCPAxisTickerText::getTickLabel(double tick, const QLocale &locale, QChar formatChar, int precision)
{
  Q_UNUSED(locale)
  Q_UNUSED(formatChar)
  Q_UNUSED(precision)
  return mTicks.value(tick);
}

/*!
  Returns the externally provided tick coordinates which are in the specified \a range. If
  available, one tick above and below the range is provided in addition, to allow possible sub tick
  calculation. The parameter \a tickStep is ignored.
  
  \seebaseclassmethod
*/
/*!
  지정된 \ a 범위에있는 외부 적으로 제공된 틱 좌표를 반환합니다. 만약
  가능하다면, 범위 위 및 아래의 1 개 틱이 추가로 제공되어 가능한 하위 틱
  계산. \ tickstep 매개 변수는 무시됩니다.
  
  \ seebaseclassmethod
*/
QVector<double> QCPAxisTickerText::createTickVector(double tickStep, const QCPRange &range)
{
  Q_UNUSED(tickStep)
  QVector<double> result;
  if (mTicks.isEmpty())
    return result;
  
  QMap<double, QString>::const_iterator start = mTicks.lowerBound(range.lower);
  QMap<double, QString>::const_iterator end = mTicks.upperBound(range.upper);
  // this method should try to give one tick outside of range so proper subticks can be generated:
  //이 메소드는 적절한 범위를 생성 할 수 있도록 하나의 눈금을 범위 밖으로 지정해야합니다.
  if (start != mTicks.constBegin()) --start;
  if (end != mTicks.constEnd()) ++end;
  for (QMap<double, QString>::const_iterator it = start; it != end; ++it)
    result.append(it.key());
  
  return result;
}
/* end of 'src/axis/axistickertext.cpp' */


/* including file 'src/axis/axistickerpi.cpp', size 11170                    */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / axis / axistickertext.cpp'의 끝 */


/* 파일 'src / axis / axistickerpi.cpp', 크기 11170  포함*/
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPAxisTickerPi
////////////////////////////////////////////////////////////////////////////////////////////////////
/*! \class QCPAxisTickerPi
  \brief Specialized axis ticker to display ticks in units of an arbitrary constant, for example pi
  
  \image html axisticker-pi.png
  
  This QCPAxisTicker subclass generates ticks that are expressed with respect to a given symbolic
  constant with a numerical value specified with \ref setPiValue and an appearance in the tick
  labels specified with \ref setPiSymbol.
  
  Ticks may be generated at fractions of the symbolic constant. How these fractions appear in the
  tick label can be configured with \ref setFractionStyle.
  
  The ticker can be created and assigned to an axis like this:
  \snippet documentation/doc-image-generator/mainwindow.cpp axistickerpi-creation
*/
/*! \ class QCPAxisTickerPi
  \ brief 틱을 임의의 상수 단위로 표시하는 특수한 축 티커 (예 : pi)
  
  \ image html axisticker-pi.png
  
  이 QCPAxisTicker 서브 클래스는 주어진 기호와 관련하여 표현되는 틱을 생성합니다
  \ ref setPiValue로 지정된 수치와 틱의 모양을 가지는 상수
  \ ref setPiSymbol로 지정된 레이블.
  
  틱은 기호 상수의 분수에서 생성 될 수 있습니다. 이러한 분수가
  눈금 레이블은 \ ref setFractionStyle을 사용하여 구성 할 수 있습니다.
  
  티커는 다음과 같이 축에 생성되고 지정 될 수 있습니다 :
  \ snippet documentation / doc-image-generator / mainwindow.cpp axistickerpi-creation
*/

/*!
  Constructs the ticker and sets reasonable default values. Axis tickers are commonly created
  managed by a QSharedPointer, which then can be passed to QCPAxis::setTicker.
*/
/*!
  티커를 구축해, 적절한 기본값을 설정합니다. 축 시세는 일반적으로 만들어집니다
  QSharedPointer에 의해 관리되며, QSharedPointer는 QCPAxis :: setTicker로 전달 될 수 있습니다.
*/
QCPAxisTickerPi::QCPAxisTickerPi() :
  mPiSymbol(QLatin1String(" ")+QChar(0x03C0)),
  mPiValue(M_PI),
  mPeriodicity(0),
  mFractionStyle(fsUnicodeFractions),
  mPiTickStep(0)
{
  setTickCount(4);
}

/*!
  Sets how the symbol part (which is always a suffix to the number) shall appear in the axis tick
  label.
  
  If a space shall appear between the number and the symbol, make sure the space is contained in \a
  symbol.
*/
/*!
  기호 부분 (항상 숫자의 접미사 임)이 축 틱에 표시되는 방식을 설정합니다.
  상표.
  
  숫자와 기호 사이에 공백이 있으면 공백이 \ a에 포함되어 있는지 확인하십시오
  상징.
*/
void QCPAxisTickerPi::setPiSymbol(QString symbol)
{
  mPiSymbol = symbol;
}

/*!
  Sets the numerical value that the symbolic constant has.

  This will be used to place the appropriate fractions of the symbol at the respective axis
  coordinates.
*/
/*!
  기호 상수에있는 숫자 값을 설정합니다.

  이것은 각 축에 심볼의 적절한 부분을 배치하는 데 사용됩니다
  좌표.
*/
void QCPAxisTickerPi::setPiValue(double pi)
{
  mPiValue = pi;
}

/*!
  Sets whether the axis labels shall appear periodicly and if so, at which multiplicity of the
  symbolic constant.
  
  To disable periodicity, set \a multiplesOfPi to zero.
  
  For example, an axis that identifies 0 with 2pi would set \a multiplesOfPi to two.
*/
/*!
  축 레이블을 주기적으로 표시할지 여부를 설정하고, 그렇다면 축 레이블의 다중성을 표시할지 여부를 설정합니다.
  기호 상수.
  
  주기성을 비활성화하려면 \ a multiplesOfPi를 0으로 설정하십시오.
  
  예를 들어, 2pi로 0을 식별하는 축은 \ a multiplesOfPi를 2로 설정합니다.
*/
void QCPAxisTickerPi::setPeriodicity(int multiplesOfPi)
{
  mPeriodicity = qAbs(multiplesOfPi);
}

/*!
  Sets how the numerical/fractional part preceding the symbolic constant is displayed in tick
  labels. See \ref FractionStyle for the various options.
*/
/*!
  기호 상수 앞의 숫자 / 분수 부분을 틱 단위로 표시하는 방법을 설정합니다.
  레이블. 다양한 옵션에 대해서는 \ ref FractionStyle을 참조하십시오.
*/
void QCPAxisTickerPi::setFractionStyle(QCPAxisTickerPi::FractionStyle style)
{
  mFractionStyle = style;
}

/*! \internal
  
  Returns the tick step, using the constant's value (\ref setPiValue) as base unit. In consequence
  the numerical/fractional part preceding the symbolic constant is made to have a readable
  mantissa.
  
  \seebaseclassmethod
*/
/*! \내부의
  
  상수 값 (\ ref setPiValue)을 기본 단위로 사용하여 눈금 단계를 반환합니다. 결과적으로
  기호 상수 앞의 숫자 / 분수 부분을 읽을 수있게 만듭니다.
  가수.
  
  \ seebaseclassmethod
*/
double QCPAxisTickerPi::getTickStep(const QCPRange &range)
{
  mPiTickStep = range.size()/mPiValue/(double)(mTickCount+1e-10);
 // mTickCount ticks on average, the small addition is to prevent jitter on exact integers
 // 평균 mTickCount 틱, 작은 추가는 정확한 정수에서 지터를 방지하는 것입니다.
  mPiTickStep = cleanMantissa(mPiTickStep);
  return mPiTickStep*mPiValue;
}

/*! \internal
  
  Returns the sub tick count, using the constant's value (\ref setPiValue) as base unit. In
  consequence the sub ticks divide the numerical/fractional part preceding the symbolic constant
  reasonably, and not the total tick coordinate.
  
  \seebaseclassmethod
*/
/*! \내부의
  
  상수 값 (\ ref setPiValue)을 기본 단위로 사용하여 하위 눈금 수를 반환합니다. 에서
  결과 하위 틱은 기호 상수 앞의 숫자 / 분수 부분을 나눕니다
  합리적으로, 그리고 전체 틱 좌표가 아닙니다.
  
  \ seebaseclassmethod
*/
int QCPAxisTickerPi::getSubTickCount(double tickStep)
{
  return QCPAxisTicker::getSubTickCount(tickStep/mPiValue);
}

/*! \internal
  
  Returns the tick label as a fractional/numerical part and a symbolic string as suffix. The
  formatting of the fraction is done according to the specified \ref setFractionStyle. The appended
  symbol is specified with \ref setPiSymbol.
  
  \seebaseclassmethod
*/
/*! \내부의
  
  눈금 레이블을 분수 / 숫자 부분으로, 기호 문자열을 접미사로 반환합니다. 그만큼
  분수의 서식은 지정된 \ ref setFractionStyle에 따라 수행됩니다. 추가 된
  symbol은 \ ref setPiSymbol로 지정됩니다.
  
  \ seebaseclassmethod
*/
QString QCPAxisTickerPi::getTickLabel(double tick, const QLocale &locale, QChar formatChar, int precision)
{
  double tickInPis = tick/mPiValue;
  if (mPeriodicity > 0)
    tickInPis = fmod(tickInPis, mPeriodicity);
  
  if (mFractionStyle != fsFloatingPoint && mPiTickStep > 0.09 && mPiTickStep < 50)
  {
    // simply construct fraction from decimal like 1.234 -> 1234/1000 and then simplify fraction, smaller digits are irrelevant due to mPiTickStep conditional above
    // 간단히 1.234 -> 1234/1000과 같이 소수를 구성한 다음 소수를 단순화합니다. 위의 mPiTickStep 조건에 따라 더 작은 자릿수는 적합하지 않습니다.
    int denominator = 1000;
    int numerator = qRound(tickInPis*denominator);
    simplifyFraction(numerator, denominator);
    if (qAbs(numerator) == 1 && denominator == 1)
      return (numerator < 0 ? QLatin1String("-") : QLatin1String("")) + mPiSymbol.trimmed();
    else if (numerator == 0)
      return QLatin1String("0");
    else
      return fractionToString(numerator, denominator) + mPiSymbol;
  } else
  {
    if (qFuzzyIsNull(tickInPis))
      return QLatin1String("0");
    else if (qFuzzyCompare(qAbs(tickInPis), 1.0))
      return (tickInPis < 0 ? QLatin1String("-") : QLatin1String("")) + mPiSymbol.trimmed();
    else
      return QCPAxisTicker::getTickLabel(tickInPis, locale, formatChar, precision) + mPiSymbol;
  }
}

/*! \internal
  
  Takes the fraction given by \a numerator and \a denominator and modifies the values to make sure
  the fraction is in irreducible form, i.e. numerator and denominator don't share any common
  factors which could be cancelled.
*/
/*! \내부의
  
  \ a 분자와 \ 분모로 주어진 분수를 가져 와서 값을 수정하여 확실하게합니다.
  분수는 환원 불가능한 형태, 즉 분자와 분모는 공통점이 없다.
  취소 될 수있는 요소.
*/
void QCPAxisTickerPi::simplifyFraction(int &numerator, int &denominator) const
{
  if (numerator == 0 || denominator == 0)
    return;
  
  int num = numerator;
  int denom = denominator;
  while (denom != 0) // euclidean gcd algorithm
  {                  // euclidean gcd 알고리즘
    int oldDenom = denom;
    denom = num % denom;
    num = oldDenom;
  }
  // num is now gcd of numerator and denominator
  // 이제 num은 분자와 분모의 gcd입니다.
  numerator /= num;
  denominator /= num;
}

/*! \internal
  
  Takes the fraction given by \a numerator and \a denominator and returns a string representation.
  The result depends on the configured fraction style (\ref setFractionStyle).
  
  This method is used to format the numerical/fractional part when generating tick labels. It
  simplifies the passed fraction to an irreducible form using \ref simplifyFraction and factors out
  any integer parts of the fraction (e.g. "10/4" becomes "2 1/2").
*/
/*! \내부의
  
  \ a 분자와 \ 분모로 주어진 분수를 취하고 문자열 표현을 반환합니다.
  결과는 구성된 분수 스타일 (\ ref setFractionStyle)에 따라 다릅니다.
  
  이 메서드는 눈금 레이블을 생성 할 때 숫자 / 분수 부분의 서식을 지정하는 데 사용됩니다. 그것
  전달 된 분수를 \ ref simplifyFraction과 factor out을 사용하여 환원 불가능한 형태로 단순화합니다.
  분수의 정수 부분 (예 : "10/4"은 "2 1/2"이됩니다).
*/
QString QCPAxisTickerPi::fractionToString(int numerator, int denominator) const
{
  if (denominator == 0)
  {
    qDebug() << Q_FUNC_INFO << "called with zero denominator";
    return QString();
  }
  if (mFractionStyle == fsFloatingPoint) // should never be the case when calling this function
  {                                      //이 함수를 호출 할 때 절대로 사용해서는 안됩니다.
    qDebug() << Q_FUNC_INFO << "shouldn't be called with fraction style fsDecimal";
    return QString::number(numerator/(double)denominator); // failsafe
  }
  int sign = numerator*denominator < 0 ? -1 : 1;
  numerator = qAbs(numerator);
  denominator = qAbs(denominator);
  
  if (denominator == 1)
  {
    return QString::number(sign*numerator);
  } else
  {
    int integerPart = numerator/denominator;
    int remainder = numerator%denominator;
    if (remainder == 0)
    {
      return QString::number(sign*integerPart);
    } else
    {
      if (mFractionStyle == fsAsciiFractions)
      {
        return QString(QLatin1String("%1%2%3/%4"))
            .arg(sign == -1 ? QLatin1String("-") : QLatin1String(""))
            .arg(integerPart > 0 ? QString::number(integerPart)+QLatin1String(" ") : QLatin1String(""))
            .arg(remainder)
            .arg(denominator);
      } else if (mFractionStyle == fsUnicodeFractions)
      {
        return QString(QLatin1String("%1%2%3"))
            .arg(sign == -1 ? QLatin1String("-") : QLatin1String(""))
            .arg(integerPart > 0 ? QString::number(integerPart) : QLatin1String(""))
            .arg(unicodeFraction(remainder, denominator));
      }
    }
  }
  return QString();
}

/*! \internal
  
  Returns the unicode string representation of the fraction given by \a numerator and \a
  denominator. This is the representation used in \ref fractionToString when the fraction style
  (\ref setFractionStyle) is \ref fsUnicodeFractions.
  
  This method doesn't use the single-character common fractions but builds each fraction from a
  superscript unicode number, the unicode fraction character, and a subscript unicode number.
*/
/*! \내부의
  
  \ a 분자와 \ a에 의해 주어진 분수의 유니 코드 문자열 표현을 반환합니다.
  분모. \ ref fractionToString에서 사용되는 표현입니다. 분수 스타일
  (\ ref setFractionStyle)은 \ ref fsUnicodeFractions입니다.
  
  이 방법은 단일 문자 공통 분수를 사용하지 않고 각 분수를
  위 첨자 유니 코드 번호, 유니 코드 분수 문자 및 아래 첨자 유니 코드 번호가 있습니다.
*/
QString QCPAxisTickerPi::unicodeFraction(int numerator, int denominator) const
{
  return unicodeSuperscript(numerator)+QChar(0x2044)+unicodeSubscript(denominator);
}

/*! \internal
  
  Returns the unicode string representing \a number as superscript. This is used to build
  unicode fractions in \ref unicodeFraction.
*/
/*! \내부의
  
  \를 위 첨자로 나타내는 유니 코드 문자열을 반환합니다. 이것은 빌드하는 데 사용됩니다.
  \ ref unicodeFraction의 유니 코드 분수.
*/
QString QCPAxisTickerPi::unicodeSuperscript(int number) const
{
  if (number == 0)
    return QString(QChar(0x2070));
  
  QString result;
  while (number > 0)
  {
    const int digit = number%10;
    switch (digit)
    {
      case 1: { result.prepend(QChar(0x00B9)); break; }
      case 2: { result.prepend(QChar(0x00B2)); break; }
      case 3: { result.prepend(QChar(0x00B3)); break; }
      default: { result.prepend(QChar(0x2070+digit)); break; }
    }
    number /= 10;
  }
  return result;
}

/*! \internal
  
  Returns the unicode string representing \a number as subscript. This is used to build unicode
  fractions in \ref unicodeFraction.
*/
/*! \내부의
  
  \를 숫자로 나타내는 유니 코드 문자열을 아래 첨자로 반환합니다. 유니 코드를 빌드하는 데 사용됩니다.
  \ ref unicodeFraction의 분수.
*/
QString QCPAxisTickerPi::unicodeSubscript(int number) const
{
  if (number == 0)
    return QString(QChar(0x2080));
  
  QString result;
  while (number > 0)
  {
    result.prepend(QChar(0x2080+number%10));
    number /= 10;
  }
  return result;
}
/* end of 'src/axis/axistickerpi.cpp' */


/* including file 'src/axis/axistickerlog.cpp', size 7106                    */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / axis / axistickerpi.cpp'의 끝 */


/* 파일 'src / axis / axistickerlog.cpp', 크기 7106  포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPAxisTickerLog
////////////////////////////////////////////////////////////////////////////////////////////////////
/*! \class QCPAxisTickerLog
  \brief Specialized axis ticker suited for logarithmic axes
  
  \image html axisticker-log.png
  
  This QCPAxisTicker subclass generates ticks with unequal tick intervals suited for logarithmic
  axis scales. The ticks are placed at powers of the specified log base (\ref setLogBase).
  
  Especially in the case of a log base equal to 10 (the default), it might be desirable to have
  tick labels in the form of powers of ten without mantissa display. To achieve this, set the
  number precision (\ref QCPAxis::setNumberPrecision) to zero and the number format (\ref
  QCPAxis::setNumberFormat) to scientific (exponential) display with beautifully typeset decimal
  powers, so a format string of <tt>"eb"</tt>. This will result in the following axis tick labels:
  
  \image html axisticker-log-powers.png

  The ticker can be created and assigned to an axis like this:
  \snippet documentation/doc-image-generator/mainwindow.cpp axistickerlog-creation
*/
/*! \ class QCPAxisTickerLog
  \ brief 로그 축에 적합한 전문 축 시세 표시기
  
  \ image html axisticker-log.png
  
  이 QCPAxisTicker 서브 클래스는 로그에 적합한 틱 간격이 다른 틱을 생성합니다.
  축 스케일. 틱은 지정된 로그베이스 (\ ref setLogBase)의 제곱에 배치됩니다.
  
  특히 로그베이스가 10 인 경우 (기본값),
  가수를 표시하지 않고 10의 거듭 제곱 형태로 눈금을 표시하십시오. 이를 달성하려면
  숫자 정밀도 (\ ref QCPAxis :: setNumberPrecision)를 0으로, 숫자 형식 (\ ref
  QCPAxis :: setNumberFormat)를 과학적으로 (기하 급수적으로) 디스플레이에 아름답게 typeset decimal
  powers이므로 <tt> "eb"</ tt>의 형식 문자열이됩니다. 그러면 다음 축 눈금 레이블이 생깁니다.
  
  \ image html axisticker-log-powers.png

  티커는 다음과 같이 축에 생성되고 지정 될 수 있습니다 :
  \ snippet documentation / doc-image-generator / mainwindow.cpp axistickerlog-creation
*/

/*!
  Constructs the ticker and sets reasonable default values. Axis tickers are commonly created
  managed by a QSharedPointer, which then can be passed to QCPAxis::setTicker.
*/
/*!
  티커를 구축해, 적절한 기본값을 설정합니다. 축 시세는 일반적으로 만들어집니다
  QSharedPointer에 의해 관리되며, QSharedPointer는 QCPAxis :: setTicker로 전달 될 수 있습니다.
*/
QCPAxisTickerLog::QCPAxisTickerLog() :
  mLogBase(10.0),
  mSubTickCount(8), // generates 10 intervals
                    // 10 개의 간격을 생성합니다.
  mLogBaseLnInv(1.0/qLn(mLogBase))
{
}

/*!
  Sets the logarithm base used for tick coordinate generation. The ticks will be placed at integer
  powers of \a base.
*/
/*!
  틱 좌표 생성에 사용되는 대수 기본을 설정합니다. 틱은 정수에 배치됩니다.
  기본의 힘.
*/
void QCPAxisTickerLog::setLogBase(double base)
{
  if (base > 0)
  {
    mLogBase = base;
    mLogBaseLnInv = 1.0/qLn(mLogBase);
  } else
    qDebug() << Q_FUNC_INFO << "log base has to be greater than zero:" << base;
}

/*!
  Sets the number of sub ticks in a tick interval. Within each interval, the sub ticks are spaced
  linearly to provide a better visual guide, so the sub tick density increases toward the higher
  tick.
  
  Note that \a subTicks is the number of sub ticks (not sub intervals) in one tick interval. So in
  the case of logarithm base 10 an intuitive sub tick spacing would be achieved with eight sub
  ticks (the default). This means e.g. between the ticks 10 and 100 there will be eight ticks,
  namely at 20, 30, 40, 50, 60, 70, 80 and 90.
*/
/*!
  눈금 간격으로 하위 눈금 수를 설정합니다. 각 간격 내에서 하위 틱은 간격을두고 있습니다.
  더 나은 시각적 가이드를 제공하기 위해 선형 적으로, 서브 틱 밀도는 더 높은쪽으로
  진드기.
  
  \ a subTicks는 하나의 눈금 간격에있는 하위 눈금 (하위 눈금 제외)의 수입니다. 그래서
  대수 기저 (10)의 경우 직관적 인 서브 틱 간격은 8 개의 서브
  틱 (기본값). 예를 들어 틱 10과 100 사이에는 틱이 8 개,
  즉 20, 30, 40, 50, 60, 70, 80 및 90 일 때.
*/
void QCPAxisTickerLog::setSubTickCount(int subTicks)
{
  if (subTicks >= 0)
    mSubTickCount = subTicks;
  else
    qDebug() << Q_FUNC_INFO << "sub tick count can't be negative:" << subTicks;
}

/*! \internal
  
  Since logarithmic tick steps are necessarily different for each tick interval, this method does
  nothing in the case of QCPAxisTickerLog
  
  \seebaseclassmethod
*/
/*! \내부의
  
  로그 눈금 단계는 각 눈금 간격마다 반드시 다르기 때문에이 방법은
  QCPAxisTickerLog의 경우에는 아무 것도
  
  \ seebaseclassmethod
*/
double QCPAxisTickerLog::getTickStep(const QCPRange &range)
{
  // Logarithmic axis ticker has unequal tick spacing, so doesn't need this method
  // 로그 축 시세 표시기에 틱 간격이 같지 않으므로이 방법이 필요하지 않습니다.
  Q_UNUSED(range)
  return 1.0;
}

/*! \internal
  
  Returns the sub tick count specified in \ref setSubTickCount. For QCPAxisTickerLog, there is no
  automatic sub tick count calculation necessary.
  
  \seebaseclassmethod
*/
/*! \내부의
  
  \ ref setSubTickCount에 지정된 하위 틱 수를 반환합니다. QCPAxisTickerLog의 경우,
  자동 하위 틱 계산이 필요합니다.
  
  \ seebaseclassmethod
*/
int QCPAxisTickerLog::getSubTickCount(double tickStep)
{
  Q_UNUSED(tickStep)
  return mSubTickCount;
}

/*! \internal
  
  Creates ticks with a spacing given by the logarithm base and an increasing integer power in the
  provided \a range. The step in which the power increases tick by tick is chosen in order to keep
  the total number of ticks as close as possible to the tick count (\ref setTickCount). The
  parameter \a tickStep is ignored for QCPAxisTickerLog
  
  \seebaseclassmethod
*/
/*! \내부의
  
  대수베이스와 증가하는 정수 배율에 의해 주어진 간격으로 틱을 만듭니다.
  \ a 범위를 제공합니다. 진드기에 의해 진드기가 증가하는 단계는 유지하기 위해 선택됩니다.
  가능한 틱 계수에 가까운 틱의 총 갯수 (\ ref setTickCount). 그만큼
  매개 변수 \ tickStep은 QCPAxisTickerLog에 대해 무시됩니다.
  
  \ seebaseclassmethod
*/
QVector<double> QCPAxisTickerLog::createTickVector(double tickStep, const QCPRange &range)
{
  Q_UNUSED(tickStep)
  QVector<double> result;
  if (range.lower > 0 && range.upper > 0) // positive range
  {                                       // 양의 범위
    double exactPowerStep =  qLn(range.upper/range.lower)*mLogBaseLnInv/(double)(mTickCount+1e-10);
    double newLogBase = qPow(mLogBase, qMax((int)cleanMantissa(exactPowerStep), 1));
    double currentTick = qPow(newLogBase, qFloor(qLn(range.lower)/qLn(newLogBase)));
    result.append(currentTick);
    while (currentTick < range.upper && currentTick > 0) 
// currentMag might be zero for ranges ~1e-300, just cancel in that case
// currentMag는 범위 ~ 1e-300에 대해 0 일 수 있습니다.이 경우 취소하십시오.
    {
      currentTick *= newLogBase;
      result.append(currentTick);
    }
  } else if (range.lower < 0 && range.upper < 0) // negative range
  {                                              // 음수 범위
    double exactPowerStep =  qLn(range.lower/range.upper)*mLogBaseLnInv/(double)(mTickCount+1e-10);
    double newLogBase = qPow(mLogBase, qMax((int)cleanMantissa(exactPowerStep), 1));
    double currentTick = -qPow(newLogBase, qCeil(qLn(-range.lower)/qLn(newLogBase)));
    result.append(currentTick);
    while (currentTick < range.upper && currentTick < 0)
 // currentMag might be zero for ranges ~1e-300, just cancel in that case
 // currentMag는 범위 ~ 1e-300에 대해 0 일 수 있습니다.이 경우 취소하십시오.
    {
      currentTick /= newLogBase;
      result.append(currentTick);
    }
  } else // invalid range for logarithmic scale, because lower and upper have different sign
  {      // 로그 스케일의 유효 범위가 잘못되었습니다. 위와 아래에는 다른 부호가 있기 때문입니다.
    qDebug() << Q_FUNC_INFO << "Invalid range for logarithmic plot: " << range.lower << ".." << range.upper;
  }
  
  return result;
}
/* end of 'src/axis/axistickerlog.cpp' */


/* including file 'src/axis/axis.cpp', size 99397                            */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / axis / axistickerlog.cpp'의 끝 */


/* 파일 'src / axis / axis.cpp'포함, 크기 99397 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */



////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPGrid
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPGrid
  \brief Responsible for drawing the grid of a QCPAxis.
  
  This class is tightly bound to QCPAxis. Every axis owns a grid instance and uses it to draw the
  grid lines, sub grid lines and zero-line. You can interact with the grid of an axis via \ref
  QCPAxis::grid. Normally, you don't need to create an instance of QCPGrid yourself.
  
  The axis and grid drawing was split into two classes to allow them to be placed on different
  layers (both QCPAxis and QCPGrid inherit from QCPLayerable). Thus it is possible to have the grid
  in the background and the axes in the foreground, and any plottables/items in between. This
  described situation is the default setup, see the QCPLayer documentation.
*/
/*! \ class QCPGrid
  \ brief QCPAxis 그리드 그리기를 담당합니다.
  
  이 클래스는 QCPAxis에 단단히 묶여 있습니다. 모든 축은 모눈 인스턴스를 소유하며 모눈 인스턴스를 그리는 데 사용합니다.
  그리드 라인, 서브 그리드 라인 및 제로 라인. \ ref를 통해 축 그리드와 상호 작용할 수 있습니다.
  QCPAxis :: grid. 일반적으로 직접 QCPGrid의 인스턴스를 만들 필요는 없습니다.
  
  축과 그리드 도면을 두 개의 클래스로 분할하여 서로 다른 위치에 배치 할 수있게했습니다.
  레이어 (QCPAxis 및 QCPGrid는 모두 QCPLayerable에서 상속 받음). 그리드를 가질 수 있습니다.
  배경 및 전경의 축 및 그 사이에있는 모든 플롯 / 항목으로 구성됩니다. 이
  위에서 설명한 상황이 기본 설정입니다. QCPLayer 설명서를 참조하십시오.
*/

/*!
  Creates a QCPGrid instance and sets default values.
  
  You shouldn't instantiate grids on their own, since every QCPAxis brings its own QCPGrid.
*/
/*!
  QCPGrid 인스턴스를 만들고 기본값을 설정합니다.
  
  모든 QCPAxis는 자체 QCPGrid를 가져 오기 때문에 그리드를 자체적으로 인스턴스화하면 안됩니다.
*/
QCPGrid::QCPGrid(QCPAxis *parentAxis) :
  QCPLayerable(parentAxis->parentPlot(), QString(), parentAxis),
  mParentAxis(parentAxis)
{
  // warning: this is called in QCPAxis constructor, so parentAxis members should not be accessed/called
  // 경고 : QCPAxis 생성자에서 호출되므로 parentAxis 멤버에 액세스하거나 호출해서는 안됩니다.
  setParent(parentAxis);
  setPen(QPen(QColor(200,200,200), 0, Qt::DotLine));
  setSubGridPen(QPen(QColor(220,220,220), 0, Qt::DotLine));
  setZeroLinePen(QPen(QColor(200,200,200), 0, Qt::SolidLine));
  setSubGridVisible(false);
  setAntialiased(false);
  setAntialiasedSubGrid(false);
  setAntialiasedZeroLine(false);
}

/*!
  Sets whether grid lines at sub tick marks are drawn.
  
  \see setSubGridPen
*/
/*!
  준 눈금의 그리드 선을 그릴 지 여부를 설정합니다.
  
  \ setSubGridPen 참조
*/
void QCPGrid::setSubGridVisible(bool visible)
{
  mSubGridVisible = visible;
}

/*!
  Sets whether sub grid lines are drawn antialiased.
*/
/*!
  서브 그리드 선을 에일리어싱 제거할지 여부를 설정합니다.
*/
void QCPGrid::setAntialiasedSubGrid(bool enabled)
{
  mAntialiasedSubGrid = enabled;
}

/*!
  Sets whether zero lines are drawn antialiased.
*/
/*!
  제로 선을 에일리어싱 제거할지 여부를 설정합니다.
*/
void QCPGrid::setAntialiasedZeroLine(bool enabled)
{
  mAntialiasedZeroLine = enabled;
}

/*!
  Sets the pen with which (major) grid lines are drawn.
*/
/*!
  (주) 그리드 선이 그려지는 펜을 설정합니다.
*/
void QCPGrid::setPen(const QPen &pen)
{
  mPen = pen;
}

/*!
  Sets the pen with which sub grid lines are drawn.
*/
/*!
  그릴 그리드 선으로 펜을 설정합니다.
*/
void QCPGrid::setSubGridPen(const QPen &pen)
{
  mSubGridPen = pen;
}

/*!
  Sets the pen with which zero lines are drawn.
  
  Zero lines are lines at value coordinate 0 which may be drawn with a different pen than other grid
  lines. To disable zero lines and just draw normal grid lines at zero, set \a pen to Qt::NoPen.
*/
/*!
  그려지는 선이 0 인 펜을 설정합니다.
  
  0 행은 다른 좌표계와 다른 펜으로 그려지는 값 좌표 0의 선입니다.
  윤곽. 0 행을 사용하지 않고 일반 격자 선을 0으로 그리려면 \ pen을 Qt :: NoPen으로 설정하십시오.
*/
void QCPGrid::setZeroLinePen(const QPen &pen)
{
  mZeroLinePen = pen;
}

/*! \internal

  A convenience function to easily set the QPainter::Antialiased hint on the provided \a painter
  before drawing the major grid lines.

  This is the antialiasing state the painter passed to the \ref draw method is in by default.
  
  This function takes into account the local setting of the antialiasing flag as well as the
  overrides set with \ref QCustomPlot::setAntialiasedElements and \ref
  QCustomPlot::setNotAntialiasedElements.
  
  \see setAntialiased
*/
/*! \내부의

  제공된 Painter에서 QPainter :: Antialiased 힌트를 쉽게 설정할 수있는 편리한 함수입니다.
  주요 그리드 선을 그리기 전에

  화가가 \ ref draw 메서드에 전달한 앤티 엘리 어싱 상태입니다.
  
  이 함수는 앤티 엘리 어싱 플래그의 로컬 설정은 물론
  \ ref QCustomPlot :: setAntialiasedElements 및 \ ref를 사용하여 설정 한 재정의
  QCustomPlot :: setNotAntialiasedElements.
  
  \ setAntialiased 참조
*/
void QCPGrid::applyDefaultAntialiasingHint(QCPPainter *painter) const
{
  applyAntialiasingHint(painter, mAntialiased, QCP::aeGrid);
}

/*! \internal
  
  Draws grid lines and sub grid lines at the positions of (sub) ticks of the parent axis, spanning
  over the complete axis rect. Also draws the zero line, if appropriate (\ref setZeroLinePen).
*/
/*! \내부의
  
  부모 축의 틱 (tick) 위치에 그리드 선과 서브 그리드 선을 그립니다.
  완전한 축 rect 위에. 또한 필요하다면 제로 라인을 그립니다 (\ ref setZeroLinePen).
*/
void QCPGrid::draw(QCPPainter *painter)
{
  if (!mParentAxis) { qDebug() << Q_FUNC_INFO << "invalid parent axis"; return; }
  
  if (mParentAxis->subTicks() && mSubGridVisible)
    drawSubGridLines(painter);
  drawGridLines(painter);
}

/*! \internal
  
  Draws the main grid lines and possibly a zero line with the specified painter.
  
  This is a helper function called by \ref draw.
*/
/*! \내부의
  
  지정된 화가를 사용하여 주 그리드 선과 가능한 0 선을 그립니다.
  
  이것은 \ ref draw에 의해 호출되는 도우미 함수입니다.
*/
void QCPGrid::drawGridLines(QCPPainter *painter) const
{
  if (!mParentAxis) { qDebug() << Q_FUNC_INFO << "invalid parent axis"; return; }
  
  const int tickCount = mParentAxis->mTickVector.size();
  double t; // helper variable, result of coordinate-to-pixel transforms
            // 헬퍼 변수, 좌표 대 Pixel 변환 결과
  if (mParentAxis->orientation() == Qt::Horizontal)
  {
    // draw zeroline:
    // 제로린 그리기 :
    int zeroLineIndex = -1;
    if (mZeroLinePen.style() != Qt::NoPen && mParentAxis->mRange.lower < 0 && mParentAxis->mRange.upper > 0)
    {
      applyAntialiasingHint(painter, mAntialiasedZeroLine, QCP::aeZeroLine);
      painter->setPen(mZeroLinePen);
      double epsilon = mParentAxis->range().size()*1E-6; // for comparing double to zero
      for (int i=0; i<tickCount; ++i)                    // double을 0으로 비교하기 위해
      {
        if (qAbs(mParentAxis->mTickVector.at(i)) < epsilon)
        {
          zeroLineIndex = i;
          t = mParentAxis->coordToPixel(mParentAxis->mTickVector.at(i)); // x
          painter->drawLine(QLineF(t, mParentAxis->mAxisRect->bottom(), t, mParentAxis->mAxisRect->top()));
          break;
        }
      }
    }
    // draw grid lines:
    // 그리드 선 그리기 :
    applyDefaultAntialiasingHint(painter);
    painter->setPen(mPen);
    for (int i=0; i<tickCount; ++i)
    {
      if (i == zeroLineIndex) continue; // don't draw a gridline on top of the zeroline
                                        // 제로린 위에 그리드 선을 그려서는 안된다.
      t = mParentAxis->coordToPixel(mParentAxis->mTickVector.at(i)); // x
      painter->drawLine(QLineF(t, mParentAxis->mAxisRect->bottom(), t, mParentAxis->mAxisRect->top()));
    }
  } else
  {
    // draw zeroline:
    // 제로린 그리기 :
    int zeroLineIndex = -1;
    if (mZeroLinePen.style() != Qt::NoPen && mParentAxis->mRange.lower < 0 && mParentAxis->mRange.upper > 0)
    {
      applyAntialiasingHint(painter, mAntialiasedZeroLine, QCP::aeZeroLine);
      painter->setPen(mZeroLinePen);
      double epsilon = mParentAxis->mRange.size()*1E-6; // for comparing double to zero
      for (int i=0; i<tickCount; ++i)                   // double을 0으로 비교하기 위해
      {
        if (qAbs(mParentAxis->mTickVector.at(i)) < epsilon)
        {
          zeroLineIndex = i;
          t = mParentAxis->coordToPixel(mParentAxis->mTickVector.at(i)); // y
          painter->drawLine(QLineF(mParentAxis->mAxisRect->left(), t, mParentAxis->mAxisRect->right(), t));
          break;
        }
      }
    }
    // draw grid lines:
    // 그리드 선 그리기 :
    applyDefaultAntialiasingHint(painter);
    painter->setPen(mPen);
    for (int i=0; i<tickCount; ++i)
    {
      if (i == zeroLineIndex) continue; // don't draw a gridline on top of the zeroline
                                        // 제로린 위에 그리드 선을 그려서는 안된다.
      t = mParentAxis->coordToPixel(mParentAxis->mTickVector.at(i)); // y
      painter->drawLine(QLineF(mParentAxis->mAxisRect->left(), t, mParentAxis->mAxisRect->right(), t));
    }
  }
}

/*! \internal
  
  Draws the sub grid lines with the specified painter.
  
  This is a helper function called by \ref draw.
*/
/*! \내부의
  
  지정된 화가를 사용하여 서브 그리드 선을 그립니다.
  
  이것은 \ ref draw에 의해 호출되는 도우미 함수입니다.
*/
void QCPGrid::drawSubGridLines(QCPPainter *painter) const
{
  if (!mParentAxis) { qDebug() << Q_FUNC_INFO << "invalid parent axis"; return; }
  
  applyAntialiasingHint(painter, mAntialiasedSubGrid, QCP::aeSubGrid);
  double t; // helper variable, result of coordinate-to-pixel transforms
            // 헬퍼 변수, 좌표 대 픽셀 변환 결과
  painter->setPen(mSubGridPen);
  if (mParentAxis->orientation() == Qt::Horizontal)
  {
    for (int i=0; i<mParentAxis->mSubTickVector.size(); ++i)
    {
      t = mParentAxis->coordToPixel(mParentAxis->mSubTickVector.at(i)); // x
      painter->drawLine(QLineF(t, mParentAxis->mAxisRect->bottom(), t, mParentAxis->mAxisRect->top()));
    }
  } else
  {
    for (int i=0; i<mParentAxis->mSubTickVector.size(); ++i)
    {
      t = mParentAxis->coordToPixel(mParentAxis->mSubTickVector.at(i)); // y
      painter->drawLine(QLineF(mParentAxis->mAxisRect->left(), t, mParentAxis->mAxisRect->right(), t));
    }
  }
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPAxis
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPAxis
  \brief Manages a single axis inside a QCustomPlot.

  Usually doesn't need to be instantiated externally. Access %QCustomPlot's default four axes via
  QCustomPlot::xAxis (bottom), QCustomPlot::yAxis (left), QCustomPlot::xAxis2 (top) and
  QCustomPlot::yAxis2 (right).
  
  Axes are always part of an axis rect, see QCPAxisRect.
  \image html AxisNamesOverview.png
  <center>Naming convention of axis parts</center>
  \n
    
  \image html AxisRectSpacingOverview.png
  <center>Overview of the spacings and paddings that define the geometry of an axis. The dashed gray line
  on the left represents the QCustomPlot widget border.</center>
  
  Each axis holds an instance of QCPAxisTicker which is used to generate the tick coordinates and
  tick labels. You can access the currently installed \ref ticker or set a new one (possibly one of
  the specialized subclasses, or your own subclass) via \ref setTicker. For details, see the
  documentation of QCPAxisTicker.
*/
/*! \ class QCPAxis
  \ brief QCustomPlot 내부의 단일 축을 관리합니다.

  일반적으로 외부 적으로 인스턴스화 할 필요는 없습니다. 를 통해 % QCustomPlot의 기본 4 축 액세스
  QCustomPlot :: xAxis (아래쪽), QCustomPlot :: yAxis (왼쪽), QCustomPlot :: xAxis2 (위쪽) 및
  QCustomPlot :: yAxis2 (오른쪽).
  
  축은 항상 축 rect의 일부입니다 (QCPAxisRect 참조).
  \ image html AxisNamesOverview.png
  <center> 축 부분의 명명 규칙 </ center>
  \엔
    
  \ image html AxisRectSpacingOverview.png
  <center> 축의 형상을 정의하는 간격 및 패딩 개요입니다. 회색 점선
  왼쪽의 QCustomPlot 위젯 테두리를 나타냅니다. </ center>
  
  각 축은 틱 좌표를 생성하는 데 사용되는 QCPAxisTicker의 인스턴스를 보유하고
  눈금 레이블. 현재 설치된 \ ref 시세 표시기에 액세스하거나 새로운 시세 표시기를 설정할 수 있습니다 (아마도
  특수 하위 클래스 또는 자신의 하위 클래스)를 \ ref setTicker를 통해 가져올 수 있습니다. 자세한 내용은
  QCPAxisTicker의 문서화.
*/

/* start of documentation of inline functions */
/* 인라인 함수의 문서화 시작 */

/*! \fn Qt::Orientation QCPAxis::orientation() const

  Returns the orientation of this axis. The axis orientation (horizontal or vertical) is deduced
  from the axis type (left, top, right or bottom).

  \see orientation(AxisType type), pixelOrientation
*/
/*! \ fn Qt :: Orientation QCPAxis :: orientation () const

  이 축의 방향을 돌려줍니다. 축 방향 (수평 또는 수직)이 추론됩니다.
  축 유형 (왼쪽, 위, 오른쪽 또는 아래)에서.

  \ 방향 (AxisType 유형), pixelOrientation
*/

/*! \fn QCPGrid *QCPAxis::grid() const
  
  Returns the \ref QCPGrid instance belonging to this axis. Access it to set details about the way the
  grid is displayed.
*/
/*! \ fn QCPGrid * QCPAxis :: grid () const
  
  이 축에 속하는 \ ref QCPGrid 인스턴스를 반환합니다. 액세스 방법에 대한 세부 정보를 설정하려면
  그리드가 표시됩니다.
*/

/*! \fn static Qt::Orientation QCPAxis::orientation(AxisType type)

  Returns the orientation of the specified axis type

  \see orientation(), pixelOrientation
*/
/*! \ fn 정적 Qt :: Orientation QCPAxis :: orientation (AxisType 타입)

  지정된 축 유형의 방향을 반환합니다.

  \ see orientation (), pixelOrientation
*/

/*! \fn int QCPAxis::pixelOrientation() const

  Returns which direction points towards higher coordinate values/keys, in pixel space.

  This method returns either 1 or -1. If it returns 1, then going in the positive direction along
  the orientation of the axis in pixels corresponds to going from lower to higher axis coordinates.
  On the other hand, if this method returns -1, going to smaller pixel values corresponds to going
  from lower to higher axis coordinates.

  For example, this is useful to easily shift axis coordinates by a certain amount given in pixels,
  without having to care about reversed or vertically aligned axes:

  \code
  double newKey = keyAxis->pixelToCoord(keyAxis->coordToPixel(oldKey)+10*keyAxis->pixelOrientation());
  \endcode

  \a newKey will then contain a key that is ten pixels towards higher keys, starting from \a oldKey.
*/
/*! \ fn int QCPAxis :: pixelOrientation () const

  픽셀 공간에서 높은 좌표 값 / 키 방향으로 향하는 점을 반환합니다.

  이 메서드는 1 또는 -1을 반환합니다. 1을 반환하면 양의 방향으로 이동합니다.
  픽셀 단위 축의 방향은 낮은 축 좌표에서 높은 축 좌표로 이동하는 것과 일치합니다.
  한편이 메서드가 -1을 반환하면 작은 픽셀 값으로 이동하면
  낮은 축 좌표에서 높은 축 좌표로.

  예를 들어, 이것은 축 좌표를 픽셀 단위로 주어진 양만큼 쉽게 이동 시키는데 유용합니다.
  반전되거나 수직으로 정렬 된 축에 대해 신경을 쓰지 않아도됩니다.

  \암호
  double newKey = keyAxis-> pixelToCoord (keyAxis-> coordToPixel (oldKey) + 10 * keyAxis-> pixelOrientation ());
  \ endcode

  \ newKey는 \ oldKey에서 시작하여 상위 키쪽으로 10 픽셀의 키를 포함합니다.
*/

/*! \fn QSharedPointer<QCPAxisTicker> QCPAxis::ticker() const

  Returns a modifiable shared pointer to the currently installed axis ticker. The axis ticker is
  responsible for generating the tick positions and tick labels of this axis. You can access the
  \ref QCPAxisTicker with this method and modify basic properties such as the approximate tick count
  (\ref QCPAxisTicker::setTickCount).

  You can gain more control over the axis ticks by setting a different \ref QCPAxisTicker subclass, see
  the documentation there. A new axis ticker can be set with \ref setTicker.

  Since the ticker is stored in the axis as a shared pointer, multiple axes may share the same axis
  ticker simply by passing the same shared pointer to multiple axes.

  \see setTicker
*/
/*! \ fn QSharedPointer <QCPAxisTicker> QCPAxis :: ticker () const

  현재 설치되어있는 축 티커에 대한 수정 가능한 공유 포인터를 반환합니다. 축 시세 표시기입니다.
  이 축의 눈금 위치 및 눈금 레이블을 생성합니다. 당신은
  \ ref QCPAxisTicker에이 메서드를 추가하고 대략적인 틱 수와 같은 기본 속성을 수정합니다.
  (\ ref QCPAxisTicker :: setTickCount).

  다른 \ ref QCPAxisTicker 서브 클래스를 설정하면 축 틱을보다 잘 제어 할 수 있습니다.
  거기에있는 문서들. 새로운 축 티커는 \ ref setTicker로 설정할 수 있습니다.

  시세 표시기는 공유 포인터로 축에 저장되기 때문에 여러 축이 같은 축을 공유 할 수 있습니다
  똑같은 공유 포인터를 여러 축으로 전달하면됩니다.

  \ setTicker 참조
*/

/* end of documentation of inline functions */
/* start of documentation of signals */
/* 인라인 함수의 문서 끝 */
/* 신호 문서화 */

/*! \fn void QCPAxis::rangeChanged(const QCPRange &newRange)

  This signal is emitted when the range of this axis has changed. You can connect it to the \ref
  setRange slot of another axis to communicate the new range to the other axis, in order for it to
  be synchronized.
  
  You may also manipulate/correct the range with \ref setRange in a slot connected to this signal.
  This is useful if for example a maximum range span shall not be exceeded, or if the lower/upper
  range shouldn't go beyond certain values (see \ref QCPRange::bounded). For example, the following
  slot would limit the x axis to ranges between 0 and 10:
  \code
  customPlot->xAxis->setRange(newRange.bounded(0, 10))
  \endcode
*/
/*! \ fn void QCPAxis :: rangeChanged (const QCPRange & newRange)

  이 축의 범위가 변경되면이 신호가 방출됩니다. \ ref에 연결할 수 있습니다.
  새로운 축을 다른 축과 통신하기 위해 다른 축의 setRange 슬롯.
  동기화 되십시오.
  
  이 신호에 연결된 슬롯에서 \ ref setRange를 사용하여 범위를 조작하거나 수정할 수도 있습니다.
  예를 들어, 최대 범위를 초과해서는 안되며, 아래쪽 / 위쪽
  범위가 특정 값을 초과하면 안됩니다 (\ ref QCPRange :: bounded 참조). 예를 들어 다음과 같습니다.
  슬롯은 x 축을 0과 10 사이의 범위로 제한합니다.
  \암호
  customPlot-> xAxis-> setRange (newRange.bounded (0, 10))
  \ endcode
*/

/*! \fn void QCPAxis::rangeChanged(const QCPRange &newRange, const QCPRange &oldRange)
  \overload
  
  Additionally to the new range, this signal also provides the previous range held by the axis as
  \a oldRange.
*/
/*! \ fn void QCPAxis :: rangeChanged (const QCPRange & newRange, const QCPRange & oldRange)
  \초과 적재
  
  또한 새로운 범위에이 신호는 축에 의해 보유 된 이전 범위를
  \ oldRange.
*/

/*! \fn void QCPAxis::scaleTypeChanged(QCPAxis::ScaleType scaleType);
  
  This signal is emitted when the scale type changes, by calls to \ref setScaleType
*/
/*! \ fn void QCPAxis :: scaleTypeChanged (QCPAxis :: ScaleType scaleType);
  
  이 신호는 스케일 유형이 변경 될 때, \ ref setScaleType
*/

/*! \fn void QCPAxis::selectionChanged(QCPAxis::SelectableParts selection)
  
  This signal is emitted when the selection state of this axis has changed, either by user interaction
  or by a direct call to \ref setSelectedParts.
*/
/*! \ fn void QCPAxis :: selectionChanged (QCPAxis :: SelectableParts 선택)
  
  이 신호는이 축의 선택 상태가 사용자 상호 작용에 의해 변경되면 방출됩니다.
  또는 \ ref setSelectedParts에 대한 직접 호출에 의해 수행됩니다.
*/

/*! \fn void QCPAxis::selectableChanged(const QCPAxis::SelectableParts &parts);
  
  This signal is emitted when the selectability changes, by calls to \ref setSelectableParts
*/
/*! \ fn void QCPAxis :: selectableChanged (const QCPAxis :: SelectableParts & parts);
  
  이 신호는 선택 가능성이 변경되면 \ ref setSelectableParts를 호출하여 방출됩니다.
*/

/* end of documentation of signals */
/* 신호의 문서화 끝 */

/*!
  Constructs an Axis instance of Type \a type for the axis rect \a parent.
  
  Usually it isn't necessary to instantiate axes directly, because you can let QCustomPlot create
  them for you with \ref QCPAxisRect::addAxis. If you want to use own QCPAxis-subclasses however,
  create them manually and then inject them also via \ref QCPAxisRect::addAxis.
*/
/*!
  축 rect \ a의 축의 Type \ a 형의 Axis 인스턴스를 구축합니다.
  
  일반적으로 축을 직접 인스턴스화 할 필요는 없습니다. QCustomPlot을 사용하여
  \ ref QCPAxisRect :: addAxis로 당신을 위해 그들을. 그러나 독자적인 QCPAxis-subclasses를 사용하려는 경우,
  수동으로 생성 한 다음 \ ref QCPAxisRect :: addAxis를 통해 주입 할 수도 있습니다.
*/
QCPAxis::QCPAxis(QCPAxisRect *parent, AxisType type) :
  QCPLayerable(parent->parentPlot(), QString(), parent),
  // axis base:
  // 축베이스 :
  mAxisType(type),
  mAxisRect(parent),
  mPadding(5),
  mOrientation(orientation(type)),
  mSelectableParts(spAxis | spTickLabels | spAxisLabel),
  mSelectedParts(spNone),
  mBasePen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),
  mSelectedBasePen(QPen(Qt::blue, 2)),
  // axis label:
  // 축 레이블 :
  mLabel(),
  mLabelFont(mParentPlot->font()),
  mSelectedLabelFont(QFont(mLabelFont.family(), mLabelFont.pointSize(), QFont::Bold)),
  mLabelColor(Qt::black),
  mSelectedLabelColor(Qt::blue),
  // tick labels:
  // 눈금 표시 :
  mTickLabels(true),
  mTickLabelFont(mParentPlot->font()),
  mSelectedTickLabelFont(QFont(mTickLabelFont.family(), mTickLabelFont.pointSize(), QFont::Bold)),
  mTickLabelColor(Qt::black),
  mSelectedTickLabelColor(Qt::blue),
  mNumberPrecision(6),
  mNumberFormatChar('g'),
  mNumberBeautifulPowers(true),
  // ticks and subticks:
  // 틱 및 하위 태그 :
  mTicks(true),
  mSubTicks(true),
  mTickPen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),
  mSelectedTickPen(QPen(Qt::blue, 2)),
  mSubTickPen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),
  mSelectedSubTickPen(QPen(Qt::blue, 2)),
  // scale and range:
  // 축척 및 범위 :
  mRange(0, 5),
  mRangeReversed(false),
  mScaleType(stLinear),
  // internal members:
  // 내부 멤버 :
  mGrid(new QCPGrid(this)),
  mAxisPainter(new QCPAxisPainterPrivate(parent->parentPlot())),
  mTicker(new QCPAxisTicker),
  mCachedMarginValid(false),
  mCachedMargin(0)
{
  setParent(parent);
  mGrid->setVisible(false);
  setAntialiased(false);
  setLayer(mParentPlot->currentLayer());
 // it's actually on that layer already, but we want it in front of the grid, so we place it on there again
 // 실제로 이미 그 레이어에 있지만 우리는 그리드 앞에 놓기를 원하기 때문에 다시 그 위에 놓습니다.
  if (type == atTop)
  {
    setTickLabelPadding(3);
    setLabelPadding(6);
  } else if (type == atRight)
  {
    setTickLabelPadding(7);
    setLabelPadding(12);
  } else if (type == atBottom)
  {
    setTickLabelPadding(3);
    setLabelPadding(3);
  } else if (type == atLeft)
  {
    setTickLabelPadding(5);
    setLabelPadding(10);
  }
}

QCPAxis::~QCPAxis()
{
  delete mAxisPainter;
  delete mGrid; // delete grid here instead of via parent ~QObject for better defined deletion order
                // 더 나은 정의 된 삭제 순서를 위해 parent ~ QObject를 사용하는 대신 여기에서 그리드를 삭제하십시오.
  
}

/* No documentation as it is a property getter */
/* 속성 getter이므로 문서가 없습니다 */
int QCPAxis::tickLabelPadding() const
{
  return mAxisPainter->tickLabelPadding;
}

/* No documentation as it is a property getter */
/* 속성 getter이므로 문서가 없습니다 */
double QCPAxis::tickLabelRotation() const
{
  return mAxisPainter->tickLabelRotation;
}

/* No documentation as it is a property getter */
/* 속성 getter이므로 문서가 없습니다 */
QCPAxis::LabelSide QCPAxis::tickLabelSide() const
{
  return mAxisPainter->tickLabelSide;
}

/* No documentation as it is a property getter */
/* 속성 getter이므로 문서가 없습니다 */
QString QCPAxis::numberFormat() const
{
  QString result;
  result.append(mNumberFormatChar);
  if (mNumberBeautifulPowers)
  {
    result.append(QLatin1Char('b'));
    if (mAxisPainter->numberMultiplyCross)
      result.append(QLatin1Char('c'));
  }
  return result;
}

/* No documentation as it is a property getter */
/* 속성 getter이므로 문서가 없습니다 */
int QCPAxis::tickLengthIn() const
{
  return mAxisPainter->tickLengthIn;
}

/* No documentation as it is a property getter */
/* 속성 getter이므로 문서가 없습니다 */
int QCPAxis::tickLengthOut() const
{
  return mAxisPainter->tickLengthOut;
}

/* No documentation as it is a property getter */
/* 속성 getter이므로 문서가 없습니다 */
int QCPAxis::subTickLengthIn() const
{
  return mAxisPainter->subTickLengthIn;
}

/* No documentation as it is a property getter */
/* 속성 getter이므로 문서가 없습니다 */
int QCPAxis::subTickLengthOut() const
{
  return mAxisPainter->subTickLengthOut;
}

/* No documentation as it is a property getter */
/* 속성 getter이므로 문서가 없습니다 */
int QCPAxis::labelPadding() const
{
  return mAxisPainter->labelPadding;
}

/* No documentation as it is a property getter */
/* 속성 getter이므로 문서가 없습니다 */
int QCPAxis::offset() const
{
  return mAxisPainter->offset;
}

/* No documentation as it is a property getter */
/* 속성 getter이므로 문서가 없습니다 */
QCPLineEnding QCPAxis::lowerEnding() const
{
  return mAxisPainter->lowerEnding;
}

/* No documentation as it is a property getter */
/* 속성 getter이므로 문서가 없습니다 */
QCPLineEnding QCPAxis::upperEnding() const
{
  return mAxisPainter->upperEnding;
}

/*!
  Sets whether the axis uses a linear scale or a logarithmic scale.
  
  Note that this method controls the coordinate transformation. You will likely also want to use a
  logarithmic tick spacing and labeling, which can be achieved by setting an instance of \ref
  QCPAxisTickerLog via \ref setTicker. See the documentation of \ref QCPAxisTickerLog about the
  details of logarithmic axis tick creation.
  
  \ref setNumberPrecision
*/
/*!
  축이 선형 눈금 또는 로그 눈금을 사용하는지 여부를 설정합니다.
  
  이 메서드는 좌표 변환을 제어합니다. 당신은 또한
  로그 눈금 간격과 라벨링은 \ ref의 인스턴스를 설정하여 얻을 수 있습니다.
  \ ref setTicker를 통한 QCPAxisTickerLog. \ ref QCPAxisTickerLog의 설명서를 참조하십시오.
  로그 축 눈금 생성의 세부 사항.
  
  \ ref setNumberPrecision
*/
void QCPAxis::setScaleType(QCPAxis::ScaleType type)
{
  if (mScaleType != type)
  {
    mScaleType = type;
    if (mScaleType == stLogarithmic)
      setRange(mRange.sanitizedForLogScale());
    mCachedMarginValid = false;
    emit scaleTypeChanged(mScaleType);
  }
}

/*!
  Sets the range of the axis.
  
  This slot may be connected with the \ref rangeChanged signal of another axis so this axis
  is always synchronized with the other axis range, when it changes.
  
  To invert the direction of an axis, use \ref setRangeReversed.
*/
/*!
  축의 범위를 설정합니다.
  
  이 슬롯은 다른 축의 \ ref rangeChanged 신호와 연결될 수 있으므로이 축
  변경 될 때 항상 다른 축 범위와 동기화됩니다.
  
  축의 방향을 반전하려면 \ ref setRangeReversed를 사용하십시오.
*/
void QCPAxis::setRange(const QCPRange &range)
{
  if (range.lower == mRange.lower && range.upper == mRange.upper)
    return;
  
  if (!QCPRange::validRange(range)) return;
  QCPRange oldRange = mRange;
  if (mScaleType == stLogarithmic)
  {
    mRange = range.sanitizedForLogScale();
  } else
  {
    mRange = range.sanitizedForLinScale();
  }
  emit rangeChanged(mRange);
  emit rangeChanged(mRange, oldRange);
}

/*!
  Sets whether the user can (de-)select the parts in \a selectable by clicking on the QCustomPlot surface.
  (When \ref QCustomPlot::setInteractions contains iSelectAxes.)
  
  However, even when \a selectable is set to a value not allowing the selection of a specific part,
  it is still possible to set the selection of this part manually, by calling \ref setSelectedParts
  directly.
  
  \see SelectablePart, setSelectedParts
*/
/*!
  사용자가 QCustomPlot 표면을 클릭하여 선택 가능한 부품을 선택할 수 있는지 여부를 설정합니다.
  (\ ref QCustomPlot :: setInteractions에는 iSelectAxes가 포함됩니다.)
  
  그러나 \ a 선택 항목이 특정 부분의 선택을 허용하지 않는 값으로 설정된 경우에도,
  \ ref setSelectedParts를 호출하여 수동으로이 부분의 선택을 설정할 수도 있습니다.
  직접.
  
  \ SelectablePart, setSelectedParts를 참조하십시오.
*/
void QCPAxis::setSelectableParts(const SelectableParts &selectable)
{
  if (mSelectableParts != selectable)
  {
    mSelectableParts = selectable;
    emit selectableChanged(mSelectableParts);
  }
}

/*!
  Sets the selected state of the respective axis parts described by \ref SelectablePart. When a part
  is selected, it uses a different pen/font.
  
  The entire selection mechanism for axes is handled automatically when \ref
  QCustomPlot::setInteractions contains iSelectAxes. You only need to call this function when you
  wish to change the selection state manually.
  
  This function can change the selection state of a part, independent of the \ref setSelectableParts setting.
  
  emits the \ref selectionChanged signal when \a selected is different from the previous selection state.
  
  \see SelectablePart, setSelectableParts, selectTest, setSelectedBasePen, setSelectedTickPen, setSelectedSubTickPen,
  setSelectedTickLabelFont, setSelectedLabelFont, setSelectedTickLabelColor, setSelectedLabelColor
*/
/*!
  \ ref SelectablePart에서 설명한 각 축 부분의 선택된 상태를 설정합니다. 부품
  이 옵션을 선택하면 다른 펜 / 글꼴을 사용합니다.
  
  축의 전체 선택 메커니즘은 \ ref가 실행될 때 자동으로 처리됩니다.
  QCustomPlot :: setInteractions에는 iSelectAxes가 포함됩니다. 이 함수는 여러분이
  수동으로 선택 상태를 변경하려고합니다.
  
  이 함수는 \ ref setSelectableParts 설정과 관계없이 파트의 선택 상태를 변경할 수 있습니다.
  
  선택이 이전 선택 상태와 다른 경우 \ ref selectionChanged 신호를 내 보냅니다.
  
  \ SelectablePart, setSelectableParts, selectTest, setSelectedBasePen, setSelectedTickPen, setSelectedSubTickPen,
  setSelectedTickLabelFont, setSelectedLabelFont, setSelectedTickLabelColor, setSelectedLabelColor
*/
void QCPAxis::setSelectedParts(const SelectableParts &selected)
{
  if (mSelectedParts != selected)
  {
    mSelectedParts = selected;
    emit selectionChanged(mSelectedParts);
  }
}

/*!
  \overload
  
  Sets the lower and upper bound of the axis range.
  
  To invert the direction of an axis, use \ref setRangeReversed.
  
  There is also a slot to set a range, see \ref setRange(const QCPRange &range).
*/
/*!
  \초과 적재
  
  축 범위의 하한과 상한을 설정합니다.
  
  축의 방향을 반전하려면 \ ref setRangeReversed를 사용하십시오.
  
  범위를 설정하는 슬롯도 있습니다. \ ref setRange (const QCPRange & range)를 참조하십시오.
*/
void QCPAxis::setRange(double lower, double upper)
{
  if (lower == mRange.lower && upper == mRange.upper)
    return;
  
  if (!QCPRange::validRange(lower, upper)) return;
  QCPRange oldRange = mRange;
  mRange.lower = lower;
  mRange.upper = upper;
  if (mScaleType == stLogarithmic)
  {
    mRange = mRange.sanitizedForLogScale();
  } else
  {
    mRange = mRange.sanitizedForLinScale();
  }
  emit rangeChanged(mRange);
  emit rangeChanged(mRange, oldRange);
}

/*!
  \overload
  
  Sets the range of the axis.
  
  The \a position coordinate indicates together with the \a alignment parameter, where the new
  range will be positioned. \a size defines the size of the new axis range. \a alignment may be
  Qt::AlignLeft, Qt::AlignRight or Qt::AlignCenter. This will cause the left border, right border,
  or center of the range to be aligned with \a position. Any other values of \a alignment will
  default to Qt::AlignCenter.
*/
/*!
  \초과 적재
  
  축의 범위를 설정합니다.
  
  \ a 위치 좌표는 \ a 정렬 매개 변수와 함께 표시되며 여기서 새
  범위가 지정됩니다. \ a 크기는 새 축 범위의 크기를 정의합니다. 정렬은
  Qt :: AlignLeft, Qt :: AlignRight 또는 Qt :: AlignCenter. 이렇게하면 왼쪽 테두리, 오른쪽 테두리,
  또는 범위의 중심을 \ a 위치로 정렬합니다. \ a 정렬의 다른 값은
  기본값은 Qt :: AlignCenter입니다.
*/
void QCPAxis::setRange(double position, double size, Qt::AlignmentFlag alignment)
{
  if (alignment == Qt::AlignLeft)
    setRange(position, position+size);
  else if (alignment == Qt::AlignRight)
    setRange(position-size, position);
  else // alignment == Qt::AlignCenter
    setRange(position-size/2.0, position+size/2.0);
}

/*!
  Sets the lower bound of the axis range. The upper bound is not changed.
  \see setRange
*/
/*!
  축 범위의 하한을 설정합니다. 상한은 변경되지 않습니다.
  \ 참조 setRange
*/
void QCPAxis::setRangeLower(double lower)
{
  if (mRange.lower == lower)
    return;
  
  QCPRange oldRange = mRange;
  mRange.lower = lower;
  if (mScaleType == stLogarithmic)
  {
    mRange = mRange.sanitizedForLogScale();
  } else
  {
    mRange = mRange.sanitizedForLinScale();
  }
  emit rangeChanged(mRange);
  emit rangeChanged(mRange, oldRange);
}

/*!
  Sets the upper bound of the axis range. The lower bound is not changed.
  \see setRange
*/
/*!
  축 범위의 하한을 설정합니다. 상한은 변경되지 않습니다.
  \ 참조 setRange
*/
void QCPAxis::setRangeUpper(double upper)
{
  if (mRange.upper == upper)
    return;
  
  QCPRange oldRange = mRange;
  mRange.upper = upper;
  if (mScaleType == stLogarithmic)
  {
    mRange = mRange.sanitizedForLogScale();
  } else
  {
    mRange = mRange.sanitizedForLinScale();
  }
  emit rangeChanged(mRange);
  emit rangeChanged(mRange, oldRange);
}

/*!
  Sets whether the axis range (direction) is displayed reversed. Normally, the values on horizontal
  axes increase left to right, on vertical axes bottom to top. When \a reversed is set to true, the
  direction of increasing values is inverted.

  Note that the range and data interface stays the same for reversed axes, e.g. the \a lower part
  of the \ref setRange interface will still reference the mathematically smaller number than the \a
  upper part.
*/
/*!
  축의 범위 (방향)를 반전 표시할지 어떨지를 설정합니다. 일반적으로 가로의 값
  축은 왼쪽에서 오른쪽으로, 수직 축에서 아래에서 위로 증가합니다. \ a 반전을 true로 설정하면
  증가하는 값의 방향이 반전됩니다.

  범위 및 데이터 인터페이스는 반전 된 축에 대해 동일하게 유지됩니다 (예 : \ a 아래 부분).
  \ ref setRange 인터페이스의 숫자는 여전히 \ a보다 수학적으로 작은 숫자를 참조합니다
  윗 부분.
*/
void QCPAxis::setRangeReversed(bool reversed)
{
  mRangeReversed = reversed;
}

/*!
  The axis ticker is responsible for generating the tick positions and tick labels. See the
  documentation of QCPAxisTicker for details on how to work with axis tickers.
  
  You can change the tick positioning/labeling behaviour of this axis by setting a different
  QCPAxisTicker subclass using this method. If you only wish to modify the currently installed axis
  ticker, access it via \ref ticker.
  
  Since the ticker is stored in the axis as a shared pointer, multiple axes may share the same axis
  ticker simply by passing the same shared pointer to multiple axes.
  
  \see ticker
*/
/*!
  축 티커는 틱 위치 및 틱 레이블을 생성합니다. 자세한 내용은
  축 시큐어로 작업하는 방법에 대한 자세한 내용은 QCPAxisTicker 문서를 참조하십시오.
  
  다른 점을 설정하여이 축의 눈금 배치 / 레이블링 동작을 변경할 수 있습니다.
  이 메소드를 사용하는 QCPAxisTicker 서브 클래스. 현재 설치된 축만 수정하려는 경우
  티커, \ ref 시세를 통해 액세스하십시오.
  
  시세 표시기는 공유 포인터로 축에 저장되기 때문에 여러 축이 같은 축을 공유 할 수 있습니다
  똑같은 공유 포인터를 여러 축으로 전달하면됩니다.
  
  \ 시세 표시
*/
void QCPAxis::setTicker(QSharedPointer<QCPAxisTicker> ticker)
{
  if (ticker)
    mTicker = ticker;
  else
    qDebug() << Q_FUNC_INFO << "can not set 0 as axis ticker";
  // no need to invalidate margin cache here because produced tick labels are checked for changes in setupTickVector
  // 생성 된 틱 레이블이 setupTickVector의 변경 사항을 검사하기 때문에 여백 캐시를 무효화 할 필요가 없습니다.
}

/*!
  Sets whether tick marks are displayed.

  Note that setting \a show to false does not imply that tick labels are invisible, too. To achieve
  that, see \ref setTickLabels.
  
  \see setSubTicks
*/
/*!
  눈금을 표시할지 여부를 설정합니다.

  \ a show를 false로 설정해도 눈금 표시가 보이지 않음을 의미하지는 않습니다. 달성하기 위해
  그건, \ ref setTickLabels를 봐라.
  
  \ see setSubTicks
*/
void QCPAxis::setTicks(bool show)
{
  if (mTicks != show)
  {
    mTicks = show;
    mCachedMarginValid = false;
  }
}

/*!
  Sets whether tick labels are displayed. Tick labels are the numbers drawn next to tick marks.
*/
/*!
  눈금 레이블을 표시할지 여부를 설정합니다. 눈금 표시는 눈금 옆에 그려지는 숫자입니다.
*/
void QCPAxis::setTickLabels(bool show)
{
  if (mTickLabels != show)
  {
    mTickLabels = show;
    mCachedMarginValid = false;
    if (!mTickLabels)
      mTickVectorLabels.clear();
  }
}

/*!
  Sets the distance between the axis base line (including any outward ticks) and the tick labels.
  \see setLabelPadding, setPadding
*/
/*!
  축 기준선 (바깥 쪽 눈금을 포함하여)과 눈금 레이블 사이의 거리를 설정합니다.
  \ setLabelPadding, setPadding을 참조하십시오.
*/
void QCPAxis::setTickLabelPadding(int padding)
{
  if (mAxisPainter->tickLabelPadding != padding)
  {
    mAxisPainter->tickLabelPadding = padding;
    mCachedMarginValid = false;
  }
}

/*!
  Sets the font of the tick labels.
  
  \see setTickLabels, setTickLabelColor
*/
/*!
  눈금 레이블의 글꼴을 설정합니다.
  
  \ setTickLabels, setTickLabelColor를 참조하십시오.
*/
void QCPAxis::setTickLabelFont(const QFont &font)
{
  if (font != mTickLabelFont)
  {
    mTickLabelFont = font;
    mCachedMarginValid = false;
  }
}

/*!
  Sets the color of the tick labels.
  
  \see setTickLabels, setTickLabelFont
*/
/*!
  눈금 레이블의 색상을 설정합니다.
  
  \ setTickLabels, setTickLabelFont 참조하십시오.
*/
void QCPAxis::setTickLabelColor(const QColor &color)
{
  mTickLabelColor = color;
}

/*!
  Sets the rotation of the tick labels. If \a degrees is zero, the labels are drawn normally. Else,
  the tick labels are drawn rotated by \a degrees clockwise. The specified angle is bound to values
  from -90 to 90 degrees.
  
  If \a degrees is exactly -90, 0 or 90, the tick labels are centered on the tick coordinate. For
  other angles, the label is drawn with an offset such that it seems to point toward or away from
  the tick mark.
*/
/*!
  눈금 레이블의 회전을 설정합니다. \ degrees가 0이면 레이블이 정상적으로 그려집니다. 그밖에,
  눈금 레이블은 시계 방향으로 \ a도 회전됩니다. 지정된 각도는 값에 바인드됩니다.
  -90도에서 90도까지.
  
  \ a degrees가 정확히 -90, 0 또는 90 인 경우 눈금 레이블은 눈금 좌표의 가운데에 배치됩니다. 에 대한
  다른 각도로 레이블을 붙이면 레이블은 오프셋을 사용하여 그 방향으로 또는 멀리
  눈금.
*/
void QCPAxis::setTickLabelRotation(double degrees)
{
  if (!qFuzzyIsNull(degrees-mAxisPainter->tickLabelRotation))
  {
    mAxisPainter->tickLabelRotation = qBound(-90.0, degrees, 90.0);
    mCachedMarginValid = false;
  }
}

/*!
  Sets whether the tick labels (numbers) shall appear inside or outside the axis rect.
  
  The usual and default setting is \ref lsOutside. Very compact plots sometimes require tick labels
  to be inside the axis rect, to save space. If \a side is set to \ref lsInside, the tick labels
  appear on the inside are additionally clipped to the axis rect.
*/
/*!
  눈금 레이블 (숫자)이 축 rect 내부 또는 외부에 나타날지 여부를 설정합니다.
  
  일반적으로 기본 설정은 \ ref lsOutside입니다. 매우 컴팩트 한 플롯에는 눈금 라벨이 필요할 때도 있습니다.
  공간을 절약하기 위해 rect 축 안쪽에 있어야합니다. \ a면이 \ ref 내부에 설정된 경우 틱 레이블
  안쪽에 나타나는 것은 축 rect에 추가로 잘립니다.
*/
void QCPAxis::setTickLabelSide(LabelSide side)
{
  mAxisPainter->tickLabelSide = side;
  mCachedMarginValid = false;
}

/*!
  Sets the number format for the numbers in tick labels. This \a formatCode is an extended version
  of the format code used e.g. by QString::number() and QLocale::toString(). For reference about
  that, see the "Argument Formats" section in the detailed description of the QString class.
  
  \a formatCode is a string of one, two or three characters. The first character is identical to
  the normal format code used by Qt. In short, this means: 'e'/'E' scientific format, 'f' fixed
  format, 'g'/'G' scientific or fixed, whichever is shorter.
  
  The second and third characters are optional and specific to QCustomPlot:\n
  If the first char was 'e' or 'g', numbers are/might be displayed in the scientific format, e.g.
  "5.5e9", which is ugly in a plot. So when the second char of \a formatCode is set to 'b' (for
  "beautiful"), those exponential numbers are formatted in a more natural way, i.e. "5.5
  [multiplication sign] 10 [superscript] 9". By default, the multiplication sign is a centered dot.
  If instead a cross should be shown (as is usual in the USA), the third char of \a formatCode can
  be set to 'c'. The inserted multiplication signs are the UTF-8 characters 215 (0xD7) for the
  cross and 183 (0xB7) for the dot.
  
  Examples for \a formatCode:
  \li \c g normal format code behaviour. If number is small, fixed format is used, if number is large,
  normal scientific format is used
  \li \c gb If number is small, fixed format is used, if number is large, scientific format is used with
  beautifully typeset decimal powers and a dot as multiplication sign
  \li \c ebc All numbers are in scientific format with beautifully typeset decimal power and a cross as
  multiplication sign
  \li \c fb illegal format code, since fixed format doesn't support (or need) beautifully typeset decimal
  powers. Format code will be reduced to 'f'.
  \li \c hello illegal format code, since first char is not 'e', 'E', 'f', 'g' or 'G'. Current format
  code will not be changed.
*/
/*!
  눈금 레이블에 숫자의 숫자 형식을 설정합니다. 이 \ a formatCode는 확장 버전입니다.
  예 : QString :: number () 및 QLocale :: toString ()에 사용 된 형식 코드. 참고로
  QString 클래스에 대한 자세한 설명의 "인수 형식"섹션을 참조하십시오.
  
  \ a formatCode는 1, 2 또는 3 자의 문자열입니다. 첫 번째 문자는 다음과 같습니다.
  Qt가 사용하는 표준 형식 코드. 즉, 이것은 'e'/ 'E'과학 형식, 'f'고정식
  형식, 'g'/ 'G'과학 또는 고정 중 더 짧은 것.
  
  두 번째 및 세 번째 문자는 선택적이며 QCustomPlot에 고유합니다. \ n
  첫 번째 문자가 'e'또는 'g'이면 숫자는 과학 형식으로 표시 될 수 있습니다.
  "5.5e9", 음모에 추한. 따라서 \ a formatCode의 두 번째 문자가 'b'(for
  "아름다운"), 그 지수의 숫자는 더 자연스러운 방식으로, 즉 "5.5
  [곱셈 기호] 10 [윗 첨자] 9 "기본적으로 곱셈 기호는 가운데 점입니다.
  대신 십자가가 표시되어야하는 경우 (미국에서와 같이) \ formatCode의 세 번째 문자는
  'c'로 설정하십시오. 삽입 된 곱셈 기호는 UTF-8 문자 215 (0xD7)입니다.
  십자가 및 도트에 대해 183 (0xB7)입니다.
  
  \ a formatCode의 예 :
  \ li \ cg 일반적인 형식 코드 동작. 숫자가 작은 경우, 고정 된 형식이 사용되며, 숫자가 클 경우,
  정상적인 과학적 형식이 사용된다.
  \ li \ c gb 숫자가 작은 경우 고정 형식이 사용되며 숫자가 큰 경우 과학 형식이 사용됩니다
  십진수를 아름답게 조판하고 곱셈 기호로 점을 찍습니다.
  \ li \ c ebc 모든 숫자는 아름답게 조판 된 십진수와 십자가가있는 과학 형식입니다.
  곱셈 기호
  \ li \ c fb 불규칙한 형식 코드. 고정 형식은 십진수를 아름답게 조판 (또는 필요)하지 않기 때문에
  힘. 포맷 코드는 'f'로 줄어 듭니다.
  첫 번째 문자가 'e', ​​'E', 'f', 'g'또는 'G'가 아니므로 \ li \ c hello 형식이 잘못되었습니다. 현재 형식
  코드는 변경되지 않습니다.
*/
void QCPAxis::setNumberFormat(const QString &formatCode)
{
  if (formatCode.isEmpty())
  {
    qDebug() << Q_FUNC_INFO << "Passed formatCode is empty";
    return;
  }
  mCachedMarginValid = false;
  
  // interpret first char as number format char:
  // 첫 번째 char을 숫자 형식으로 해석 char :
  QString allowedFormatChars(QLatin1String("eEfgG"));
  if (allowedFormatChars.contains(formatCode.at(0)))
  {
    mNumberFormatChar = QLatin1Char(formatCode.at(0).toLatin1());
  } else
  {
    qDebug() << Q_FUNC_INFO << "Invalid number format code (first char not in 'eEfgG'):" << formatCode;
    return;
  }
  if (formatCode.length() < 2)
  {
    mNumberBeautifulPowers = false;
    mAxisPainter->numberMultiplyCross = false;
    return;
  }
  
  // interpret second char as indicator for beautiful decimal powers:
  // 아름다운 십진수를 나타내는 지표로 두 번째 char을 해석합니다.
  if (formatCode.at(1) == QLatin1Char('b') && (mNumberFormatChar == QLatin1Char('e') || mNumberFormatChar == QLatin1Char('g')))
  {
    mNumberBeautifulPowers = true;
  } else
  {
    qDebug() << Q_FUNC_INFO << "Invalid number format code (second char not 'b' or first char neither 'e' nor 'g'):" << formatCode;
    return;
  }
  if (formatCode.length() < 3)
  {
    mAxisPainter->numberMultiplyCross = false;
    return;
  }
  
  // interpret third char as indicator for dot or cross multiplication symbol:
  // 도트 또는 십자가 곱셈 기호에 대한 지시자로 세 번째 문자를 해석합니다.
  if (formatCode.at(2) == QLatin1Char('c'))
  {
    mAxisPainter->numberMultiplyCross = true;
  } else if (formatCode.at(2) == QLatin1Char('d'))
  {
    mAxisPainter->numberMultiplyCross = false;
  } else
  {
    qDebug() << Q_FUNC_INFO << "Invalid number format code (third char neither 'c' nor 'd'):" << formatCode;
    return;
  }
}

/*!
  Sets the precision of the tick label numbers. See QLocale::toString(double i, char f, int prec)
  for details. The effect of precisions are most notably for number Formats starting with 'e', see
  \ref setNumberFormat
*/
/*!
  눈금 레이블 번호의 정밀도를 설정합니다. QLocale :: toString (double i, char f, int prec)를 참조하십시오.
  자세한 내용은 정밀도의 효과는 특히 'e'로 시작하는 숫자 형식의 경우에 특히 두드러집니다.
  \ ref setNumberFormat
*/
void QCPAxis::setNumberPrecision(int precision)
{
  if (mNumberPrecision != precision)
  {
    mNumberPrecision = precision;
    mCachedMarginValid = false;
  }
}

/*!
  Sets the length of the ticks in pixels. \a inside is the length the ticks will reach inside the
  plot and \a outside is the length they will reach outside the plot. If \a outside is greater than
  zero, the tick labels and axis label will increase their distance to the axis accordingly, so
  they won't collide with the ticks.
  
  \see setSubTickLength, setTickLengthIn, setTickLengthOut
*/
/*!
  틱의 길이를 픽셀 단위로 설정합니다. 내부는 틱이 내부에 도달하는 길이입니다.
  플롯과 외부는 그들이 플롯 바깥에 도달 할 길이입니다. 외부가 \ a보다 큰 경우
  0이면 틱 레이블과 축 레이블은 그에 따라 축까지의 거리를 증가시킵니다.
  그들은 진드기와 충돌하지 않을 것입니다.
  
  \ setSubTickLength, setTickLengthIn, setTickLengthOut를 참조하십시오.
*/
void QCPAxis::setTickLength(int inside, int outside)
{
  setTickLengthIn(inside);
  setTickLengthOut(outside);
}

/*!
  Sets the length of the inward ticks in pixels. \a inside is the length the ticks will reach
  inside the plot.
  
  \see setTickLengthOut, setTickLength, setSubTickLength
*/
/*!
  안쪽 눈금의 길이를 픽셀 단위로 설정합니다. 내부는 틱이 도달 할 길이입니다.
  음모 안에.
  
  \ setTickLengthOut, setTickLength, setSubTickLength를 참조하십시오.
*/
void QCPAxis::setTickLengthIn(int inside)
{
  if (mAxisPainter->tickLengthIn != inside)
  {
    mAxisPainter->tickLengthIn = inside;
  }
}

/*!
  Sets the length of the outward ticks in pixels. \a outside is the length the ticks will reach
  outside the plot. If \a outside is greater than zero, the tick labels and axis label will
  increase their distance to the axis accordingly, so they won't collide with the ticks.
  
  \see setTickLengthIn, setTickLength, setSubTickLength
*/
/*!
  바깥 쪽 눈금의 길이를 픽셀 단위로 설정합니다. \ a outside는 틱이 도달 할 길이입니다.
  줄거리 바깥. \ a 외부가 0보다 큰 경우 눈금 레이블과 축 레이블은
  그에 따라 축에 대한 거리가 증가하므로 진드기와 충돌하지 않습니다.
  
  \ setTickLengthIn, setTickLength, setSubTickLength를 참조하십시오.
*/
void QCPAxis::setTickLengthOut(int outside)
{
  if (mAxisPainter->tickLengthOut != outside)
  {
    mAxisPainter->tickLengthOut = outside;
    mCachedMarginValid = false; // only outside tick length can change margin
                                // 외부 틱 길이 만이 마진을 변경할 수 있습니다.
  }
}

/*!
  Sets whether sub tick marks are displayed.
  
  Sub ticks are only potentially visible if (major) ticks are also visible (see \ref setTicks)
  
  \see setTicks
*/
/*!
  하위 눈금 표시 여부를 설정합니다.
  
  하위 틱은 (주요) 틱이 표시 될 때만 볼 수 있습니다 (\ ref setTicks 참조)
  
  \ see setTicks
*/
void QCPAxis::setSubTicks(bool show)
{
  if (mSubTicks != show)
  {
    mSubTicks = show;
    mCachedMarginValid = false;
  }
}

/*!
  Sets the length of the subticks in pixels. \a inside is the length the subticks will reach inside
  the plot and \a outside is the length they will reach outside the plot. If \a outside is greater
  than zero, the tick labels and axis label will increase their distance to the axis accordingly,
  so they won't collide with the ticks.
  
  \see setTickLength, setSubTickLengthIn, setSubTickLengthOut
*/
/*!
  하위 픽셀의 길이를 픽셀 단위로 설정합니다. \ a inside는 하위가 내부에 도달 할 길이입니다.
  플롯과 외부는 그들이 플롯 바깥에 도달 할 길이입니다. 외부의 \ a가 더 큰 경우
  0보다 틱 레이블 및 축 레이블은 이에 따라 축과의 거리가 증가하므로,
  그래서 그들은 진드기와 충돌하지 않을 것입니다.
  
  \ setTickLength, setSubTickLengthIn, setSubTickLengthOut을 참조하십시오.
*/
void QCPAxis::setSubTickLength(int inside, int outside)
{
  setSubTickLengthIn(inside);
  setSubTickLengthOut(outside);
}

/*!
  Sets the length of the inward subticks in pixels. \a inside is the length the subticks will reach inside
  the plot.
  
  \see setSubTickLengthOut, setSubTickLength, setTickLength
*/
/*!
  안쪽 부분의 길이를 픽셀 단위로 설정합니다. \ a inside는 하위가 내부에 도달 할 길이입니다.
  줄거리.
  
  \ setSubTickLengthOut, setSubTickLength, setTickLength를 참조하십시오.
*/
void QCPAxis::setSubTickLengthIn(int inside)
{
  if (mAxisPainter->subTickLengthIn != inside)
  {
    mAxisPainter->subTickLengthIn = inside;
  }
}

/*!
  Sets the length of the outward subticks in pixels. \a outside is the length the subticks will reach
  outside the plot. If \a outside is greater than zero, the tick labels will increase their
  distance to the axis accordingly, so they won't collide with the ticks.
  
  \see setSubTickLengthIn, setSubTickLength, setTickLength
*/

/*!
  바깥 쪽 하위 픽셀의 길이를 픽셀 단위로 설정합니다. \ a 바깥 쪽은 하위가 도달 할 길이입니다.
  줄거리 바깥. \ a 외부가 0보다 큰 경우, 눈금 레이블은
  따라서 축에 대한 거리가 있으므로 틱과 충돌하지 않습니다.
  
  \ setSubTickLengthIn, setSubTickLength, setTickLength를 참조하십시오.
*/
void QCPAxis::setSubTickLengthOut(int outside)
{
  if (mAxisPainter->subTickLengthOut != outside)
  {
    mAxisPainter->subTickLengthOut = outside;
    mCachedMarginValid = false; // only outside tick length can change margin
                                // 외부 틱 길이 만이 마진을 변경할 수 있습니다.
  }
}

/*!
  Sets the pen, the axis base line is drawn with.
  
  \see setTickPen, setSubTickPen
*/
/*!
  펜을 설정하면 축 기본선이 그려집니다.
  
  \ setTickPen, setSubTickPen 참조하십시오.
*/
void QCPAxis::setBasePen(const QPen &pen)
{
  mBasePen = pen;
}

/*!
  Sets the pen, tick marks will be drawn with.
  
  \see setTickLength, setBasePen
*/
/*!
  펜을 설정하고 눈금이 그려집니다.
  
  \ setTickLength, setBasePen을 참조하십시오.
*/
void QCPAxis::setTickPen(const QPen &pen)
{
  mTickPen = pen;
}

/*!
  Sets the pen, subtick marks will be drawn with.
  
  \see setSubTickCount, setSubTickLength, setBasePen
*/
/*!
  펜을 설정하면, 하위 표식이 그려집니다.
  
  \ setSubTickCount, setSubTickLength, setBasePen을 참조하십시오.
*/
void QCPAxis::setSubTickPen(const QPen &pen)
{
  mSubTickPen = pen;
}

/*!
  Sets the font of the axis label.
  
  \see setLabelColor
*/
/*!
  축 레이블의 글꼴을 설정합니다.
  
  \ setLabelColor 참조
*/
void QCPAxis::setLabelFont(const QFont &font)
{
  if (mLabelFont != font)
  {
    mLabelFont = font;
    mCachedMarginValid = false;
  }
}

/*!
  Sets the color of the axis label.
  
  \see setLabelFont
*/
/*!
  축 레이블의 색상을 설정합니다.
  
  \ see setLabelFont
*/
void QCPAxis::setLabelColor(const QColor &color)
{
  mLabelColor = color;
}

/*!
  Sets the text of the axis label that will be shown below/above or next to the axis, depending on
  its orientation. To disable axis labels, pass an empty string as \a str.
*/
/*!
  에 따라 축 아래 또는 위 또는 옆에 표시 될 축 레이블의 텍스트를 설정합니다.
  그것의 방향. 축 레이블을 사용하지 않으려면 빈 문자열을 \ a str으로 전달하십시오.
*/
void QCPAxis::setLabel(const QString &str)
{
  if (mLabel != str)
  {
    mLabel = str;
    mCachedMarginValid = false;
  }
}

/*!
  Sets the distance between the tick labels and the axis label.
  
  \see setTickLabelPadding, setPadding
*/
/*!
  눈금 레이블과 축 레이블 사이의 거리를 설정합니다.
  
  \ setTickLabelPadding, setPadding을 참조하십시오.
*/
void QCPAxis::setLabelPadding(int padding)
{
  if (mAxisPainter->labelPadding != padding)
  {
    mAxisPainter->labelPadding = padding;
    mCachedMarginValid = false;
  }
}

/*!
  Sets the padding of the axis.

  When \ref QCPAxisRect::setAutoMargins is enabled, the padding is the additional outer most space,
  that is left blank.
  
  The axis padding has no meaning if \ref QCPAxisRect::setAutoMargins is disabled.
  
  \see setLabelPadding, setTickLabelPadding
*/
/*!
  축의 패딩을 설정합니다.

  \ ref QCPAxisRect :: setAutoMargins이 활성화되면 패딩은 추가 외부 공간이며,
  그것은 비어 있습니다.
  
  \ ref QCPAxisRect :: setAutoMargins가 비활성화되면 축 채우기가 의미가 없습니다.
  
  \ setLabelPadding, setTickLabelPadding을 참조하십시오.
*/
void QCPAxis::setPadding(int padding)
{
  if (mPadding != padding)
  {
    mPadding = padding;
    mCachedMarginValid = false;
  }
}

/*!
  Sets the offset the axis has to its axis rect side.
  
  If an axis rect side has multiple axes and automatic margin calculation is enabled for that side,
  only the offset of the inner most axis has meaning (even if it is set to be invisible). The
  offset of the other, outer axes is controlled automatically, to place them at appropriate
  positions.
*/
/*!
  축의 축 직각 측에 대한 오프셋 (offset)를 설정합니다.
  
  축 rect면에 여러 축이 있고 그면에 자동 여백 계산이 사용 가능한 경우,
  가장 안쪽에있는 축의 오프셋 만 의미가 있습니다 (보이지 않게 설정되어 있어도). 그만큼
  다른 축의 오프셋, 외부 축이 자동으로 제어되어 해당 축을 적절하게 배치합니다.
  위치.
*/
void QCPAxis::setOffset(int offset)
{
  mAxisPainter->offset = offset;
}

/*!
  Sets the font that is used for tick labels when they are selected.
  
  \see setTickLabelFont, setSelectableParts, setSelectedParts, QCustomPlot::setInteractions
*/
/*!
  틱 레이블을 선택할 때 사용되는 글꼴을 설정합니다.
  
  \ setTickLabelFont, setSelectableParts, setSelectedParts, QCustomPlot :: setInteractions를 참조하십시오.
*/
void QCPAxis::setSelectedTickLabelFont(const QFont &font)
{
  if (font != mSelectedTickLabelFont)
  {
    mSelectedTickLabelFont = font;
    // don't set mCachedMarginValid to false here because margin calculation is always done with non-selected fonts
    // 여백 계산은 항상 선택되지 않은 글꼴로 끝나기 때문에 mCachedMarginValid를 false로 설정하지 마십시오.

  }
}

/*!
  Sets the font that is used for the axis label when it is selected.
  
  \see setLabelFont, setSelectableParts, setSelectedParts, QCustomPlot::setInteractions
*/
/*!
  선택한 경우 축 레이블에 사용되는 글꼴을 설정합니다.
  
  \ setLabelFont, setSelectableParts, setSelectedParts, QCustomPlot :: setInteractions를 참조하십시오.
*/
void QCPAxis::setSelectedLabelFont(const QFont &font)
{
  mSelectedLabelFont = font;
  // don't set mCachedMarginValid to false here because margin calculation is always done with non-selected fonts
  // 여백 계산은 항상 선택되지 않은 글꼴로 끝나기 때문에 mCachedMarginValid를 false로 설정하지 마십시오.
}

/*!
  Sets the color that is used for tick labels when they are selected.
  
  \see setTickLabelColor, setSelectableParts, setSelectedParts, QCustomPlot::setInteractions
*/
/*!
  틱 레이블을 선택할 때 사용되는 색을 설정합니다.
  
  \ setTickLabelColor, setSelectableParts, setSelectedParts, QCustomPlot :: setInteractions를 참조하십시오.
*/
void QCPAxis::setSelectedTickLabelColor(const QColor &color)
{
  if (color != mSelectedTickLabelColor)
  {
    mSelectedTickLabelColor = color;
  }
}

/*!
  Sets the color that is used for the axis label when it is selected.
  
  \see setLabelColor, setSelectableParts, setSelectedParts, QCustomPlot::setInteractions
*/
/*!
  축 레이블을 선택할 때 사용되는 색을 설정합니다.
  
  \ setLabelColor, setSelectableParts, setSelectedParts, QCustomPlot :: setInteractions를 참조하십시오.
*/
void QCPAxis::setSelectedLabelColor(const QColor &color)
{
  mSelectedLabelColor = color;
}

/*!
  Sets the pen that is used to draw the axis base line when selected.
  
  \see setBasePen, setSelectableParts, setSelectedParts, QCustomPlot::setInteractions
*/
/*!
  선택시 축 기준선을 그리는 데 사용되는 펜을 설정합니다.
  
  \ setBasePen, setSelectableParts, setSelectedParts, QCustomPlot :: setInteractions를 참조하십시오.
*/
void QCPAxis::setSelectedBasePen(const QPen &pen)
{
  mSelectedBasePen = pen;
}

/*!
  Sets the pen that is used to draw the (major) ticks when selected.
  
  \see setTickPen, setSelectableParts, setSelectedParts, QCustomPlot::setInteractions
*/
/*!
  선택한 경우 (주) 틱을 그리는 데 사용되는 펜을 설정합니다.
  
  \ setTickPen, setSelectableParts, setSelectedParts, QCustomPlot :: setInteractions를 참조하십시오.
*/
void QCPAxis::setSelectedTickPen(const QPen &pen)
{
  mSelectedTickPen = pen;
}

/*!
  Sets the pen that is used to draw the subticks when selected.
  
  \see setSubTickPen, setSelectableParts, setSelectedParts, QCustomPlot::setInteractions
*/
/*!
  선택한 경우 하위 그림 그리기에 사용되는 펜을 설정합니다.
  
  \ setSubTickPen, setSelectableParts, setSelectedParts, QCustomPlot :: setInteractions를 참조하십시오.
*/
void QCPAxis::setSelectedSubTickPen(const QPen &pen)
{
  mSelectedSubTickPen = pen;
}

/*!
  Sets the style for the lower axis ending. See the documentation of QCPLineEnding for available
  styles.
  
  For horizontal axes, this method refers to the left ending, for vertical axes the bottom ending.
  Note that this meaning does not change when the axis range is reversed with \ref
  setRangeReversed.
  
  \see setUpperEnding
*/
/*!
  끝나는 하단 축의 스타일을 설정합니다. QCPLineEnding의 설명서를 참조하십시오.
  스타일.
  
  수평축의 경우,이 메소드는 왼쪽의 엔딩을 나타내, 세로의 축은 맨 아래의 엔딩을 나타냅니다.
  \ ref를 사용하여 축 범위를 역전하면이 의미가 변경되지 않습니다.
  setRangeReversed.
  
  \ setUpperEnding 참조
*/
void QCPAxis::setLowerEnding(const QCPLineEnding &ending)
{
  mAxisPainter->lowerEnding = ending;
}

/*!
  Sets the style for the upper axis ending. See the documentation of QCPLineEnding for available
  styles.
  
  For horizontal axes, this method refers to the right ending, for vertical axes the top ending.
  Note that this meaning does not change when the axis range is reversed with \ref
  setRangeReversed.
  
  \see setLowerEnding
*/
/*!
  상단 축 종료 스타일을 설정합니다. QCPLineEnding의 설명서를 참조하십시오.
  스타일.
  
  수평축의 경우,이 메소드는 우측의 엔딩을 나타내, 수직의 경우는 상단의 엔딩을 나타냅니다.
  \ ref를 사용하여 축 범위를 역전하면이 의미가 변경되지 않습니다.
  setRangeReversed.
  
  \ setLowerEnding을 참조하십시오.
*/
void QCPAxis::setUpperEnding(const QCPLineEnding &ending)
{
  mAxisPainter->upperEnding = ending;
}

/*!
  If the scale type (\ref setScaleType) is \ref stLinear, \a diff is added to the lower and upper
  bounds of the range. The range is simply moved by \a diff.
  
  If the scale type is \ref stLogarithmic, the range bounds are multiplied by \a diff. This
  corresponds to an apparent "linear" move in logarithmic scaling by a distance of log(diff).
*/
/*!
  눈금 유형 (\ ref setScaleType)이 \ ref stLinear이면 \ diff가 하위 및 상위에 추가됩니다.
  범위의 범위. 범위는 단순히 \ a diff로 이동됩니다.
  
  스케일 유형이 \ ref stLogarithmic 인 경우 범위 경계에 \ a diff가 곱 해집니다. 이
  log (diff)의 거리에 의한 로그 스케일링에서 명백한 "선형"이동에 해당합니다.
*/
void QCPAxis::moveRange(double diff)
{
  QCPRange oldRange = mRange;
  if (mScaleType == stLinear)
  {
    mRange.lower += diff;
    mRange.upper += diff;
  } else // mScaleType == stLogarithmic
  {      
    mRange.lower *= diff;
    mRange.upper *= diff;
  }
  emit rangeChanged(mRange);
  emit rangeChanged(mRange, oldRange);
}

/*!
  Scales the range of this axis by \a factor around the center of the current axis range. For
  example, if \a factor is 2.0, then the axis range will double its size, and the point at the axis
  range center won't have changed its position in the QCustomPlot widget (i.e. coordinates around
  the center will have moved symmetrically closer).

  If you wish to scale around a different coordinate than the current axis range center, use the
  overload \ref scaleRange(double factor, double center).
*/
/*!
  현재 축 범위의 중심을 기준으로이 축의 범위를 \ a 배율로 조정합니다. 에 대한
  예를 들어, \ a factor가 2.0이면 축 범위가 크기가 두 배가되고 축의 지점이
  범위 센터는 QCustomPlot 위젯에서 위치를 변경하지 않습니다 (즉, 주변 좌표
  센터는 대칭 적으로 더 가까워 질 것입니다).

  현재 축 범위 중심과 다른 좌표 주위로 축척하려면,
  과부하 \ ref scaleRange (double factor, double center).
*/
void QCPAxis::scaleRange(double factor)
{
  scaleRange(factor, range().center());
}

/*! \overload

  Scales the range of this axis by \a factor around the coordinate \a center. For example, if \a
  factor is 2.0, \a center is 1.0, then the axis range will double its size, and the point at
  coordinate 1.0 won't have changed its position in the QCustomPlot widget (i.e. coordinates
  around 1.0 will have moved symmetrically closer to 1.0).

  \see scaleRange(double factor)
*/
/*! \초과 적재

  이 축의 범위를 좌표 \ a를 중심으로 \ 배율로 조정합니다. 예를 들어, \ a
  요소가 2.0이고 중심이 1.0이면 축 범위가 두 배가되고 점은
  좌표 1.0은 QCustomPlot 위젯에서 위치를 변경하지 않습니다 (즉 좌표
  약 1.0은 대칭 적으로 1.0에 가깝게 움직일 것입니다).

  \ see scaleRange (double factor)
*/
void QCPAxis::scaleRange(double factor, double center)
{
  QCPRange oldRange = mRange;
  if (mScaleType == stLinear)
  {
    QCPRange newRange;
    newRange.lower = (mRange.lower-center)*factor + center;
    newRange.upper = (mRange.upper-center)*factor + center;
    if (QCPRange::validRange(newRange))
      mRange = newRange.sanitizedForLinScale();
  } else // mScaleType == stLogarithmic
  {
    if ((mRange.upper < 0 && center < 0) || (mRange.upper > 0 && center > 0)) 
// make sure center has same sign as range
// 중심이 범위와 같은 부호를 갖는지 확인
    {
      QCPRange newRange;
      newRange.lower = qPow(mRange.lower/center, factor)*center;
      newRange.upper = qPow(mRange.upper/center, factor)*center;
      if (QCPRange::validRange(newRange))
        mRange = newRange.sanitizedForLogScale();
    } else
      qDebug() << Q_FUNC_INFO << "Center of scaling operation doesn't lie in same logarithmic sign domain as range:" << center;
  }
  emit rangeChanged(mRange);
  emit rangeChanged(mRange, oldRange);
}

/*!
  Scales the range of this axis to have a certain scale \a ratio to \a otherAxis. The scaling will
  be done around the center of the current axis range.

  For example, if \a ratio is 1, this axis is the \a yAxis and \a otherAxis is \a xAxis, graphs
  plotted with those axes will appear in a 1:1 aspect ratio, independent of the aspect ratio the
  axis rect has.

  This is an operation that changes the range of this axis once, it doesn't fix the scale ratio
  indefinitely. Note that calling this function in the constructor of the QCustomPlot's parent
  won't have the desired effect, since the widget dimensions aren't defined yet, and a resizeEvent
  will follow.
*/
/*!
  이 축의 범위를, \ a otherAxis 에의 일정한 비율이되도록 조정합니다. 스케일링은
  현재 축 범위의 중심을 중심으로 수행됩니다.

  예를 들어, 비율이 1 인 경우이 축은 \ a yAxis이고 \ a otherAxis는 \ a xAxis, 그래프
  그 축으로 플롯 된 것은 1 : 1 종횡비로 나타납니다.
  축 rect가 있습니다.

  이 축의 범위를 한 번 변경하고 축척 비율을 고정하지 않는 작업입니다.
  무한정. QCustomPlot의 부모 생성자에서이 함수를 호출하면
  위젯 차원이 아직 정의되지 않았기 때문에 원하는 효과를 얻을 수 없으며 resizeEvent
  따를 것이다.
*/
void QCPAxis::setScaleRatio(const QCPAxis *otherAxis, double ratio)
{
  int otherPixelSize, ownPixelSize;
  
  if (otherAxis->orientation() == Qt::Horizontal)
    otherPixelSize = otherAxis->axisRect()->width();
  else
    otherPixelSize = otherAxis->axisRect()->height();
  
  if (orientation() == Qt::Horizontal)
    ownPixelSize = axisRect()->width();
  else
    ownPixelSize = axisRect()->height();
  
  double newRangeSize = ratio*otherAxis->range().size()*ownPixelSize/(double)otherPixelSize;
  setRange(range().center(), newRangeSize, Qt::AlignCenter);
}

/*!
  Changes the axis range such that all plottables associated with this axis are fully visible in
  that dimension.
  
  \see QCPAbstractPlottable::rescaleAxes, QCustomPlot::rescaleAxes
*/
/*!
  이 축과 연관된 모든 plottable이 완전히 볼 수 있도록 축 범위를 변경합니다.
  그 차원.
  
  \ QCPAbstractPlottable :: rescaleAxes, QCustomPlot :: rescaleAxes를 참조하십시오.
*/
void QCPAxis::rescale(bool onlyVisiblePlottables)
{
  QList<QCPAbstractPlottable*> p = plottables();
  QCPRange newRange;
  bool haveRange = false;
  for (int i=0; i<p.size(); ++i)
  {
    if (!p.at(i)->realVisibility() && onlyVisiblePlottables)
      continue;
    QCPRange plottableRange;
    bool currentFoundRange;
    QCP::SignDomain signDomain = QCP::sdBoth;
    if (mScaleType == stLogarithmic)
      signDomain = (mRange.upper < 0 ? QCP::sdNegative : QCP::sdPositive);
    if (p.at(i)->keyAxis() == this)
      plottableRange = p.at(i)->getKeyRange(currentFoundRange, signDomain);
    else
      plottableRange = p.at(i)->getValueRange(currentFoundRange, signDomain);
    if (currentFoundRange)
    {
      if (!haveRange)
        newRange = plottableRange;
      else
        newRange.expand(plottableRange);
      haveRange = true;
    }
  }
  if (haveRange)
  {
    if (!QCPRange::validRange(newRange)) // likely due to range being zero (plottable has only constant data in this axis dimension), shift current range to at least center the plottable
// 범위가 0 일 가능성이 높습니다 (plottable은이 축 차원에서 일정한 데이터 만 가짐), 현재 범위를 적어도 plottable을 가운데로 이동합니다.
    {
      double center = (newRange.lower+newRange.upper)*0.5; // upper and lower should be equal anyway, but just to make sure, incase validRange returned false for other reason
// upper와 lower는 반드시 동일해야하지만, 확실하게하려면 incase validRange가 다른 이유로 false를 반환합니다.
      if (mScaleType == stLinear)
      {
        newRange.lower = center-mRange.size()/2.0;
        newRange.upper = center+mRange.size()/2.0;
      } else // mScaleType == stLogarithmic
      {
        newRange.lower = center/qSqrt(mRange.upper/mRange.lower);
        newRange.upper = center*qSqrt(mRange.upper/mRange.lower);
      }
    }
    setRange(newRange);
  }
}

/*!
  Transforms \a value, in pixel coordinates of the QCustomPlot widget, to axis coordinates.
*/
/*!
  QCustomPlot 위젯의 픽셀 좌표 값을 축 좌표로 변환합니다.
*/
double QCPAxis::pixelToCoord(double value) const
{
  if (orientation() == Qt::Horizontal)
  {
    if (mScaleType == stLinear)
    {
      if (!mRangeReversed)
        return (value-mAxisRect->left())/(double)mAxisRect->width()*mRange.size()+mRange.lower;
      else
        return -(value-mAxisRect->left())/(double)mAxisRect->width()*mRange.size()+mRange.upper;
    } else // mScaleType == stLogarithmic
    {
      if (!mRangeReversed)
        return qPow(mRange.upper/mRange.lower, (value-mAxisRect->left())/(double)mAxisRect->width())*mRange.lower;
      else
        return qPow(mRange.upper/mRange.lower, (mAxisRect->left()-value)/(double)mAxisRect->width())*mRange.upper;
    }
  } else // orientation() == Qt::Vertical
  {
    if (mScaleType == stLinear)
    {
      if (!mRangeReversed)
        return (mAxisRect->bottom()-value)/(double)mAxisRect->height()*mRange.size()+mRange.lower;
      else
        return -(mAxisRect->bottom()-value)/(double)mAxisRect->height()*mRange.size()+mRange.upper;
    } else // mScaleType == stLogarithmic
    {
      if (!mRangeReversed)
        return qPow(mRange.upper/mRange.lower, (mAxisRect->bottom()-value)/(double)mAxisRect->height())*mRange.lower;
      else
        return qPow(mRange.upper/mRange.lower, (value-mAxisRect->bottom())/(double)mAxisRect->height())*mRange.upper;
    }
  }
}

/*!
  Transforms \a value, in coordinates of the axis, to pixel coordinates of the QCustomPlot widget.
*/
/*!
  축의 좌표 값을 QCustomPlot 위젯의 픽셀 좌표로 변환합니다.
*/
double QCPAxis::coordToPixel(double value) const
{
  if (orientation() == Qt::Horizontal)
  {
    if (mScaleType == stLinear)
    {
      if (!mRangeReversed)
        return (value-mRange.lower)/mRange.size()*mAxisRect->width()+mAxisRect->left();
      else
        return (mRange.upper-value)/mRange.size()*mAxisRect->width()+mAxisRect->left();
    } else // mScaleType == stLogarithmic
    {
      if (value >= 0.0 && mRange.upper < 0.0)
// invalid value for logarithmic scale, just draw it outside visible range
// 로그 스케일의 값이 잘못되었습니다. 보이는 범위 밖에 그립니다.
        return !mRangeReversed ? mAxisRect->right()+200 : mAxisRect->left()-200;
      else if (value <= 0.0 && mRange.upper >= 0.0) 
// invalid value for logarithmic scale, just draw it outside visible range
// 로그 스케일의 값이 잘못되었습니다. 보이는 범위 밖에 그립니다.
        return !mRangeReversed ? mAxisRect->left()-200 : mAxisRect->right()+200;
      else
      {
        if (!mRangeReversed)
          return qLn(value/mRange.lower)/qLn(mRange.upper/mRange.lower)*mAxisRect->width()+mAxisRect->left();
        else
          return qLn(mRange.upper/value)/qLn(mRange.upper/mRange.lower)*mAxisRect->width()+mAxisRect->left();
      }
    }
  } else // orientation() == Qt::Vertical
  {
    if (mScaleType == stLinear)
    {
      if (!mRangeReversed)
        return mAxisRect->bottom()-(value-mRange.lower)/mRange.size()*mAxisRect->height();
      else
        return mAxisRect->bottom()-(mRange.upper-value)/mRange.size()*mAxisRect->height();
    } else // mScaleType == stLogarithmic
    {
      if (value >= 0.0 && mRange.upper < 0.0) 
// invalid value for logarithmic scale, just draw it outside visible range
// 로그 스케일의 값이 잘못되었습니다. 보이는 범위 밖에 그립니다.
        return !mRangeReversed ? mAxisRect->top()-200 : mAxisRect->bottom()+200;
      else if (value <= 0.0 && mRange.upper >= 0.0) 
// invalid value for logarithmic scale, just draw it outside visible range
// 로그 스케일의 값이 잘못되었습니다. 보이는 범위 밖에 그립니다.
        return !mRangeReversed ? mAxisRect->bottom()+200 : mAxisRect->top()-200;
      else
      {
        if (!mRangeReversed)
          return mAxisRect->bottom()-qLn(value/mRange.lower)/qLn(mRange.upper/mRange.lower)*mAxisRect->height();
        else
          return mAxisRect->bottom()-qLn(mRange.upper/value)/qLn(mRange.upper/mRange.lower)*mAxisRect->height();
      }
    }
  }
}

/*!
  Returns the part of the axis that is hit by \a pos (in pixels). The return value of this function
  is independent of the user-selectable parts defined with \ref setSelectableParts. Further, this
  function does not change the current selection state of the axis.
  
  If the axis is not visible (\ref setVisible), this function always returns \ref spNone.
  
  \see setSelectedParts, setSelectableParts, QCustomPlot::setInteractions
*/
/*!
  \ a pos에 의해 히트 된 축의 일부를 돌려줍니다 (픽셀 단위). 이 함수의 반환 값
  \ ref setSelectableParts로 정의 된 사용자가 선택할 수있는 부분과는 독립적입니다. 또한,
  함수는 축의 현재 선택 상태를 변경하지 않습니다.
  
  축이 표시되지 않으면 (\ ref setVisible)이 함수는 항상 \ ref spNone을 반환합니다.
  
  \ setSelectedParts, setSelectableParts, QCustomPlot :: setInteractions를 참조하십시오.
*/
QCPAxis::SelectablePart QCPAxis::getPartAt(const QPointF &pos) const
{
  if (!mVisible)
    return spNone;
  
  if (mAxisPainter->axisSelectionBox().contains(pos.toPoint()))
    return spAxis;
  else if (mAxisPainter->tickLabelsSelectionBox().contains(pos.toPoint()))
    return spTickLabels;
  else if (mAxisPainter->labelSelectionBox().contains(pos.toPoint()))
    return spAxisLabel;
  else
    return spNone;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPAxis::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  if (!mParentPlot) return -1;
  SelectablePart part = getPartAt(pos);
  if ((onlySelectable && !mSelectableParts.testFlag(part)) || part == spNone)
    return -1;
  
  if (details)
    details->setValue(part);
  return mParentPlot->selectionTolerance()*0.99;
}

/*!
  Returns a list of all the plottables that have this axis as key or value axis.
  
  If you are only interested in plottables of type QCPGraph, see \ref graphs.
  
  \see graphs, items
*/
/*!
  이 축을 키 또는 값 축으로 갖는 모든 플롯 테이블 목록을 반환합니다.
  
  QCPGraph 유형의 플롯 테이블에만 관심이있는 경우 \ ref 그래프를 참조하십시오.
  
  \ 그래프, 항목보기
*/
QList<QCPAbstractPlottable*> QCPAxis::plottables() const
{
  QList<QCPAbstractPlottable*> result;
  if (!mParentPlot) return result;
  
  for (int i=0; i<mParentPlot->mPlottables.size(); ++i)
  {
    if (mParentPlot->mPlottables.at(i)->keyAxis() == this ||mParentPlot->mPlottables.at(i)->valueAxis() == this)
      result.append(mParentPlot->mPlottables.at(i));
  }
  return result;
}

/*!
  Returns a list of all the graphs that have this axis as key or value axis.
  
  \see plottables, items
*/
/*!
  이 축을 키 또는 값의 축으로서 가지는 모든 그래프의리스트를 돌려줍니다.
  
  \ plottables, items보기
*/
QList<QCPGraph*> QCPAxis::graphs() const
{
  QList<QCPGraph*> result;
  if (!mParentPlot) return result;
  
  for (int i=0; i<mParentPlot->mGraphs.size(); ++i)
  {
    if (mParentPlot->mGraphs.at(i)->keyAxis() == this || mParentPlot->mGraphs.at(i)->valueAxis() == this)
      result.append(mParentPlot->mGraphs.at(i));
  }
  return result;
}

/*!
  Returns a list of all the items that are associated with this axis. An item is considered
  associated with an axis if at least one of its positions uses the axis as key or value axis.
  
  \see plottables, graphs
*/
/*!
  이 축에 관련 지을 수 있던 모든 아이템의리스트를 돌려줍니다. 항목이 고려됩니다.
  축 중 하나 이상이 축을 키 또는 값 축으로 사용하는 경우 축과 관련됩니다.
  
  \ plotables, 그래프보기
*/
QList<QCPAbstractItem*> QCPAxis::items() const
{
  QList<QCPAbstractItem*> result;
  if (!mParentPlot) return result;
  
  for (int itemId=0; itemId<mParentPlot->mItems.size(); ++itemId)
  {
    QList<QCPItemPosition*> positions = mParentPlot->mItems.at(itemId)->positions();
    for (int posId=0; posId<positions.size(); ++posId)
    {
      if (positions.at(posId)->keyAxis() == this || positions.at(posId)->valueAxis() == this)
      {
        result.append(mParentPlot->mItems.at(itemId));
        break;
      }
    }
  }
  return result;
}

/*!
  Transforms a margin side to the logically corresponding axis type. (QCP::msLeft to
  QCPAxis::atLeft, QCP::msRight to QCPAxis::atRight, etc.)
*/
/*!
  논리적으로 해당하는 축 유형으로 여백 측면을 변환합니다. (QCP :: msLeft to
  QCPAxis :: atLeft, QCP :: msRight to QCPAxis :: atRight 등)
*/
QCPAxis::AxisType QCPAxis::marginSideToAxisType(QCP::MarginSide side)
{
  switch (side)
  {
    case QCP::msLeft: return atLeft;
    case QCP::msRight: return atRight;
    case QCP::msTop: return atTop;
    case QCP::msBottom: return atBottom;
    default: break;
  }
  qDebug() << Q_FUNC_INFO << "Invalid margin side passed:" << (int)side;
  return atLeft;
}

/*!
  Returns the axis type that describes the opposite axis of an axis with the specified \a type.
*/
/*!
  지정된 \ a 유형을 사용하여 축의 반대 축을 설명하는 축 유형을 반환합니다.
*/
QCPAxis::AxisType QCPAxis::opposite(QCPAxis::AxisType type)
{
  switch (type)
  {
    case atLeft: return atRight; break;
    case atRight: return atLeft; break;
    case atBottom: return atTop; break;
    case atTop: return atBottom; break;
    default: qDebug() << Q_FUNC_INFO << "invalid axis type"; return atLeft; break;
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPAxis::selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)
{
  Q_UNUSED(event)
  SelectablePart part = details.value<SelectablePart>();
  if (mSelectableParts.testFlag(part))
  {
    SelectableParts selBefore = mSelectedParts;
    setSelectedParts(additive ? mSelectedParts^part : part);
    if (selectionStateChanged)
      *selectionStateChanged = mSelectedParts != selBefore;
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPAxis::deselectEvent(bool *selectionStateChanged)
{
  SelectableParts selBefore = mSelectedParts;
  setSelectedParts(mSelectedParts & ~mSelectableParts);
  if (selectionStateChanged)
    *selectionStateChanged = mSelectedParts != selBefore;
}

/*! \internal
  
  This mouse event reimplementation provides the functionality to let the user drag individual axes
  exclusively, by startig the drag on top of the axis.

  For the axis to accept this event and perform the single axis drag, the parent \ref QCPAxisRect
  must be configured accordingly, i.e. it must allow range dragging in the orientation of this axis
  (\ref QCPAxisRect::setRangeDrag) and this axis must be a draggable axis (\ref
  QCPAxisRect::setRangeDragAxes)
  
  \seebaseclassmethod
  
  \note The dragging of possibly multiple axes at once by starting the drag anywhere in the axis
  rect is handled by the axis rect's mouse event, e.g. \ref QCPAxisRect::mousePressEvent.
*/
/*! \내부의
  
  이 마우스 이벤트 재 구현은 사용자가 개별 축
  배타적으로, 축 위에 드래그를 시작합니다.

  축이이 이벤트를 받아들이고 단일 축 끌기를 수행하려면 부모 \ ref QCPAxisRect
  그에 따라 구성되어야합니다. 즉,이 축의 방향으로 범위 드래그를 허용해야합니다.
  (\ ref QCPAxisRect :: setRangeDrag)이 축은 드래그 가능한 축이어야합니다 (\ ref
  QCPAxisRect :: setRangeDragAxes)
  
  \ seebaseclassmethod
  
  \ note 축에서 드래그를 시작하여 가능한 한 여러 축을 한 번에 드래그합니다.
  rect는 축 rect의 마우스 이벤트에 의해 처리됩니다 (예 : \ ref QCPAxisRect :: mousePressEvent).
*/
void QCPAxis::mousePressEvent(QMouseEvent *event, const QVariant &details)
{
  Q_UNUSED(details)
  if (!mParentPlot->interactions().testFlag(QCP::iRangeDrag) ||
      !mAxisRect->rangeDrag().testFlag(orientation()) ||
      !mAxisRect->rangeDragAxes(orientation()).contains(this))
  {
    event->ignore();
    return;
  }
  
  if (event->buttons() & Qt::LeftButton)
  {
    mDragging = true;
    // initialize antialiasing backup in case we start dragging:
    // 드래그를 시작할 경우를 대비해 앤티 엘리 어싱 백업을 초기화합니다.
    if (mParentPlot->noAntialiasingOnDrag())
    {
      mAADragBackup = mParentPlot->antialiasedElements();
      mNotAADragBackup = mParentPlot->notAntialiasedElements();
    }
    // Mouse range dragging interaction:
    // 마우스 범위 드래그 상호 작용 :
    if (mParentPlot->interactions().testFlag(QCP::iRangeDrag))
      mDragStartRange = mRange;
  }
}

/*! \internal
  
  This mouse event reimplementation provides the functionality to let the user drag individual axes
  exclusively, by startig the drag on top of the axis.
  
  \seebaseclassmethod
  
  \note The dragging of possibly multiple axes at once by starting the drag anywhere in the axis
  rect is handled by the axis rect's mouse event, e.g. \ref QCPAxisRect::mousePressEvent.
  
  \see QCPAxis::mousePressEvent
*/
/*! \내부의
  
  이 마우스 이벤트 재 구현은 사용자가 개별 축
  배타적으로, 축 위에 드래그를 시작합니다.
  
  \ seebaseclassmethod
  
  \ note 축에서 드래그를 시작하여 가능한 한 여러 축을 한 번에 드래그합니다.
  rect는 축 rect의 마우스 이벤트에 의해 처리됩니다 (예 : \ ref QCPAxisRect :: mousePressEvent).
  
  \ see QCPAxis :: mousePressEvent
*/
void QCPAxis::mouseMoveEvent(QMouseEvent *event, const QPointF &startPos)
{
  if (mDragging)
  {
    const double startPixel = orientation() == Qt::Horizontal ? startPos.x() : startPos.y();
    const double currentPixel = orientation() == Qt::Horizontal ? event->pos().x() : event->pos().y();
    if (mScaleType == QCPAxis::stLinear)
    {
      const double diff = pixelToCoord(startPixel) - pixelToCoord(currentPixel);
      setRange(mDragStartRange.lower+diff, mDragStartRange.upper+diff);
    } else if (mScaleType == QCPAxis::stLogarithmic)
    {
      const double diff = pixelToCoord(startPixel) / pixelToCoord(currentPixel);
      setRange(mDragStartRange.lower*diff, mDragStartRange.upper*diff);
    }
    
    if (mParentPlot->noAntialiasingOnDrag())
      mParentPlot->setNotAntialiasedElements(QCP::aeAll);
    mParentPlot->replot(QCustomPlot::rpQueuedReplot);
  }
}

/*! \internal
  
  This mouse event reimplementation provides the functionality to let the user drag individual axes
  exclusively, by startig the drag on top of the axis.
  
  \seebaseclassmethod
  
  \note The dragging of possibly multiple axes at once by starting the drag anywhere in the axis
  rect is handled by the axis rect's mouse event, e.g. \ref QCPAxisRect::mousePressEvent.
  
  \see QCPAxis::mousePressEvent
*/
/*! \내부의
  
  이 마우스 이벤트 재 구현은 사용자가 개별 축
  배타적으로, 축 위에 드래그를 시작합니다.
  
  \ seebaseclassmethod
  
  \ note 축에서 드래그를 시작하여 가능한 한 여러 축을 한 번에 드래그합니다.
  rect는 축 rect의 마우스 이벤트에 의해 처리됩니다 (예 : \ ref QCPAxisRect :: mousePressEvent).
  
  \ see QCPAxis :: mousePressEvent
*/
void QCPAxis::mouseReleaseEvent(QMouseEvent *event, const QPointF &startPos)
{
  Q_UNUSED(event)
  Q_UNUSED(startPos)
  mDragging = false;
  if (mParentPlot->noAntialiasingOnDrag())
  {
    mParentPlot->setAntialiasedElements(mAADragBackup);
    mParentPlot->setNotAntialiasedElements(mNotAADragBackup);
  }
}

/*! \internal
  
  This mouse event reimplementation provides the functionality to let the user zoom individual axes
  exclusively, by performing the wheel event on top of the axis.

  For the axis to accept this event and perform the single axis zoom, the parent \ref QCPAxisRect
  must be configured accordingly, i.e. it must allow range zooming in the orientation of this axis
  (\ref QCPAxisRect::setRangeZoom) and this axis must be a zoomable axis (\ref
  QCPAxisRect::setRangeZoomAxes)
  
  \seebaseclassmethod
  
  \note The zooming of possibly multiple axes at once by performing the wheel event anywhere in the
  axis rect is handled by the axis rect's mouse event, e.g. \ref QCPAxisRect::wheelEvent.
*/
/*! \내부의
  
  이 마우스 이벤트 재 구현은 사용자가 개별 축을 ​​확대 / 축소 할 수있는 기능을 제공합니다.
  배타적으로, 축 위에 휠 이벤트를 수행합니다.

  축이이 이벤트를 받아들이고 단일 축 확대 / 축소를 수행하기 위해 부모 \ ref QCPAxisRect
  그에 따라 구성되어야합니다. 즉,이 축의 방향으로 범위 확대를 허용해야합니다.
  (\ ref QCPAxisRect :: setRangeZoom)이 축은 줌 가능한 축이어야합니다 (\ ref
  QCPAxisRect :: setRangeZoomAxes)
  
  \ seebaseclassmethod
  
  \ note 휠 이벤트를 한 번에 여러 축을 확대 / 축소합니다.
  축 rect는 축 rect의 마우스 이벤트에 의해 처리됩니다 (예 : \ ref QCPAxisRect :: wheelEvent).
*/
void QCPAxis::wheelEvent(QWheelEvent *event)
{
  // Mouse range zooming interaction:
  // 마우스 범위 확대 / 축소 상호 작용 :
  if (!mParentPlot->interactions().testFlag(QCP::iRangeZoom) ||
      !mAxisRect->rangeZoom().testFlag(orientation()) ||
      !mAxisRect->rangeZoomAxes(orientation()).contains(this))
  {
    event->ignore();
    return;
  }
  
  const double wheelSteps = event->delta()/120.0; // a single step delta is +/-120 usually
                                                  // 한 단계 델타는 보통 +/- 120입니다.
  const double factor = qPow(mAxisRect->rangeZoomFactor(orientation()), wheelSteps);
  scaleRange(factor, pixelToCoord(orientation() == Qt::Horizontal ? event->pos().x() : event->pos().y()));
  mParentPlot->replot();
}

/*! \internal

  A convenience function to easily set the QPainter::Antialiased hint on the provided \a painter
  before drawing axis lines.

  This is the antialiasing state the painter passed to the \ref draw method is in by default.
  
  This function takes into account the local setting of the antialiasing flag as well as the
  overrides set with \ref QCustomPlot::setAntialiasedElements and \ref
  QCustomPlot::setNotAntialiasedElements.
  
  \seebaseclassmethod
  
  \see setAntialiased
*/
/*! \내부의

  제공된 Painter에서 QPainter :: Antialiased 힌트를 쉽게 설정할 수있는 편리한 함수입니다.
  축 선을 그리기 전에

  화가가 \ ref draw 메서드에 전달한 앤티 엘리 어싱 상태입니다.
  
  이 함수는 앤티 엘리 어싱 플래그의 로컬 설정은 물론
  \ ref QCustomPlot :: setAntialiasedElements 및 \ ref를 사용하여 설정 한 재정의
  QCustomPlot :: setNotAntialiasedElements.
  
  \ seebaseclassmethod
  
  \ setAntialiased 참조
*/
void QCPAxis::applyDefaultAntialiasingHint(QCPPainter *painter) const
{
  applyAntialiasingHint(painter, mAntialiased, QCP::aeAxes);
}

/*! \internal
  
  Draws the axis with the specified \a painter, using the internal QCPAxisPainterPrivate instance.

  \seebaseclassmethod
*/
/*! \내부의
  
  내부 QCPAxisPainterPrivate 인스턴스를 사용하여 지정된 \ painter로 축을 그립니다.

  \ seebaseclassmethod
*/
void QCPAxis::draw(QCPPainter *painter)
{
  QVector<double> subTickPositions; // the final coordToPixel transformed vector passed to QCPAxisPainter
                                    // QCPAxisPainter에 전달 된 최종 coordToPixel 변형 벡터
  QVector<double> tickPositions; // the final coordToPixel transformed vector passed to QCPAxisPainter
                                 // QCPAxisPainter에 전달 된 최종 coordToPixel 변형 벡터
  QVector<QString> tickLabels; // the final vector passed to QCPAxisPainter
                               // QCPAxisPainter에 전달 된 최종 벡터
  tickPositions.reserve(mTickVector.size());
  tickLabels.reserve(mTickVector.size());
  subTickPositions.reserve(mSubTickVector.size());
  
  if (mTicks)
  {
    for (int i=0; i<mTickVector.size(); ++i)
    {
      tickPositions.append(coordToPixel(mTickVector.at(i)));
      if (mTickLabels)
        tickLabels.append(mTickVectorLabels.at(i));
    }

    if (mSubTicks)
    {
      const int subTickCount = mSubTickVector.size();
      for (int i=0; i<subTickCount; ++i)
        subTickPositions.append(coordToPixel(mSubTickVector.at(i)));
    }
  }
  
  // transfer all properties of this axis to QCPAxisPainterPrivate which it needs to draw the axis.
  // Note that some axis painter properties are already set by direct feed-through with QCPAxis setters
  //이 축의 모든 속성을 축을 그리는 데 필요한 QCPAxisPainterPrivate로 전송합니다.
  // 일부 축 페인터 속성은 QCPAxis setter를 사용하여 직접 피드 스루를 통해 이미 설정되어 있음을 참고하십시오
  mAxisPainter->type = mAxisType;
  mAxisPainter->basePen = getBasePen();
  mAxisPainter->labelFont = getLabelFont();
  mAxisPainter->labelColor = getLabelColor();
  mAxisPainter->label = mLabel;
  mAxisPainter->substituteExponent = mNumberBeautifulPowers;
  mAxisPainter->tickPen = getTickPen();
  mAxisPainter->subTickPen = getSubTickPen();
  mAxisPainter->tickLabelFont = getTickLabelFont();
  mAxisPainter->tickLabelColor = getTickLabelColor();
  mAxisPainter->axisRect = mAxisRect->rect();
  mAxisPainter->viewportRect = mParentPlot->viewport();
  mAxisPainter->abbreviateDecimalPowers = mScaleType == stLogarithmic;
  mAxisPainter->reversedEndings = mRangeReversed;
  mAxisPainter->tickPositions = tickPositions;
  mAxisPainter->tickLabels = tickLabels;
  mAxisPainter->subTickPositions = subTickPositions;
  mAxisPainter->draw(painter);
}

/*! \internal
  
  Prepares the internal tick vector, sub tick vector and tick label vector. This is done by calling
  QCPAxisTicker::generate on the currently installed ticker.
  
  If a change in the label text/count is detected, the cached axis margin is invalidated to make
  sure the next margin calculation recalculates the label sizes and returns an up-to-date value.
*/
/*! \내부의
  
  내부 틱 벡터, 서브 틱 벡터 및 틱 레이블 벡터를 준비합니다. 이것은
  QCPAxisTicker :: generate 현재 설치된 티커에서 생성합니다.
  
  라벨 텍스트 / 카운트의 변경이 감지되면 캐시 된 축 여백은 무효화되어
  다음 여백 계산이 레이블 크기를 다시 계산하고 최신 값을 반환하는지 확인하십시오.
*/
void QCPAxis::setupTickVectors()
{
  if (!mParentPlot) return;
  if ((!mTicks && !mTickLabels && !mGrid->visible()) || mRange.size() <= 0) return;
  
  QVector<QString> oldLabels = mTickVectorLabels;
  mTicker->generate(mRange, mParentPlot->locale(), mNumberFormatChar, mNumberPrecision, mTickVector, mSubTicks ? &mSubTickVector : 0, mTickLabels ? &mTickVectorLabels : 0);
  mCachedMarginValid &= mTickVectorLabels == oldLabels; // if labels have changed, margin might have changed, too
}

/*! \internal
  
  Returns the pen that is used to draw the axis base line. Depending on the selection state, this
  is either mSelectedBasePen or mBasePen.
*/
/*! \내부의
  
  축 기준선을 그리는 데 사용되는 펜을 반환합니다. 선택 상태에 따라
  mSelectedBasePen 또는 mBasePen입니다.
*/
QPen QCPAxis::getBasePen() const
{
  return mSelectedParts.testFlag(spAxis) ? mSelectedBasePen : mBasePen;
}

/*! \internal
  
  Returns the pen that is used to draw the (major) ticks. Depending on the selection state, this
  is either mSelectedTickPen or mTickPen.
*/
/*! \내부의
  
  (메이저) 틱을 묘화하는데 사용하는 펜을 리턴합니다. 선택 상태에 따라
  mSelectedTickPen 또는 mTickPen입니다.
*/
QPen QCPAxis::getTickPen() const
{
  return mSelectedParts.testFlag(spAxis) ? mSelectedTickPen : mTickPen;
}

/*! \internal
  
  Returns the pen that is used to draw the subticks. Depending on the selection state, this
  is either mSelectedSubTickPen or mSubTickPen.
*/
/*! \내부의
  
  하위 그래픽 그리기에 사용되는 펜을 반환합니다. 선택 상태에 따라
  mSelectedSubTickPen 또는 mSubTickPen입니다.
*/
QPen QCPAxis::getSubTickPen() const
{
  return mSelectedParts.testFlag(spAxis) ? mSelectedSubTickPen : mSubTickPen;
}

/*! \internal
  
  Returns the font that is used to draw the tick labels. Depending on the selection state, this
  is either mSelectedTickLabelFont or mTickLabelFont.
*/
/*! \내부의
  
  눈금 레이블을 그리는 데 사용되는 글꼴을 반환합니다. 선택 상태에 따라
  mSelectedTickLabelFont 또는 mTickLabelFont입니다.
*/
QFont QCPAxis::getTickLabelFont() const
{
  return mSelectedParts.testFlag(spTickLabels) ? mSelectedTickLabelFont : mTickLabelFont;
}

/*! \internal
  
  Returns the font that is used to draw the axis label. Depending on the selection state, this
  is either mSelectedLabelFont or mLabelFont.
*/
/*! \내부의
  
  축 레이블을 그리는 데 사용되는 글꼴을 반환합니다. 선택 상태에 따라
  mSelectedLabelFont 또는 mLabelFont입니다.
*/
QFont QCPAxis::getLabelFont() const
{
  return mSelectedParts.testFlag(spAxisLabel) ? mSelectedLabelFont : mLabelFont;
}

/*! \internal
  
  Returns the color that is used to draw the tick labels. Depending on the selection state, this
  is either mSelectedTickLabelColor or mTickLabelColor.
*/
/*! \내부의
  
  눈금 레이블을 그리는 데 사용되는 색을 반환합니다. 선택 상태에 따라
  mSelectedTickLabelColor 또는 mTickLabelColor입니다.
*/
QColor QCPAxis::getTickLabelColor() const
{
  return mSelectedParts.testFlag(spTickLabels) ? mSelectedTickLabelColor : mTickLabelColor;
}

/*! \internal
  
  Returns the color that is used to draw the axis label. Depending on the selection state, this
  is either mSelectedLabelColor or mLabelColor.
*/

/*! \내부의
  
  축 레이블을 그리는 데 사용되는 색상을 반환합니다. 선택 상태에 따라
  mSelectedLabelColor 또는 mLabelColor입니다.
*/
QColor QCPAxis::getLabelColor() const
{
  return mSelectedParts.testFlag(spAxisLabel) ? mSelectedLabelColor : mLabelColor;
}

/*! \internal
  
  Returns the appropriate outward margin for this axis. It is needed if \ref
  QCPAxisRect::setAutoMargins is set to true on the parent axis rect. An axis with axis type \ref
  atLeft will return an appropriate left margin, \ref atBottom will return an appropriate bottom
  margin and so forth. For the calculation, this function goes through similar steps as \ref draw,
  so changing one function likely requires the modification of the other one as well.
  
  The margin consists of the outward tick length, tick label padding, tick label size, label
  padding, label size, and padding.
  
  The margin is cached internally, so repeated calls while leaving the axis range, fonts, etc.
  unchanged are very fast.
*/
/*! \내부의
  
  이 축의 적절한 바깥 쪽 마진을 반환합니다. \ ref라면 필요하다.
  qCPAxisRect :: setAutoMargins는 부모 축 rect에서 true로 설정됩니다. 축 유형 \ ref가있는 축
  atLeft는 적절한 왼쪽 마진을 반환하고, \ ref는 bottom을 반환합니다.
  마진 등. 계산을 위해이 함수는 \ ref draw와 비슷한 단계를 거치며,
  한 기능을 변경하려면 다른 기능을 수정해야 할 가능성이 높습니다.
  
  여백은 바깥 쪽 눈금 길이, 눈금 레이블 채우기, 눈금 레이블 크기, 레이블
  패딩, 레이블 크기 및 패딩을 지정합니다.
  
  여백은 내부적으로 캐시되므로 축 범위, 글꼴 등을 벗어나지 않고 반복되는 호출
  변하지 않은 것은 매우 빠릅니다.
*/
int QCPAxis::calculateMargin()
{
  if (!mVisible) // if not visible, directly return 0, don't cache 0 because we can't react to setVisible in QCPAxis
    return 0;    // 보이지 않는 경우 직접 0을 반환하고 QCPAxis에서 setVisible에 반응 할 수 없기 때문에 0을 캐시하지 않습니다.
  
  if (mCachedMarginValid)
    return mCachedMargin;
  
  // run through similar steps as QCPAxis::draw, and calculate margin needed to fit axis and its labels
  // QCPAxis :: draw와 비슷한 단계를 수행하고 축과 레이블에 맞추기 위해 필요한 여백을 계산합니다.
  int margin = 0;
  
  QVector<double> tickPositions; // the final coordToPixel transformed vector passed to QCPAxisPainter
                                 // QCPAxisPainter에 전달 된 최종 coordToPixel 변형 벡터
  QVector<QString> tickLabels; // the final vector passed to QCPAxisPainter
                               // QCPAxisPainter에 전달 된 최종 벡터
  tickPositions.reserve(mTickVector.size());
  tickLabels.reserve(mTickVector.size());
  
  if (mTicks)
  {
    for (int i=0; i<mTickVector.size(); ++i)
    {
      tickPositions.append(coordToPixel(mTickVector.at(i)));
      if (mTickLabels)
        tickLabels.append(mTickVectorLabels.at(i));
    }
  }
  // transfer all properties of this axis to QCPAxisPainterPrivate which it needs to calculate the size.
  // Note that some axis painter properties are already set by direct feed-through with QCPAxis setters
  //이 축의 모든 속성을 크기를 계산하는 데 필요한 QCPAxisPainterPrivate로 전송합니다.
  // 일부 축 페인터 속성은 QCPAxis setter를 사용하여 직접 피드 스루를 통해 이미 설정되어 있음을 참고하십시오
  mAxisPainter->type = mAxisType;
  mAxisPainter->labelFont = getLabelFont();
  mAxisPainter->label = mLabel;
  mAxisPainter->tickLabelFont = mTickLabelFont;
  mAxisPainter->axisRect = mAxisRect->rect();
  mAxisPainter->viewportRect = mParentPlot->viewport();
  mAxisPainter->tickPositions = tickPositions;
  mAxisPainter->tickLabels = tickLabels;
  margin += mAxisPainter->size();
  margin += mPadding;

  mCachedMargin = margin;
  mCachedMarginValid = true;
  return margin;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCP::Interaction QCPAxis::selectionCategory() const
{
  return QCP::iSelectAxes;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPAxisPainterPrivate
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPAxisPainterPrivate

  \internal
  \brief (Private)
  
  This is a private class and not part of the public QCustomPlot interface.
  
  It is used by QCPAxis to do the low-level drawing of axis backbone, tick marks, tick labels and
  axis label. It also buffers the labels to reduce replot times. The parameters are configured by
  directly accessing the public member variables.
*/
/*! \ class QCPAxisPainterPrivate

  \내부의
  \ brief (비공개)
  
  이것은 개인 클래스이며 공용 QCustomPlot 인터페이스의 일부가 아닙니다.
  
  QCPAxis는 축 백본, 눈금, 눈금 레이블 및 눈금 표시의 하위 수준 그리기를 수행하는 데 사용합니다.
  축 레이블. 또한 replot 시간을 줄이기 위해 레이블을 버퍼링합니다. 매개 변수는 다음과 같이 구성됩니다.
  public 멤버 변수에 직접 액세스합니다.
*/

/*!
  Constructs a QCPAxisPainterPrivate instance. Make sure to not create a new instance on every
  redraw, to utilize the caching mechanisms.
*/
/*!
  QCPAxisPainterPrivate 인스턴스를 구축합니다. 모든 인스턴스에 새 인스턴스를 만들지 않도록하십시오.
  캐싱 메커니즘을 활용하기 위해 다시 그리기.
*/
QCPAxisPainterPrivate::QCPAxisPainterPrivate(QCustomPlot *parentPlot) :
  type(QCPAxis::atLeft),
  basePen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),
  lowerEnding(QCPLineEnding::esNone),
  upperEnding(QCPLineEnding::esNone),
  labelPadding(0),
  tickLabelPadding(0),
  tickLabelRotation(0),
  tickLabelSide(QCPAxis::lsOutside),
  substituteExponent(true),
  numberMultiplyCross(false),
  tickLengthIn(5),
  tickLengthOut(0),
  subTickLengthIn(2),
  subTickLengthOut(0),
  tickPen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),
  subTickPen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),
  offset(0),
  abbreviateDecimalPowers(false),
  reversedEndings(false),
  mParentPlot(parentPlot),
  mLabelCache(16) // cache at most 16 (tick) labels
                  // 최대 16 (틱) 레이블을 캐시합니다.
{
}

QCPAxisPainterPrivate::~QCPAxisPainterPrivate()
{
}

/*! \internal
  
  Draws the axis with the specified \a painter.
  
  The selection boxes (mAxisSelectionBox, mTickLabelsSelectionBox, mLabelSelectionBox) are set
  here, too.
*/
/*! \내부의
  
  지정된 \ painter로 축을 그립니다.
  
  선택 상자 (mAxisSelectionBox, mTickLabelsSelectionBox, mLabelSelectionBox)가 설정됩니다.
  여기도.
*/
void QCPAxisPainterPrivate::draw(QCPPainter *painter)
{
  QByteArray newHash = generateLabelParameterHash();
  if (newHash != mLabelParameterHash)
  {
    mLabelCache.clear();
    mLabelParameterHash = newHash;
  }
  
  QPoint origin;
  switch (type)
  {
    case QCPAxis::atLeft:   origin = axisRect.bottomLeft() +QPoint(-offset, 0); break;
    case QCPAxis::atRight:  origin = axisRect.bottomRight()+QPoint(+offset, 0); break;
    case QCPAxis::atTop:    origin = axisRect.topLeft()    +QPoint(0, -offset); break;
    case QCPAxis::atBottom: origin = axisRect.bottomLeft() +QPoint(0, +offset); break;
  }

  double xCor = 0, yCor = 0; 
// paint system correction, for pixel exact matches (affects baselines and ticks of top/right axes)
// 픽셀 정확한 일치 (상단 / 우측 축의 기준선과 틱에 영향을 미침)에 대한 시스템 보정을 페인트합니다.

  switch (type)
  {
    case QCPAxis::atTop: yCor = -1; break;
    case QCPAxis::atRight: xCor = 1; break;
    default: break;
  }
  int margin = 0;
  // draw baseline:
  // 기준선 그리기 :
  QLineF baseLine;
  painter->setPen(basePen);
  if (QCPAxis::orientation(type) == Qt::Horizontal)
    baseLine.setPoints(origin+QPointF(xCor, yCor), origin+QPointF(axisRect.width()+xCor, yCor));
  else
    baseLine.setPoints(origin+QPointF(xCor, yCor), origin+QPointF(xCor, -axisRect.height()+yCor));
  if (reversedEndings)
    baseLine = QLineF(baseLine.p2(), baseLine.p1()); 
// won't make a difference for line itself, but for line endings later
// 라인 자체에는 차이가 없지만 나중에 라인 엔딩에는 차이가 있습니다.
  painter->drawLine(baseLine);
  
  // draw ticks:
  // 틱을 그립니다.
  if (!tickPositions.isEmpty())
  {
    painter->setPen(tickPen);
    int tickDir = (type == QCPAxis::atBottom || type == QCPAxis::atRight) ? -1 : 1; 
// direction of ticks ("inward" is right for left axis and left for right axis)
// 틱의 방향 ( "안쪽"은 왼쪽 축은 오른쪽, 왼쪽 축은 오른쪽)
    if (QCPAxis::orientation(type) == Qt::Horizontal)
    {
      for (int i=0; i<tickPositions.size(); ++i)
        painter->drawLine(QLineF(tickPositions.at(i)+xCor, origin.y()-tickLengthOut*tickDir+yCor, tickPositions.at(i)+xCor, origin.y()+tickLengthIn*tickDir+yCor));
    } else
    {
      for (int i=0; i<tickPositions.size(); ++i)
        painter->drawLine(QLineF(origin.x()-tickLengthOut*tickDir+xCor, tickPositions.at(i)+yCor, origin.x()+tickLengthIn*tickDir+xCor, tickPositions.at(i)+yCor));
    }
  }
  
  // draw subticks:
  // 하위 트리 그리기 :
  if (!subTickPositions.isEmpty())
  {
    painter->setPen(subTickPen);
    // direction of ticks ("inward" is right for left axis and left for right axis)
    // 틱의 방향 ( "안쪽"은 왼쪽 축은 오른쪽, 왼쪽 축은 오른쪽)
    int tickDir = (type == QCPAxis::atBottom || type == QCPAxis::atRight) ? -1 : 1;
    if (QCPAxis::orientation(type) == Qt::Horizontal)
    {
      for (int i=0; i<subTickPositions.size(); ++i)
        painter->drawLine(QLineF(subTickPositions.at(i)+xCor, origin.y()-subTickLengthOut*tickDir+yCor, subTickPositions.at(i)+xCor, origin.y()+subTickLengthIn*tickDir+yCor));
    } else
    {
      for (int i=0; i<subTickPositions.size(); ++i)
        painter->drawLine(QLineF(origin.x()-subTickLengthOut*tickDir+xCor, subTickPositions.at(i)+yCor, origin.x()+subTickLengthIn*tickDir+xCor, subTickPositions.at(i)+yCor));
    }
  }
  margin += qMax(0, qMax(tickLengthOut, subTickLengthOut));
  
  // draw axis base endings:
  // 축 기본 끝을 그립니다.
  bool antialiasingBackup = painter->antialiasing();
  painter->setAntialiasing(true); // always want endings to be antialiased, even if base and ticks themselves aren't
                                  //베이스와 틱 자체가 앤티 엘리 어싱되지 않도록하더라도 앤티 앨리어싱을 항상 원한다.
  painter->setBrush(QBrush(basePen.color()));
  QCPVector2D baseLineVector(baseLine.dx(), baseLine.dy());
  if (lowerEnding.style() != QCPLineEnding::esNone)
    lowerEnding.draw(painter, QCPVector2D(baseLine.p1())-baseLineVector.normalized()*lowerEnding.realLength()*(lowerEnding.inverted()?-1:1), -baseLineVector);
  if (upperEnding.style() != QCPLineEnding::esNone)
    upperEnding.draw(painter, QCPVector2D(baseLine.p2())+baseLineVector.normalized()*upperEnding.realLength()*(upperEnding.inverted()?-1:1), baseLineVector);
  painter->setAntialiasing(antialiasingBackup);
  
  // tick labels:
  // 눈금 표시 :
  QRect oldClipRect;
  if (tickLabelSide == QCPAxis::lsInside) // if using inside labels, clip them to the axis rect
                                          // 내부 레이블을 사용하는 경우 축 rect에 클립합니다.
  {
    oldClipRect = painter->clipRegion().boundingRect();
    painter->setClipRect(axisRect);
  }
  QSize tickLabelsSize(0, 0); // size of largest tick label, for offset calculation of axis label
  if (!tickLabels.isEmpty())  // 축 레이블의 오프셋 계산을위한 가장 큰 눈금 레이블의 크기
  {
    if (tickLabelSide == QCPAxis::lsOutside)
      margin += tickLabelPadding;
    painter->setFont(tickLabelFont);
    painter->setPen(QPen(tickLabelColor));
    const int maxLabelIndex = qMin(tickPositions.size(), tickLabels.size());
    int distanceToAxis = margin;
    if (tickLabelSide == QCPAxis::lsInside)
      distanceToAxis = -(qMax(tickLengthIn, subTickLengthIn)+tickLabelPadding);
    for (int i=0; i<maxLabelIndex; ++i)
      placeTickLabel(painter, tickPositions.at(i), distanceToAxis, tickLabels.at(i), &tickLabelsSize);
    if (tickLabelSide == QCPAxis::lsOutside)
      margin += (QCPAxis::orientation(type) == Qt::Horizontal) ? tickLabelsSize.height() : tickLabelsSize.width();
  }
  if (tickLabelSide == QCPAxis::lsInside)
    painter->setClipRect(oldClipRect);
  
  // axis label:
  // 축 레이블 :
  QRect labelBounds;
  if (!label.isEmpty())
  {
    margin += labelPadding;
    painter->setFont(labelFont);
    painter->setPen(QPen(labelColor));
    labelBounds = painter->fontMetrics().boundingRect(0, 0, 0, 0, Qt::TextDontClip, label);
    if (type == QCPAxis::atLeft)
    {
      QTransform oldTransform = painter->transform();
      painter->translate((origin.x()-margin-labelBounds.height()), origin.y());
      painter->rotate(-90);
      painter->drawText(0, 0, axisRect.height(), labelBounds.height(), Qt::TextDontClip | Qt::AlignCenter, label);
      painter->setTransform(oldTransform);
    }
    else if (type == QCPAxis::atRight)
    {
      QTransform oldTransform = painter->transform();
      painter->translate((origin.x()+margin+labelBounds.height()), origin.y()-axisRect.height());
      painter->rotate(90);
      painter->drawText(0, 0, axisRect.height(), labelBounds.height(), Qt::TextDontClip | Qt::AlignCenter, label);
      painter->setTransform(oldTransform);
    }
    else if (type == QCPAxis::atTop)
      painter->drawText(origin.x(), origin.y()-margin-labelBounds.height(), axisRect.width(), labelBounds.height(), Qt::TextDontClip | Qt::AlignCenter, label);
    else if (type == QCPAxis::atBottom)
      painter->drawText(origin.x(), origin.y()+margin, axisRect.width(), labelBounds.height(), Qt::TextDontClip | Qt::AlignCenter, label);
  }
  
  // set selection boxes:
  // 선택 상자 설정 :
  int selectionTolerance = 0;
  if (mParentPlot)
    selectionTolerance = mParentPlot->selectionTolerance();
  else
    qDebug() << Q_FUNC_INFO << "mParentPlot is null";
  int selAxisOutSize = qMax(qMax(tickLengthOut, subTickLengthOut), selectionTolerance);
  int selAxisInSize = selectionTolerance;
  int selTickLabelSize;
  int selTickLabelOffset;
  if (tickLabelSide == QCPAxis::lsOutside)
  {
    selTickLabelSize = (QCPAxis::orientation(type) == Qt::Horizontal ? tickLabelsSize.height() : tickLabelsSize.width());
    selTickLabelOffset = qMax(tickLengthOut, subTickLengthOut)+tickLabelPadding;
  } else
  {
    selTickLabelSize = -(QCPAxis::orientation(type) == Qt::Horizontal ? tickLabelsSize.height() : tickLabelsSize.width());
    selTickLabelOffset = -(qMax(tickLengthIn, subTickLengthIn)+tickLabelPadding);
  }
  int selLabelSize = labelBounds.height();
  int selLabelOffset = qMax(tickLengthOut, subTickLengthOut)+(!tickLabels.isEmpty() && tickLabelSide == QCPAxis::lsOutside ? tickLabelPadding+selTickLabelSize : 0)+labelPadding;
  if (type == QCPAxis::atLeft)
  {
    mAxisSelectionBox.setCoords(origin.x()-selAxisOutSize, axisRect.top(), origin.x()+selAxisInSize, axisRect.bottom());
    mTickLabelsSelectionBox.setCoords(origin.x()-selTickLabelOffset-selTickLabelSize, axisRect.top(), origin.x()-selTickLabelOffset, axisRect.bottom());
    mLabelSelectionBox.setCoords(origin.x()-selLabelOffset-selLabelSize, axisRect.top(), origin.x()-selLabelOffset, axisRect.bottom());
  } else if (type == QCPAxis::atRight)
  {
    mAxisSelectionBox.setCoords(origin.x()-selAxisInSize, axisRect.top(), origin.x()+selAxisOutSize, axisRect.bottom());
    mTickLabelsSelectionBox.setCoords(origin.x()+selTickLabelOffset+selTickLabelSize, axisRect.top(), origin.x()+selTickLabelOffset, axisRect.bottom());
    mLabelSelectionBox.setCoords(origin.x()+selLabelOffset+selLabelSize, axisRect.top(), origin.x()+selLabelOffset, axisRect.bottom());
  } else if (type == QCPAxis::atTop)
  {
    mAxisSelectionBox.setCoords(axisRect.left(), origin.y()-selAxisOutSize, axisRect.right(), origin.y()+selAxisInSize);
    mTickLabelsSelectionBox.setCoords(axisRect.left(), origin.y()-selTickLabelOffset-selTickLabelSize, axisRect.right(), origin.y()-selTickLabelOffset);
    mLabelSelectionBox.setCoords(axisRect.left(), origin.y()-selLabelOffset-selLabelSize, axisRect.right(), origin.y()-selLabelOffset);
  } else if (type == QCPAxis::atBottom)
  {
    mAxisSelectionBox.setCoords(axisRect.left(), origin.y()-selAxisInSize, axisRect.right(), origin.y()+selAxisOutSize);
    mTickLabelsSelectionBox.setCoords(axisRect.left(), origin.y()+selTickLabelOffset+selTickLabelSize, axisRect.right(), origin.y()+selTickLabelOffset);
    mLabelSelectionBox.setCoords(axisRect.left(), origin.y()+selLabelOffset+selLabelSize, axisRect.right(), origin.y()+selLabelOffset);
  }
  mAxisSelectionBox = mAxisSelectionBox.normalized();
  mTickLabelsSelectionBox = mTickLabelsSelectionBox.normalized();
  mLabelSelectionBox = mLabelSelectionBox.normalized();
  // draw hitboxes for debug purposes:
  // 디버그 목적으로 히트 박스를 그립니다.
  //painter->setBrush(Qt::NoBrush);
  //painter->drawRects(QVector<QRect>() << mAxisSelectionBox << mTickLabelsSelectionBox << mLabelSelectionBox);
}

/*! \internal
  
  Returns the size ("margin" in QCPAxisRect context, so measured perpendicular to the axis backbone
  direction) needed to fit the axis.
*/
/*! \내부의
  
  QCPAxisRect 컨텍스트에서 크기 ( "margin", 축 백본에 수직으로 측정 됨)을 반환합니다.
  방향).
*/
int QCPAxisPainterPrivate::size() const
{
  int result = 0;
  
  // get length of tick marks pointing outwards:
  // 바깥 쪽을 향한 눈금의 길이를 얻는다 :
  if (!tickPositions.isEmpty())
    result += qMax(0, qMax(tickLengthOut, subTickLengthOut));
  
  // calculate size of tick labels:
  // 눈금 라벨의 크기를 계산합니다.
  if (tickLabelSide == QCPAxis::lsOutside)
  {
    QSize tickLabelsSize(0, 0);
    if (!tickLabels.isEmpty())
    {
      for (int i=0; i<tickLabels.size(); ++i)
        getMaxTickLabelSize(tickLabelFont, tickLabels.at(i), &tickLabelsSize);
      result += QCPAxis::orientation(type) == Qt::Horizontal ? tickLabelsSize.height() : tickLabelsSize.width();
    result += tickLabelPadding;
    }
  }
  
  // calculate size of axis label (only height needed, because left/right labels are rotated by 90 degrees):
  // 축 레이블의 크기를 계산합니다 (왼쪽 / 오른쪽 레이블이 90도 회전하기 때문에 높이만 필요함).
  if (!label.isEmpty())
  {
    QFontMetrics fontMetrics(labelFont);
    QRect bounds;
    bounds = fontMetrics.boundingRect(0, 0, 0, 0, Qt::TextDontClip | Qt::AlignHCenter | Qt::AlignVCenter, label);
    result += bounds.height() + labelPadding;
  }
  
  return result;
}

/*! \internal
  
  Clears the internal label cache. Upon the next \ref draw, all labels will be created new. This
  method is called automatically in \ref draw, if any parameters have changed that invalidate the
  cached labels, such as font, color, etc.
*/
/*! \내부의
  
  내부 레이블 캐시를 지 웁니다. 다음 \ ref 드로우시 모든 라벨이 새로 만들어집니다. 이
  메서드는 \ ref draw에서 자동으로 호출됩니다. 매개 변수가 변경되면 해당 매개 변수가 무효화됩니다.
  글꼴, 색상 등과 같은 캐시 된 레이블
*/
void QCPAxisPainterPrivate::clearCache()
{
  mLabelCache.clear();
}

/*! \internal
  
  Returns a hash that allows uniquely identifying whether the label parameters have changed such
  that the cached labels must be refreshed (\ref clearCache). It is used in \ref draw. If the
  return value of this method hasn't changed since the last redraw, the respective label parameters
  haven't changed and cached labels may be used.
*/
/*! \내부의
  
  레이블 매개 변수가 변경되었는지 여부를 고유하게 식별 할 수있는 해시를 반환합니다.
  캐시 된 레이블을 새로 고쳐야합니다 (\ ref clearCache). 그것은 \ ref draw에서 사용됩니다. 만약
  이 메서드의 반환 값은 마지막 다시 그리기 이후 변경되지 않았으므로 각 레이블 매개 변수
  변경되지 않았으며 캐시 된 레이블을 사용할 수 있습니다.
*/
QByteArray QCPAxisPainterPrivate::generateLabelParameterHash() const
{
  QByteArray result;
  result.append(QByteArray::number(mParentPlot->bufferDevicePixelRatio()));
  result.append(QByteArray::number(tickLabelRotation));
  result.append(QByteArray::number((int)tickLabelSide));
  result.append(QByteArray::number((int)substituteExponent));
  result.append(QByteArray::number((int)numberMultiplyCross));
  result.append(tickLabelColor.name().toLatin1()+QByteArray::number(tickLabelColor.alpha(), 16));
  result.append(tickLabelFont.toString().toLatin1());
  return result;
}

/*! \internal
  
  Draws a single tick label with the provided \a painter, utilizing the internal label cache to
  significantly speed up drawing of labels that were drawn in previous calls. The tick label is
  always bound to an axis, the distance to the axis is controllable via \a distanceToAxis in
  pixels. The pixel position in the axis direction is passed in the \a position parameter. Hence
  for the bottom axis, \a position would indicate the horizontal pixel position (not coordinate),
  at which the label should be drawn.
  
  In order to later draw the axis label in a place that doesn't overlap with the tick labels, the
  largest tick label size is needed. This is acquired by passing a \a tickLabelsSize to the \ref
  drawTickLabel calls during the process of drawing all tick labels of one axis. In every call, \a
  tickLabelsSize is expanded, if the drawn label exceeds the value \a tickLabelsSize currently
  holds.
  
  The label is drawn with the font and pen that are currently set on the \a painter. To draw
  superscripted powers, the font is temporarily made smaller by a fixed factor (see \ref
  getTickLabelData).
*/
/*! \내부의
  
  내부 라벨 캐쉬를 사용하여 제공된 화가를 사용하여 단일 눈금 레이블을 그립니다.
  이전 통화에서 그려진 레이블 그리기 속도가 크게 향상되었습니다. 눈금 레이블은
  항상 축에 묶여 있으며 축에 대한 거리는 \ a distanceToAxis를 통해 제어 할 수 있습니다.
  픽셀. 축 방향의 픽셀 위치는 \ a 위치 매개 변수로 전달됩니다. 금후
  하단 축에 대해 \ a 위치는 수평 픽셀 위치 (좌표가 아님)를 나타냅니다.
  라벨을 그려야한다.
  
  나중에 틱 레이블과 겹치지 않는 위치에 축 레이블을 그리려면
  가장 큰 눈금 라벨 크기가 필요합니다. \ tickLabelsSize를 \ ref에 전달하면이 값을 얻을 수 있습니다.
  drawTickLabel은 한 축의 모든 눈금 레이블을 그리는 과정에서 호출합니다. 모든 전화에서 \ a
  그려지는 라벨이 현재 \ tickLabelsSize 값을 초과하면 tickLabelsSize가 확장됩니다.
  보유.
  
  라벨은 현재 \ a 페인터에 설정된 글꼴과 펜으로 그려집니다. 그릴 때
  윗 첨자를 쓰면 폰트는 일시적으로 고정 인수만큼 작아진다. (\ ref
  getTickLabelData).
*/
void QCPAxisPainterPrivate::placeTickLabel(QCPPainter *painter, double position, int distanceToAxis, const QString &text, QSize *tickLabelsSize)
{
  // warning: if you change anything here, also adapt getMaxTickLabelSize() accordingly!
  // 경고 : 여기에서 무엇인가를 변경하면 그에 따라 getMaxTickLabelSize ()도 변경됩니다!
  if (text.isEmpty()) return;
  QSize finalSize;
  QPointF labelAnchor;
  switch (type)
  {
    case QCPAxis::atLeft:   labelAnchor = QPointF(axisRect.left()-distanceToAxis-offset, position); break;
    case QCPAxis::atRight:  labelAnchor = QPointF(axisRect.right()+distanceToAxis+offset, position); break;
    case QCPAxis::atTop:    labelAnchor = QPointF(position, axisRect.top()-distanceToAxis-offset); break;
    case QCPAxis::atBottom: labelAnchor = QPointF(position, axisRect.bottom()+distanceToAxis+offset); break;
  }
  if (mParentPlot->plottingHints().testFlag(QCP::phCacheLabels) && !painter->modes().testFlag(QCPPainter::pmNoCaching)) // label caching enabled
  {                        // 레이블 캐싱 사용 가능
    CachedLabel *cachedLabel = mLabelCache.take(text); 
// attempt to get label from cache
// 캐시에서 레이블을 가져 오려고 시도합니다.
    if (!cachedLabel)  // no cached label existed, create it
    {                  // 캐시 된 레이블이 없으면 만듭니다.
      cachedLabel = new CachedLabel;
      TickLabelData labelData = getTickLabelData(painter->font(), text);
      cachedLabel->offset = getTickLabelDrawOffset(labelData)+labelData.rotatedTotalBounds.topLeft();
      if (!qFuzzyCompare(1.0, mParentPlot->bufferDevicePixelRatio()))
      {
        cachedLabel->pixmap = QPixmap(labelData.rotatedTotalBounds.size()*mParentPlot->bufferDevicePixelRatio());
#ifdef QCP_DEVICEPIXELRATIO_SUPPORTED
#  ifdef QCP_DEVICEPIXELRATIO_FLOAT
        cachedLabel->pixmap.setDevicePixelRatio(mParentPlot->devicePixelRatioF());
#  else
        cachedLabel->pixmap.setDevicePixelRatio(mParentPlot->devicePixelRatio());
#  endif
#endif
      } else
        cachedLabel->pixmap = QPixmap(labelData.rotatedTotalBounds.size());
      cachedLabel->pixmap.fill(Qt::transparent);
      QCPPainter cachePainter(&cachedLabel->pixmap);
      cachePainter.setPen(painter->pen());
      drawTickLabel(&cachePainter, -labelData.rotatedTotalBounds.topLeft().x(), -labelData.rotatedTotalBounds.topLeft().y(), labelData);
    }
    // if label would be partly clipped by widget border on sides, don't draw it (only for outside tick labels):
    // 라벨이 측면의 위젯 경계에 의해 부분적으로 클리핑되는 경우 그 라벨을 그려서는 안됩니다 (외부 눈금 라벨의 경우에만 해당).
    bool labelClippedByBorder = false;
    if (tickLabelSide == QCPAxis::lsOutside)
    {
      if (QCPAxis::orientation(type) == Qt::Horizontal)
        labelClippedByBorder = labelAnchor.x()+cachedLabel->offset.x()+cachedLabel->pixmap.width()/mParentPlot->bufferDevicePixelRatio() > viewportRect.right() || labelAnchor.x()+cachedLabel->offset.x() < viewportRect.left();
      else
        labelClippedByBorder = labelAnchor.y()+cachedLabel->offset.y()+cachedLabel->pixmap.height()/mParentPlot->bufferDevicePixelRatio() > viewportRect.bottom() || labelAnchor.y()+cachedLabel->offset.y() < viewportRect.top();
    }
    if (!labelClippedByBorder)
    {
      painter->drawPixmap(labelAnchor+cachedLabel->offset, cachedLabel->pixmap);
      finalSize = cachedLabel->pixmap.size()/mParentPlot->bufferDevicePixelRatio();
    }
    mLabelCache.insert(text, cachedLabel); 
// return label to cache or insert for the first time if newly created
// 새로 생성 된 경우 처음으로 레이블을 캐쉬하거나 삽입합니다.
  } else // label caching disabled, draw text directly on surface:
  {      // 캐싱 비활성화 라벨을 지정하고 텍스트를 표면에 직접 그립니다.
    TickLabelData labelData = getTickLabelData(painter->font(), text);
    QPointF finalPosition = labelAnchor + getTickLabelDrawOffset(labelData);
    // if label would be partly clipped by widget border on sides, don't draw it (only for outside tick labels):
    // 라벨이 측면의 위젯 경계에 의해 부분적으로 클리핑되는 경우 그 라벨을 그려서는 안됩니다 (외부 눈금 라벨의 경우에만 해당).
     bool labelClippedByBorder = false;
    if (tickLabelSide == QCPAxis::lsOutside)
    {
      if (QCPAxis::orientation(type) == Qt::Horizontal)
        labelClippedByBorder = finalPosition.x()+(labelData.rotatedTotalBounds.width()+labelData.rotatedTotalBounds.left()) > viewportRect.right() || finalPosition.x()+labelData.rotatedTotalBounds.left() < viewportRect.left();
      else
        labelClippedByBorder = finalPosition.y()+(labelData.rotatedTotalBounds.height()+labelData.rotatedTotalBounds.top()) > viewportRect.bottom() || finalPosition.y()+labelData.rotatedTotalBounds.top() < viewportRect.top();
    }
    if (!labelClippedByBorder)
    {
      drawTickLabel(painter, finalPosition.x(), finalPosition.y(), labelData);
      finalSize = labelData.rotatedTotalBounds.size();
    }
  }
  
  // expand passed tickLabelsSize if current tick label is larger:
  // 현재 눈금 레이블이 더 큰 경우 전달 된 tickLabelsSize를 확장합니다.
  if (finalSize.width() > tickLabelsSize->width())
    tickLabelsSize->setWidth(finalSize.width());
  if (finalSize.height() > tickLabelsSize->height())
    tickLabelsSize->setHeight(finalSize.height());
}

/*! \internal
  
  This is a \ref placeTickLabel helper function.
  
  Draws the tick label specified in \a labelData with \a painter at the pixel positions \a x and \a
  y. This function is used by \ref placeTickLabel to create new tick labels for the cache, or to
  directly draw the labels on the QCustomPlot surface when label caching is disabled, i.e. when
  QCP::phCacheLabels plotting hint is not set.
*/
/*! \내부의
  
  이것은 \ ref placeTickLabel 도우미 함수입니다.
  
  \ a labelData로 지정된 눈금의 label를, 픽셀 위치 \ ax 및 \ a의 \ painter로 묘화합니다.
  와이. 이 함수는 \ ref placeTickLabel에 의해 캐시를위한 새로운 눈금 레이블을 만들거나
  라벨 캐싱이 비활성화되어있을 때 QCustomPlot 표면에 라벨을 직접 그립니다.
  플롯 팅 힌트가 설정되지 않은 QCP :: phCacheLabels.
*/
void QCPAxisPainterPrivate::drawTickLabel(QCPPainter *painter, double x, double y, const TickLabelData &labelData) const
{
  // backup painter settings that we're about to change:
  // 변경하려는 백업 화가 설정 :
  QTransform oldTransform = painter->transform();
  QFont oldFont = painter->font();
  
  // transform painter to position/rotation:
  // 위치 / 회전으로 화가 변환 :
  painter->translate(x, y);
  if (!qFuzzyIsNull(tickLabelRotation))
    painter->rotate(tickLabelRotation);
  
  // draw text:
  // 텍스트 그리기 :
  if (!labelData.expPart.isEmpty()) // indicator that beautiful powers must be used
  {                                 // 아름다운 힘을 사용해야한다는 지시자
    painter->setFont(labelData.baseFont);
    painter->drawText(0, 0, 0, 0, Qt::TextDontClip, labelData.basePart);
    if (!labelData.suffixPart.isEmpty())
      painter->drawText(labelData.baseBounds.width()+1+labelData.expBounds.width(), 0, 0, 0, Qt::TextDontClip, labelData.suffixPart);
    painter->setFont(labelData.expFont);
    painter->drawText(labelData.baseBounds.width()+1, 0, labelData.expBounds.width(), labelData.expBounds.height(), Qt::TextDontClip,  labelData.expPart);
  } else
  {
    painter->setFont(labelData.baseFont);
    painter->drawText(0, 0, labelData.totalBounds.width(), labelData.totalBounds.height(), Qt::TextDontClip | Qt::AlignHCenter, labelData.basePart);
  }
  
  // reset painter settings to what it was before:
  // 이전의 상태로 화가 설정을 재설정합니다.
  painter->setTransform(oldTransform);
  painter->setFont(oldFont);
}

/*! \internal
  
  This is a \ref placeTickLabel helper function.
  
  Transforms the passed \a text and \a font to a tickLabelData structure that can then be further
  processed by \ref getTickLabelDrawOffset and \ref drawTickLabel. It splits the text into base and
  exponent if necessary (member substituteExponent) and calculates appropriate bounding boxes.
*/
/*! \내부의
  
  이것은 \ ref placeTickLabel 도우미 함수입니다.
  
  건네받은 \ a 텍스트 및 \ 폰트를 tickLabelData 구조체로 변환합니다.
  \ ref getTickLabelDrawOffset 및 \ ref drawTickLabel에 의해 처리됩니다. 텍스트를 기본 및
  필요한 경우 exponent (member substituteExponent) 적절한 경계 상자를 계산합니다.
*/
QCPAxisPainterPrivate::TickLabelData QCPAxisPainterPrivate::getTickLabelData(const QFont &font, const QString &text) const
{
  TickLabelData result;
  
  // determine whether beautiful decimal powers should be used
  // 아름다운 십진수를 사용해야하는지 여부를 결정합니다.
  bool useBeautifulPowers = false;
  int ePos = -1; // first index of exponent part, text before that will be basePart, text until eLast will be expPart
                 // exponent 부분의 첫 번째 인덱스, 그 전의 텍스트는 basePart, eLast가 expPart가 될 때까지 텍스트
  int eLast = -1; // last index of exponent part, rest of text after this will be suffixPart
                  // 지수 부분의 마지막 인덱스. 나머지 이후의 텍스트는 suffixPart가된다.
  if (substituteExponent)
  {
    ePos = text.indexOf(QLatin1Char('e'));
    if (ePos > 0 && text.at(ePos-1).isDigit())
    {
      eLast = ePos;
      while (eLast+1 < text.size() && (text.at(eLast+1) == QLatin1Char('+') || text.at(eLast+1) == QLatin1Char('-') || text.at(eLast+1).isDigit()))
        ++eLast;
      if (eLast > ePos) // only if also to right of 'e' is a digit/+/- interpret it as beautifiable power
                        // 'e'의 오른쪽에있는 경우에만 숫자가 / / / - 아름다운 힘으로 해석합니다.
        useBeautifulPowers = true;
    }
  }
  
  // calculate text bounding rects and do string preparation for beautiful decimal powers:
  // 텍스트 경계 사각형을 계산하고 아름다운 십진수를위한 문자열 준비를하십시오.
  result.baseFont = font;
  if (result.baseFont.pointSizeF() > 0) 
// might return -1 if specified with setPixelSize, in that case we can't do correction in next line
// setPixelSize로 지정된 경우 -1을 반환 할 수 있습니다.이 경우 다음 줄에서 수정할 수 없습니다.
    result.baseFont.setPointSizeF(result.baseFont.pointSizeF()+0.05); 
// QFontMetrics.boundingRect has a bug for exact point sizes that make the results oscillate due to internal rounding
// QFontMetrics.boundingRect는 내부 반올림으로 인해 결과가 진동하는 정확한 포인트 크기에 대한 버그가 있습니다.
  if (useBeautifulPowers)
  {
    // split text into parts of number/symbol that will be drawn normally and part that will be drawn as exponent:
    // 텍스트를 숫자 / 기호의 부분으로 분리하여 정상적으로 그려지며 일부는 지수로 그려집니다 :
  
    result.basePart = text.left(ePos);
    result.suffixPart = text.mid(eLast+1); // also drawn normally but after exponent
                                           // 또한 일반적으로 그려지지만 지수 다음에 그려집니다.
    // in log scaling, we want to turn "1*10^n" into "10^n", else add multiplication sign and decimal base:
    // 로그 스케일링에서 "1 * 10 ^ n"을 "10 ^ n"으로 바꾸고, 그렇지 않으면 곱셈 기호와 10 진수를 더합니다.
    if (abbreviateDecimalPowers && result.basePart == QLatin1String("1"))
      result.basePart = QLatin1String("10");
    else
      result.basePart += (numberMultiplyCross ? QString(QChar(215)) : QString(QChar(183))) + QLatin1String("10");
    result.expPart = text.mid(ePos+1, eLast-ePos);
    // clip "+" and leading zeros off expPart:
    // 클립 "+"및 앞에 오는 0을 expPart :
    while (result.expPart.length() > 2 && result.expPart.at(1) == QLatin1Char('0'))
    // length > 2 so we leave one zero when numberFormatChar is 'e'
    // length> 2 따라서 numberFormatChar가 'e'이면 1을 남겨 둡니다.
      result.expPart.remove(1, 1);
    if (!result.expPart.isEmpty() && result.expPart.at(0) == QLatin1Char('+'))
      result.expPart.remove(0, 1);
    // prepare smaller font for exponent:
    // 작은 글꼴을 지수로 준비 :
    result.expFont = font;
    if (result.expFont.pointSize() > 0)
      result.expFont.setPointSize(result.expFont.pointSize()*0.75);
    else
      result.expFont.setPixelSize(result.expFont.pixelSize()*0.75);
    // calculate bounding rects of base part(s), exponent part and total one:
    // 기본 부분, 지수 부분 및 전체 부분의 경계 rect를 계산합니다.
    result.baseBounds = QFontMetrics(result.baseFont).boundingRect(0, 0, 0, 0, Qt::TextDontClip, result.basePart);
    result.expBounds = QFontMetrics(result.expFont).boundingRect(0, 0, 0, 0, Qt::TextDontClip, result.expPart);
    if (!result.suffixPart.isEmpty())
      result.suffixBounds = QFontMetrics(result.baseFont).boundingRect(0, 0, 0, 0, Qt::TextDontClip, result.suffixPart);
    result.totalBounds = result.baseBounds.adjusted(0, 0, result.expBounds.width()+result.suffixBounds.width()+2, 0);
 // +2 consists of the 1 pixel spacing between base and exponent (see drawTickLabel) and an extra pixel to include AA
 // +2는 밑과 지수 사이의 1 픽셀 간격 (drawTickLabel 참조)과 AA를 포함하는 추가 픽셀로 구성됩니다
  } else // useBeautifulPowers == false
  {
    result.basePart = text;
    result.totalBounds = QFontMetrics(result.baseFont).boundingRect(0, 0, 0, 0, Qt::TextDontClip | Qt::AlignHCenter, result.basePart);
  }
  result.totalBounds.moveTopLeft(QPoint(0, 0)); 
// want bounding box aligned top left at origin, independent of how it was created, to make further processing simpler
// 경계 상자를 원점에서 왼쪽 상단에 정렬하여 생성 방법에 관계없이 추가 처리를 단순화합니다.  
 
 // calculate possibly different bounding rect after rotation:
 // 회전 후 서로 다른 경계 사각형을 계산합니다.
  result.rotatedTotalBounds = result.totalBounds;
  if (!qFuzzyIsNull(tickLabelRotation))
  {
    QTransform transform;
    transform.rotate(tickLabelRotation);
    result.rotatedTotalBounds = transform.mapRect(result.rotatedTotalBounds);
  }
  
  return result;
}

/*! \internal
  
  This is a \ref placeTickLabel helper function.
  
  Calculates the offset at which the top left corner of the specified tick label shall be drawn.
  The offset is relative to a point right next to the tick the label belongs to.
  
  This function is thus responsible for e.g. centering tick labels under ticks and positioning them
  appropriately when they are rotated.
*/
/*! \내부의
  
  이것은 \ ref placeTickLabel 도우미 함수입니다.
  
  지정된 눈금 라벨의 좌상 구석을 그릴 때의 오프셋 (offset)를 계산합니다.
  오프셋은 레이블이 속한 틱 바로 옆의 점을 기준으로합니다.
  
  이 기능은 예를 들어 진드기 레이블을 틱 아래에 배치하고 위치를 지정하는 역할을합니다
  회전 할 때 적절하게.
*/
QPointF QCPAxisPainterPrivate::getTickLabelDrawOffset(const TickLabelData &labelData) const
{
  /*
    calculate label offset from base point at tick (non-trivial, for best visual appearance): short
    explanation for bottom axis: The anchor, i.e. the point in the label that is placed
    horizontally under the corresponding tick is always on the label side that is closer to the
    axis (e.g. the left side of the text when we're rotating clockwise). On that side, the height
    is halved and the resulting point is defined the anchor. This way, a 90 degree rotated text
    will be centered under the tick (i.e. displaced horizontally by half its height). At the same
    time, a 45 degree rotated text will "point toward" its tick, as is typical for rotated tick
    labels.
  */
  /*
    틱 (tick)에서 기점으로부터의 레이블 오프셋을 계산합니다 (가장 좋은 시각적 표현을 위해 중요하지 않음) : short
    하단 축에 대한 설명 : 앵커, 즉 배치 된 레이블의 지점
    해당 틱 아래에서 가로로 항상 레이블 측면에있는
    축 (예 : 시계 방향으로 회전 할 때 텍스트의 왼쪽). 그면에서 높이
    결과 지점이 앵커로 정의됩니다. 이렇게하면 90도 회전 된 텍스트
    진드기의 중심에 놓일 것입니다 (즉, 높이의 반으로 수평으로 옮겨 짐). 같은에서
    회전 된 진드기에서는 45도 회전 텍스트가 눈금을 가리킬 것입니다.
    레이블.
  */
  bool doRotation = !qFuzzyIsNull(tickLabelRotation);
  bool flip = qFuzzyCompare(qAbs(tickLabelRotation), 90.0);
  // perfect +/-90 degree flip. Indicates vertical label centering on vertical axes.
  // 완벽한 +/- 90도 뒤집기. 세로 축을 중심으로 세로 레이블을 나타냅니다.
  double radians = tickLabelRotation/180.0*M_PI;
  int x=0, y=0;
  if ((type == QCPAxis::atLeft && tickLabelSide == QCPAxis::lsOutside) || (type == QCPAxis::atRight && tickLabelSide == QCPAxis::lsInside)) // Anchor at right side of tick label
                       // 눈금 라벨의 오른쪽에 앵커
  {
    if (doRotation)
    {
      if (tickLabelRotation > 0)
      {
        x = -qCos(radians)*labelData.totalBounds.width();
        y = flip ? -labelData.totalBounds.width()/2.0 : -qSin(radians)*labelData.totalBounds.width()-qCos(radians)*labelData.totalBounds.height()/2.0;
      } else
      {
        x = -qCos(-radians)*labelData.totalBounds.width()-qSin(-radians)*labelData.totalBounds.height();
        y = flip ? +labelData.totalBounds.width()/2.0 : +qSin(-radians)*labelData.totalBounds.width()-qCos(-radians)*labelData.totalBounds.height()/2.0;
      }
    } else
    {
      x = -labelData.totalBounds.width();
      y = -labelData.totalBounds.height()/2.0;
    }
  } else if ((type == QCPAxis::atRight && tickLabelSide == QCPAxis::lsOutside) || (type == QCPAxis::atLeft && tickLabelSide == QCPAxis::lsInside)) // Anchor at left side of tick label
  {                                  // 눈금 라벨의 왼쪽 앵커
    if (doRotation)
    {
      if (tickLabelRotation > 0)
      {
        x = +qSin(radians)*labelData.totalBounds.height();
        y = flip ? -labelData.totalBounds.width()/2.0 : -qCos(radians)*labelData.totalBounds.height()/2.0;
      } else
      {
        x = 0;
        y = flip ? +labelData.totalBounds.width()/2.0 : -qCos(-radians)*labelData.totalBounds.height()/2.0;
      }
    } else
    {
      x = 0;
      y = -labelData.totalBounds.height()/2.0;
    }
  } else if ((type == QCPAxis::atTop && tickLabelSide == QCPAxis::lsOutside) || (type == QCPAxis::atBottom && tickLabelSide == QCPAxis::lsInside)) // Anchor at bottom side of tick label
  {                                   // 눈금 라벨의 하단에 앵커
    if (doRotation)
    {
      if (tickLabelRotation > 0)
      {
        x = -qCos(radians)*labelData.totalBounds.width()+qSin(radians)*labelData.totalBounds.height()/2.0;
        y = -qSin(radians)*labelData.totalBounds.width()-qCos(radians)*labelData.totalBounds.height();
      } else
      {
        x = -qSin(-radians)*labelData.totalBounds.height()/2.0;
        y = -qCos(-radians)*labelData.totalBounds.height();
      }
    } else
    {
      x = -labelData.totalBounds.width()/2.0;
      y = -labelData.totalBounds.height();
    }
  } else if ((type == QCPAxis::atBottom && tickLabelSide == QCPAxis::lsOutside) || (type == QCPAxis::atTop && tickLabelSide == QCPAxis::lsInside)) // Anchor at top side of tick label
  {                                  // 눈금 라벨의 위쪽에 앵커
    if (doRotation)
    {
      if (tickLabelRotation > 0)
      {
        x = +qSin(radians)*labelData.totalBounds.height()/2.0;
        y = 0;
      } else
      {
        x = -qCos(-radians)*labelData.totalBounds.width()-qSin(-radians)*labelData.totalBounds.height()/2.0;
        y = +qSin(-radians)*labelData.totalBounds.width();
      }
    } else
    {
      x = -labelData.totalBounds.width()/2.0;
      y = 0;
    }
  }
  
  return QPointF(x, y);
}

/*! \internal
  
  Simulates the steps done by \ref placeTickLabel by calculating bounding boxes of the text label
  to be drawn, depending on number format etc. Since only the largest tick label is wanted for the
  margin calculation, the passed \a tickLabelsSize is only expanded, if it's currently set to a
  smaller width/height.
*/
 /*! \내부의
  
  텍스트 레이블의 경계 상자를 계산하여 \ ref placeTickLabel에 의해 수행 된 단계를 시뮬레이션합니다.
  숫자 형식 등에 따라 그려야합니다. 가장 큰 눈금 레이블 만이
  여백 계산에서 전달 된 \ tickLabelsSize는 현재 확장 된 경우에만 확장됩니다.
  너비 / 높이가 작습니다.
*/
void QCPAxisPainterPrivate::getMaxTickLabelSize(const QFont &font, const QString &text,  QSize *tickLabelsSize) const
{
  // note: this function must return the same tick label sizes as the placeTickLabel function.
  // 참고 :이 함수는 placeTickLabel 함수와 동일한 눈금 레이블 크기를 반환해야합니다.
  QSize finalSize;
  if (mParentPlot->plottingHints().testFlag(QCP::phCacheLabels) && mLabelCache.contains(text))
  // label caching enabled and have cached label
  // 캐싱 레이블을 설정하고 캐싱 된 레이블을 가짐
  {
    const CachedLabel *cachedLabel = mLabelCache.object(text);
    finalSize = cachedLabel->pixmap.size()/mParentPlot->bufferDevicePixelRatio();
  } else // label caching disabled or no label with this text cached:
  {      // 캐싱을 사용 안 함으로 설정하거나이 텍스트가있는 레이블을 캐싱하지 않음 :
    TickLabelData labelData = getTickLabelData(font, text);
    finalSize = labelData.rotatedTotalBounds.size();
  }
  
  // expand passed tickLabelsSize if current tick label is larger:
  // 현재 눈금 레이블이 더 큰 경우 전달 된 tickLabelsSize를 확장합니다.
  if (finalSize.width() > tickLabelsSize->width())
    tickLabelsSize->setWidth(finalSize.width());
  if (finalSize.height() > tickLabelsSize->height())
    tickLabelsSize->setHeight(finalSize.height());
}
/* end of 'src/axis/axis.cpp' */


/* including file 'src/scatterstyle.cpp', size 17450                         */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / axis / axis.cpp'의 끝 */


/* 파일 'src / scatterstyle.cpp'포함, 크기 17450 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPScatterStyle
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPScatterStyle
  \brief Represents the visual appearance of scatter points
  
  This class holds information about shape, color and size of scatter points. In plottables like
  QCPGraph it is used to store how scatter points shall be drawn. For example, \ref
  QCPGraph::setScatterStyle takes a QCPScatterStyle instance.
  
  A scatter style consists of a shape (\ref setShape), a line color (\ref setPen) and possibly a
  fill (\ref setBrush), if the shape provides a fillable area. Further, the size of the shape can
  be controlled with \ref setSize.

  \section QCPScatterStyle-defining Specifying a scatter style
  
  You can set all these configurations either by calling the respective functions on an instance:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpscatterstyle-creation-1
  
  Or you can use one of the various constructors that take different parameter combinations, making
  it easy to specify a scatter style in a single call, like so:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpscatterstyle-creation-2
  
  \section QCPScatterStyle-undefinedpen Leaving the color/pen up to the plottable
  
  There are two constructors which leave the pen undefined: \ref QCPScatterStyle() and \ref
  QCPScatterStyle(ScatterShape shape, double size). If those constructors are used, a call to \ref
  isPenDefined will return false. It leads to scatter points that inherit the pen from the
  plottable that uses the scatter style. Thus, if such a scatter style is passed to QCPGraph, the line
  color of the graph (\ref QCPGraph::setPen) will be used by the scatter points. This makes
  it very convenient to set up typical scatter settings:
  
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpscatterstyle-shortcreation

  Notice that it wasn't even necessary to explicitly call a QCPScatterStyle constructor. This works
  because QCPScatterStyle provides a constructor that can transform a \ref ScatterShape directly
  into a QCPScatterStyle instance (that's the \ref QCPScatterStyle(ScatterShape shape, double size)
  constructor with a default for \a size). In those cases, C++ allows directly supplying a \ref
  ScatterShape, where actually a QCPScatterStyle is expected.
  
  \section QCPScatterStyle-custompath-and-pixmap Custom shapes and pixmaps
  
  QCPScatterStyle supports drawing custom shapes and arbitrary pixmaps as scatter points.

  For custom shapes, you can provide a QPainterPath with the desired shape to the \ref
  setCustomPath function or call the constructor that takes a painter path. The scatter shape will
  automatically be set to \ref ssCustom.
  
  For pixmaps, you call \ref setPixmap with the desired QPixmap. Alternatively you can use the
  constructor that takes a QPixmap. The scatter shape will automatically be set to \ref ssPixmap.
  Note that \ref setSize does not influence the appearance of the pixmap.
*/
/*! \ class QCPScatterStyle
  \ brief 분산 점의 시각적 모양을 나타냅니다.
  
  이 클래스에는 모양, 색상 및 분산 점의 크기에 대한 정보가 들어 있습니다. 플래툰 같은
  QCPGraph는 스 캐터 포인트가 그려지는 방법을 저장하는 데 사용됩니다. 예를 들어, \ ref
  QCPGraph :: setScatterStyle은 QCPScatterStyle 인스턴스를 취합니다.
  
  스 캐터 스타일은 모양 (\ ref setShape), 선 색상 (\ ref setPen) 및 가능하면 a
  fill (\ ref setBrush). 모양이 채우기 영역을 제공하는 경우. 또한, 형상의 크기는
  \ ref setSize로 제어 할 수 있습니다.

  \ section QCPScatterStyle-defining 분산 형 스타일 지정
  
  인스턴스의 해당 함수를 호출하여 이러한 구성을 모두 설정할 수 있습니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpscatterstyle-creation-1
  
  또는 다른 매개 변수 조합을 취하는 다양한 생성자 중 하나를 사용하여
  단일 호출에서 스 캐터 스타일을 쉽게 지정할 수 있습니다. 예를 들면 다음과 같습니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpscatterstyle-creation-2
  
  \ section QCPScatterStyle-undefinedpen 색상 / 펜을 plottable까지 남겨 둡니다.
  
  펜을 정의하지 않은 상태로 두 가지 생성자가 있습니다 : \ ref QCPScatterStyle () 및 \ ref
  QCPScatterStyle (ScatterShape 모양, 두 배 크기). 이러한 생성자가 사용되면 \ ref를 호출합니다.
  isPenDefined는 false를 반환합니다. 그것은 펜을 상속받은 분산 점으로 이어집니다.
  스 캐터 스타일을 사용하는 plottable. 따라서, 그러한 스 캐터 스타일이 QCPGraph에 전달되면, 라인
  그래프의 색 (\ ref QCPGraph :: setPen)은 분산 점에 의해 사용됩니다. 이것은 만든다
  일반적인 분산 설정을 설정하는 것이 매우 편리합니다.
  
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpscatterstyle-shortcreation

  QCPScatterStyle 생성자를 명시 적으로 호출 할 필요조차 없습니다. 이 작품
  QCPScatterStyle은 \ ref ScatterShape를 직접 변형 할 수있는 생성자를 제공하기 때문에
  QCPScatterStyle 인스턴스 (\ ref QCPScatterStyle (ScatterShape 모양, 두 배 크기)
  \ a 크기의 기본값이있는 생성자). 이러한 경우 C ++은 \ ref를 직접 제공 할 수 있습니다.
  ScatterShape, 실제로 QCPScatterStyle이 필요합니다.
  
  \ section QCPScatterStyle-custompath-and-pixmap 사용자 정의 모양 및 픽스맵
  
  QCPScatterStyle은 사용자 정의 모양 및 임의의 픽맵을 분산 점으로 그리는 기능을 지원합니다.

  커스텀 쉐이프의 경우 \ ref에 원하는 모양의 QPainterPath를 제공 할 수 있습니다.
  setCustomPath 함수를 호출하거나 화가 경로를 사용하는 생성자를 호출합니다. 산포 모양은
  자동으로 \ ref ssCustom로 설정됩니다.
  
  픽스맵의 경우 \ ref setPixmap을 원하는 QPixmap과 함께 호출합니다. 다른 방법으로는
  QPixmap을 사용하는 생성자. 산포 모양은 \ ref ssPixmap으로 자동 설정됩니다.
  \ ref setSize는 픽스맵의 모양에 영향을 미치지 않습니다.
*/

/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */

/*! \fn bool QCPScatterStyle::isNone() const
  
  Returns whether the scatter shape is \ref ssNone.
  
  \see setShape
*/
/*! \ fn bool QCPScatterStyle :: isNone () const
  
  산포 모양이 \ ref ssNone인지 여부를 반환합니다.
  
  \ see setShape
*/

/*! \fn bool QCPScatterStyle::isPenDefined() const
  
  Returns whether a pen has been defined for this scatter style.
  
  The pen is undefined if a constructor is called that does not carry \a pen as parameter. Those
  are \ref QCPScatterStyle() and \ref QCPScatterStyle(ScatterShape shape, double size). If the pen
  is undefined, the pen of the respective plottable will be used for drawing scatters.
  
  If a pen was defined for this scatter style instance, and you now wish to undefine the pen, call
  \ref undefinePen.
  
  \see setPen
*/
/*! \ fn bool QCPScatterStyle :: isPenDefined () const
  
  이 분산 형에 대해서 펜이 정의되고 있는지 어떤지를 돌려줍니다.
  
  펜을 매개 변수로 사용하지 않는 생성자가 호출되면 펜은 정의되지 않습니다. 그
  \ ref QCPScatterStyle () 및 \ ref QCPScatterStyle (ScatterShape 모양, 배 크기)입니다. 펜의 경우
  정의되지 않은 경우, 각각의 플롯 테이블의 펜은 그림 그리기에 사용됩니다.
  
  이 분산 형 인스턴스에 대해 펜이 정의되어 있고 이제 펜을 정의 해제하려는 경우,
  \ ref undefinePen.
  
  \ see setPen
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */

/*!
  Creates a new QCPScatterStyle instance with size set to 6. No shape, pen or brush is defined.
  
  Since the pen is undefined (\ref isPenDefined returns false), the scatter color will be inherited
  from the plottable that uses this scatter style.
*/
/*!
  크기를 6으로 설정하여 새 QCPScatterStyle 인스턴스를 만듭니다. 모양, 펜 또는 브러시가 정의되어 있지 않습니다.
  
  펜이 정의되어 있지 않으므로 (\ ref isPenDefined가 false를 반환 함), 분산 색상이 상속됩니다
  이 스 캐터 스타일을 사용하는 플롯 테이블에서.
*/
QCPScatterStyle::QCPScatterStyle() :
  mSize(6),
  mShape(ssNone),
  mPen(Qt::NoPen),
  mBrush(Qt::NoBrush),
  mPenDefined(false)
{
}

/*!
  Creates a new QCPScatterStyle instance with shape set to \a shape and size to \a size. No pen or
  brush is defined.
  
  Since the pen is undefined (\ref isPenDefined returns false), the scatter color will be inherited
  from the plottable that uses this scatter style.
*/
/*!
  모양을 \ 모양으로하고 크기를 \ a 크기로 설정하여 새 QCPScatterStyle 인스턴스를 만듭니다. 펜이 없거나
  브러시가 정의됩니다.
  
  펜이 정의되어 있지 않으므로 (\ ref isPenDefined가 false를 반환 함), 분산 색상이 상속됩니다
  이 스 캐터 스타일을 사용하는 플롯 테이블에서.
*/
QCPScatterStyle::QCPScatterStyle(ScatterShape shape, double size) :
  mSize(size),
  mShape(shape),
  mPen(Qt::NoPen),
  mBrush(Qt::NoBrush),
  mPenDefined(false)
{
}

/*!
  Creates a new QCPScatterStyle instance with shape set to \a shape, the pen color set to \a color,
  and size to \a size. No brush is defined, i.e. the scatter point will not be filled.
*/
/*!
  모양이 \ 모양으로 설정된 새 QCPScatterStyle 인스턴스를 만들고 펜 색을 \ a 색으로 설정하고,
  크기를 \ a 크기로 지정하십시오. 브러시가 정의되어 있지 않습니다. 즉, 분산 점이 채워지지 않습니다.
*/
QCPScatterStyle::QCPScatterStyle(ScatterShape shape, const QColor &color, double size) :
  mSize(size),
  mShape(shape),
  mPen(QPen(color)),
  mBrush(Qt::NoBrush),
  mPenDefined(true)
{
}

/*!
  Creates a new QCPScatterStyle instance with shape set to \a shape, the pen color set to \a color,
  the brush color to \a fill (with a solid pattern), and size to \a size.
*/
/*!
  모양이 \ 모양으로 설정된 새 QCPScatterStyle 인스턴스를 만들고 펜 색을 \ a 색으로 설정하고,
  \ a 채우기 (단색 패턴 사용) 및 \ a 크기로 크기 변경이 가능합니다.
*/
QCPScatterStyle::QCPScatterStyle(ScatterShape shape, const QColor &color, const QColor &fill, double size) :
  mSize(size),
  mShape(shape),
  mPen(QPen(color)),
  mBrush(QBrush(fill)),
  mPenDefined(true)
{
}

/*!
  Creates a new QCPScatterStyle instance with shape set to \a shape, the pen set to \a pen, the
  brush to \a brush, and size to \a size.
  
  \warning In some cases it might be tempting to directly use a pen style like <tt>Qt::NoPen</tt> as \a pen
  and a color like <tt>Qt::blue</tt> as \a brush. Notice however, that the corresponding call\n
  <tt>QCPScatterStyle(QCPScatterShape::ssCircle, Qt::NoPen, Qt::blue, 5)</tt>\n
  doesn't necessarily lead C++ to use this constructor in some cases, but might mistake
  <tt>Qt::NoPen</tt> for a QColor and use the
  \ref QCPScatterStyle(ScatterShape shape, const QColor &color, const QColor &fill, double size)
  constructor instead (which will lead to an unexpected look of the scatter points). To prevent
  this, be more explicit with the parameter types. For example, use <tt>QBrush(Qt::blue)</tt>
  instead of just <tt>Qt::blue</tt>, to clearly point out to the compiler that this constructor is
  wanted.
*/
/*!
  모양을 \ 모양으로 설정하고 펜을 \ pen으로 설정 한 새 QCPScatterStyle 인스턴스를 만듭니다.
  브러쉬를 \ 브러쉬로, 크기를 \ a 크기로 지정하십시오.
  
  \ warning 어떤 경우에는 <tt> Qt :: NoPen </ tt>과 같은 펜 스타일을 펜으로 직접 사용하는 것이 유혹 될 수도 있습니다
  브러쉬로 <tt> Qt :: blue </ tt>와 같은 색상을 사용합니다. 그러나 해당 호출 \ n
  <tt> QCPScatterStyle (QCPScatterShape :: ssCircle, Qt :: NoPen, Qt :: blue, 5) </ tt> \ n
  반드시 C ++이 어떤 경우에는이 생성자를 사용하도록 유도하지는 않지만 실수 할 수도 있습니다
  QColor에 대한 <tt> Qt :: NoPen </ tt>을 사용하고
  \ ref QCPScatterStyle (ScatterShape 모양, const QColor & color, const QColor & fill, double size)
  대신 생성자를 사용하십시오 (이로 인해 예상치 못한 흩어져있는 모양이 나타납니다). 방지하기 위해
  매개 변수 유형에 대해보다 명확하게 설명하십시오. 예를 들어, <tt> QBrush (Qt :: blue) </ tt>
  명확하게 <tt> Qt :: blue </ tt> 대신에이 생성자가
  원했어.
*/
QCPScatterStyle::QCPScatterStyle(ScatterShape shape, const QPen &pen, const QBrush &brush, double size) :
  mSize(size),
  mShape(shape),
  mPen(pen),
  mBrush(brush),
  mPenDefined(pen.style() != Qt::NoPen)
{
}

/*!
  Creates a new QCPScatterStyle instance which will show the specified \a pixmap. The scatter shape
  is set to \ref ssPixmap.
*/
/*!
  지정된 \ pixmap을 표시 할 새 QCPScatterStyle 인스턴스를 만듭니다. 산포 모양
  \ ref ssPixmap으로 설정됩니다.
*/
QCPScatterStyle::QCPScatterStyle(const QPixmap &pixmap) :
  mSize(5),
  mShape(ssPixmap),
  mPen(Qt::NoPen),
  mBrush(Qt::NoBrush),
  mPixmap(pixmap),
  mPenDefined(false)
{
}

/*!
  Creates a new QCPScatterStyle instance with a custom shape that is defined via \a customPath. The
  scatter shape is set to \ref ssCustom.
  
  The custom shape line will be drawn with \a pen and filled with \a brush. The size has a slightly
  different meaning than for built-in scatter points: The custom path will be drawn scaled by a
  factor of \a size/6.0. Since the default \a size is 6, the custom path will appear in its
  original size by default. To for example double the size of the path, set \a size to 12.
*/
/*!
  \ customPath를 통해 정의 된 사용자 지정 셰이프로 새 QCPScatterStyle 인스턴스를 만듭니다. 그만큼
  scatter 모양은 \ ref ssCustom로 설정됩니다.
  
  사용자 정의 모양 선은 \ a 펜으로 그려지고 \ 브러시로 채워집니다. 크기는 약간 있습니다
  내장 된 분산 점보다 다른 의미 : 사용자 정의 경로는
  \ a 크기 / 6.0 팩터. 기본 \ a 크기가 6이므로 맞춤 경로가
  원래 크기. 예를 들어 경로의 크기를 두 배로하려면 \ a 크기를 12로 설정하십시오.
*/
QCPScatterStyle::QCPScatterStyle(const QPainterPath &customPath, const QPen &pen, const QBrush &brush, double size) :
  mSize(size),
  mShape(ssCustom),
  mPen(pen),
  mBrush(brush),
  mCustomPath(customPath),
  mPenDefined(pen.style() != Qt::NoPen)
{
}

/*!
  Copies the specified \a properties from the \a other scatter style to this scatter style.
*/
/*!
  지정된 \ a 속성을 다른 분산 형 스타일에서이 분산 형 스타일로 복사합니다.
*/
void QCPScatterStyle::setFromOther(const QCPScatterStyle &other, ScatterProperties properties)
{
  if (properties.testFlag(spPen))
  {
    setPen(other.pen());
    if (!other.isPenDefined())
      undefinePen();
  }
  if (properties.testFlag(spBrush))
    setBrush(other.brush());
  if (properties.testFlag(spSize))
    setSize(other.size());
  if (properties.testFlag(spShape))
  {
    setShape(other.shape());
    if (other.shape() == ssPixmap)
      setPixmap(other.pixmap());
    else if (other.shape() == ssCustom)
      setCustomPath(other.customPath());
  }
}

/*!
  Sets the size (pixel diameter) of the drawn scatter points to \a size.
  
  \see setShape
*/
/*!
  묘화 된 분산 점의 크기 (픽셀 직경)를 \ a 크기로 설정합니다.
  
  \ see setShape
*/
void QCPScatterStyle::setSize(double size)
{
  mSize = size;
}

/*!
  Sets the shape to \a shape.
  
  Note that the calls \ref setPixmap and \ref setCustomPath automatically set the shape to \ref
  ssPixmap and \ref ssCustom, respectively.
  
  \see setSize
*/
/*!
  모양을 \ 모양으로 설정합니다.
  
  \ ref setPixmap과 \ ref setCustomPath를 호출하면 모양이 자동으로 \ ref로 설정됩니다.
  ssPixmap 및 \ refssCustom에 각각 있습니다.
  
  \ setSize를 참조하십시오.
*/
void QCPScatterStyle::setShape(QCPScatterStyle::ScatterShape shape)
{
  mShape = shape;
}

/*!
  Sets the pen that will be used to draw scatter points to \a pen.
  
  If the pen was previously undefined (see \ref isPenDefined), the pen is considered defined after
  a call to this function, even if \a pen is <tt>Qt::NoPen</tt>. If you have defined a pen
  previously by calling this function and now wish to undefine the pen, call \ref undefinePen.
  
  \see setBrush
*/
/*!
  흩어진 점을 그리는 데 사용할 펜을 \ 펜으로 설정합니다.
  
  펜이 이전에 정의되지 않은 경우 (\ ref isPenDefined 참조), 펜은
  \ a 펜이 <tt> Qt :: NoPen </ tt> 인 경우에도이 함수에 대한 호출. 펜을 정의한 경우
  이전에이 함수를 호출하고 이제 펜을 정의 해제하려면 \ ref undefinePen을 호출하십시오.
  
  \ setBrush를 참조하십시오.
*/
void QCPScatterStyle::setPen(const QPen &pen)
{
  mPenDefined = true;
  mPen = pen;
}

/*!
  Sets the brush that will be used to fill scatter points to \a brush. Note that not all scatter
  shapes have fillable areas. For example, \ref ssPlus does not while \ref ssCircle does.
  
  \see setPen
*/

/*!
  분산 점을 채우는 데 사용할 브러시를 \ 브러시로 설정합니다. 모든 스 캐터가
  도형에는 칠할 수있는 영역이 있습니다. 예를 들어, \ ref ssPlus는 \ ref ssCircle이 수행하는 동안 나타나지 않습니다.
  
  \ see setPen
*/
void QCPScatterStyle::setBrush(const QBrush &brush)
{
  mBrush = brush;
}

/*!
  Sets the pixmap that will be drawn as scatter point to \a pixmap.
  
  Note that \ref setSize does not influence the appearance of the pixmap.
  
  The scatter shape is automatically set to \ref ssPixmap.
*/
/*!
  scatterpoint로 그려지는 pixmap을 \ pixmap으로 설정합니다.
  
  \ ref setSize는 픽스맵의 모양에 영향을 미치지 않습니다.
  
  산포 모양은 \ ref ssPixmap으로 자동 설정됩니다.
*/
void QCPScatterStyle::setPixmap(const QPixmap &pixmap)
{
  setShape(ssPixmap);
  mPixmap = pixmap;
}

/*!
  Sets the custom shape that will be drawn as scatter point to \a customPath.
  
  The scatter shape is automatically set to \ref ssCustom.
*/
/*!
  scatterPath로 그려지는 사용자 지정 모양을 \ customPath로 설정합니다.
  
  산포 모양은 자동으로 \ ref ssCustom로 설정됩니다.
*/
void QCPScatterStyle::setCustomPath(const QPainterPath &customPath)
{
  setShape(ssCustom);
  mCustomPath = customPath;
}

/*!
  Sets this scatter style to have an undefined pen (see \ref isPenDefined for what an undefined pen
  implies).

  A call to \ref setPen will define a pen.
*/
/*!
  이 분산 형 스타일을 정의되지 않은 펜으로 설정합니다 (\ ref isPenDefined에서 정의되지 않은 펜 참조).
  의미한다).

  \ ref setPen을 호출하면 펜이 정의됩니다.
*/
void QCPScatterStyle::undefinePen()
{
  mPenDefined = false;
}

/*!
  Applies the pen and the brush of this scatter style to \a painter. If this scatter style has an
  undefined pen (\ref isPenDefined), sets the pen of \a painter to \a defaultPen instead.
  
  This function is used by plottables (or any class that wants to draw scatters) just before a
  number of scatters with this style shall be drawn with the \a painter.
  
  \see drawShape
*/
/*!
  이 분산 형 스타일의 펜과 브러시를 \ painter에 적용합니다. 이 분산 형 스타일에
  정의되지 않은 펜 (\ ref isPenDefined)은 \ painter의 펜을 \ defaultPen으로 설정합니다.
  
  이 함수는 plottables (또는 분산을 그리려는 모든 클래스)에 의해 사용됩니다.
  이 스타일을 가진 산란 자의 수는 \ a 화가와 함께 그려야한다.
  
  \ drawShape 참조
*/
void QCPScatterStyle::applyTo(QCPPainter *painter, const QPen &defaultPen) const
{
  painter->setPen(mPenDefined ? mPen : defaultPen);
  painter->setBrush(mBrush);
}

/*!
  Draws the scatter shape with \a painter at position \a pos.
  
  This function does not modify the pen or the brush on the painter, as \ref applyTo is meant to be
  called before scatter points are drawn with \ref drawShape.
  
  \see applyTo
*/
/*!
  \ a 위치에있는 화가를 사용하여 scatter 모양을 그립니다.
  
  이 함수는 painter의 펜이나 브러시를 수정하지 않습니다. \ ref applyTo는 의도 된 것입니다.
  분산 점이 \ ref drawShape로 그려지기 전에 호출됩니다.
  
  \ see applyTo
*/
void QCPScatterStyle::drawShape(QCPPainter *painter, const QPointF &pos) const
{
  drawShape(painter, pos.x(), pos.y());
}

/*! \overload
  Draws the scatter shape with \a painter at position \a x and \a y.
*/
/*! \초과 적재
  \ ax와 \ y에 위치하는 화가를 사용하여 산포 모양을 그립니다.
*/
void QCPScatterStyle::drawShape(QCPPainter *painter, double x, double y) const
{
  double w = mSize/2.0;
  switch (mShape)
  {
    case ssNone: break;
    case ssDot:
    {
      painter->drawLine(QPointF(x, y), QPointF(x+0.0001, y));
      break;
    }
    case ssCross:
    {
      painter->drawLine(QLineF(x-w, y-w, x+w, y+w));
      painter->drawLine(QLineF(x-w, y+w, x+w, y-w));
      break;
    }
    case ssPlus:
    {
      painter->drawLine(QLineF(x-w,   y, x+w,   y));
      painter->drawLine(QLineF(  x, y+w,   x, y-w));
      break;
    }
    case ssCircle:
    {
      painter->drawEllipse(QPointF(x , y), w, w);
      break;
    }
    case ssDisc:
    {
      QBrush b = painter->brush();
      painter->setBrush(painter->pen().color());
      painter->drawEllipse(QPointF(x , y), w, w);
      painter->setBrush(b);
      break;
    }
    case ssSquare:
    {
      painter->drawRect(QRectF(x-w, y-w, mSize, mSize));
      break;
    }
    case ssDiamond:
    {
      QPointF lineArray[4] = {QPointF(x-w,   y),
                              QPointF(  x, y-w),
                              QPointF(x+w,   y),
                              QPointF(  x, y+w)};
      painter->drawPolygon(lineArray, 4);
      break;
    }
    case ssStar:
    {
      painter->drawLine(QLineF(x-w,   y, x+w,   y));
      painter->drawLine(QLineF(  x, y+w,   x, y-w));
      painter->drawLine(QLineF(x-w*0.707, y-w*0.707, x+w*0.707, y+w*0.707));
      painter->drawLine(QLineF(x-w*0.707, y+w*0.707, x+w*0.707, y-w*0.707));
      break;
    }
    case ssTriangle:
    {
      QPointF lineArray[3] = {QPointF(x-w, y+0.755*w),
                              QPointF(x+w, y+0.755*w),
                              QPointF(  x, y-0.977*w)};
      painter->drawPolygon(lineArray, 3);
      break;
    }
    case ssTriangleInverted:
    {
      QPointF lineArray[3] = {QPointF(x-w, y-0.755*w),
                              QPointF(x+w, y-0.755*w),
                              QPointF(  x, y+0.977*w)};
      painter->drawPolygon(lineArray, 3);
      break;
    }
    case ssCrossSquare:
    {
      painter->drawRect(QRectF(x-w, y-w, mSize, mSize));
      painter->drawLine(QLineF(x-w, y-w, x+w*0.95, y+w*0.95));
      painter->drawLine(QLineF(x-w, y+w*0.95, x+w*0.95, y-w));
      break;
    }
    case ssPlusSquare:
    {
      painter->drawRect(QRectF(x-w, y-w, mSize, mSize));
      painter->drawLine(QLineF(x-w,   y, x+w*0.95,   y));
      painter->drawLine(QLineF(  x, y+w,        x, y-w));
      break;
    }
    case ssCrossCircle:
    {
      painter->drawEllipse(QPointF(x, y), w, w);
      painter->drawLine(QLineF(x-w*0.707, y-w*0.707, x+w*0.670, y+w*0.670));
      painter->drawLine(QLineF(x-w*0.707, y+w*0.670, x+w*0.670, y-w*0.707));
      break;
    }
    case ssPlusCircle:
    {
      painter->drawEllipse(QPointF(x, y), w, w);
      painter->drawLine(QLineF(x-w,   y, x+w,   y));
      painter->drawLine(QLineF(  x, y+w,   x, y-w));
      break;
    }
    case ssPeace:
    {
      painter->drawEllipse(QPointF(x, y), w, w);
      painter->drawLine(QLineF(x, y-w,         x,       y+w));
      painter->drawLine(QLineF(x,   y, x-w*0.707, y+w*0.707));
      painter->drawLine(QLineF(x,   y, x+w*0.707, y+w*0.707));
      break;
    }
    case ssPixmap:
    {
      const double widthHalf = mPixmap.width()*0.5;
      const double heightHalf = mPixmap.height()*0.5;
#if QT_VERSION < QT_VERSION_CHECK(4, 8, 0)
      const QRectF clipRect = painter->clipRegion().boundingRect().adjusted(-widthHalf, -heightHalf, widthHalf, heightHalf);
#else
      const QRectF clipRect = painter->clipBoundingRect().adjusted(-widthHalf, -heightHalf, widthHalf, heightHalf);
#endif
      if (clipRect.contains(x, y))
        painter->drawPixmap(x-widthHalf, y-heightHalf, mPixmap);
      break;
    }
    case ssCustom:
    {
      QTransform oldTransform = painter->transform();
      painter->translate(x, y);
      painter->scale(mSize/6.0, mSize/6.0);
      painter->drawPath(mCustomPath);
      painter->setTransform(oldTransform);
      break;
    }
  }
}
/* end of 'src/scatterstyle.cpp' */

//amalgamation: add datacontainer.cpp

/* including file 'src/plottable.cpp', size 38845                            */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / scatterstyle.cpp'의 끝 */

// amalgamation : datacontainer.cpp를 추가합니다.

/* 파일 'src / plottable.cpp', 크기 38845 포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPSelectionDecorator
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPSelectionDecorator
  \brief Controls how a plottable's data selection is drawn
  
  Each \ref QCPAbstractPlottable instance has one \ref QCPSelectionDecorator (accessible via \ref
  QCPAbstractPlottable::selectionDecorator) and uses it when drawing selected segments of its data.
  
  The selection decorator controls both pen (\ref setPen) and brush (\ref setBrush), as well as the
  scatter style (\ref setScatterStyle) if the plottable draws scatters. Since a \ref
  QCPScatterStyle is itself composed of different properties such as color shape and size, the
  decorator allows specifying exactly which of those properties shall be used for the selected data
  point, via \ref setUsedScatterProperties.
  
  A \ref QCPSelectionDecorator subclass instance can be passed to a plottable via \ref
  QCPAbstractPlottable::setSelectionDecorator, allowing greater customizability of the appearance
  of selected segments.
  
  Use \ref copyFrom to easily transfer the settings of one decorator to another one. This is
  especially useful since plottables take ownership of the passed selection decorator, and thus the
  same decorator instance can not be passed to multiple plottables.
  
  Selection decorators can also themselves perform drawing operations by reimplementing \ref
  drawDecoration, which is called by the plottable's draw method. The base class \ref
  QCPSelectionDecorator does not make use of this however. For example, \ref
  QCPSelectionDecoratorBracket draws brackets around selected data segments.
*/
/*! \ class QCPSelectionDecorator
  \ brief 플롯 테이블의 데이터 선택 방법을 제어합니다.
  
  각 \ ref QCPAbstractPlottable 인스턴스에는 \ ref QCPSelectionDecorator (\ ref를 통해 액세스 할 수 있습니다.
  QCPAbstractPlottable :: selectionDecorator) 데이터의 선택된 세그먼트를 그릴 때이를 사용합니다.
  
  선택 데코레이터는 펜 (\ ref setPen)과 브러시 (\ ref setBrush)를 모두 제어합니다.
  플롯 테이블이 뿌려지면 분산 형 (\ ref setScatterStyle) 스타일. \ ref 이후
  QCPScatterStyle 자체는 색상 모양 및 크기와 같은 다양한 속성으로 구성됩니다.
  데코레이터를 사용하면 선택한 데이터에 대해 해당 속성 중 어느 것을 사용해야하는지 정확하게 지정할 수 있습니다.
  point를 통해 \ ref setUsedScatterProperties.
  
  \ ref QCPSelectionDecorator 하위 클래스 인스턴스는 \ ref를 통해 플롯 테이블에 전달 될 수 있습니다.
  QCPAbstractPlottable :: setSelectionDecorator를 사용하여 모양의 커스터마이즈가 가능합니다.
  선택한 세그먼트의
  
  \ ref copyFrom을 사용하여 한 데코레이터의 설정을 다른 데코레이터로 쉽게 전송할 수 있습니다. 이것은
  특히 plottables가 전달 된 선택 데코레이터의 소유권을 취하므로 유용합니다.
  동일한 데코레이터 인스턴스를 여러 플롯 테이블에 전달할 수 없습니다.
  
  Selection Decorator는 \ ref를 다시 구현하여 드로잉 작업을 수행 할 수도 있습니다.
  drawDecoration : plottable의 draw 메소드에 의해 불려갑니다. 기본 클래스 \ ref
  그러나 QCPSelectionDecorator는 이것을 사용하지 않습니다. 예를 들어, \ ref
  QCPSelectionDecoratorBracket은 선택된 데이터 세그먼트 주위에 대괄호를 그립니다.
*/

/*!
  Creates a new QCPSelectionDecorator instance with default values
*/
/*!
  기본값을 사용하여 새 QCPSelectionDecorator 인스턴스를 생성합니다.
*/
QCPSelectionDecorator::QCPSelectionDecorator() :
  mPen(QColor(80, 80, 255), 2.5),
  mBrush(Qt::NoBrush),
  mScatterStyle(),
  mUsedScatterProperties(QCPScatterStyle::spNone),
  mPlottable(0)
{
}

QCPSelectionDecorator::~QCPSelectionDecorator()
{
}

/*!
  Sets the pen that will be used by the parent plottable to draw selected data segments.
*/
/*!
  부모 플롯 테이블에서 선택한 데이터 세그먼트를 그리는 데 사용할 펜을 설정합니다.
*/
void QCPSelectionDecorator::setPen(const QPen &pen)
{
  mPen = pen;
}

/*!
  Sets the brush that will be used by the parent plottable to draw selected data segments.
*/
/*!
  부모 플롯 테이블에서 선택한 데이터 세그먼트를 그리는 데 사용할 브러시를 설정합니다.
*/
void QCPSelectionDecorator::setBrush(const QBrush &brush)
{
  mBrush = brush;
}

/*!
  Sets the scatter style that will be used by the parent plottable to draw scatters in selected
  data segments.
  
  \a usedProperties specifies which parts of the passed \a scatterStyle will be used by the
  plottable. The used properties can also be changed via \ref setUsedScatterProperties.
*/
/*!
  부모 Plottable이 선택된면에 산점도를 그리는 데 사용할 산포 스타일을 설정합니다.
  데이터 세그먼트.
  
  \ a usedProperties는 전달 된 \ scatterStyle의 어느 부분이
  plottable. 사용 된 속성은 \ ref setUsedScatterProperties를 통해 변경할 수도 있습니다.
*/
void QCPSelectionDecorator::setScatterStyle(const QCPScatterStyle &scatterStyle, QCPScatterStyle::ScatterProperties usedProperties)
{
  mScatterStyle = scatterStyle;
  setUsedScatterProperties(usedProperties);
}

/*!
  Use this method to define which properties of the scatter style (set via \ref setScatterStyle)
  will be used for selected data segments. All properties of the scatter style that are not
  specified in \a properties will remain as specified in the plottable's original scatter style.
  
  \see QCPScatterStyle::ScatterProperty
*/
/*!
  이 메서드를 사용하여 분산 스타일의 속성을 정의합니다 (\ ref setScatterStyle을 통해 설정).
  선택한 데이터 세그먼트에 사용됩니다. 스 캐터 스타일의 모든 속성은 그렇지 않습니다.
  \ a 속성에 지정된 값은 plottable의 원래 스 캐터 스타일에 지정된대로 유지됩니다.
  
  \ QCPScatterStyle :: ScatterProperty를 참조하십시오.
*/
void QCPSelectionDecorator::setUsedScatterProperties(const QCPScatterStyle::ScatterProperties &properties)
{
  mUsedScatterProperties = properties;
}

/*!
  Sets the pen of \a painter to the pen of this selection decorator.
  
  \see applyBrush, getFinalScatterStyle
*/
/*!
  이 선택 데코레이터의 펜에 \ painter의 펜을 설정합니다.
  
  \ applyBrush, getFinalScatterStyle을 참조하십시오.
*/
void QCPSelectionDecorator::applyPen(QCPPainter *painter) const
{
  painter->setPen(mPen);
}

/*!
  Sets the brush of \a painter to the brush of this selection decorator.
  
  \see applyPen, getFinalScatterStyle
*/
/*!
  이 선택 데코레이터의 브러시에 \ painter의 브러시를 설정합니다.
  
  \ see applyPen, getFinalScatterStyle
*/
void QCPSelectionDecorator::applyBrush(QCPPainter *painter) const
{
  painter->setBrush(mBrush);
}

/*!
  Returns the scatter style that the parent plottable shall use for selected scatter points. The
  plottable's original (unselected) scatter style must be passed as \a unselectedStyle. Depending
  on the setting of \ref setUsedScatterProperties, the returned scatter style is a mixture of this
  selecion decorator's scatter style (\ref setScatterStyle), and \a unselectedStyle.
  
  \see applyPen, applyBrush, setScatterStyle
*/
/*!
  부모 스폿이 선택된 스 캐터 포인트에 사용할 스 캐터 스타일을 반환합니다. 그만큼
  plottable의 원래 (선택되지 않은) 분산 스타일은 \ unselectedStyle로 전달되어야합니다. 의존
  \ ref setUsedScatterProperties 설정에서 반환 된 분산 형 스타일은 다음과 같습니다.
  selecion 데코레이터의 분산 스타일 (\ ref setScatterStyle) 및 \ a unselectedStyle.
  
  \ applyPen, applyBrush, setScatterStyle을 참조하십시오.
*/
QCPScatterStyle QCPSelectionDecorator::getFinalScatterStyle(const QCPScatterStyle &unselectedStyle) const
{
  QCPScatterStyle result(unselectedStyle);
  result.setFromOther(mScatterStyle, mUsedScatterProperties);
  
  // if style shall inherit pen from plottable (has no own pen defined), give it the selected
  // plottable pen explicitly, so it doesn't use the unselected plottable pen when used in the
  // plottable:
  // 스타일이 plottable에서 펜을 상속 할 경우 (펜이 정의되지 않은 경우), 선택한
  // plottable 펜을 명시 적으로 사용하므로 선택되지 않은 plottable 펜을 사용하지 않습니다.
  // plottable :
  if (!result.isPenDefined())
    result.setPen(mPen);
  
  return result;
}

/*!
  Copies all properties (e.g. color, fill, scatter style) of the \a other selection decorator to
  this selection decorator.
*/
/*!
  다른 선택 데코레이터의 모든 속성 (예 : 색상, 채우기, 분산 형 스타일)을 다음으로 복사합니다.
  이 선택 장식 자.
*/
void QCPSelectionDecorator::copyFrom(const QCPSelectionDecorator *other)
{
  setPen(other->pen());
  setBrush(other->brush());
  setScatterStyle(other->scatterStyle(), other->usedScatterProperties());
}

/*!
  This method is called by all plottables' draw methods to allow custom selection decorations to be
  drawn. Use the passed \a painter to perform the drawing operations. \a selection carries the data
  selection for which the decoration shall be drawn.
  
  The default base class implementation of \ref QCPSelectionDecorator has no special decoration, so
  this method does nothing.
*/
/*!
  이 메소드는 모든 plottables의 그리기 메소드에 의해 호출되어 사용자 정의 선택 장식을 허용합니다.
  그어진. 전달 된 \ painter를 사용하여 그리기 작업을 수행합니다. 선택에 따라 데이터가 전달됩니다.
  장식을 그려야하는 선택.
  
  \ ref QCPSelectionDecorator의 기본 기본 클래스 구현에는 특별한 장식이 없으므로
  이 메소드는 아무것도하지 않습니다.
*/
void QCPSelectionDecorator::drawDecoration(QCPPainter *painter, QCPDataSelection selection)
{
  Q_UNUSED(painter)
  Q_UNUSED(selection)
}

/*! \internal
  
  This method is called as soon as a selection decorator is associated with a plottable, by a call
  to \ref QCPAbstractPlottable::setSelectionDecorator. This way the selection decorator can obtain a pointer to the plottable that uses it (e.g. to access
  data points via the \ref QCPAbstractPlottable::interface1D interface).
  
  If the selection decorator was already added to a different plottable before, this method aborts
  the registration and returns false.
*/
/*! \내부의
  
  이 메소드는 선택 데코레이터가 플롯 테이블과 연관된 즉시 호출됩니다
  \ ref QCPAbstractPlottable :: setSelectionDecorator. 이 방법을 사용하면 선택 데코레이터는이를 사용하는 플롯 테이블에 대한 포인터를 얻을 수 있습니다 (예 : 액세스
  \ ref QCPAbstractPlottable :: interface1D 인터페이스를 통해 데이터 포인트).
  
  이전에 selection decorator가 다른 plottable에 이미 추가 된 경우이 메서드는 중단됩니다.
  등록 및 false를 반환합니다.
*/
bool QCPSelectionDecorator::registerWithPlottable(QCPAbstractPlottable *plottable)
{
  if (!mPlottable)
  {
    mPlottable = plottable;
    return true;
  } else
  {
    qDebug() << Q_FUNC_INFO << "This selection decorator is already registered with plottable:" << reinterpret_cast<quintptr>(mPlottable);
    return false;
  }
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPAbstractPlottable
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPAbstractPlottable
  \brief The abstract base class for all data representing objects in a plot.

  It defines a very basic interface like name, pen, brush, visibility etc. Since this class is
  abstract, it can't be instantiated. Use one of the subclasses or create a subclass yourself to
  create new ways of displaying data (see "Creating own plottables" below). Plottables that display
  one-dimensional data (i.e. data points have a single key dimension and one or multiple values at
  each key) are based off of the template subclass \ref QCPAbstractPlottable1D, see details
  there.
  
  All further specifics are in the subclasses, for example:
  \li A normal graph with possibly a line and/or scatter points \ref QCPGraph
  (typically created with \ref QCustomPlot::addGraph)
  \li A parametric curve: \ref QCPCurve
  \li A bar chart: \ref QCPBars
  \li A statistical box plot: \ref QCPStatisticalBox
  \li A color encoded two-dimensional map: \ref QCPColorMap
  \li An OHLC/Candlestick chart: \ref QCPFinancial
  
  \section plottables-subclassing Creating own plottables
  
  Subclassing directly from QCPAbstractPlottable is only recommended if you wish to display
  two-dimensional data like \ref QCPColorMap, i.e. two logical key dimensions and one (or more)
  data dimensions. If you want to display data with only one logical key dimension, you should
  rather derive from \ref QCPAbstractPlottable1D.
  
  If subclassing QCPAbstractPlottable directly, these are the pure virtual functions you must
  implement:
  \li \ref selectTest
  \li \ref draw
  \li \ref drawLegendIcon
  \li \ref getKeyRange
  \li \ref getValueRange
  
  See the documentation of those functions for what they need to do.
  
  For drawing your plot, you can use the \ref coordsToPixels functions to translate a point in plot
  coordinates to pixel coordinates. This function is quite convenient, because it takes the
  orientation of the key and value axes into account for you (x and y are swapped when the key axis
  is vertical and the value axis horizontal). If you are worried about performance (i.e. you need
  to translate many points in a loop like QCPGraph), you can directly use \ref
  QCPAxis::coordToPixel. However, you must then take care about the orientation of the axis
  yourself.
  
  Here are some important members you inherit from QCPAbstractPlottable:
  <table>
  <tr>
    <td>QCustomPlot *\b mParentPlot</td>
    <td>A pointer to the parent QCustomPlot instance. The parent plot is inferred from the axes that are passed in the constructor.</td>
  </tr><tr>
    <td>QString \b mName</td>
    <td>The name of the plottable.</td>
  </tr><tr>
    <td>QPen \b mPen</td>
    <td>The generic pen of the plottable. You should use this pen for the most prominent data representing lines in the plottable
        (e.g QCPGraph uses this pen for its graph lines and scatters)</td>
  </tr><tr>
    <td>QBrush \b mBrush</td>
    <td>The generic brush of the plottable. You should use this brush for the most prominent fillable structures in the plottable
        (e.g. QCPGraph uses this brush to control filling under the graph)</td>
  </tr><tr>
    <td>QPointer<\ref QCPAxis> \b mKeyAxis, \b mValueAxis</td>
    <td>The key and value axes this plottable is attached to. Call their QCPAxis::coordToPixel functions to translate coordinates
        to pixels in either the key or value dimension. Make sure to check whether the pointer is null before using it. If one of
        the axes is null, don't draw the plottable.</td>
  </tr><tr>
    <td>\ref QCPSelectionDecorator \b mSelectionDecorator</td>
    <td>The currently set selection decorator which specifies how selected data of the plottable shall be drawn and decorated.
        When drawing your data, you must consult this decorator for the appropriate pen/brush before drawing unselected/selected data segments.
        Finally, you should call its \ref QCPSelectionDecorator::drawDecoration method at the end of your \ref draw implementation.</td>
  </tr><tr>
    <td>\ref QCP::SelectionType \b mSelectable</td>
    <td>In which composition, if at all, this plottable's data may be selected. Enforcing this setting on the data selection is done
        by QCPAbstractPlottable automatically.</td>
  </tr><tr>
    <td>\ref QCPDataSelection \b mSelection</td>
    <td>Holds the current selection state of the plottable's data, i.e. the selected data ranges (\ref QCPDataRange).</td>
  </tr>
  </table>
*/
/*! \ class QCPAbstractPlottable
  \ brief 플롯의 오브젝트를 나타내는 모든 데이터의 추상 기본 클래스.

  이 클래스는 이름, 펜, 브러시, 가시성 등과 같은 매우 기본적인 인터페이스를 정의합니다.
  추상, 인스턴스화 할 수 없습니다. 서브 클래스 중 하나를 사용하거나 서브 클래스를 직접 작성하십시오.
  데이터를 표시하는 새로운 방법을 만듭니다 (아래 "자신의 플롯 테이블 만들기"참조). 표시되는 플롯 테이블
  1 차원 데이터 (즉, 데이터 포인트에는 단일 키 차원과 하나 이상의 값이 있습니다.
  각 키)는 템플릿 하위 클래스 \ ref QCPAbstractPlottable1D를 기반으로합니다 (세부 정보 참조).
  그곳에.
  
  모든 세부 사항은 서브 클래스에 있습니다. 예를 들면 다음과 같습니다.
  \ li 가능성이있는 선 및 / 또는 분산 점을 가진 정상적인 그래프 \ ref QCPGraph
  (일반적으로 \ ref QCustomPlot :: addGraph로 생성)
  \ li 매개 변수 곡선 : \ ref QCPCurve
  \ li 막 대형 차트 : \ ref QCPBars
  \ li 통계 상자 플롯 : \ ref QCPStatisticalBox
  \ li 색으로 인코딩 된 2 차원 맵 : \ ref QCPColorMap
  \ li OHLC / 촛대 차트 : \ ref QCPFinancial
  
  \ section plottables-subclassing 자신의 플롯 테이블 만들기
  
  QCPAbstractPlottable에서 직접 서브 클래 싱하는 것은 표시하려는 경우에만 권장됩니다.
  \ ref QCPColorMap과 같은 2 차원 데이터, 즉 2 개의 논리 키 차원과 하나 이상의 (또는 그 이상)
  데이터 크기. 논리 키 차원이 하나만있는 데이터를 표시하려면
  오히려 \ ref QCPAbstractPlottable1D에서 파생됩니다.
  
  QCPAbstractPlottable을 직접 서브 클래 싱하는 경우, 이들은 순수 가상 함수입니다.
  도구:
  \ li \ ref select test
  \ li \ ref 끌기
  \ li \ ref drawLegendIcon
  \ li \ ref getKeyRange
  \ li \ ref getValueRange
  
  필요한 기능에 대한 설명서를 참조하십시오.
  
  플롯을 그리기 위해 \ ref coordsToPixels 함수를 사용하여 플롯의 한 점을 변환 할 수 있습니다
  좌표를 픽셀 좌표로 지정합니다. 이 함수는 매우 편리합니다.
  키 축과 값 축의 방향을 고려해야합니다 (x와 y는 키 축
  수직이고 값 축은 수평 임). 실적에 대해 걱정한다면 (즉,
  QCPGraph와 같은 루프에서 많은 점들을 번역하기 위해) \ ref를 직접 사용할 수 있습니다.
  QCPAxis :: coordToPixel. 그러나 축의 방향에주의해야합니다
  당신 자신.
  
  다음은 QCPAbstractPlottable에서 상속 한 중요한 멤버입니다.
  <table>
  <tr>
    <td> QCustomPlot * \ b mParentPlot </ td>
    <td> 부모 QCustomPlot 인스턴스에 대한 포인터입니다. 부모 플롯은 생성자에서 전달 된 축으로부터 추론됩니다. </ td>
  </ tr> <tr>
    <td> QString \ b mName </ td>
    <td> 플롯 테이블의 이름입니다. </ td>
  </ tr> <tr>
    <td> QPen \ b mPen </ td>
    <td> plottable의 일반 펜. 이 펜을 사용하여 plottable의 선을 나타내는 가장 눈에 띄는 데이터를 사용해야합니다.
        (예 : QCPGraph는이 펜을 그래프 선과 산란 자로 사용합니다.) </ td>
  </ tr> <tr>
    <td> QBrush \ b mBrush </ td>
    <td> plottable의 일반 브러시입니다. 플롯 테이블에서 가장 눈에 띄는 채울 수있는 구조에이 브러시를 사용해야합니다.
        (예 : QCPGraph는이 브러시를 사용하여 그래프 아래의 채우기를 제어합니다.) </ td>
  </ tr> <tr>
    <td> QPointer <\ ref QCPAxis> \ b mKeyAxis, \ b mValueAxis </ td>
    <td>이 플롯 테이블이 첨부 된 키 및 값 축입니다. QCPAxis :: coordToPixel 함수를 호출하여 좌표 변환
        키 또는 값 차원의 픽셀로 포인터를 사용하기 전에 포인터가 null인지 확인하십시오. 다음 중 하나 인 경우
        축이 null 인 경우, 플롯 테이블을 그리지 않습니다. </ td>
  </ tr> <tr>
    <td> \ ref QCPSelectionDecorator \ b mSelectionDecorator </ td>
    <td> plottable의 선택된 데이터를 그려 장식하는 방법을 지정하는 현재 설정된 선택 데코레이터입니다.
        데이터를 그릴 때 선택되지 않은 / 선택된 데이터 세그먼트를 그리기 전에이 펜 / 브러쉬에 대해이 데코레이터를 참조해야합니다.
        마지막으로 \ ref draw 구현이 끝날 때 \ ref QCPSelectionDecorator :: drawDecoration 메소드를 호출해야합니다. </ td>
  </ tr> <tr>
    <td> \ ref QCP :: SelectionType \ b mSelectable </ td>
    <td> 어떤 구성에서,이 플롯 테이블의 데이터가 선택 될 수 있습니다. 데이터 선택시이 설정을 적용합니다.
        자동으로 QCPAbstractPlottable. </ td>
  </ tr> <tr>
    <td> \ ref QCPDataSelection \ b mSelection </ td>
    <td> 플롯 테이블의 현재 선택 상태, 즉 선택된 데이터 범위 (\ ref QCPDataRange)를 보유합니다. </ td>
  </ tr>
  </ table>
*/

/* start of documentation of inline functions */
/* 인라인 함수의 문서화 시작 */

/*! \fn QCPSelectionDecorator *QCPAbstractPlottable::selectionDecorator() const
  
  Provides access to the selection decorator of this plottable. The selection decorator controls
  how selected data ranges are drawn (e.g. their pen color and fill), see \ref
  QCPSelectionDecorator for details.
  
  If you wish to use an own \ref QCPSelectionDecorator subclass, pass an instance of it to \ref
  setSelectionDecorator.
*/
/*! \ fn QCPSelectionDecorator * QCPAbstractPlottable :: selectionDecorator () const
  
  이 Plotable의 선택 데코레이터에 대한 액세스를 제공합니다. 선택 데코레이터 컨트롤
  선택된 데이터 범위가 그려지는 방법 (예 : 펜의 색상과 채우기)은 \ ref를 참조하십시오.
  자세한 내용은 QCPSelectionDecorator를 참조하십시오.
  
  자신의 \ ref QCPSelectionDecorator 서브 클래스를 사용하고자한다면 \ ref의 인스턴스를 전달한다.
  setSelectionDecorator.
*/

/*! \fn bool QCPAbstractPlottable::selected() const
  
  Returns true if there are any data points of the plottable currently selected. Use \ref selection
  to retrieve the current \ref QCPDataSelection.
*/
/*! \ fn bool QCPAbstractPlottable :: selected () const
  
  현재 선택되고있는 plottable의 데이터 포인트가있는 경우는 true를 돌려줍니다. \ ref 선택 사용
  현재 \ ref QCPDataSelection을 검색합니다.
*/

/*! \fn QCPDataSelection QCPAbstractPlottable::selection() const
  
  Returns a \ref QCPDataSelection encompassing all the data points that are currently selected on
  this plottable.
  
  \see selected, setSelection, setSelectable
*/
/*! \ fn QCPDataSelection QCPAbstractPlottable :: selection () const
  
  현재 선택되어있는 모든 데이터 요소를 포함하는 \ ref QCPDataSelection을 반환합니다.
  이 plottable.
  
  \ see selected, setSelection, setSelectable
*/

/*! \fn virtual QCPPlottableInterface1D *QCPAbstractPlottable::interface1D()
  
  If this plottable is a one-dimensional plottable, i.e. it implements the \ref
  QCPPlottableInterface1D, returns the \a this pointer with that type. Otherwise (e.g. in the case
  of a \ref QCPColorMap) returns zero.
  
  You can use this method to gain read access to data coordinates while holding a pointer to the
  abstract base class only.
*/
/*! \ fn 가상 QCPPlottableInterface1D * QCPAbstractPlottable :: interface1D ()
  
  이 plottable이 1 차원 plottable 인 경우 즉, \ ref를 구현하는 경우
  QCPPlottableInterface1D,이 포인터를 해당 유형으로 리턴합니다. 그렇지 않은 경우 (예 :
  \ ref QCPColorMap)는 0을 반환합니다.
  
  이 메소드를 사용하면 (자), 포인터를 보관 유지하면서 데이터 좌표에의 읽어 내 액세스를 얻을 수 있습니다.
  추상 기본 클래스 만.
*/

/* end of documentation of inline functions */
/* start of documentation of pure virtual functions */
/* 인라인 함수의 문서 끝 */
/* 순수 가상 함수의 문서화 시작 */

/*! \fn void QCPAbstractPlottable::drawLegendIcon(QCPPainter *painter, const QRect &rect) const = 0
  \internal
  
  called by QCPLegend::draw (via QCPPlottableLegendItem::draw) to create a graphical representation
  of this plottable inside \a rect, next to the plottable name.
  
  The passed \a painter has its cliprect set to \a rect, so painting outside of \a rect won't
  appear outside the legend icon border.
*/
/*! \ fn void QCPAbstractPlottable :: drawLegendIcon (QCPPainter * painter, const QRect & rect) const = 0
  \내부의
  
  그래픽 표현을 만들기 위해 QCPLegend :: draw (QCPPlottableLegendItem :: draw를 통해)에 의해 호출
  이 plottable 내부의 \ rect, plottable 이름 옆.
  
  전달 된 \ painter는 cliprect가 \ rect로 설정되어 있기 때문에 \ rect의 외부에있는 그림은 그렇지 않습니다.
  범례 아이콘 테두리 바깥에 나타납니다.
*/

/*! \fn QCPRange QCPAbstractPlottable::getKeyRange(bool &foundRange, QCP::SignDomain inSignDomain) const = 0
  
  Returns the coordinate range that all data in this plottable span in the key axis dimension. For
  logarithmic plots, one can set \a inSignDomain to either \ref QCP::sdNegative or \ref
  QCP::sdPositive in order to restrict the returned range to that sign domain. E.g. when only
  negative range is wanted, set \a inSignDomain to \ref QCP::sdNegative and all positive points
  will be ignored for range calculation. For no restriction, just set \a inSignDomain to \ref
  QCP::sdBoth (default). \a foundRange is an output parameter that indicates whether a range could
  be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).

  Note that \a foundRange is not the same as \ref QCPRange::validRange, since the range returned by
  this function may have size zero (e.g. when there is only one data point). In this case \a
  foundRange would return true, but the returned range is not a valid range in terms of \ref
  QCPRange::validRange.
  
  \see rescaleAxes, getValueRange
*/
/*! \ fn QCPRange QCPAbstractPlottable :: getKeyRange (bool & foundRange, QCP :: SignDomain inSignDomain) const = 0
  
  이 Plotable의 모든 데이터가 키 축 차원에서 확장되는 좌표 범위를 반환합니다. 에 대한
  로그 플롯을 사용하면 \ in inSignDomain을 \ ref QCP :: sdNegative 또는 \ ref로 설정할 수 있습니다.
  리턴 된 범위를 해당 사인 도메인으로 제한하기 위해 QCP :: sdPositive. 예를 들면
  음수 범위가 필요하면 \ in inSignDomain을 \ ref QCP :: sdNegative 및 모든 양의 점으로 설정하십시오
  범위 계산을 위해 무시됩니다. 제한없이 \ a inSignDomain을 \ ref로 설정하면됩니다.
  QCP :: sdBoth (기본값). \ a foundRange는 범위가 범위를 벗어날 수 있는지 여부를 나타내는 출력 매개 변수입니다.
  찾거나 내지 마라. false 인 경우 반환 된 범위를 사용하면 안됩니다 (예 : 데이터의 점 없음).

  \ r foundRange는 \ ref QCPRange :: validRange와 같지 않습니다.
  이 함수는 크기가 0 일 수도 있습니다 (예 : 데이터 포인트가 하나 뿐인 경우). 이 경우 \ a
  foundRange는 true를 반환하지만 반환 된 범위는 \ ref를 기준으로 유효한 범위가 아닙니다.
  QCPRange :: validRange.
  
  \ rescaleAxes, getValueRange를 참조하십시오.
*/

/*! \fn QCPRange QCPAbstractPlottable::getValueRange(bool &foundRange, QCP::SignDomain inSignDomain, const QCPRange &inKeyRange) const = 0
  
  Returns the coordinate range that the data points in the specified key range (\a inKeyRange) span
  in the value axis dimension. For logarithmic plots, one can set \a inSignDomain to either \ref
  QCP::sdNegative or \ref QCP::sdPositive in order to restrict the returned range to that sign
  domain. E.g. when only negative range is wanted, set \a inSignDomain to \ref QCP::sdNegative and
  all positive points will be ignored for range calculation. For no restriction, just set \a
  inSignDomain to \ref QCP::sdBoth (default). \a foundRange is an output parameter that indicates
  whether a range could be found or not. If this is false, you shouldn't use the returned range
  (e.g. no points in data).
  
  If \a inKeyRange has both lower and upper bound set to zero (is equal to <tt>QCPRange()</tt>),
  all data points are considered, without any restriction on the keys.

  Note that \a foundRange is not the same as \ref QCPRange::validRange, since the range returned by
  this function may have size zero (e.g. when there is only one data point). In this case \a
  foundRange would return true, but the returned range is not a valid range in terms of \ref
  QCPRange::validRange.
  
  \see rescaleAxes, getKeyRange
*/
/*! \ fn QCPRange QCPAbstractPlottable :: getValueRange (bool & foundRange, QCP :: SignDomain inSignDomain, const QCPRange & inKeyRange) const = 0
  
  지정된 키 범위 (\ inKeyRange) span에있는 데이터를 가리키는 좌표 범위를 리턴합니다.
  값 축 차원에서. 로그 플롯의 경우 \ a inSignDomain을 \ ref
  리턴 된 범위를 그 부호로 제한하기 위해 QCP :: sdNegative 또는 \ ref QCP :: sdPositive
  도메인. 예를 들어, 음의 범위 만 원하면, \ in inSignDomain을 \ ref QCP :: sdNegative로 설정하고
  모든 양의 점은 범위 계산을 위해 무시됩니다. 제한없이, \ a를 설정하면됩니다.
  inSignDomain을 \ ref QCP :: sdBoth (기본값)로 변경하십시오. \ a foundRange는 다음을 나타내는 출력 매개 변수입니다.
  범위의 발견 여부. false 인 경우 반환 된 범위를 사용하면 안됩니다.
  (예 : 데이터의 점 없음).
  
  inKeyRange가 하한과 상한이 모두 0으로 설정되어있는 경우 (<tt> QCPRange () </ tt>와 동일)
  모든 데이터 포인트는 키에 대한 제한없이 고려됩니다.

  \ r foundRange는 \ ref QCPRange :: validRange와 같지 않습니다.
  이 함수는 크기가 0 일 수도 있습니다 (예 : 데이터 포인트가 하나 뿐인 경우). 이 경우 \ a
  foundRange는 true를 반환하지만 반환 된 범위는 \ ref를 기준으로 유효한 범위가 아닙니다.
  QCPRange :: validRange.
  
  \ rescaleAxes, getKeyRange를 참조하십시오.
*/

/* end of documentation of pure virtual functions */
/* start of documentation of signals */
/* 순수 가상 함수의 문서 끝 */
/* 신호 문서화 */

/*! \fn void QCPAbstractPlottable::selectionChanged(bool selected)
  
  This signal is emitted when the selection state of this plottable has changed, either by user
  interaction or by a direct call to \ref setSelection. The parameter \a selected indicates whether
  there are any points selected or not.
  
  \see selectionChanged(const QCPDataSelection &selection)
*/
/*! \ fn void QCPAbstractPlottable :: selectionChanged (bool 선택됨)
  
  이 신호는 사용자가이 Plotable의 선택 상태를 변경하면 방출됩니다.
  상호 작용 또는 \ ref setSelection에 대한 직접 호출에 의해 수행됩니다. 선택한 매개 변수 \ a는
  포인트가 선택되거나 선택되지 않습니다.
  
  \ seeChanged (const QCPDataSelection & selection) 참조하십시오.
*/

/*! \fn void QCPAbstractPlottable::selectionChanged(const QCPDataSelection &selection)
  
  This signal is emitted when the selection state of this plottable has changed, either by user
  interaction or by a direct call to \ref setSelection. The parameter \a selection holds the
  currently selected data ranges.
  
  \see selectionChanged(bool selected)
*/
/*! \ fn void QCPAbstractPlottable :: selectionChanged (const QCPDataSelection & selection)
  
  이 신호는 사용자가이 Plotable의 선택 상태를 변경하면 방출됩니다.
  상호 작용 또는 \ ref setSelection에 대한 직접 호출에 의해 수행됩니다. 매개 변수 \ a는
  현재 선택된 데이터 범위.
  
  \ seeChanged (bool 선택됨)
*/

/*! \fn void QCPAbstractPlottable::selectableChanged(QCP::SelectionType selectable);
  
  This signal is emitted when the selectability of this plottable has changed.
  
  \see setSelectable
*/
/*! \ fn void QCPAbstractPlottable :: selectableChanged (QCP :: SelectionType 선택 가능);
  
  이 플롯 테이블의 선택 가능성이 변경되면이 신호가 방출됩니다.
  
  \ setSelectable 참조
*/

/* end of documentation of signals */
/* 신호의 문서화 끝 */

/*!
  Constructs an abstract plottable which uses \a keyAxis as its key axis ("x") and \a valueAxis as
  its value axis ("y"). \a keyAxis and \a valueAxis must reside in the same QCustomPlot instance
  and have perpendicular orientations. If either of these restrictions is violated, a corresponding
  message is printed to the debug output (qDebug), the construction is not aborted, though.
  
  Since QCPAbstractPlottable is an abstract class that defines the basic interface to plottables,
  it can't be directly instantiated.
  
  You probably want one of the subclasses like \ref QCPGraph or \ref QCPCurve instead.
*/
/*!
  키 축 ( "x")으로서 \ keyAxis를 사용해, 값 축으로서 \ valueAxis를 사용하는 추상의 plottable를 구축합니다.
  그 값 축 ( "y"). \ a keyAxis와 \ valueAxis는 동일한 QCustomPlot 인스턴스에 있어야합니다.
  수직 배향을 갖는다. 이러한 제한 사항 중 하나가 위반되면 해당하는
  메시지가 디버그 출력 (qDebug)에 인쇄되면 구성은 중단되지 않습니다.
  
  QCPAbstractPlottable은 plottables에 대한 기본 인터페이스를 정의하는 추상 클래스이므로,
  직접 인스턴스화 할 수 없습니다.
  
  아마도 \ ref QCPGraph 또는 \ ref QCPCurve와 같은 서브 클래스 중 하나를 원할 것입니다.
*/
QCPAbstractPlottable::QCPAbstractPlottable(QCPAxis *keyAxis, QCPAxis *valueAxis) :
  QCPLayerable(keyAxis->parentPlot(), QString(), keyAxis->axisRect()),
  mName(),
  mAntialiasedFill(true),
  mAntialiasedScatters(true),
  mPen(Qt::black),
  mBrush(Qt::NoBrush),
  mKeyAxis(keyAxis),
  mValueAxis(valueAxis),
  mSelectable(QCP::stWhole),
  mSelectionDecorator(0)
{
  if (keyAxis->parentPlot() != valueAxis->parentPlot())
    qDebug() << Q_FUNC_INFO << "Parent plot of keyAxis is not the same as that of valueAxis.";
  if (keyAxis->orientation() == valueAxis->orientation())
    qDebug() << Q_FUNC_INFO << "keyAxis and valueAxis must be orthogonal to each other.";
  
  mParentPlot->registerPlottable(this);
  setSelectionDecorator(new QCPSelectionDecorator);
}

QCPAbstractPlottable::~QCPAbstractPlottable()
{
  if (mSelectionDecorator)
  {
    delete mSelectionDecorator;
    mSelectionDecorator = 0;
  }
}

/*!
   The name is the textual representation of this plottable as it is displayed in the legend
   (\ref QCPLegend). It may contain any UTF-8 characters, including newlines.
*/
/*!
   이름은이 플롯 테이블이 범례에 표시되는 텍스트 표현입니다.
   (\ ref QCPLegend). 개행을 포함하여 UTF-8 문자를 포함 할 수 있습니다.
*/
void QCPAbstractPlottable::setName(const QString &name)
{
  mName = name;
}

/*!
  Sets whether fills of this plottable are drawn antialiased or not.
  
  Note that this setting may be overridden by \ref QCustomPlot::setAntialiasedElements and \ref
  QCustomPlot::setNotAntialiasedElements.
*/
/*!
  이 Plotable의 칠을 앤티 엘리 어싱할지 여부를 설정합니다.
  
  이 설정은 \ ref QCustomPlot :: setAntialiasedElements 및 \ ref에 의해 무시 될 수 있습니다
  QCustomPlot :: setNotAntialiasedElements.
*/
void QCPAbstractPlottable::setAntialiasedFill(bool enabled)
{
  mAntialiasedFill = enabled;
}

/*!
  Sets whether the scatter symbols of this plottable are drawn antialiased or not.
  
  Note that this setting may be overridden by \ref QCustomPlot::setAntialiasedElements and \ref
  QCustomPlot::setNotAntialiasedElements.
*/
/*!
  이 Plotable의 스 캐터 심볼을 앤티 앨리어스로 그릴 것인지 여부를 설정합니다.
  
  이 설정은 \ ref QCustomPlot :: setAntialiasedElements 및 \ ref에 의해 무시 될 수 있습니다
  QCustomPlot :: setNotAntialiasedElements.
*/
void QCPAbstractPlottable::setAntialiasedScatters(bool enabled)
{
  mAntialiasedScatters = enabled;
}

/*!
  The pen is used to draw basic lines that make up the plottable representation in the
  plot.
  
  For example, the \ref QCPGraph subclass draws its graph lines with this pen.

  \see setBrush
*/
/*!
  펜을 사용하여 기본 선을 그릴 수 있습니다.
  음모.
  
  예를 들어, \ ref QCPGraph 서브 클래스는이 펜으로 그래프 선을 그립니다.

  \ setBrush를 참조하십시오.
*/
void QCPAbstractPlottable::setPen(const QPen &pen)
{
  mPen = pen;
}

/*!
  The brush is used to draw basic fills of the plottable representation in the
  plot. The Fill can be a color, gradient or texture, see the usage of QBrush.
  
  For example, the \ref QCPGraph subclass draws the fill under the graph with this brush, when
  it's not set to Qt::NoBrush.

  \see setPen
*/
/*!
  브러시는 플롯 가능한 표현의 기본 채우기를
  음모. 채우기는 색상, 그라디언트 또는 텍스처 일 수 있습니다. QBrush 사용법을 참조하십시오.
  
  예를 들어, \ ref QCPGraph 서브 클래스는이 브러시로 그래프 아래에 채우기를 그립니다.
  Qt :: NoBrush로 설정되지 않았습니다.

  \ see setPen
*/
void QCPAbstractPlottable::setBrush(const QBrush &brush)
{
  mBrush = brush;
}

/*!
  The key axis of a plottable can be set to any axis of a QCustomPlot, as long as it is orthogonal
  to the plottable's value axis. This function performs no checks to make sure this is the case.
  The typical mathematical choice is to use the x-axis (QCustomPlot::xAxis) as key axis and the
  y-axis (QCustomPlot::yAxis) as value axis.
  
  Normally, the key and value axes are set in the constructor of the plottable (or \ref
  QCustomPlot::addGraph when working with QCPGraphs through the dedicated graph interface).

  \see setValueAxis
*/
/*!
  플롯 테이블의 키 축은 QCustomPlot의 임의의 축으로 설정할 수 있습니다.
  플롯 값 축에 연결합니다. 이 함수는이 경우를 확인하지 않습니다.
  일반적인 수학적 선택은 x 축 (QCustomPlot :: xAxis)을 키 축으로 사용하고
  y 축 (QCustomPlot :: yAxis)을 값 축으로 사용합니다.
  
  일반적으로 키와 값 축은 플롯 테이블의 생성자 (또는 \ ref
  전용 그래프 인터페이스를 통해 QCPGraphs로 작업 할 때 QCustomPlot :: addGraph).

  \ setValueAxis 참조
*/
void QCPAbstractPlottable::setKeyAxis(QCPAxis *axis)
{
  mKeyAxis = axis;
}

/*!
  The value axis of a plottable can be set to any axis of a QCustomPlot, as long as it is
  orthogonal to the plottable's key axis. This function performs no checks to make sure this is the
  case. The typical mathematical choice is to use the x-axis (QCustomPlot::xAxis) as key axis and
  the y-axis (QCustomPlot::yAxis) as value axis.

  Normally, the key and value axes are set in the constructor of the plottable (or \ref
  QCustomPlot::addGraph when working with QCPGraphs through the dedicated graph interface).
  
  \see setKeyAxis
*/
/*!
  plottable의 값 축은 QCustomPlot의 모든 축으로 설정할 수 있습니다.
  플롯 테이블의 주요 축과 직각을 이룹니다. 이 함수는 체크를 수행하지 않고 이것이
  케이스. 일반적인 수학적 선택은 x 축 (QCustomPlot :: xAxis)을 키 축으로 사용하고
  y 축 (QCustomPlot :: yAxis)을 값 축으로 사용합니다.

  일반적으로 키와 값 축은 플롯 테이블의 생성자 (또는 \ ref
  전용 그래프 인터페이스를 통해 QCPGraphs로 작업 할 때 QCustomPlot :: addGraph).
  
  \ setKeyAxis 참조
*/
void QCPAbstractPlottable::setValueAxis(QCPAxis *axis)
{
  mValueAxis = axis;
}


/*!
  Sets which data ranges of this plottable are selected. Selected data ranges are drawn differently
  (e.g. color) in the plot. This can be controlled via the selection decorator (see \ref
  selectionDecorator).
  
  The entire selection mechanism for plottables is handled automatically when \ref
  QCustomPlot::setInteractions contains iSelectPlottables. You only need to call this function when
  you wish to change the selection state programmatically.
  
  Using \ref setSelectable you can further specify for each plottable whether and to which
  granularity it is selectable. If \a selection is not compatible with the current \ref
  QCP::SelectionType set via \ref setSelectable, the resulting selection will be adjusted
  accordingly (see \ref QCPDataSelection::enforceType).
  
  emits the \ref selectionChanged signal when \a selected is different from the previous selection state.
  
  \see setSelectable, selectTest
*/
/*!
  이 Plotable의 데이터 범위를 선택합니다. 선택한 데이터 범위가 다르게 그려집니다.
  (예 : 색). 이것은 선택 데코레이터를 통해 제어 할 수 있습니다 (\ ref 참조).
  selectionDecorator)를 호출합니다.
  
  plottables에 대한 전체 선택 메커니즘은 \ ref를 사용할 때 자동으로 처리됩니다.
  QCustomPlot :: setInteractions에는 iSelectPlottables가 포함되어 있습니다. 다음과 같은 경우에만이 함수를 호출하면됩니다.
  프로그래밍 방식으로 선택 상태를 변경하려고합니다.
  
  \ ref setSelectable을 사용하면 각 플롯 테이블에 대해
  세분성이 선택 가능합니다. 선택 사항이 현재 \ ref와 호환되지 않는 경우
  \ ref setSelectable을 통해 설정된 QCP :: SelectionType, 결과 선택이 조정됩니다.
  그에 따라 (\ ref QCPDataSelection :: enforceType 참조).
  
  선택이 이전 선택 상태와 다른 경우 \ ref selectionChanged 신호를 내 보냅니다.
  
  \ setSelectable 참조, selectTest
*/
void QCPAbstractPlottable::setSelection(QCPDataSelection selection)
{
  selection.enforceType(mSelectable);
  if (mSelection != selection)
  {
    mSelection = selection;
    emit selectionChanged(selected());
    emit selectionChanged(mSelection);
  }
}

/*!
  Use this method to set an own QCPSelectionDecorator (subclass) instance. This allows you to
  customize the visual representation of selected data ranges further than by using the default
  QCPSelectionDecorator.
  
  The plottable takes ownership of the \a decorator.
  
  The currently set decorator can be accessed via \ref selectionDecorator.
*/
/*!
  이 메서드를 사용하여 자체 QCPSelectionDecorator (하위 클래스) 인스턴스를 설정합니다. 이렇게하면
  기본값을 사용하는 것보다 선택한 데이터 범위의 시각적 표현을 사용자 정의 할 수 있습니다.
  QCPSelectionDecorator.
  
  plottable은 \ decorator의 소유권을가집니다.
  
  현재 설정된 데코레이터는 \ ref selectionDecorator를 통해 액세스 할 수 있습니다.
*/
void QCPAbstractPlottable::setSelectionDecorator(QCPSelectionDecorator *decorator)
{
  if (decorator)
  {
    if (decorator->registerWithPlottable(this))
    {
      if (mSelectionDecorator) // delete old decorator if necessary
                               // 필요한 경우 오래된 데코레이터를 삭제합니다.
        delete mSelectionDecorator;
      mSelectionDecorator = decorator;
    }
  } else if (mSelectionDecorator) // just clear decorator
  {                               // 그냥 장식자를 지우십시오.
    delete mSelectionDecorator;
    mSelectionDecorator = 0;
  }
}

/*!
  Sets whether and to which granularity this plottable can be selected.

  A selection can happen by clicking on the QCustomPlot surface (When \ref
  QCustomPlot::setInteractions contains \ref QCP::iSelectPlottables), by dragging a selection rect
  (When \ref QCustomPlot::setSelectionRectMode is \ref QCP::srmSelect), or programmatically by
  calling \ref setSelection.
  
  \see setSelection, QCP::SelectionType
*/
/*!
  이 Plotable을 선택할 수 있는지 여부 및 그 단위를 선택할 수 있습니다.

  선택은 QCustomPlot 표면을 클릭하여 발생할 수 있습니다 (\ ref의 경우
  QCustomPlot :: setInteractions에는 \ ref QCP :: iSelectPlottables가 포함됩니다.), 선택 rect를 드래그하여
  (\ ref QCustomPlot :: setSelectionRectMode가 \ ref QCP :: srmSelect 인 경우) 또는 프로그래밍 방식으로
  \ ref setSelection을 호출합니다.
  
  \ setSelection, QCP :: SelectionType을 보라.
*/
void QCPAbstractPlottable::setSelectable(QCP::SelectionType selectable)
{
  if (mSelectable != selectable)
  {
    mSelectable = selectable;
    QCPDataSelection oldSelection = mSelection;
    mSelection.enforceType(mSelectable);
    emit selectableChanged(mSelectable);
    if (mSelection != oldSelection)
    {
      emit selectionChanged(selected());
      emit selectionChanged(mSelection);
    }
  }
}


/*!
  Convenience function for transforming a key/value pair to pixels on the QCustomPlot surface,
  taking the orientations of the axes associated with this plottable into account (e.g. whether key
  represents x or y).

  \a key and \a value are transformed to the coodinates in pixels and are written to \a x and \a y.

  \see pixelsToCoords, QCPAxis::coordToPixel
*/
/*!
  키 / 값 쌍을 QCustomPlot 표면의 픽셀로 변환하는 편리한 기능,
  이 플롯 테이블과 연관된 축의 방향을 고려합니다 (예 : 키
  x 또는 y를 나타냄).

  \ a 키와 \ a 값은 픽셀 단위의 좌표로 변환되어 \ ax와 \ y에 기록됩니다.

  \ see pixelsToCoords, QCPAxis :: coordToPixel
*/
void QCPAbstractPlottable::coordsToPixels(double key, double value, double &x, double &y) const
{
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
  
  if (keyAxis->orientation() == Qt::Horizontal)
  {
    x = keyAxis->coordToPixel(key);
    y = valueAxis->coordToPixel(value);
  } else
  {
    y = keyAxis->coordToPixel(key);
    x = valueAxis->coordToPixel(value);
  }
}

/*! \overload

  Transforms the given \a key and \a value to pixel coordinates and returns them in a QPointF.
*/
/*! \초과 적재

  주어진 \ a 키와 \ 값을 픽셀 좌표로 변환하여 QPointF로 반환합니다.
*/
const QPointF QCPAbstractPlottable::coordsToPixels(double key, double value) const
{
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QPointF(); }
  
  if (keyAxis->orientation() == Qt::Horizontal)
    return QPointF(keyAxis->coordToPixel(key), valueAxis->coordToPixel(value));
  else
    return QPointF(valueAxis->coordToPixel(value), keyAxis->coordToPixel(key));
}

/*!
  Convenience function for transforming a x/y pixel pair on the QCustomPlot surface to plot coordinates,
  taking the orientations of the axes associated with this plottable into account (e.g. whether key
  represents x or y).

  \a x and \a y are transformed to the plot coodinates and are written to \a key and \a value.

  \see coordsToPixels, QCPAxis::coordToPixel
*/
/*!
  QCustomPlot 표면의 ax / y 픽셀 쌍을 좌표를 그리는 데 변환하는 편리한 함수,
  이 플롯 테이블과 연관된 축의 방향을 고려합니다 (예 : 키
  x 또는 y를 나타냄).

  \ ax와 \ ay는 플롯 좌표로 변환되고 \ a 키와 \ a 값에 기록됩니다.

  \ coordsToPixels, QCPAxis :: coordToPixel을 참조하십시오.
*/
void QCPAbstractPlottable::pixelsToCoords(double x, double y, double &key, double &value) const
{
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
  
  if (keyAxis->orientation() == Qt::Horizontal)
  {
    key = keyAxis->pixelToCoord(x);
    value = valueAxis->pixelToCoord(y);
  } else
  {
    key = keyAxis->pixelToCoord(y);
    value = valueAxis->pixelToCoord(x);
  }
}

/*! \overload

  Returns the pixel input \a pixelPos as plot coordinates \a key and \a value.
*/
/*! \초과 적재

  플롯 좌표 \ a 키와 \ a 값으로 픽셀 입력 \ pixelPos를 반환합니다.
*/
void QCPAbstractPlottable::pixelsToCoords(const QPointF &pixelPos, double &key, double &value) const
{
  pixelsToCoords(pixelPos.x(), pixelPos.y(), key, value);
}

/*!
  Rescales the key and value axes associated with this plottable to contain all displayed data, so
  the whole plottable is visible. If the scaling of an axis is logarithmic, rescaleAxes will make
  sure not to rescale to an illegal range i.e. a range containing different signs and/or zero.
  Instead it will stay in the current sign domain and ignore all parts of the plottable that lie
  outside of that domain.
  
  \a onlyEnlarge makes sure the ranges are only expanded, never reduced. So it's possible to show
  multiple plottables in their entirety by multiple calls to rescaleAxes where the first call has
  \a onlyEnlarge set to false (the default), and all subsequent set to true.
  
  \see rescaleKeyAxis, rescaleValueAxis, QCustomPlot::rescaleAxes, QCPAxis::rescale
*/
/*!
  표시된 모든 데이터를 포함하도록이 플롯 테이블과 연관된 키 및 값 축의 크기를 다시 조정합니다.
  전체 표식이 보입니다. 축의 스케일링이 대수 인 경우 rescaleAxes가
  불법적 범위, 즉 다른 기호 및 / 또는 0을 포함하는 범위로 재조정하지 않도록하십시오.
  대신 현재 사인 영역에 머무르고 거짓말을하는 모든 부분을 무시합니다.
  해당 도메인 외부.
  
  \ a onlyEnlarge는 범위가 확장되고 축소되지 않도록합니다. 그래서 보여줄 수 있습니다.
  첫 번째 호출이있는 rescaleAxes에 대한 여러 호출을 통해 여러 개의 plottables 전체
  \ a onlyEnlarge는 false (기본값)로 설정되고 이후의 모든 값은 true로 설정됩니다.
  
  \ rescaleKeyAxis, rescaleValueAxis, QCustomPlot :: rescaleAxes, QCPAxis :: rescale 참조.
*/
void QCPAbstractPlottable::rescaleAxes(bool onlyEnlarge) const
{
  rescaleKeyAxis(onlyEnlarge);
  rescaleValueAxis(onlyEnlarge);
}

/*!
  Rescales the key axis of the plottable so the whole plottable is visible.
  
  See \ref rescaleAxes for detailed behaviour.
*/
/*!
  전체 플롯이 표시되도록 플롯 테이블의 키 축을 다시 계산합니다.
  
  자세한 동작은 \ ref rescaleAxes를 참조하십시오.
*/
void QCPAbstractPlottable::rescaleKeyAxis(bool onlyEnlarge) const
{
  QCPAxis *keyAxis = mKeyAxis.data();
  if (!keyAxis) { qDebug() << Q_FUNC_INFO << "invalid key axis"; return; }
  
  QCP::SignDomain signDomain = QCP::sdBoth;
  if (keyAxis->scaleType() == QCPAxis::stLogarithmic)
    signDomain = (keyAxis->range().upper < 0 ? QCP::sdNegative : QCP::sdPositive);
  
  bool foundRange;
  QCPRange newRange = getKeyRange(foundRange, signDomain);
  if (foundRange)
  {
    if (onlyEnlarge)
      newRange.expand(keyAxis->range());
    if (!QCPRange::validRange(newRange)) 
// likely due to range being zero (plottable has only constant data in this axis dimension), shift current range to at least center the plottable
// 범위가 0 일 가능성이 높습니다 (plottable은이 축 차원에서 일정한 데이터 만 가짐), 현재 범위를 적어도 plottable을 가운데로 이동합니다.
    {
      double center = (newRange.lower+newRange.upper)*0.5;
// upper and lower should be equal anyway, but just to make sure, incase validRange returned false for other reason
// upper와 lower는 반드시 동일해야하지만, 확실하게하려면 incase validRange가 다른 이유로 false를 반환합니다.
      if (keyAxis->scaleType() == QCPAxis::stLinear)
      {
        newRange.lower = center-keyAxis->range().size()/2.0;
        newRange.upper = center+keyAxis->range().size()/2.0;
      } else // scaleType() == stLogarithmic
      {
        newRange.lower = center/qSqrt(keyAxis->range().upper/keyAxis->range().lower);
        newRange.upper = center*qSqrt(keyAxis->range().upper/keyAxis->range().lower);
      }
    }
    keyAxis->setRange(newRange);
  }
}

/*!
  Rescales the value axis of the plottable so the whole plottable is visible. If \a inKeyRange is
  set to true, only the data points which are in the currently visible key axis range are
  considered.

  Returns true if the axis was actually scaled. This might not be the case if this plottable has an
  invalid range, e.g. because it has no data points.

  See \ref rescaleAxes for detailed behaviour.
*/
/*!
  전체 plottable이 표시되도록 plottable의 값 축을 다시 계산합니다. \ inKeyRange가있는 경우
  true로 설정하면 현재 보이는 키 축 범위에있는 데이터 포인트 만
  깊이 생각한.

  축이 실제로 축척 된 경우 true를 반환합니다. 이 플롯 테이블에
  유효하지 않은 범위. 예를 들어 데이터 포인트가 없기 때문입니다.

  자세한 동작은 \ ref rescaleAxes를 참조하십시오.
*/
void QCPAbstractPlottable::rescaleValueAxis(bool onlyEnlarge, bool inKeyRange) const
{
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
  
  QCP::SignDomain signDomain = QCP::sdBoth;
  if (valueAxis->scaleType() == QCPAxis::stLogarithmic)
    signDomain = (valueAxis->range().upper < 0 ? QCP::sdNegative : QCP::sdPositive);
  
  bool foundRange;
  QCPRange newRange = getValueRange(foundRange, signDomain, inKeyRange ? keyAxis->range() : QCPRange());
  if (foundRange)
  {
    if (onlyEnlarge)
      newRange.expand(valueAxis->range());
    if (!QCPRange::validRange(newRange)) 
// likely due to range being zero (plottable has only constant data in this axis dimension), shift current range to at least center the plottable
// 범위가 0 일 가능성이 높습니다 (plottable은이 축 차원에서 일정한 데이터 만 가짐), 현재 범위를 적어도 plottable을 가운데로 이동합니다.
    {
      double center = (newRange.lower+newRange.upper)*0.5; 
// upper and lower should be equal anyway, but just to make sure, incase validRange returned false for other reason
// upper와 lower는 반드시 동일해야하지만, 확실하게하려면 incase validRange가 다른 이유로 false를 반환합니다.
      if (valueAxis->scaleType() == QCPAxis::stLinear)
      {
        newRange.lower = center-valueAxis->range().size()/2.0;
        newRange.upper = center+valueAxis->range().size()/2.0;
      } else // scaleType() == stLogarithmic
      {
        newRange.lower = center/qSqrt(valueAxis->range().upper/valueAxis->range().lower);
        newRange.upper = center*qSqrt(valueAxis->range().upper/valueAxis->range().lower);
      }
    }
    valueAxis->setRange(newRange);
  }
}

/*! \overload

  Adds this plottable to the specified \a legend.

  Creates a QCPPlottableLegendItem which is inserted into the legend. Returns true on success, i.e.
  when the legend exists and a legend item associated with this plottable isn't already in the
  legend.

  If the plottable needs a more specialized representation in the legend, you can create a
  corresponding subclass of \ref QCPPlottableLegendItem and add it to the legend manually instead
  of calling this method.

  \see removeFromLegend, QCPLegend::addItem
*/
/*! \초과 적재

  이 플롯 테이블을 지정된 \ 범례에 추가합니다.

  범례에 삽입되는 QCPPlottableLegendItem을 만듭니다. 성공하면 true를 반환합니다.
  범례가 존재하고이 플롯 테이블과 연결된 범례 항목이 이미
  전설.

  플롯 테이블에 범례에보다 전문화 된 표현이 필요한 경우
  \ ref QCPPlottableLegendItem의 해당 하위 클래스를 수동으로 범례에 추가합니다.
  이 메소드를 호출하는 방법.

  \ removeFromLegend, QCPLegend :: addItem 참조.
*/
bool QCPAbstractPlottable::addToLegend(QCPLegend *legend)
{
  if (!legend)
  {
    qDebug() << Q_FUNC_INFO << "passed legend is null";
    return false;
  }
  if (legend->parentPlot() != mParentPlot)
  {
    qDebug() << Q_FUNC_INFO << "passed legend isn't in the same QCustomPlot as this plottable";
    return false;
  }
  
  if (!legend->hasItemWithPlottable(this))
  {
    legend->addItem(new QCPPlottableLegendItem(legend, this));
    return true;
  } else
    return false;
}

/*! \overload

  Adds this plottable to the legend of the parent QCustomPlot (\ref QCustomPlot::legend).

  \see removeFromLegend
*/
/*! \초과 적재

  이 Plotable을 부모 QCustomPlot (\ ref QCustomPlot :: legend)의 범례에 추가합니다.

  \ see removeFromLegend
*/
bool QCPAbstractPlottable::addToLegend()
{
  if (!mParentPlot || !mParentPlot->legend)
    return false;
  else
    return addToLegend(mParentPlot->legend);
}

/*! \overload

  Removes the plottable from the specifed \a legend. This means the \ref QCPPlottableLegendItem
  that is associated with this plottable is removed.

  Returns true on success, i.e. if the legend exists and a legend item associated with this
  plottable was found and removed.

  \see addToLegend, QCPLegend::removeItem
*/
/*! \초과 적재

  지정된 \ 범례에서 플롯 테이블을 제거합니다. 이것은 \ ref QCPPlottableLegendItem을 의미합니다.
  이 plottable과 관련된 객체가 제거됩니다.

  성공하면 true를 반환합니다. 즉, 범례가 있고이 범례 항목과 연결된 범례 항목
  plottable을 찾아 제거했습니다.

  \ addToLegend, QCPLegend :: removeItem을 보라.
*/
bool QCPAbstractPlottable::removeFromLegend(QCPLegend *legend) const
{
  if (!legend)
  {
    qDebug() << Q_FUNC_INFO << "passed legend is null";
    return false;
  }
  
  if (QCPPlottableLegendItem *lip = legend->itemWithPlottable(this))
    return legend->removeItem(lip);
  else
    return false;
}

/*! \overload

  Removes the plottable from the legend of the parent QCustomPlot.

  \see addToLegend
*/
/*! \초과 적재

  상위 QCustomPlot의 범례에서 플롯 테이블을 제거합니다.

  \ see addToLegend
*/
bool QCPAbstractPlottable::removeFromLegend() const
{
  if (!mParentPlot || !mParentPlot->legend)
    return false;
  else
    return removeFromLegend(mParentPlot->legend);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QRect QCPAbstractPlottable::clipRect() const
{
  if (mKeyAxis && mValueAxis)
    return mKeyAxis.data()->axisRect()->rect() & mValueAxis.data()->axisRect()->rect();
  else
    return QRect();
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCP::Interaction QCPAbstractPlottable::selectionCategory() const
{
  return QCP::iSelectPlottables;
}

/*! \internal

  A convenience function to easily set the QPainter::Antialiased hint on the provided \a painter
  before drawing plottable lines.

  This is the antialiasing state the painter passed to the \ref draw method is in by default.
  
  This function takes into account the local setting of the antialiasing flag as well as the
  overrides set with \ref QCustomPlot::setAntialiasedElements and \ref
  QCustomPlot::setNotAntialiasedElements.
  
  \seebaseclassmethod
  
  \see setAntialiased, applyFillAntialiasingHint, applyScattersAntialiasingHint
*/
/*! \내부의

  제공된 Painter에서 QPainter :: Antialiased 힌트를 쉽게 설정할 수있는 편리한 함수입니다.
  플롯 가능한 선을 그리기 전에.

  화가가 \ ref draw 메서드에 전달한 앤티 엘리 어싱 상태입니다.
  
  이 함수는 앤티 엘리 어싱 플래그의 로컬 설정은 물론
  \ ref QCustomPlot :: setAntialiasedElements 및 \ ref를 사용하여 설정 한 재정의
  QCustomPlot :: setNotAntialiasedElements.
  
  \ seebaseclassmethod
  
  \ setAntialiased 참조, applyFillAntialiasingHint, applyScattersAntialiasingHint
*/
void QCPAbstractPlottable::applyDefaultAntialiasingHint(QCPPainter *painter) const
{
  applyAntialiasingHint(painter, mAntialiased, QCP::aePlottables);
}

/*! \internal

  A convenience function to easily set the QPainter::Antialiased hint on the provided \a painter
  before drawing plottable fills.
  
  This function takes into account the local setting of the antialiasing flag as well as the
  overrides set with \ref QCustomPlot::setAntialiasedElements and \ref
  QCustomPlot::setNotAntialiasedElements.
  
  \see setAntialiased, applyDefaultAntialiasingHint, applyScattersAntialiasingHint
*/
/*! \내부의

  제공된 Painter에서 QPainter :: Antialiased 힌트를 쉽게 설정할 수있는 편리한 함수입니다.
  플롯 가능한 채우기를 그리기 전에
  
  이 함수는 앤티 엘리 어싱 플래그의 로컬 설정은 물론
  \ ref QCustomPlot :: setAntialiasedElements 및 \ ref를 사용하여 설정 한 재정의
  QCustomPlot :: setNotAntialiasedElements.
  
  \ setAntialiased 참조, applyDefaultAntialiasingHint, applyScattersAntialiasingHint
*/
void QCPAbstractPlottable::applyFillAntialiasingHint(QCPPainter *painter) const
{
  applyAntialiasingHint(painter, mAntialiasedFill, QCP::aeFills);
}

/*! \internal

  A convenience function to easily set the QPainter::Antialiased hint on the provided \a painter
  before drawing plottable scatter points.
  
  This function takes into account the local setting of the antialiasing flag as well as the
  overrides set with \ref QCustomPlot::setAntialiasedElements and \ref
  QCustomPlot::setNotAntialiasedElements.
  
  \see setAntialiased, applyFillAntialiasingHint, applyDefaultAntialiasingHint
*/
/*! \내부의

  제공된 Painter에서 QPainter :: Antialiased 힌트를 쉽게 설정할 수있는 편리한 함수입니다.
  플롯 가능한 스 캐터 포인트를 그리기 전에
  
  이 함수는 앤티 엘리 어싱 플래그의 로컬 설정은 물론
  \ ref QCustomPlot :: setAntialiasedElements 및 \ ref를 사용하여 설정 한 재정의
  QCustomPlot :: setNotAntialiasedElements.
  
  \ setAntialiased 참조, applyAllialiasingHint, applyDefaultAntialiasingHint를 참조하십시오.
*/
void QCPAbstractPlottable::applyScattersAntialiasingHint(QCPPainter *painter) const
{
  applyAntialiasingHint(painter, mAntialiasedScatters, QCP::aeScatters);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPAbstractPlottable::selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)
{
  Q_UNUSED(event)
  
  if (mSelectable != QCP::stNone)
  {
    QCPDataSelection newSelection = details.value<QCPDataSelection>();
    QCPDataSelection selectionBefore = mSelection;
    if (additive)
    {
      if (mSelectable == QCP::stWhole) 
// in whole selection mode, we toggle to no selection even if currently unselected point was hit
// 전체 선택 모드에서 현재 선택되지 않은 점에 도달 했더라도 선택하지 않음으로 토글합니다.
      {
        if (selected())
          setSelection(QCPDataSelection());
        else
          setSelection(newSelection);
      } else // in all other selection modes we toggle selections of homogeneously selected/unselected segments
      {      // 다른 모든 선택 모드에서 우리는 균등하게 선택된 / 선택되지 않은 세그먼트의 선택을 토글합니다
        if (mSelection.contains(newSelection))  // if entire newSelection is already selected, toggle selection
          setSelection(mSelection-newSelection);// 전체 newSelection이 이미 선택된 경우 선택 영역을 토글합니다.
        else
          setSelection(mSelection+newSelection);
      }
    } else
      setSelection(newSelection);
    if (selectionStateChanged)
      *selectionStateChanged = mSelection != selectionBefore;
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPAbstractPlottable::deselectEvent(bool *selectionStateChanged)
{
  if (mSelectable != QCP::stNone)
  {
    QCPDataSelection selectionBefore = mSelection;
    setSelection(QCPDataSelection());
    if (selectionStateChanged)
      *selectionStateChanged = mSelection != selectionBefore;
  }
}
/* end of 'src/plottable.cpp' */


/* including file 'src/item.cpp', size 49269                                 */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / plottable.cpp'의 끝 */


/* 파일 'src / item.cpp', 크기 49269 포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPItemAnchor
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPItemAnchor
  \brief An anchor of an item to which positions can be attached to.
  
  An item (QCPAbstractItem) may have one or more anchors. Unlike QCPItemPosition, an anchor doesn't
  control anything on its item, but provides a way to tie other items via their positions to the
  anchor.

  For example, a QCPItemRect is defined by its positions \a topLeft and \a bottomRight.
  Additionally it has various anchors like \a top, \a topRight or \a bottomLeft etc. So you can
  attach the \a start (which is a QCPItemPosition) of a QCPItemLine to one of the anchors by
  calling QCPItemPosition::setParentAnchor on \a start, passing the wanted anchor of the
  QCPItemRect. This way the start of the line will now always follow the respective anchor location
  on the rect item.
  
  Note that QCPItemPosition derives from QCPItemAnchor, so every position can also serve as an
  anchor to other positions.
  
  To learn how to provide anchors in your own item subclasses, see the subclassing section of the
  QCPAbstractItem documentation.
*/
/*! \ class QCPItemAnchor
  \ brief 위치를 첨부 할 수있는 항목의 앵커입니다.
  
  항목 (QCPAbstractItem)은 하나 이상의 앵커를 가질 수 있습니다. QCPItemPosition과 달리 앵커는
  아이템에 대한 모든 것을 통제하지만, 다른 아이템을 자신의 위치를 ​​통해
  닻.

  예를 들어, QCPItemRect는 \ a topLeft 및 \ a bottomRight 위치로 정의됩니다.
  또한 \ top, \ rightRight 또는 \ bottom과 같은 다양한 앵커가 있습니다. 왼쪽 등등.
  QCPItemLine의 시작 부분 (QCPItemPosition)을 다음 중 하나의 앵커에 첨부하십시오.
  \ QCPItemPosition :: setParentAnchor를 \ a start로 호출하고, 원하는 anchor를 전달한다.
  QCPItemRect. 이렇게하면 선의 시작이 항상 각 앵커 위치를 따릅니다.
  직사각형 항목에.
  
  QCPItemPosition은 QCPItemAnchor에서 파생되므로 모든 위치가
  다른 위치에 닻을 내린다.
  
  자신의 항목 하위 클래스에 앵커를 제공하는 방법을 배우려면 해당 하위 클래스의 하위 클래스 화 섹션을 참조하십시오.
  QCPAbstractItem 문서.
*/

/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */

/*! \fn virtual QCPItemPosition *QCPItemAnchor::toQCPItemPosition()
  
  Returns 0 if this instance is merely a QCPItemAnchor, and a valid pointer of type QCPItemPosition* if
  it actually is a QCPItemPosition (which is a subclass of QCPItemAnchor).
  
  This safe downcast functionality could also be achieved with a dynamic_cast. However, QCustomPlot avoids
  dynamic_cast to work with projects that don't have RTTI support enabled (e.g. -fno-rtti flag with
  gcc compiler).
*/
/*! \ fn 가상 QCPItemPosition * QCPItemAnchor :: toQCPItemPosition ()
  
  이 인스턴스가 단지 QCPItemAnchor 일 경우 0을 반환하고 QCPItemPosition * 유형의 유효한 포인터를 반환합니다. if
  실제로는 QCPItemPosition (QCPItemAnchor의 서브 클래스)입니다.
  
  이 안전한 다운 캐스트 기능은 dynamic_cast를 사용하여 수행 할 수도 있습니다. 그러나 QCustomPlot은
  RTTI 지원이 활성화되지 않은 프로젝트에서 작동하는 dynamic_cast (예 : -fno-rtti flag with
  gcc 컴파일러).
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */

/*!
  Creates a new QCPItemAnchor. You shouldn't create QCPItemAnchor instances directly, even if
  you want to make a new item subclass. Use \ref QCPAbstractItem::createAnchor instead, as
  explained in the subclassing section of the QCPAbstractItem documentation.
*/
/*!
  새 QCPItemAnchor를 만듭니다. QCPItemAnchor 인스턴스를 직접 만들지 않아야합니다.
  새 항목 하위 클래스를 만들고 싶습니다. 대신 \ ref QCPAbstractItem :: createAnchor를 다음과 같이 사용하십시오.
  QCPAbstractItem 문서의 서브 클래 싱 섹션에서 설명합니다.
*/
QCPItemAnchor::QCPItemAnchor(QCustomPlot *parentPlot, QCPAbstractItem *parentItem, const QString &name, int anchorId) :
  mName(name),
  mParentPlot(parentPlot),
  mParentItem(parentItem),
  mAnchorId(anchorId)
{
}

QCPItemAnchor::~QCPItemAnchor()
{
  // unregister as parent at children:
  // 자식에서 부모로 등록 취소 :
  foreach (QCPItemPosition *child, mChildrenX.toList())
  {
    if (child->parentAnchorX() == this)
      child->setParentAnchorX(0); // this acts back on this anchor and child removes itself from mChildrenX
                                  // 이것은이 앵커에 대해 다시 작용하고 자식은 자신을 mChildrenX에서 제거합니다.
  }
  foreach (QCPItemPosition *child, mChildrenY.toList())
  {
    if (child->parentAnchorY() == this)
      child->setParentAnchorY(0); // this acts back on this anchor and child removes itself from mChildrenY
                                  // this는이 앵커에 대해 다시 작용하고 자식은 자신을 mChildrenY에서 제거합니다.
  }
}

/*!
  Returns the final absolute pixel position of the QCPItemAnchor on the QCustomPlot surface.
  
  The pixel information is internally retrieved via QCPAbstractItem::anchorPixelPosition of the
  parent item, QCPItemAnchor is just an intermediary.
*/
/*!
  QCustomPlot 표면의 QCPItemAnchor의 최종 절대 픽셀 위치를 반환합니다.
  
  픽셀 정보는 내부적으로 QCPAbstractItem :: anchorPixelPosition을 통해 검색됩니다.
  상위 항목 인 QCPItemAnchor는 중간 단계에 불과합니다.
*/
QPointF QCPItemAnchor::pixelPosition() const
{
  if (mParentItem)
  {
    if (mAnchorId > -1)
    {
      return mParentItem->anchorPixelPosition(mAnchorId);
    } else
    {
      qDebug() << Q_FUNC_INFO << "no valid anchor id set:" << mAnchorId;
      return QPointF();
    }
  } else
  {
    qDebug() << Q_FUNC_INFO << "no parent item set";
    return QPointF();
  }
}

/*! \internal

  Adds \a pos to the childX list of this anchor, which keeps track of which children use this
  anchor as parent anchor for the respective coordinate. This is necessary to notify the children
  prior to destruction of the anchor.
  
  Note that this function does not change the parent setting in \a pos.
*/
/*! \내부의

  이 앵커의 childX 목록에 \ a pos를 추가합니다.이 앵커는 어떤 자식이이 앵커를 사용하는지 추적합니다.
  각 좌표에 대한 부모 앵커로 앵커를 지정합니다. 이것은 아이들에게 알리기 위해 필요합니다.
  앵커가 파괴되기 전에.
  
  이 함수는 \ a pos의 부모 설정을 변경하지 않습니다.
*/
void QCPItemAnchor::addChildX(QCPItemPosition *pos)
{
  if (!mChildrenX.contains(pos))
    mChildrenX.insert(pos);
  else
    qDebug() << Q_FUNC_INFO << "provided pos is child already" << reinterpret_cast<quintptr>(pos);
}

/*! \internal

  Removes \a pos from the childX list of this anchor.
  
  Note that this function does not change the parent setting in \a pos.
*/
/*! \내부의

  이 앵커의 childX 목록에서 pos를 제거합니다.
  
  이 함수는 \ a pos의 부모 설정을 변경하지 않습니다.
*/
void QCPItemAnchor::removeChildX(QCPItemPosition *pos)
{
  if (!mChildrenX.remove(pos))
    qDebug() << Q_FUNC_INFO << "provided pos isn't child" << reinterpret_cast<quintptr>(pos);
}

/*! \internal

  Adds \a pos to the childY list of this anchor, which keeps track of which children use this
  anchor as parent anchor for the respective coordinate. This is necessary to notify the children
  prior to destruction of the anchor.
  
  Note that this function does not change the parent setting in \a pos.
*/
/*! \내부의

  이 앵커의 childY 목록에 \ a pos를 추가합니다.이 목록은 어떤 자식이이 앵커를 사용했는지 추적합니다.
  각 좌표에 대한 부모 앵커로 앵커를 지정합니다. 이것은 아이들에게 알리기 위해 필요합니다.
  앵커가 파괴되기 전에.
  
  이 함수는 \ a pos의 부모 설정을 변경하지 않습니다.
*/
void QCPItemAnchor::addChildY(QCPItemPosition *pos)
{
  if (!mChildrenY.contains(pos))
    mChildrenY.insert(pos);
  else
    qDebug() << Q_FUNC_INFO << "provided pos is child already" << reinterpret_cast<quintptr>(pos);
}

/*! \internal

  Removes \a pos from the childY list of this anchor.
  
  Note that this function does not change the parent setting in \a pos.
*/
/*! \내부의

  이 앵커의 childY 목록에서 pos를 제거합니다.
  
  이 함수는 \ a pos의 부모 설정을 변경하지 않습니다.
*/
void QCPItemAnchor::removeChildY(QCPItemPosition *pos)
{
  if (!mChildrenY.remove(pos))
    qDebug() << Q_FUNC_INFO << "provided pos isn't child" << reinterpret_cast<quintptr>(pos);
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPItemPosition
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPItemPosition
  \brief Manages the position of an item.
  
  Every item has at least one public QCPItemPosition member pointer which provides ways to position the
  item on the QCustomPlot surface. Some items have multiple positions, for example QCPItemRect has two:
  \a topLeft and \a bottomRight.

  QCPItemPosition has a type (\ref PositionType) that can be set with \ref setType. This type
  defines how coordinates passed to \ref setCoords are to be interpreted, e.g. as absolute pixel
  coordinates, as plot coordinates of certain axes, etc. For more advanced plots it is also
  possible to assign different types per X/Y coordinate of the position (see \ref setTypeX, \ref
  setTypeY). This way an item could be positioned at a fixed pixel distance from the top in the Y
  direction, while following a plot coordinate in the X direction.

  A QCPItemPosition may have a parent QCPItemAnchor, see \ref setParentAnchor. This way you can tie
  multiple items together. If the QCPItemPosition has a parent, its coordinates (\ref setCoords)
  are considered to be absolute pixels in the reference frame of the parent anchor, where (0, 0)
  means directly ontop of the parent anchor. For example, You could attach the \a start position of
  a QCPItemLine to the \a bottom anchor of a QCPItemText to make the starting point of the line
  always be centered under the text label, no matter where the text is moved to. For more advanced
  plots, it is possible to assign different parent anchors per X/Y coordinate of the position, see
  \ref setParentAnchorX, \ref setParentAnchorY. This way an item could follow another item in the X
  direction but stay at a fixed position in the Y direction. Or even follow item A in X, and item B
  in Y.

  Note that every QCPItemPosition inherits from QCPItemAnchor and thus can itself be used as parent
  anchor for other positions.

  To set the apparent pixel position on the QCustomPlot surface directly, use \ref setPixelPosition. This
  works no matter what type this QCPItemPosition is or what parent-child situation it is in, as \ref
  setPixelPosition transforms the coordinates appropriately, to make the position appear at the specified
  pixel values.
*/
/*! \ class QCPItemPosition
  \ brief 항목의 위치를 ​​관리합니다.
  
  모든 항목에는 적어도 하나의 public QCPItemPosition 멤버 포인터가 있습니다.이 포인터는
  QCustomPlot 표면의 항목. 일부 항목에는 여러 위치가 있습니다. 예를 들어 QCPItemRect에는 두 가지가 있습니다.
  \ a topLeft 및 \ a bottomright.

  QCPItemPosition은 \ ref setType으로 설정할 수있는 유형 (\ ref PositionType)을가집니다. 이 유형
  \ ref setCoords에 전달 된 좌표를 해석 할 방법을 정의합니다 (예 : 절대 픽셀).
  좌표, 특정 축의 플롯 좌표 등.보다 진보 된 플롯의 경우
  위치의 X / Y 좌표마다 다른 유형을 할당 할 수 있습니다 (\ ref setTypeX, \ ref 참조).
  setTypeY). 이 방법으로 항목은 Y에서 위쪽에서 고정 된 픽셀 거리에 배치 될 수 있습니다.
  X 방향의 플롯 좌표를 따라 이동합니다.

  QCPItemPosition에는 부모 QCPItemAnchor가있을 수 있습니다 (\ ref setParentAnchor 참조). 이렇게하면 넥타이 할 수 있습니다.
  여러 항목을 함께. QCPItemPosition에 부모가있는 경우 해당 좌표 (\ ref setCoords)
  는 부모 앵커의 참조 프레임에서 절대 픽셀로 간주되며, 여기서 (0, 0)
  부모 앵커의 바로 위를 의미합니다. 예를 들어, \ a 시작 위치를
  선의 시작점을 만들기 위해 QCPItemLine을 QCPItemText의 하단 앵커에 연결합니다.
  텍스트가 어디로 옮겨 지든 관계없이 항상 텍스트 레이블 아래 가운데에 위치해야합니다. 고급 기능
  플롯을 사용하면 위치의 X / Y 좌표마다 다른 부모 앵커를 지정할 수 있습니다.
  \ ref setParentAnchorX, \ ref setParentAnchorY입니다. 이렇게하면 항목이 X의 다른 항목을 따라갈 수 있습니다.
  Y 방향의 고정 된 위치에 머문다. 또는 X 항목 A 및 B 항목을 따르십시오.
  Y.

  모든 QCPItemPosition은 QCPItemAnchor를 상속하므로 부모로 사용할 수 있습니다.
  다른 위치에 대한 앵커.

  QCustomPlot 표면의 픽셀 위치를 직접 설정하려면 \ ref setPixelPosition을 사용하십시오. 이
  이 QCPItemPosition이 어떤 유형인지 또는 부모 - 자식 상황인지 여부에 관계없이 \ ref로 작동합니다.
  setPixelPosition은 좌표를 적절히 변환하여 지정된 위치에 위치를 표시합니다.
  픽셀 값.
*/

/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */

/*! \fn QCPItemPosition::PositionType *QCPItemPosition::type() const
  
  Returns the current position type.
  
  If different types were set for X and Y (\ref setTypeX, \ref setTypeY), this method returns the
  type of the X coordinate. In that case rather use \a typeX() and \a typeY().
  
  \see setType
*/
/*! \ fn QCPItemPosition :: PositionType * QCPItemPosition :: type () const
  
  현재의 위치 유형을 리턴합니다.
  
  X 및 Y (\ ref setTypeX, \ ref setTypeY)에 다른 유형이 설정된 경우이 메소드는
  X 좌표의 유형. 이 경우 오히려 \ a typeX () 및 \ a typeY ()를 사용하십시오.
  
  \ setType을 참조하십시오.
*/

/*! \fn QCPItemAnchor *QCPItemPosition::parentAnchor() const
  
  Returns the current parent anchor.
  
  If different parent anchors were set for X and Y (\ref setParentAnchorX, \ref setParentAnchorY),
  this method returns the parent anchor of the Y coordinate. In that case rather use \a
  parentAnchorX() and \a parentAnchorY().
  
  \see setParentAnchor
*/
/*! \ fn QCPItemAnchor * QCPItemPosition :: parentAnchor () const
  
  현재의 부모 앵커를 반환합니다.
  
  X 및 Y (\ ref setParentAnchorX, \ ref setParentAnchorY)에 다른 상위 앵커가 설정된 경우
  이 메소드는 Y 좌표의 상위 앵커를 리턴합니다. 이 경우 오히려 \ a를 사용하십시오.
  parentAnchorX () 및 \ a parentAnchorY ()입니다.
  
  \ setParentAnchor를 참조하십시오.
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */

/*!
  Creates a new QCPItemPosition. You shouldn't create QCPItemPosition instances directly, even if
  you want to make a new item subclass. Use \ref QCPAbstractItem::createPosition instead, as
  explained in the subclassing section of the QCPAbstractItem documentation.
*/
/*!
  새 QCPItemPosition을 만듭니다. QCPItemPosition 인스턴스를 직접 만들지 않아야합니다.
  새 항목 하위 클래스를 만들고 싶습니다. \ ref QCPAbstractItem :: createPosition을 대신 사용하십시오.
  QCPAbstractItem 문서의 서브 클래 싱 섹션에서 설명합니다.
*/
QCPItemPosition::QCPItemPosition(QCustomPlot *parentPlot, QCPAbstractItem *parentItem, const QString &name) :
  QCPItemAnchor(parentPlot, parentItem, name),
  mPositionTypeX(ptAbsolute),
  mPositionTypeY(ptAbsolute),
  mKey(0),
  mValue(0),
  mParentAnchorX(0),
  mParentAnchorY(0)
{
}

QCPItemPosition::~QCPItemPosition()
{
  // unregister as parent at children:
  // Note: this is done in ~QCPItemAnchor again, but it's important QCPItemPosition does it itself, because only then
  //       the setParentAnchor(0) call the correct QCPItemPosition::pixelPosition function instead of QCPItemAnchor::pixelPosition
  // 자식에서 부모로 등록 취소 :
  // 참고 : 이것은 ~ QCPItemAnchor에서 다시 수행됩니다. 그러나 QCPItemPosition은 그 자체 만 수행하므로 중요합니다.
  // setParentAnchor (0)는 QCPItemAnchor :: pixelPosition 대신 올바른 QCPItemPosition :: pixelPosition 함수를 호출합니다.
  foreach (QCPItemPosition *child, mChildrenX.toList())
  {
    if (child->parentAnchorX() == this)
      child->setParentAnchorX(0); // this acts back on this anchor and child removes itself from mChildrenX
                                  // 이것은이 앵커에 대해 다시 작용하고 자식은 자신을 mChildrenX에서 제거합니다.
  }
  foreach (QCPItemPosition *child, mChildrenY.toList())
  {
    if (child->parentAnchorY() == this)
      child->setParentAnchorY(0); // this acts back on this anchor and child removes itself from mChildrenY
                                  // this는이 앵커에 대해 다시 작용하고 자식은 자신을 mChildrenY에서 제거합니다.
  }
  // unregister as child in parent:
  // 부모에서 자식으로 등록 취소 :
  if (mParentAnchorX)
    mParentAnchorX->removeChildX(this);
  if (mParentAnchorY)
    mParentAnchorY->removeChildY(this);
}

/* can't make this a header inline function, because QPointer breaks with forward declared types, see QTBUG-29588 */
/* QPointer가 앞으로 선언 된 유형으로 중단되기 때문에 이것을 헤더 인라인 함수로 만들 수 없습니다. QTBUG-29588 */
QCPAxisRect *QCPItemPosition::axisRect() const
{
  return mAxisRect.data();
}

/*!
  Sets the type of the position. The type defines how the coordinates passed to \ref setCoords
  should be handled and how the QCPItemPosition should behave in the plot.
  
  The possible values for \a type can be separated in two main categories:

  \li The position is regarded as a point in plot coordinates. This corresponds to \ref ptPlotCoords
  and requires two axes that define the plot coordinate system. They can be specified with \ref setAxes.
  By default, the QCustomPlot's x- and yAxis are used.
  
  \li The position is fixed on the QCustomPlot surface, i.e. independent of axis ranges. This
  corresponds to all other types, i.e. \ref ptAbsolute, \ref ptViewportRatio and \ref
  ptAxisRectRatio. They differ only in the way the absolute position is described, see the
  documentation of \ref PositionType for details. For \ref ptAxisRectRatio, note that you can specify
  the axis rect with \ref setAxisRect. By default this is set to the main axis rect.
  
  Note that the position type \ref ptPlotCoords is only available (and sensible) when the position
  has no parent anchor (\ref setParentAnchor).
  
  If the type is changed, the apparent pixel position on the plot is preserved. This means
  the coordinates as retrieved with coords() and set with \ref setCoords may change in the process.
  
  This method sets the type for both X and Y directions. It is also possible to set different types
  for X and Y, see \ref setTypeX, \ref setTypeY.
*/
/*!
  위치의 유형을 설정합니다. 이 유형은 \ ref setCoords에 좌표가 전달되는 방식을 정의합니다.
  처리해야하며 QCPItemPosition이 플롯에서 어떻게 작동해야 하는지를 지정해야합니다.
  
  \ a 유형에 사용할 수있는 값은 두 가지 주요 범주로 구분할 수 있습니다.

  \ li 위치는 좌표 좌표의 한 점으로 간주됩니다. \ ref ptPlotCoords에 해당합니다.
  플롯 좌표계를 정의하는 두 개의 축이 필요합니다. \ ref setAxes로 지정할 수 있습니다.
  기본적으로 QCustomPlot의 x 및 yAx가 사용됩니다.
  
  \ li 위치는 QCustomPlot 표면에 고정됩니다. 즉, 축 범위에 관계 없습니다. 이
  \ ref ptAbsolute, \ ref ptViewportRatio 및 \ ref와 같은 다른 모든 유형에 해당합니다.
  ptAxisRectRatio. 그들은 절대 위치가 기술되는 방식 만 다르다.
  자세한 내용은 \ ref PositionType 문서를 참조하십시오. \ ref ptAxisRectRatio의 경우 다음을 지정할 수 있습니다.
  \ ref setAxisRect를 가지는 축 rect. 기본적으로 이것은 주축 rect로 설정됩니다.
  
  위치 유형 \ ref ptPlotCoords는 위치 (예 :
  상위 앵커가 없습니다 (\ ref setParentAnchor).
  
  유형이 변경되면 플롯의 겉보기 픽셀 위치가 유지됩니다. 이것은
  coords ()로 검색되고 \ ref setCoords로 설정된 좌표는 프로세스에서 변경 될 수 있습니다.
  
  이 방법은 X와 Y 방향 모두에 대해 유형을 설정합니다. 다른 유형을 설정할 수도 있습니다.
  X 및 Y의 경우 \ ref setTypeX, \ ref setTypeY를 참조하십시오.
*/
void QCPItemPosition::setType(QCPItemPosition::PositionType type)
{
  setTypeX(type);
  setTypeY(type);
}

/*!
  This method sets the position type of the X coordinate to \a type.
  
  For a detailed description of what a position type is, see the documentation of \ref setType.
  
  \see setType, setTypeY
*/
/*!
  이 메소드는 X 좌표의 위치 유형을 \ a 유형으로 설정합니다.
  
  위치 유형이 무엇인지에 대한 자세한 설명은 \ ref setType 문서를 참조하십시오.
  
  \ setType, setTypeY를 참조하십시오.
*/
void QCPItemPosition::setTypeX(QCPItemPosition::PositionType type)
{
  if (mPositionTypeX != type)
  {
    // if switching from or to coordinate type that isn't valid (e.g. because axes or axis rect
    // were deleted), don't try to recover the pixelPosition() because it would output a qDebug warning.
    // 유효하지 않은 좌표 유형 (예 : 축 또는 축 rect)으로 전환하거나 좌표 유형으로 전환하는 경우
    // 삭제 된 경우) qDebug 경고를 출력하므로 pixelPosition ()을 복구하지 마십시오.
    bool retainPixelPosition = true;
    if ((mPositionTypeX == ptPlotCoords || type == ptPlotCoords) && (!mKeyAxis || !mValueAxis))
      retainPixelPosition = false;
    if ((mPositionTypeX == ptAxisRectRatio || type == ptAxisRectRatio) && (!mAxisRect))
      retainPixelPosition = false;
    
    QPointF pixel;
    if (retainPixelPosition)
      pixel = pixelPosition();
    
    mPositionTypeX = type;
    
    if (retainPixelPosition)
      setPixelPosition(pixel);
  }
}

/*!
  This method sets the position type of the Y coordinate to \a type.
  
  For a detailed description of what a position type is, see the documentation of \ref setType.
  
  \see setType, setTypeX
*/
/*!
  이 메소드는 Y 좌표의 위치 유형을 \ a 유형으로 설정합니다.
  
  위치 유형이 무엇인지에 대한 자세한 설명은 \ ref setType 문서를 참조하십시오.
  
  \ setType, setTypeX를 참조하십시오.
*/
void QCPItemPosition::setTypeY(QCPItemPosition::PositionType type)
{
  if (mPositionTypeY != type)
  {
    // if switching from or to coordinate type that isn't valid (e.g. because axes or axis rect
    // were deleted), don't try to recover the pixelPosition() because it would output a qDebug warning.
    // 유효하지 않은 좌표 유형 (예 : 축 또는 축 rect)으로 전환하거나 좌표 유형으로 전환하는 경우
    // 삭제 된 경우) qDebug 경고를 출력하므로 pixelPosition ()을 복구하지 마십시오.
    bool retainPixelPosition = true;
    if ((mPositionTypeY == ptPlotCoords || type == ptPlotCoords) && (!mKeyAxis || !mValueAxis))
      retainPixelPosition = false;
    if ((mPositionTypeY == ptAxisRectRatio || type == ptAxisRectRatio) && (!mAxisRect))
      retainPixelPosition = false;
    
    QPointF pixel;
    if (retainPixelPosition)
      pixel = pixelPosition();
    
    mPositionTypeY = type;
    
    if (retainPixelPosition)
      setPixelPosition(pixel);
  }
}

/*!
  Sets the parent of this QCPItemPosition to \a parentAnchor. This means the position will now
  follow any position changes of the anchor. The local coordinate system of positions with a parent
  anchor always is absolute pixels, with (0, 0) being exactly on top of the parent anchor. (Hence
  the type shouldn't be set to \ref ptPlotCoords for positions with parent anchors.)
  
  if \a keepPixelPosition is true, the current pixel position of the QCPItemPosition is preserved
  during reparenting. If it's set to false, the coordinates are set to (0, 0), i.e. the position
  will be exactly on top of the parent anchor.
  
  To remove this QCPItemPosition from any parent anchor, set \a parentAnchor to 0.
  
  If the QCPItemPosition previously had no parent and the type is \ref ptPlotCoords, the type is
  set to \ref ptAbsolute, to keep the position in a valid state.
  
  This method sets the parent anchor for both X and Y directions. It is also possible to set
  different parents for X and Y, see \ref setParentAnchorX, \ref setParentAnchorY.
*/
/*!
  이 QCPItemPosition의 부모를 \ parentAnchor로 설정합니다. 이것은 현재 위치가
  앵커의 위치 변경을 따릅니다. 부모를 가지는 위치의 로컬 좌표 체계
  앵커는 항상 절대 픽셀이며, (0, 0)은 정확히 부모 앵커의 맨 위에 있습니다. (금후
  상위 앵커가있는 위치의 경우 형식을 \ ref ptPlotCoords로 설정하면 안됩니다.
  
  \ keepPixelPosition이 true이면 QCPItemPosition의 현재 픽셀 위치가 유지됩니다.
  재임 중. false로 설정하면 좌표가 (0, 0)으로 설정됩니다. 즉 위치
  부모 앵커의 꼭대기에 정확하게 위치 할 것입니다.
  
  부모 앵커에서이 QCPItemPosition을 제거하려면 \ a parentAnchor를 0으로 설정하십시오.
  
  이전에 QCPItemPosition에 상위 항목이없고 유형이 \ ref ptPlotCoords 인 경우 유형은 다음과 같습니다.
  위치를 유효한 상태로 유지하려면 \ ref ptAbsolute로 설정하십시오.
  
  이 메서드는 X 및 Y 방향 모두에 대한 부모 앵커를 설정합니다. 설정하는 것도 가능합니다.
  X와 Y에 대한 다른 부모는 \ ref setParentAnchorX, \ ref setParentAnchorY를 참조하십시오.
*/
bool QCPItemPosition::setParentAnchor(QCPItemAnchor *parentAnchor, bool keepPixelPosition)
{
  bool successX = setParentAnchorX(parentAnchor, keepPixelPosition);
  bool successY = setParentAnchorY(parentAnchor, keepPixelPosition);
  return successX && successY;
}

/*!
  This method sets the parent anchor of the X coordinate to \a parentAnchor.
  
  For a detailed description of what a parent anchor is, see the documentation of \ref setParentAnchor.
  
  \see setParentAnchor, setParentAnchorY
*/
/*!
  이 메서드는 X 좌표의 부모 앵커를 \ a parentAnchor로 설정합니다.
  
  부모 앵커가 무엇인지에 대한 자세한 설명은 \ ref setParentAnchor의 설명서를 참조하십시오.
  
  \ setParentAnchor, setParentAnchorY를 참조하십시오.
*/
bool QCPItemPosition::setParentAnchorX(QCPItemAnchor *parentAnchor, bool keepPixelPosition)
{
  // make sure self is not assigned as parent:
  // self가 parent로 할당되지 않았는지 확인합니다.
  if (parentAnchor == this)
  {
    qDebug() << Q_FUNC_INFO << "can't set self as parent anchor" << reinterpret_cast<quintptr>(parentAnchor);
    return false;
  }
  // make sure no recursive parent-child-relationships are created:
  // 재귀적인 부모 - 자식 관계가 생성되지 않았는지 확인하십시오 :
  QCPItemAnchor *currentParent = parentAnchor;
  while (currentParent)
  {
    if (QCPItemPosition *currentParentPos = currentParent->toQCPItemPosition())
    {
      // is a QCPItemPosition, might have further parent, so keep iterating
      //는 QCPItemPosition이며, 추가 부모를 가질 수 있으므로 계속 반복 수행하십시오.
      if (currentParentPos == this)
      {
        qDebug() << Q_FUNC_INFO << "can't create recursive parent-child-relationship" << reinterpret_cast<quintptr>(parentAnchor);
        return false;
      }
      currentParent = currentParentPos->parentAnchorX();
    } else
    {
      // is a QCPItemAnchor, can't have further parent. Now make sure the parent items aren't the
      // same, to prevent a position being child of an anchor which itself depends on the position,
      // because they're both on the same item:
      //는 QCPItemAnchor이므로 상위 항목을 가질 수 없습니다. 이제 상위 항목이
      // 동일하다. 위치 자체에 의존하는 앵커의 자식 인 위치를 막기 위해,
      // 두 항목이 같은 항목에 있기 때문에 :
      if (currentParent->mParentItem == mParentItem)
      {
        qDebug() << Q_FUNC_INFO << "can't set parent to be an anchor which itself depends on this position" << reinterpret_cast<quintptr>(parentAnchor);
        return false;
      }
      break;
    }
  }
  
  // if previously no parent set and PosType is still ptPlotCoords, set to ptAbsolute:
  // 이전에 부모 집합이없고 PosType이 여전히 ptPlotCoords 인 경우 ptAbsolute로 설정합니다.
  if (!mParentAnchorX && mPositionTypeX == ptPlotCoords)
    setTypeX(ptAbsolute);
  
  // save pixel position:
  // 픽셀 위치 저장 :
  QPointF pixelP;
  if (keepPixelPosition)
    pixelP = pixelPosition();
  // unregister at current parent anchor:
  // 현재 부모 앵커에서 등록 취소 :
  if (mParentAnchorX)
    mParentAnchorX->removeChildX(this);
  // register at new parent anchor:
  // 새로운 부모 앵커에 등록 :
  if (parentAnchor)
    parentAnchor->addChildX(this);
  mParentAnchorX = parentAnchor;
  // restore pixel position under new parent:
  // 새 부모 아래에서 픽셀 위치를 복원합니다.
  if (keepPixelPosition)
    setPixelPosition(pixelP);
  else
    setCoords(0, coords().y());
  return true;
}

/*!
  This method sets the parent anchor of the Y coordinate to \a parentAnchor.
  
  For a detailed description of what a parent anchor is, see the documentation of \ref setParentAnchor.
  
  \see setParentAnchor, setParentAnchorX
*/
/*!
  이 메서드는 Y 좌표의 부모 앵커를 \ a parentAnchor로 설정합니다.
  
  부모 앵커가 무엇인지에 대한 자세한 설명은 \ ref setParentAnchor의 설명서를 참조하십시오.
  
  \ setParentAnchor, setParentAnchorX를 참조하십시오.
*/
bool QCPItemPosition::setParentAnchorY(QCPItemAnchor *parentAnchor, bool keepPixelPosition)
{
  // make sure self is not assigned as parent:
  // self가 parent로 할당되지 않았는지 확인합니다.
  if (parentAnchor == this)
  {
    qDebug() << Q_FUNC_INFO << "can't set self as parent anchor" << reinterpret_cast<quintptr>(parentAnchor);
    return false;
  }
  // make sure no recursive parent-child-relationships are created:
  // 재귀적인 부모 - 자식 관계가 생성되지 않았는지 확인하십시오 :
  QCPItemAnchor *currentParent = parentAnchor;
  while (currentParent)
  {
    if (QCPItemPosition *currentParentPos = currentParent->toQCPItemPosition())
    {
      // is a QCPItemPosition, might have further parent, so keep iterating
      //는 QCPItemPosition이며, 추가 부모를 가질 수 있으므로 계속 반복 수행하십시오.
      if (currentParentPos == this)
      {
        qDebug() << Q_FUNC_INFO << "can't create recursive parent-child-relationship" << reinterpret_cast<quintptr>(parentAnchor);
        return false;
      }
      currentParent = currentParentPos->parentAnchorY();
    } else
    {
      // is a QCPItemAnchor, can't have further parent. Now make sure the parent items aren't the
      // same, to prevent a position being child of an anchor which itself depends on the position,
      // because they're both on the same item:
      //는 QCPItemAnchor이므로 상위 항목을 가질 수 없습니다. 이제 상위 항목이
      // 동일하다. 위치 자체에 의존하는 앵커의 자식 인 위치를 막기 위해,
      // 두 항목이 같은 항목에 있기 때문에 :
      if (currentParent->mParentItem == mParentItem)
      {
        qDebug() << Q_FUNC_INFO << "can't set parent to be an anchor which itself depends on this position" << reinterpret_cast<quintptr>(parentAnchor);
        return false;
      }
      break;
    }
  }
  
  // if previously no parent set and PosType is still ptPlotCoords, set to ptAbsolute:
  // 이전에 부모 집합이없고 PosType이 여전히 ptPlotCoords 인 경우 ptAbsolute로 설정합니다.
  if (!mParentAnchorY && mPositionTypeY == ptPlotCoords)
    setTypeY(ptAbsolute);
  
  // save pixel position:
  // 픽셀 위치 저장 :
  QPointF pixelP;
  if (keepPixelPosition)
    pixelP = pixelPosition();
  // unregister at current parent anchor:
  // 현재 부모 앵커에서 등록 취소 :
  if (mParentAnchorY)
    mParentAnchorY->removeChildY(this);
  // register at new parent anchor:
  // 새로운 부모 앵커에 등록 :
  if (parentAnchor)
    parentAnchor->addChildY(this);
  mParentAnchorY = parentAnchor;
  // restore pixel position under new parent:
  // 새 부모 아래에서 픽셀 위치를 복원합니다.
  if (keepPixelPosition)
    setPixelPosition(pixelP);
  else
    setCoords(coords().x(), 0);
  return true;
}

/*!
  Sets the coordinates of this QCPItemPosition. What the coordinates mean, is defined by the type
  (\ref setType, \ref setTypeX, \ref setTypeY).
  
  For example, if the type is \ref ptAbsolute, \a key and \a value mean the x and y pixel position
  on the QCustomPlot surface. In that case the origin (0, 0) is in the top left corner of the
  QCustomPlot viewport. If the type is \ref ptPlotCoords, \a key and \a value mean a point in the
  plot coordinate system defined by the axes set by \ref setAxes. By default those are the
  QCustomPlot's xAxis and yAxis. See the documentation of \ref setType for other available
  coordinate types and their meaning.
  
  If different types were configured for X and Y (\ref setTypeX, \ref setTypeY), \a key and \a
  value must also be provided in the different coordinate systems. Here, the X type refers to \a
  key, and the Y type refers to \a value.

  \see setPixelPosition
*/
/*!
  이 QCPItemPosition의 좌표를 설정합니다. 좌표의 의미는 타입에 의해 정의됩니다.
  (\ ref setType, \ ref setTypeX, \ ref setTypeY).
  
  예를 들어 유형이 \ ref ptAbsolute 인 경우 \ a 키와 \ a 값은 x 및 y 픽셀 위치를 의미합니다.
  QCustomPlot 표면에서. 이 경우 원점 (0, 0)은 왼쪽 상단 모서리에 있습니다.
  QCustomPlot 뷰포트. 형식이 \ ref ptPlotCoords 인 경우 \ a 키와 \ a 값은
  \ ref setAxes에 의해 설정된 축으로 정의 된 플롯 좌표계. 기본적으로
  QCustomPlot의 xAxis 및 yAxis입니다. 사용할 수있는 다른 것에 대해서는 \ ref setType 문서를 참조하십시오.
  좌표 유형 및 그 의미.
  
  X와 Y (\ ref setTypeX, \ ref setTypeY)에 서로 다른 유형이 구성된 경우 \ a 키와 \ a
  값은 다른 좌표계에서도 제공되어야합니다. 여기에서 X 유형은 \ a
  키이고 Y 유형은 \ a 값을 나타냅니다.

  \ see setPixelPosition
*/
void QCPItemPosition::setCoords(double key, double value)
{
  mKey = key;
  mValue = value;
}

/*! \overload

  Sets the coordinates as a QPointF \a pos where pos.x has the meaning of \a key and pos.y the
  meaning of \a value of the \ref setCoords(double key, double value) method.
*/
/*! \초과 적재

  좌표를 QPointF \ a pos로 설정합니다. 여기서 pos.x는 \ a 키의 의미를 가지며 pos.y는
  \ ref setCoords (double key, double value) 메소드의 \ a 값의 의미.
*/
void QCPItemPosition::setCoords(const QPointF &pos)
{
  setCoords(pos.x(), pos.y());
}

/*!
  Returns the final absolute pixel position of the QCPItemPosition on the QCustomPlot surface. It
  includes all effects of type (\ref setType) and possible parent anchors (\ref setParentAnchor).

  \see setPixelPosition
*/
/*!
  QCustomPlot 표면의 QCPItemPosition의 최종 절대 픽셀 위치를 반환합니다. 그것
  type (\ ref setType)과 가능한 parent anchors (\ ref setParentAnchor)의 모든 효과를 포함합니다.

  \ see setPixelPosition
*/
QPointF QCPItemPosition::pixelPosition() const
{
  QPointF result;
  
  // determine X:
  // X를 결정 :
  switch (mPositionTypeX)
  {
    case ptAbsolute:
    {
      result.rx() = mKey;
      if (mParentAnchorX)
        result.rx() += mParentAnchorX->pixelPosition().x();
      break;
    }
    case ptViewportRatio:
    {
      result.rx() = mKey*mParentPlot->viewport().width();
      if (mParentAnchorX)
        result.rx() += mParentAnchorX->pixelPosition().x();
      else
        result.rx() += mParentPlot->viewport().left();
      break;
    }
    case ptAxisRectRatio:
    {
      if (mAxisRect)
      {
        result.rx() = mKey*mAxisRect.data()->width();
        if (mParentAnchorX)
          result.rx() += mParentAnchorX->pixelPosition().x();
        else
          result.rx() += mAxisRect.data()->left();
      } else
        qDebug() << Q_FUNC_INFO << "Item position type x is ptAxisRectRatio, but no axis rect was defined";
      break;
    }
    case ptPlotCoords:
    {
      if (mKeyAxis && mKeyAxis.data()->orientation() == Qt::Horizontal)
        result.rx() = mKeyAxis.data()->coordToPixel(mKey);
      else if (mValueAxis && mValueAxis.data()->orientation() == Qt::Horizontal)
        result.rx() = mValueAxis.data()->coordToPixel(mValue);
      else
        qDebug() << Q_FUNC_INFO << "Item position type x is ptPlotCoords, but no axes were defined";
      break;
    }
  }
  
  // determine Y:
  // Y를 결정하십시오.
  switch (mPositionTypeY)
  {
    case ptAbsolute:
    {
      result.ry() = mValue;
      if (mParentAnchorY)
        result.ry() += mParentAnchorY->pixelPosition().y();
      break;
    }
    case ptViewportRatio:
    {
      result.ry() = mValue*mParentPlot->viewport().height();
      if (mParentAnchorY)
        result.ry() += mParentAnchorY->pixelPosition().y();
      else
        result.ry() += mParentPlot->viewport().top();
      break;
    }
    case ptAxisRectRatio:
    {
      if (mAxisRect)
      {
        result.ry() = mValue*mAxisRect.data()->height();
        if (mParentAnchorY)
          result.ry() += mParentAnchorY->pixelPosition().y();
        else
          result.ry() += mAxisRect.data()->top();
      } else
        qDebug() << Q_FUNC_INFO << "Item position type y is ptAxisRectRatio, but no axis rect was defined";
      break;
    }
    case ptPlotCoords:
    {
      if (mKeyAxis && mKeyAxis.data()->orientation() == Qt::Vertical)
        result.ry() = mKeyAxis.data()->coordToPixel(mKey);
      else if (mValueAxis && mValueAxis.data()->orientation() == Qt::Vertical)
        result.ry() = mValueAxis.data()->coordToPixel(mValue);
      else
        qDebug() << Q_FUNC_INFO << "Item position type y is ptPlotCoords, but no axes were defined";
      break;
    }
  }
  
  return result;
}

/*!
  When \ref setType is \ref ptPlotCoords, this function may be used to specify the axes the
  coordinates set with \ref setCoords relate to. By default they are set to the initial xAxis and
  yAxis of the QCustomPlot.
*/
/*!
  \ ref setType이 \ ref ptPlotCoords 인 경우이 함수는 축을 지정하는 데 사용될 수 있습니다.
  \ ref setCoords가 설정된 좌표입니다. 기본적으로 초기 xAxis 및
  QCustomPlot의 yAx입니다.
*/
void QCPItemPosition::setAxes(QCPAxis *keyAxis, QCPAxis *valueAxis)
{
  mKeyAxis = keyAxis;
  mValueAxis = valueAxis;
}

/*!
  When \ref setType is \ref ptAxisRectRatio, this function may be used to specify the axis rect the
  coordinates set with \ref setCoords relate to. By default this is set to the main axis rect of
  the QCustomPlot.
*/
/*!
  \ ref setType이 \ ref ptAxisRectRatio 일 때이 함수는 축을 지정하는 데 사용될 수 있습니다.
  \ ref setCoords가 설정된 좌표입니다. 기본적으로 이것은 주축 rect로 설정됩니다.
  QCustomPlot.
*/
void QCPItemPosition::setAxisRect(QCPAxisRect *axisRect)
{
  mAxisRect = axisRect;
}

/*!
  Sets the apparent pixel position. This works no matter what type (\ref setType) this
  QCPItemPosition is or what parent-child situation it is in, as coordinates are transformed
  appropriately, to make the position finally appear at the specified pixel values.

  Only if the type is \ref ptAbsolute and no parent anchor is set, this function's effect is
  identical to that of \ref setCoords.

  \see pixelPosition, setCoords
*/
/*!
  겉보기 픽셀 위치를 설정합니다. 이것은 어떤 타입 (\ ref setType)이든 관계없이 작동한다.
  QCPItemPosition은 좌표가 변환 될 때의 부모 또는 자식 상황입니다.
  적절하게, 지정된 픽셀 값에 위치가 최종적으로 나타나게합니다.

  유형이 \ ref ptAbsolute이고 상위 앵커가 설정되지 않은 경우에만이 함수의 효과는 다음과 같습니다.
  \ ref setCoords와 동일합니다.

  \ see pixel 위치, setCoords
*/
void QCPItemPosition::setPixelPosition(const QPointF &pixelPosition)
{
  double x = pixelPosition.x();
  double y = pixelPosition.y();
  
  switch (mPositionTypeX)
  {
    case ptAbsolute:
    {
      if (mParentAnchorX)
        x -= mParentAnchorX->pixelPosition().x();
      break;
    }
    case ptViewportRatio:
    {
      if (mParentAnchorX)
        x -= mParentAnchorX->pixelPosition().x();
      else
        x -= mParentPlot->viewport().left();
      x /= (double)mParentPlot->viewport().width();
      break;
    }
    case ptAxisRectRatio:
    {
      if (mAxisRect)
      {
        if (mParentAnchorX)
          x -= mParentAnchorX->pixelPosition().x();
        else
          x -= mAxisRect.data()->left();
        x /= (double)mAxisRect.data()->width();
      } else
        qDebug() << Q_FUNC_INFO << "Item position type x is ptAxisRectRatio, but no axis rect was defined";
      break;
    }
    case ptPlotCoords:
    {
      if (mKeyAxis && mKeyAxis.data()->orientation() == Qt::Horizontal)
        x = mKeyAxis.data()->pixelToCoord(x);
      else if (mValueAxis && mValueAxis.data()->orientation() == Qt::Horizontal)
        y = mValueAxis.data()->pixelToCoord(x);
      else
        qDebug() << Q_FUNC_INFO << "Item position type x is ptPlotCoords, but no axes were defined";
      break;
    }
  }
  
  switch (mPositionTypeY)
  {
    case ptAbsolute:
    {
      if (mParentAnchorY)
        y -= mParentAnchorY->pixelPosition().y();
      break;
    }
    case ptViewportRatio:
    {
      if (mParentAnchorY)
        y -= mParentAnchorY->pixelPosition().y();
      else
        y -= mParentPlot->viewport().top();
      y /= (double)mParentPlot->viewport().height();
      break;
    }
    case ptAxisRectRatio:
    {
      if (mAxisRect)
      {
        if (mParentAnchorY)
          y -= mParentAnchorY->pixelPosition().y();
        else
          y -= mAxisRect.data()->top();
        y /= (double)mAxisRect.data()->height();
      } else
        qDebug() << Q_FUNC_INFO << "Item position type y is ptAxisRectRatio, but no axis rect was defined";
      break;
    }
    case ptPlotCoords:
    {
      if (mKeyAxis && mKeyAxis.data()->orientation() == Qt::Vertical)
        x = mKeyAxis.data()->pixelToCoord(y);
      else if (mValueAxis && mValueAxis.data()->orientation() == Qt::Vertical)
        y = mValueAxis.data()->pixelToCoord(y);
      else
        qDebug() << Q_FUNC_INFO << "Item position type y is ptPlotCoords, but no axes were defined";
      break;
    }
  }
  
  setCoords(x, y);
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPAbstractItem
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPAbstractItem
  \brief The abstract base class for all items in a plot.
  
  In QCustomPlot, items are supplemental graphical elements that are neither plottables
  (QCPAbstractPlottable) nor axes (QCPAxis). While plottables are always tied to two axes and thus
  plot coordinates, items can also be placed in absolute coordinates independent of any axes. Each
  specific item has at least one QCPItemPosition member which controls the positioning. Some items
  are defined by more than one coordinate and thus have two or more QCPItemPosition members (For
  example, QCPItemRect has \a topLeft and \a bottomRight).
  
  This abstract base class defines a very basic interface like visibility and clipping. Since this
  class is abstract, it can't be instantiated. Use one of the subclasses or create a subclass
  yourself to create new items.
  
  The built-in items are:
  <table>
  <tr><td>QCPItemLine</td><td>A line defined by a start and an end point. May have different ending styles on each side (e.g. arrows).</td></tr>
  <tr><td>QCPItemStraightLine</td><td>A straight line defined by a start and a direction point. Unlike QCPItemLine, the straight line is infinitely long and has no endings.</td></tr>
  <tr><td>QCPItemCurve</td><td>A curve defined by start, end and two intermediate control points. May have different ending styles on each side (e.g. arrows).</td></tr>
  <tr><td>QCPItemRect</td><td>A rectangle</td></tr>
  <tr><td>QCPItemEllipse</td><td>An ellipse</td></tr>
  <tr><td>QCPItemPixmap</td><td>An arbitrary pixmap</td></tr>
  <tr><td>QCPItemText</td><td>A text label</td></tr>
  <tr><td>QCPItemBracket</td><td>A bracket which may be used to reference/highlight certain parts in the plot.</td></tr>
  <tr><td>QCPItemTracer</td><td>An item that can be attached to a QCPGraph and sticks to its data points, given a key coordinate.</td></tr>
  </table>
  
  \section items-clipping Clipping

  Items are by default clipped to the main axis rect (they are only visible inside the axis rect).
  To make an item visible outside that axis rect, disable clipping via \ref setClipToAxisRect
  "setClipToAxisRect(false)".

  On the other hand if you want the item to be clipped to a different axis rect, specify it via
  \ref setClipAxisRect. This clipAxisRect property of an item is only used for clipping behaviour, and
  in principle is independent of the coordinate axes the item might be tied to via its position
  members (\ref QCPItemPosition::setAxes). However, it is common that the axis rect for clipping
  also contains the axes used for the item positions.
  
  \section items-using Using items
  
  First you instantiate the item you want to use and add it to the plot:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpitemline-creation-1
  by default, the positions of the item are bound to the x- and y-Axis of the plot. So we can just
  set the plot coordinates where the line should start/end:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpitemline-creation-2
  If we don't want the line to be positioned in plot coordinates but a different coordinate system,
  e.g. absolute pixel positions on the QCustomPlot surface, we need to change the position type like this:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpitemline-creation-3
  Then we can set the coordinates, this time in pixels:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpitemline-creation-4
  and make the line visible on the entire QCustomPlot, by disabling clipping to the axis rect:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpitemline-creation-5
  
  For more advanced plots, it is even possible to set different types and parent anchors per X/Y
  coordinate of an item position, using for example \ref QCPItemPosition::setTypeX or \ref
  QCPItemPosition::setParentAnchorX. For details, see the documentation of \ref QCPItemPosition.
  
  \section items-subclassing Creating own items
  
  To create an own item, you implement a subclass of QCPAbstractItem. These are the pure
  virtual functions, you must implement:
  \li \ref selectTest
  \li \ref draw
  
  See the documentation of those functions for what they need to do.
  
  \subsection items-positioning Allowing the item to be positioned
  
  As mentioned, item positions are represented by QCPItemPosition members. Let's assume the new item shall
  have only one point as its position (as opposed to two like a rect or multiple like a polygon). You then add
  a public member of type QCPItemPosition like so:
  
  \code QCPItemPosition * const myPosition;\endcode
  
  the const makes sure the pointer itself can't be modified from the user of your new item (the QCPItemPosition
  instance it points to, can be modified, of course).
  The initialization of this pointer is made easy with the \ref createPosition function. Just assign
  the return value of this function to each QCPItemPosition in the constructor of your item. \ref createPosition
  takes a string which is the name of the position, typically this is identical to the variable name.
  For example, the constructor of QCPItemExample could look like this:
  
  \code
  QCPItemExample::QCPItemExample(QCustomPlot *parentPlot) :
    QCPAbstractItem(parentPlot),
    myPosition(createPosition("myPosition"))
  {
    // other constructor code
  }
  \endcode
  
  \subsection items-drawing The draw function
  
  To give your item a visual representation, reimplement the \ref draw function and use the passed
  QCPPainter to draw the item. You can retrieve the item position in pixel coordinates from the
  position member(s) via \ref QCPItemPosition::pixelPosition.

  To optimize performance you should calculate a bounding rect first (don't forget to take the pen
  width into account), check whether it intersects the \ref clipRect, and only draw the item at all
  if this is the case.
  
  \subsection items-selection The selectTest function
  
  Your implementation of the \ref selectTest function may use the helpers \ref
  QCPVector2D::distanceSquaredToLine and \ref rectDistance. With these, the implementation of the
  selection test becomes significantly simpler for most items. See the documentation of \ref
  selectTest for what the function parameters mean and what the function should return.
  
  \subsection anchors Providing anchors
  
  Providing anchors (QCPItemAnchor) starts off like adding a position. First you create a public
  member, e.g.
  
  \code QCPItemAnchor * const bottom;\endcode

  and create it in the constructor with the \ref createAnchor function, assigning it a name and an
  anchor id (an integer enumerating all anchors on the item, you may create an own enum for this).
  Since anchors can be placed anywhere, relative to the item's position(s), your item needs to
  provide the position of every anchor with the reimplementation of the \ref anchorPixelPosition(int
  anchorId) function.
  
  In essence the QCPItemAnchor is merely an intermediary that itself asks your item for the pixel
  position when anything attached to the anchor needs to know the coordinates.
*/
/*! \ class QCPAbstractItem
  \ brief 플롯의 모든 항목에 대한 추상 기본 클래스입니다.
  
  QCustomPlot에서 항목은 plottables가 아닌 보완 그래픽 요소입니다
  (QCPAbstractPlottable) 또는 축 (QCPAxis)이 아닙니다. 플롯 테이블은 항상 두 개의 축에 연결되므로
  플롯 좌표를 사용하면 항목을 축과 상관없이 절대 좌표로 배치 할 수 있습니다. 마다
  특정 항목에는 위치 지정을 제어하는 ​​QCPItemPosition 멤버가 하나 이상 있습니다. 일부 항목
  둘 이상의 좌표로 정의되므로 두 개 이상의 QCPItemPosition 멤버가 있습니다 (For
  예를 들어, QCPItemRect에는 \는 topLeft이고 \는 bottomRight입니다.
  
  이 추상 기본 클래스는 가시성 및 클리핑과 같은 매우 기본적인 인터페이스를 정의합니다. 이후
  클래스는 추상 클래스이므로 인스턴스화 할 수 없습니다. 하위 클래스 중 하나를 사용하거나 하위 클래스를 만듭니다.
  새로운 항목을 만들 수 있습니다.
  
  기본 제공 항목은 다음과 같습니다.
  <table>
  <tr> <td> QCPItemLine </ td> <td> 시작과 끝 지점으로 정의 된 선. 각면에 다른 끝 스타일이있을 수 있습니다 (예 : 화살표). </ td> </ tr>
  <tr> <td> QCPItemStraightLine </ td> <td> 시작점과 방향 점으로 정의되는 직선. QCPItemLine과 달리 직선은 무한히 길며 끝이 없습니다. </ td> </ tr>
  <tr> <td> QCPItemCurve </ td> <td> 시작, 끝 및 두 개의 중간 컨트롤 포인트로 정의되는 커브입니다. 각면에 다른 끝 스타일이있을 수 있습니다 (예 : 화살표). </ td> </ tr>
  <tr> <td> QCPItemRect </ td> <td> 사각형 </ td> </ tr>
  <tr> <td> QCPItemEllipse </ td> <td> 타원 </ td> </ tr>
  <td> QCPItemPixmap </ td> <td> 임의의 픽스맵 </ td> </ tr>
  <tr> <td> QCPItemText </ td> <td> 텍스트 레이블 </ td> </ tr>
  <tr> <td> QCPItemBracket </ td> 플롯의 특정 부분을 참조 / 강조 표시하는 데 사용할 수있는 브래킷. </ td> </ tr>
  </ td> </ tr> <tr> <td> QCPItemTracer </ td> QCPGraph에 부착 할 수 있고 키 좌표가 주어지면 데이터 포인트에 고정 될 수있는 항목입니다.
  </ table>
  
  \ 섹션 항목 클리핑 클리핑

  항목은 기본적으로 기본 축 rect로 잘립니다 (축 rect 내부에서만 볼 수 있음).
  해당 축 rect 외부에서 항목을 표시하려면 \ ref setClipToAxisRect를 통한 클리핑을 사용하지 않도록 설정하십시오.
  "setClipToAxisRect (false)".

  다른 한편으로는, 아이템을 다른 축 rect에 클립하고 싶은 경우는, 다음과 같이 지정합니다.
  \ ref setClipAxisRect. 항목의이 clipAxisRect 속성은 클리핑 동작에만 사용됩니다.
  원칙적으로 항목이 위치를 통해 연결될 수있는 좌표 축과는 독립적입니다.
  멤버 (\ ref QCPItemPosition :: setAxes). 그러나, 클리핑을위한 축 rect
  또한 항목 위치에 사용 된 축을 포함합니다.
  
  \ section items-using 항목 사용
  
  먼저 사용할 항목을 인스턴스화하고 플롯에 추가합니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpitemline-creation-1
  기본적으로 항목의 위치는 플롯의 x 축과 y 축에 바인딩됩니다. 그래서 우리는 단지
  라인을 시작 / 끝내야 할 좌표를 설정하십시오 :
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpitemline-creation-2
  선을 플롯 좌표로 배치하고 다른 좌표계로 배치하지 않으려면,
  예를 들어 QCustomPlot 표면의 절대 픽셀 위치를 변경하려면 다음과 같이 위치 유형을 변경해야합니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpitemline-creation-3
  그런 다음 우리는이 시간을 픽셀 단위로 설정할 수 있습니다 :
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpitemline-creation-4
  축 rect에 대한 자르기를 비활성화하여 전체 QCustomPlot에 선을 표시 할 수 있습니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpitemline-creation-5
  
  보다 진보 된 플롯의 경우, X / Y마다 다른 유형 및 상위 앵커를 설정할 수도 있습니다
  \ ref QCPItemPosition :: setTypeX 또는 \ ref를 사용하여 항목 위치의 좌표
  QCPItemPosition :: setParentAnchorX. 자세한 내용은 \ ref QCPItemPosition의 설명서를 참조하십시오.
  
  \ section items-subclassing 자신의 항목 만들기
  
  자체 항목을 만들려면 QCPAbstractItem의 하위 클래스를 구현해야합니다. 이들은 순수하다.
  가상 함수를 구현하려면 다음을 구현해야합니다.
  \ li \ ref select test
  \ li \ ref 끌기
  
  필요한 기능에 대한 설명서를 참조하십시오.
  
  \ subsection items-positioning 항목 배치 허용
  
  언급 한 바와 같이 항목 위치는 QCPItemPosition 멤버로 표시됩니다. 새 항목을 다음과 같이 가정 해 봅시다.
  그 위치에 하나의 점만 가져야합니다 (두 개는 정사각형 또는 다각형과 같이 반대). 그런 다음
  다음과 같이 QCPItemPosition 유형의 공용 멤버입니다.
  
  \ code QCPItemPosition * const myPosition; \ endcode
  
  const는 포인터 자체가 새 항목의 사용자 (QCPItemPosition
  인스턴스가 가리키는 인스턴스, 물론 수정할 수 있습니다).
  이 포인터의 초기화는 \ ref createPosition 함수로 쉽게 할 수 있습니다. 그냥 지정하십시오.
  이 함수의 반환 값은 해당 항목의 생성자에있는 각 QCPItemPosition입니다. \ ref createPosition
  위치의 이름 인 문자열을 취하며 일반적으로 변수 이름과 동일합니다.
  예를 들어 QCPItemExample의 생성자는 다음과 같습니다.
  
  \암호
  QCPItemExample :: QCPItemExample (QCustomPlot * parentPlot) :
    QCPAbstractItem (parentPlot),
    myPosition (createPosition ( "myPosition"))
  {
    // 다른 생성자 코드
  }
  \ endcode
  
  \ subsection items-drawing 그리기 기능
  
  항목에 시각적 표현을 부여하려면 \ ref draw 함수를 다시 구현하고 전달 된 항목을 사용하십시오.
  항목을 그리는 QCPPainter. 픽셀 좌표에서 항목 위치를
  \ ref QCPItemPosition :: pixelPosition을 통해 위치 멤버 (들).

  성능을 최적화하려면 먼저 경계 사각형을 계산해야합니다 (펜을 가져가는 것을 잊지 마십시오.
  너비를 고려함), \ ref clipRect와 교차하는지 확인하고 항목을 모두 그리십시오
  만일이 경우라면.
  
  \ subsection items-selection selectTest 함수
  
  \ ref selectTest 함수를 구현하면 helpers \ ref를 사용할 수 있습니다.
  QCPVector2D :: distanceSquaredToLine 및 \ ref rectDistance입니다. 이것들과 함께,
  선택 테스트는 대부분의 항목에서 훨씬 간단 해집니다. \ ref의 문서를 참조하십시오.
  함수 매개 변수의 의미와 함수가 반환해야하는 대상에 대한 selectTest.
  
  \ subsection anchors 앵커 제공
  
  앵커 (QCPItemAnchor)를 제공하는 것은 위치 추가와 같이 시작됩니다. 먼저 공개를 만듭니다.
  회원
  
  \ code QCPItemAnchor * const bottom; \ endcode

  \ ref createAnchor 함수를 사용하여 생성자에 이름을 지정하고
  anchor id (항목의 모든 앵커를 열거하는 정수입니다.이 항목에 대한 고유 한 열거 형을 만들 수 있습니다).
  앵커는 항목의 위치에 관계없이 어느 위치 에나 배치 할 수 있으므로 항목에
  모든 앵커의 위치를 ​​\ ref anchorPixelPosition (int
  anchorId) 함수를 호출합니다.
  
  본질적으로 QCPItemAnchor는 그 자체가 귀하의 아이템에 픽셀을 요청하는 중개자 일뿐입니다
  앵커에 붙어있는 것이 좌표를 알아야 할 때 위치.
*/

/* start of documentation of inline functions */
/* 인라인 함수의 문서화 시작 */

/*! \fn QList<QCPItemPosition*> QCPAbstractItem::positions() const
  
  Returns all positions of the item in a list.
  
  \see anchors, position
*/
/*! \ fn QList <QCPItemPosition *> QCPAbstractItem :: positions () const
  
  목록에있는 항목의 모든 위치를 반환합니다.
  
  \ 앵커, 위치보기
*/

/*! \fn QList<QCPItemAnchor*> QCPAbstractItem::anchors() const
  
  Returns all anchors of the item in a list. Note that since a position (QCPItemPosition) is always
  also an anchor, the list will also contain the positions of this item.
  
  \see positions, anchor
*/
/*! \ fn QList <QCPItemAnchor *> QCPAbstractItem :: anchors () const
  
  목록에있는 항목의 모든 앵커를 반환합니다. 위치 (QCPItemPosition)는 항상
  앵커도 목록에이 항목의 위치가 포함됩니다.
  
  \ 위치, 앵커보기
*/

/* end of documentation of inline functions */
/* start documentation of pure virtual functions */
/* 인라인 함수의 문서 끝 */
/* 순수 가상 함수의 시작 문서 */

/*! \fn void QCPAbstractItem::draw(QCPPainter *painter) = 0
  \internal
  
  Draws this item with the provided \a painter.
  
  The cliprect of the provided painter is set to the rect returned by \ref clipRect before this
  function is called. The clipRect depends on the clipping settings defined by \ref
  setClipToAxisRect and \ref setClipAxisRect.
*/
/*! \ fn void QCPAbstractItem :: draw (QCPPainter * painter) = 0
  \내부의
  
  제공된 화가를 사용하여이 항목을 그립니다.
  
  제공된 painter의 cliprect는 \ ref clipRect에 의해 반환 된 rect로 설정됩니다.
  함수가 호출됩니다. clipRect는 \ ref에 정의 된 클리핑 세팅에 의존한다.
  setClipToAxisRect 및 \ ref setClipAxisRect입니다.
*/

/* end documentation of pure virtual functions */
/* start documentation of signals */
/* 순수 가상 함수의 끝 문서 */
/* 신호의 문서화를 시작한다. */


/*! \fn void QCPAbstractItem::selectionChanged(bool selected)
  This signal is emitted when the selection state of this item has changed, either by user interaction
  or by a direct call to \ref setSelected.
*/
/*! \ fn void QCPAbstractItem :: selectionChanged (bool 선택됨)
  이 신호는이 항목의 선택 상태가 사용자 상호 작용에 의해 변경되면 방출됩니다.
  또는 \ ref setSelected에 대한 직접 호출에 의해 호출됩니다.
*/

/* end documentation of signals */
/* 신호의 끝 문서 */

/*!
  Base class constructor which initializes base class members.
*/
/*!
  기본 클래스 멤버를 초기화하는 기본 클래스 생성자입니다.
*/
QCPAbstractItem::QCPAbstractItem(QCustomPlot *parentPlot) :
  QCPLayerable(parentPlot),
  mClipToAxisRect(false),
  mSelectable(true),
  mSelected(false)
{
  parentPlot->registerItem(this);
  
  QList<QCPAxisRect*> rects = parentPlot->axisRects();
  if (rects.size() > 0)
  {
    setClipToAxisRect(true);
    setClipAxisRect(rects.first());
  }
}

QCPAbstractItem::~QCPAbstractItem()
{
  // don't delete mPositions because every position is also an anchor and thus in mAnchors
  // 모든 위치가 앵커이기 때문에 mPosition을 삭제하지 않습니다. 따라서 mAnchors에 있습니다.
  qDeleteAll(mAnchors);
}

/* can't make this a header inline function, because QPointer breaks with forward declared types, see QTBUG-29588 */
/* QPointer가 앞으로 선언 된 유형으로 중단되기 때문에 이것을 헤더 인라인 함수로 만들 수 없습니다. QTBUG-29588 */
QCPAxisRect *QCPAbstractItem::clipAxisRect() const
{
  return mClipAxisRect.data();
}

/*!
  Sets whether the item shall be clipped to an axis rect or whether it shall be visible on the
  entire QCustomPlot. The axis rect can be set with \ref setClipAxisRect.
  
  \see setClipAxisRect
*/
/*!
  아이템을 축 rect에 클리핑할지, 또는 아이템을 축 rect에 표시할지 어떨지를 설정합니다.
  전체 QCustomPlot. 축 rect는 \ ref setClipAxisRect로 설정할 수 있습니다.
  
  \ setClipAxisRect 참조
*/
void QCPAbstractItem::setClipToAxisRect(bool clip)
{
  mClipToAxisRect = clip;
  if (mClipToAxisRect)
    setParentLayerable(mClipAxisRect.data());
}

/*!
  Sets the clip axis rect. It defines the rect that will be used to clip the item when \ref
  setClipToAxisRect is set to true.
  
  \see setClipToAxisRect
*/
/*!
  클립 축 rect를 설정합니다. \ ref가있을 때 항목을 클립하는 데 사용할 rect를 정의합니다.
  setClipToAxisRect가 true로 설정됩니다.
  
  \ setClipToAxisRect 참조
*/
void QCPAbstractItem::setClipAxisRect(QCPAxisRect *rect)
{
  mClipAxisRect = rect;
  if (mClipToAxisRect)
    setParentLayerable(mClipAxisRect.data());
}

/*!
  Sets whether the user can (de-)select this item by clicking on the QCustomPlot surface.
  (When \ref QCustomPlot::setInteractions contains QCustomPlot::iSelectItems.)
  
  However, even when \a selectable was set to false, it is possible to set the selection manually,
  by calling \ref setSelected.
  
  \see QCustomPlot::setInteractions, setSelected
*/
/*!
  사용자가 QCustomPlot 표면을 클릭하여이 항목을 선택할 수 있는지 여부를 설정합니다.
  (\ ref QCustomPlot :: setInteractions에는 QCustomPlot :: iSelectItems가 포함됩니다.)
  
  그러나 \ a selectable이 false로 설정된 경우에도 수동으로 선택 항목을 설정할 수 있지만,
  \ ref setSelected를 호출하여.
  
  \ QCustomPlot :: setInteractions, setSelected를 참조하십시오.
*/
void QCPAbstractItem::setSelectable(bool selectable)
{
  if (mSelectable != selectable)
  {
    mSelectable = selectable;
    emit selectableChanged(mSelectable);
  }
}

/*!
  Sets whether this item is selected or not. When selected, it might use a different visual
  appearance (e.g. pen and brush), this depends on the specific item though.

  The entire selection mechanism for items is handled automatically when \ref
  QCustomPlot::setInteractions contains QCustomPlot::iSelectItems. You only need to call this
  function when you wish to change the selection state manually.
  
  This function can change the selection state even when \ref setSelectable was set to false.
  
  emits the \ref selectionChanged signal when \a selected is different from the previous selection state.
  
  \see setSelectable, selectTest
*/
/*!
  이 항목의 선택 여부를 설정합니다. 선택하면 다른 비주얼을 사용할 수 있습니다.
  외관 (예 : 펜 및 브러쉬), 이것은 특정 항목에 따라 다릅니다.

  항목에 대한 전체 선택 메커니즘은 \ ref
  QCustomPlot :: setInteractions에는 QCustomPlot :: iSelectItems가 포함됩니다. 너는 이것을 단지 부르면된다.
  기능을 사용하여 선택 상태를 수동으로 변경할 수 있습니다.
  
  이 함수는 \ ref setSelectable이 false로 설정된 경우에도 선택 상태를 변경할 수 있습니다.
  
  선택이 이전 선택 상태와 다른 경우 \ ref selectionChanged 신호를 내 보냅니다.
  
  \ setSelectable 참조, selectTest
*/
void QCPAbstractItem::setSelected(bool selected)
{
  if (mSelected != selected)
  {
    mSelected = selected;
    emit selectionChanged(mSelected);
  }
}

/*!
  Returns the QCPItemPosition with the specified \a name. If this item doesn't have a position by
  that name, returns 0.
  
  This function provides an alternative way to access item positions. Normally, you access
  positions direcly by their member pointers (which typically have the same variable name as \a
  name).
  
  \see positions, anchor
*/
/*!
  지정된 \ a 이름을 가진 QCPItemPosition을 리턴합니다. 이 항목에 의해 위치가없는 경우
  그 이름은 0을 반환합니다.
  
  이 기능은 항목 위치에 액세스하는 다른 방법을 제공합니다. 일반적으로 액세스 할 수 있습니다.
  멤버 포인터 (일반적으로 \ a와 같은 변수 이름을가집니다.
  이름).
  
  \ 위치, 앵커보기
*/
QCPItemPosition *QCPAbstractItem::position(const QString &name) const
{
  for (int i=0; i<mPositions.size(); ++i)
  {
    if (mPositions.at(i)->name() == name)
      return mPositions.at(i);
  }
  qDebug() << Q_FUNC_INFO << "position with name not found:" << name;
  return 0;
}

/*!
  Returns the QCPItemAnchor with the specified \a name. If this item doesn't have an anchor by
  that name, returns 0.
  
  This function provides an alternative way to access item anchors. Normally, you access
  anchors direcly by their member pointers (which typically have the same variable name as \a
  name).
  
  \see anchors, position
*/
/*!
  지정된 \ a 이름을 가진 QCPItemAnchor를 리턴합니다. 이 항목에 의해 앵커가없는 경우
  그 이름은 0을 반환합니다.
  
  이 함수는 항목 앵커에 액세스하는 다른 방법을 제공합니다. 일반적으로 액세스 할 수 있습니다.
  멤버 포인터 (일반적으로 \ a와 같은 변수 이름을 가짐)로 direcly 앵커합니다.
  이름).
  
  \ 앵커, 위치보기
*/
QCPItemAnchor *QCPAbstractItem::anchor(const QString &name) const
{
  for (int i=0; i<mAnchors.size(); ++i)
  {
    if (mAnchors.at(i)->name() == name)
      return mAnchors.at(i);
  }
  qDebug() << Q_FUNC_INFO << "anchor with name not found:" << name;
  return 0;
}

/*!
  Returns whether this item has an anchor with the specified \a name.
  
  Note that you can check for positions with this function, too. This is because every position is
  also an anchor (QCPItemPosition inherits from QCPItemAnchor).
  
  \see anchor, position
*/
/*!
  이 항목에 지정된 \ a 이름의 앵커가 있는지 여부를 반환합니다.
  
  이 기능으로 위치를 확인할 수도 있습니다. 모든 위치가
  또한 앵커 (QCPItemPosition은 QCPItemAnchor를 상속받습니다).
  
  \ 앵커, 위치보기
*/
bool QCPAbstractItem::hasAnchor(const QString &name) const
{
  for (int i=0; i<mAnchors.size(); ++i)
  {
    if (mAnchors.at(i)->name() == name)
      return true;
  }
  return false;
}

/*! \internal
  
  Returns the rect the visual representation of this item is clipped to. This depends on the
  current setting of \ref setClipToAxisRect as well as the axis rect set with \ref setClipAxisRect.
  
  If the item is not clipped to an axis rect, QCustomPlot's viewport rect is returned.
  
  \see draw
*/
/*! \내부의
  
  이 아이템의 시각 표현이 잘리는 부분을 돌려줍니다. 이것은
  \ ref setClipToAxisRect의 현재 설정과 \ ref setClipAxisRect로 설정된 축 rect.
  
  항목이 축 rect에 잘리지 않으면 QCustomPlot의 뷰포트 rect가 반환됩니다.
  
  \ 그림 그리기
*/
QRect QCPAbstractItem::clipRect() const
{
  if (mClipToAxisRect && mClipAxisRect)
    return mClipAxisRect.data()->rect();
  else
    return mParentPlot->viewport();
}

/*! \internal

  A convenience function to easily set the QPainter::Antialiased hint on the provided \a painter
  before drawing item lines.

  This is the antialiasing state the painter passed to the \ref draw method is in by default.
  
  This function takes into account the local setting of the antialiasing flag as well as the
  overrides set with \ref QCustomPlot::setAntialiasedElements and \ref
  QCustomPlot::setNotAntialiasedElements.
  
  \see setAntialiased
*/
/*! \내부의

  제공된 Painter에서 QPainter :: Antialiased 힌트를 쉽게 설정할 수있는 편리한 함수입니다.
  항목 행을 그리기 전에

  화가가 \ ref draw 메서드에 전달한 앤티 엘리 어싱 상태입니다.
  
  이 함수는 앤티 엘리 어싱 플래그의 로컬 설정은 물론
  \ ref QCustomPlot :: setAntialiasedElements 및 \ ref를 사용하여 설정 한 재정의
  QCustomPlot :: setNotAntialiasedElements.
  
  \ setAntialiased 참조
*/
void QCPAbstractItem::applyDefaultAntialiasingHint(QCPPainter *painter) const
{
  applyAntialiasingHint(painter, mAntialiased, QCP::aeItems);
}

/*! \internal

  A convenience function which returns the selectTest value for a specified \a rect and a specified
  click position \a pos. \a filledRect defines whether a click inside the rect should also be
  considered a hit or whether only the rect border is sensitive to hits.
  
  This function may be used to help with the implementation of the \ref selectTest function for
  specific items.
  
  For example, if your item consists of four rects, call this function four times, once for each
  rect, in your \ref selectTest reimplementation. Finally, return the minimum (non -1) of all four
  returned values.
*/
/*! \내부의

  지정된 \ rect 및 select에 대한 selectTest 값을 반환하는 편리한 함수입니다.
  위치 \ a 위치를 클릭하십시오. \ filledRect는 rect 내부의 클릭도 있어야하는지 여부를 정의합니다.
  히트를 고려했거나 직사각형 경계 만 히트에 민감한 지 여부를 고려해야합니다.
  
  이 함수는 \ ref selectTest 함수의 구현을 돕기 위해 사용될 수있다.
  특정 항목.
  
  예를 들어 항목이 네 개의 rect로 구성된 경우이 함수를 네 번
  rect, \ ref selectTest reimplementation에서. 마지막으로 네 개 모두의 최소값 (-1이 아닌 값)을 반환합니다.
  반환 값.
*/
double QCPAbstractItem::rectDistance(const QRectF &rect, const QPointF &pos, bool filledRect) const
{
  double result = -1;

  // distance to border:
  // 경계와의 거리 :
  QList<QLineF> lines;
  lines << QLineF(rect.topLeft(), rect.topRight()) << QLineF(rect.bottomLeft(), rect.bottomRight())
        << QLineF(rect.topLeft(), rect.bottomLeft()) << QLineF(rect.topRight(), rect.bottomRight());
  double minDistSqr = std::numeric_limits<double>::max();
  for (int i=0; i<lines.size(); ++i)
  {
    double distSqr = QCPVector2D(pos).distanceSquaredToLine(lines.at(i).p1(), lines.at(i).p2());
    if (distSqr < minDistSqr)
      minDistSqr = distSqr;
  }
  result = qSqrt(minDistSqr);
  
  // filled rect, allow click inside to count as hit:
  // rect를 채우면 inside를 클릭하여 계산됩니다 :
  if (filledRect && result > mParentPlot->selectionTolerance()*0.99)
  {
    if (rect.contains(pos))
      result = mParentPlot->selectionTolerance()*0.99;
  }
  return result;
}

/*! \internal

  Returns the pixel position of the anchor with Id \a anchorId. This function must be reimplemented in
  item subclasses if they want to provide anchors (QCPItemAnchor).
  
  For example, if the item has two anchors with id 0 and 1, this function takes one of these anchor
  ids and returns the respective pixel points of the specified anchor.
  
  \see createAnchor
*/
/*! \내부의

  Id \ a anchorId를 가지는 앵커의 픽셀 위치를 반환합니다. 이 함수는에서 다시 구현해야합니다.
  항목 하위 클래스가 앵커 (QCPItemAnchor)를 제공하려는 경우
  
  예를 들어 항목에 ID가 0과 1 인 앵커가 두 개있는 경우이 함수는이 앵커 중 하나를 사용합니다.
  ids를 반환하고 지정된 앵커의 각 픽셀 점을 반환합니다.
  
  \ create createAnchor를 참조하십시오.
*/
QPointF QCPAbstractItem::anchorPixelPosition(int anchorId) const
{
  qDebug() << Q_FUNC_INFO << "called on item which shouldn't have any anchors (this method not reimplemented). anchorId" << anchorId;
  return QPointF();
}

/*! \internal

  Creates a QCPItemPosition, registers it with this item and returns a pointer to it. The specified
  \a name must be a unique string that is usually identical to the variable name of the position
  member (This is needed to provide the name-based \ref position access to positions).
  
  Don't delete positions created by this function manually, as the item will take care of it.
  
  Use this function in the constructor (initialization list) of the specific item subclass to
  create each position member. Don't create QCPItemPositions with \b new yourself, because they
  won't be registered with the item properly.
  
  \see createAnchor
*/
/*! \내부의

  QCPItemPosition을 만들어이 항목에 등록하고 포인터를 반환합니다. 지정된
  \ 이름은 일반적으로 위치의 변수 이름과 동일한 고유 한 문자열이어야합니다.
  member (위치에 대한 이름 기반 \ ref 위치 액세스를 제공해야합니다.)
  
  아이템이 그것을 처리 할 때 수동으로이 함수로 생성 된 위치를 삭제하지 마십시오.
  
  특정 항목 하위 클래스의 생성자 (초기화 목록)에서이 함수를 사용하여
  각 위치 구성원을 작성하십시오. 새로운 \ b와 함께 QCPItemPosition을 만들지 마십시오.
  항목에 제대로 등록되지 않습니다.
  
  \ create createAnchor를 참조하십시오.
*/
QCPItemPosition *QCPAbstractItem::createPosition(const QString &name)
{
  if (hasAnchor(name))
    qDebug() << Q_FUNC_INFO << "anchor/position with name exists already:" << name;
  QCPItemPosition *newPosition = new QCPItemPosition(mParentPlot, this, name);
  mPositions.append(newPosition);
  mAnchors.append(newPosition); // every position is also an anchor
  newPosition->setAxes(mParentPlot->xAxis, mParentPlot->yAxis);
  newPosition->setType(QCPItemPosition::ptPlotCoords);
  if (mParentPlot->axisRect())
    newPosition->setAxisRect(mParentPlot->axisRect());
  newPosition->setCoords(0, 0);
  return newPosition;
}

/*! \internal

  Creates a QCPItemAnchor, registers it with this item and returns a pointer to it. The specified
  \a name must be a unique string that is usually identical to the variable name of the anchor
  member (This is needed to provide the name based \ref anchor access to anchors).
  
  The \a anchorId must be a number identifying the created anchor. It is recommended to create an
  enum (e.g. "AnchorIndex") for this on each item that uses anchors. This id is used by the anchor
  to identify itself when it calls QCPAbstractItem::anchorPixelPosition. That function then returns
  the correct pixel coordinates for the passed anchor id.
  
  Don't delete anchors created by this function manually, as the item will take care of it.
  
  Use this function in the constructor (initialization list) of the specific item subclass to
  create each anchor member. Don't create QCPItemAnchors with \b new yourself, because then they
  won't be registered with the item properly.
  
  \see createPosition
*/
/*! \내부의

  QCPItemAnchor를 만들고이 항목에 등록하고 포인터를 반환합니다. 지정된
  \ 이름은 일반적으로 앵커의 변수 이름과 동일한 고유 한 문자열이어야합니다.
  member (앵커에 대한 이름 기반 \ ref 앵커 액세스를 제공하는 데 필요합니다.)
  
  \ anchorId는 생성 된 앵커를 식별하는 숫자 여야합니다. 생성하는 것이 좋습니다.
  enum (예 : "AnchorIndex") 앵커를 사용하는 각 항목에 대한이. 이 ID는 앵커에 의해 사용됩니다.
  그것이 QCPAbstractItem :: anchorPixelPosition을 호출 할 때 자신을 식별한다. 그 함수는 다음을 반환합니다.
  건네받은 엥커 아이디의 올바른 픽셀 좌표
  
  이 함수가 생성 한 앵커는 항목이 수동으로 삭제하므로 삭제하지 마십시오.
  
  특정 항목 하위 클래스의 생성자 (초기화 목록)에서이 함수를 사용하여
  각 앵커 구성원을 만듭니다. \ b 새로운 QCPItemAnchors를 직접 만들지 마십시오.
  항목에 제대로 등록되지 않습니다.
  
  \ see createPosition
*/
QCPItemAnchor *QCPAbstractItem::createAnchor(const QString &name, int anchorId)
{
  if (hasAnchor(name))
    qDebug() << Q_FUNC_INFO << "anchor/position with name exists already:" << name;
  QCPItemAnchor *newAnchor = new QCPItemAnchor(mParentPlot, this, name, anchorId);
  mAnchors.append(newAnchor);
  return newAnchor;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPAbstractItem::selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)
{
  Q_UNUSED(event)
  Q_UNUSED(details)
  if (mSelectable)
  {
    bool selBefore = mSelected;
    setSelected(additive ? !mSelected : true);
    if (selectionStateChanged)
      *selectionStateChanged = mSelected != selBefore;
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPAbstractItem::deselectEvent(bool *selectionStateChanged)
{
  if (mSelectable)
  {
    bool selBefore = mSelected;
    setSelected(false);
    if (selectionStateChanged)
      *selectionStateChanged = mSelected != selBefore;
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCP::Interaction QCPAbstractItem::selectionCategory() const
{
  return QCP::iSelectItems;
}
/* end of 'src/item.cpp' */


/* including file 'src/core.cpp', size 125037                                */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / item.cpp'의 끝 */


/* 파일 'src / core.cpp'포함, 크기 125037 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCustomPlot
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCustomPlot
  
  \brief The central class of the library. This is the QWidget which displays the plot and
  interacts with the user.
  
  For tutorials on how to use QCustomPlot, see the website\n
  http://www.qcustomplot.com/
*/
/*! \ class QCustomPlot
  
  \ brief 라이브러리의 중앙 클래스. 이것은 플롯을 표시하는 QWidget이며
  사용자와 상호 작용합니다.
  
  QCustomPlot 사용법에 대한 자습서는 웹 사이트를 참조하십시오. \ n
  http://www.qcustomplot.com/
*/

/* start of documentation of inline functions */
/* 인라인 함수의 문서화 시작 */

/*! \fn QCPSelectionRect *QCustomPlot::selectionRect() const
  
  Allows access to the currently used QCPSelectionRect instance (or subclass thereof), that is used
  to handle and draw selection rect interactions (see \ref setSelectionRectMode).
  
  \see setSelectionRect
*/
/*! \ fn QCPSelectionRect * QCustomPlot :: selectionRect () const
  
  사용 된 현재 사용중인 QCPSelectionRect 인스턴스 (또는 그 하위 클래스)에 대한 액세스를 허용합니다.
  선택 사각형 상호 작용을 처리하고 그립니다 (\ ref setSelectionRectMode 참조).
  
  \ see setSelectionRect
*/

/*! \fn QCPLayoutGrid *QCustomPlot::plotLayout() const
  
  Returns the top level layout of this QCustomPlot instance. It is a \ref QCPLayoutGrid, initially containing just
  one cell with the main QCPAxisRect inside.
*/
/*! \ fn QCPLayoutGrid * QCustomPlot :: plotLayout () const
  
  이 QCustomPlot 인스턴스의 최상위 레이아웃을 반환합니다. \ ref QCPLayoutGrid입니다. 처음에는 그냥
  내부에 메인 QCPAxisRect가있는 하나의 셀.
*/

/* end of documentation of inline functions */
/* start of documentation of signals */
/* 인라인 함수의 문서 끝 */
/* 신호 문서화 */

/*! \fn void QCustomPlot::mouseDoubleClick(QMouseEvent *event)

  This signal is emitted when the QCustomPlot receives a mouse double click event.
*/
/*! \ fn void QCustomPlot :: mouseDoubleClick (QMouseEvent * event)

  이 신호는 QCustomPlot이 마우스 두 번 클릭 이벤트를받을 때 생성됩니다.
*/

/*! \fn void QCustomPlot::mousePress(QMouseEvent *event)

  This signal is emitted when the QCustomPlot receives a mouse press event.
  
  It is emitted before QCustomPlot handles any other mechanism like range dragging. So a slot
  connected to this signal can still influence the behaviour e.g. with \ref QCPAxisRect::setRangeDrag or \ref
  QCPAxisRect::setRangeDragAxes.
*/
/*! \ fn void QCustomPlot :: mousePress (QMouseEvent * event)

  QCustomPlot이 마우스 누르기 이벤트를 받으면이 신호가 방출됩니다.
  
  QCustomPlot이 범위 드래그와 같은 다른 메커니즘을 처리하기 전에이 컨트롤이 표시됩니다. 그래서 슬롯
  이 신호에 연결된 것은 여전히 ​​\ ref QCPAxisRect :: setRangeDrag 또는 \ ref를 사용하여 동작에 영향을 줄 수 있습니다
  QCPAxisRect :: setRangeDragAxes.
*/

/*! \fn void QCustomPlot::mouseMove(QMouseEvent *event)

  This signal is emitted when the QCustomPlot receives a mouse move event.
  
  It is emitted before QCustomPlot handles any other mechanism like range dragging. So a slot
  connected to this signal can still influence the behaviour e.g. with \ref QCPAxisRect::setRangeDrag or \ref
  QCPAxisRect::setRangeDragAxes.
  
  \warning It is discouraged to change the drag-axes with \ref QCPAxisRect::setRangeDragAxes here,
  because the dragging starting point was saved the moment the mouse was pressed. Thus it only has
  a meaning for the range drag axes that were set at that moment. If you want to change the drag
  axes, consider doing this in the \ref mousePress signal instead.
*/
/*! \ fn void QCustomPlot :: mouseMove (QMouseEvent * event)

  QCustomPlot이 마우스 이동 이벤트를 받으면이 신호가 방출됩니다.
  
  QCustomPlot이 범위 드래그와 같은 다른 메커니즘을 처리하기 전에이 컨트롤이 표시됩니다. 그래서 슬롯
  이 신호에 연결된 것은 여전히 ​​\ ref QCPAxisRect :: setRangeDrag 또는 \ ref를 사용하여 동작에 영향을 줄 수 있습니다
  QCPAxisRect :: setRangeDragAxes.
  
  \ warning 여기서 \ ref QCPAxisRect :: setRangeDragAxes를 사용하여 드래그 축을 변경하는 것은 바람직하지 않습니다.
  드래그 시작점은 마우스를 누른 순간 저장되었습니다. 따라서
  그 순간에 설정된 범위 끌기 축의 의미. 드래그를 변경하려면
  축 대신 \ ref mousePress 신호에서이 작업을 수행하십시오.
*/

/*! \fn void QCustomPlot::mouseRelease(QMouseEvent *event)

  This signal is emitted when the QCustomPlot receives a mouse release event.
  
  It is emitted before QCustomPlot handles any other mechanisms like object selection. So a
  slot connected to this signal can still influence the behaviour e.g. with \ref setInteractions or
  \ref QCPAbstractPlottable::setSelectable.
*/
/*! \ fn void QCustomPlot :: mouseRelease (QMouseEvent * event)

  QCustomPlot이 마우스 놓기 이벤트를 받으면이 신호가 방출됩니다.
  
  QCustomPlot이 개체 선택과 같은 다른 메커니즘을 처리하기 전에이 개체가 방출됩니다. 그래서
  이 신호에 연결된 슬롯은 동작에 영향을 미칠 수 있습니다. 예 : \ ref setInteractions 또는
  \ ref QCPAbstractPlottable :: setSelectable.
*/

/*! \fn void QCustomPlot::mouseWheel(QMouseEvent *event)

  This signal is emitted when the QCustomPlot receives a mouse wheel event.
  
  It is emitted before QCustomPlot handles any other mechanisms like range zooming. So a slot
  connected to this signal can still influence the behaviour e.g. with \ref QCPAxisRect::setRangeZoom, \ref
  QCPAxisRect::setRangeZoomAxes or \ref QCPAxisRect::setRangeZoomFactor.
*/
/*! \ fn void QCustomPlot :: mouseWheel (QMouseEvent * event)

  QCustomPlot이 마우스 휠 이벤트를 받으면이 신호가 방출됩니다.
  
  QCustomPlot이 범위 확대와 같은 다른 메커니즘을 처리하기 전에 표시됩니다. 그래서 슬롯
  공동 여전히 QCPAxisRect :: setRangeZoom REF \로 예를 들면 행동에 영향을 미칠 수있는 신호로 nnected, \ 심판
  QCPAxisRect :: setRangeZoomAxes 또는 \ ref QCPAxisRect :: setRangeZoomFactor.
*/

/*! \fn void QCustomPlot::plottableClick(QCPAbstractPlottable *plottable, int dataIndex, QMouseEvent *event)

  This signal is emitted when a plottable is clicked.

  \a event is the mouse event that caused the click and \a plottable is the plottable that received
  the click. The parameter \a dataIndex indicates the data point that was closest to the click
  position.

  \see plottableDoubleClick
*/
/*! \ fn void QCustomPlot :: plottableClick (QCPAbstractPlottable * plottable, int dataIndex, QMouseEvent * event)

  이 신호는 플롯 테이블을 클릭하면 방출됩니다.

  \ a 이벤트는 클릭을 일으킨 마우스 이벤트이고 \ plottable은 수신 한 플롯 테이블입니다.
  클릭. \ a dataIndex 매개 변수는 클릭에 가장 가까운 데이터 요소를 나타냅니다.
  위치.

  \ plottableDoubleClick 참조
*/

/*! \fn void QCustomPlot::plottableDoubleClick(QCPAbstractPlottable *plottable, int dataIndex, QMouseEvent *event)

  This signal is emitted when a plottable is double clicked.

  \a event is the mouse event that caused the click and \a plottable is the plottable that received
  the click. The parameter \a dataIndex indicates the data point that was closest to the click
  position.

  \see plottableClick
*/
/*! \ fn void QCustomPlot :: plottableDoubleClick (QCPAbstractPlottable * plottable, int dataIndex, QMouseEvent * event)

  이 신호는 플롯 테이블을 두 번 클릭하면 방출됩니다.

  \ a 이벤트는 클릭을 일으킨 마우스 이벤트이고 \ plottable은 수신 한 플롯 테이블입니다.
  클릭. \ a dataIndex 매개 변수는 클릭에 가장 가까운 데이터 요소를 나타냅니다.
  위치.

  \ see plottableClick
*/

/*! \fn void QCustomPlot::itemClick(QCPAbstractItem *item, QMouseEvent *event)
  
  This signal is emitted when an item is clicked.

  \a event is the mouse event that caused the click and \a item is the item that received the
  click.
  
  \see itemDoubleClick
*/
/*! \ fn void QCustomPlot :: itemClick (QCPAbstractItem * item, QMouseEvent * event)
  
  이 신호는 항목을 클릭하면 방출됩니다.

  \ a 이벤트는 클릭을 유발 한 마우스 이벤트이고 \ item은 해당 이벤트를 수신 한 항목입니다.
  딸깍 하는 소리.
  
  \ see itemDoubleClick
*/

/*! \fn void QCustomPlot::itemDoubleClick(QCPAbstractItem *item, QMouseEvent *event)
  
  This signal is emitted when an item is double clicked.
  
  \a event is the mouse event that caused the click and \a item is the item that received the
  click.
  
  \see itemClick
*/
/*! \ fn void QCustomPlot :: itemDoubleClick (QCPAbstractItem * item, QMouseEvent * event)
  
  이 신호는 항목을 두 번 클릭하면 방출됩니다.
  
  \ a 이벤트는 클릭을 유발 한 마우스 이벤트이고 \ item은 해당 이벤트를 수신 한 항목입니다.
  딸깍 하는 소리.
  
  \ see itemClick
*/

/*! \fn void QCustomPlot::axisClick(QCPAxis *axis, QCPAxis::SelectablePart part, QMouseEvent *event)
  
  This signal is emitted when an axis is clicked.
  
  \a event is the mouse event that caused the click, \a axis is the axis that received the click and
  \a part indicates the part of the axis that was clicked.
  
  \see axisDoubleClick
*/
/*! \ fn void QCustomPlot :: axisClick (QCPAxis * 축, QCPAxis :: SelectablePart 부분, QMouseEvent * 이벤트)
  
  이 신호는 축을 클릭하면 방출됩니다.
  
  \ a 이벤트는 클릭을 일으킨 마우스 이벤트이고 \ a 축은 클릭을받은 축이며
  \ a 부분은 클릭 된 축 부분을 나타냅니다.
  
  \ see axisDoubleClick
*/

/*! \fn void QCustomPlot::axisDoubleClick(QCPAxis *axis, QCPAxis::SelectablePart part, QMouseEvent *event)

  This signal is emitted when an axis is double clicked.
  
  \a event is the mouse event that caused the click, \a axis is the axis that received the click and
  \a part indicates the part of the axis that was clicked.
  
  \see axisClick
*/

/*! \fn void QCustomPlot::legendClick(QCPLegend *legend, QCPAbstractLegendItem *item, QMouseEvent *event)

  This signal is emitted when a legend (item) is clicked.
  
  \a event is the mouse event that caused the click, \a legend is the legend that received the
  click and \a item is the legend item that received the click. If only the legend and no item is
  clicked, \a item is 0. This happens for a click inside the legend padding or the space between
  two items.
  
  \see legendDoubleClick
*/
/*! \ fn void QCustomPlot :: axisDoubleClick (QCPAxis * 축, QCPAxis :: SelectablePart 부분, QMouseEvent * 이벤트)

  이 신호는 축을 두 번 클릭하면 방출됩니다.
  
  \ a 이벤트는 클릭을 일으킨 마우스 이벤트이고 \ a 축은 클릭을받은 축이며
  \ a 부분은 클릭 된 축 부분을 나타냅니다.
  
  \ see axisClick
*/

/*! \fn void QCustomPlot::legendDoubleClick(QCPLegend *legend,  QCPAbstractLegendItem *item, QMouseEvent *event)

  This signal is emitted when a legend (item) is double clicked.
  
  \a event is the mouse event that caused the click, \a legend is the legend that received the
  click and \a item is the legend item that received the click. If only the legend and no item is
  clicked, \a item is 0. This happens for a click inside the legend padding or the space between
  two items.
  
  \see legendClick
*/
/*! \ fn void QCustomPlot :: legendClick (QCPLegend * 범례, QCPAbstractLegendItem * item, QMouseEvent * 이벤트)

  범례 (항목)를 클릭하면이 신호가 방출됩니다.
  
  \ a 이벤트는 클릭을 일으킨 마우스 이벤트입니다. \ 범례는 해당 범례를 수신 한 범례입니다.
  클릭하고 \ a 항목은 클릭을받은 범례 항목입니다. 범례 만 있고 항목이없는 경우
  클릭하면 항목이 0이됩니다. 이는 범례 패딩이나 클릭 사이의 클릭에 대해 발생합니다.
  두 가지 항목.
  
  \ legendDoubleClick 참조
*/

/*! \fn void QCustomPlot::selectionChangedByUser()
  
  This signal is emitted after the user has changed the selection in the QCustomPlot, e.g. by
  clicking. It is not emitted when the selection state of an object has changed programmatically by
  a direct call to <tt>setSelected()</tt>/<tt>setSelection()</tt> on an object or by calling \ref
  deselectAll.
  
  In addition to this signal, selectable objects also provide individual signals, for example \ref
  QCPAxis::selectionChanged or \ref QCPAbstractPlottable::selectionChanged. Note that those signals
  are emitted even if the selection state is changed programmatically.
  
  See the documentation of \ref setInteractions for details about the selection mechanism.
  
  \see selectedPlottables, selectedGraphs, selectedItems, selectedAxes, selectedLegends
*/
/*! \ fn 무효 QCustomPlot :: selectionChangedByUser ()
  
  이 신호는 사용자가 QCustomPlot에서 선택을 변경 한 후에, 예를 들어
  클릭. 객체의 선택 상태가 프로그래밍 방식으로 변경되었을 때 발생하지 않습니다.
  객체에 setSelected () </ tt> / <tt> setSelection () </ tt>을 직접 호출하거나 \ ref를 호출하여
  선택 취소하십시오.
  
  이 신호 외에도 선택 가능한 객체는 개별 신호를 제공합니다 (예 : \ ref).
  QCPAxis :: selectionChanged 또는 \ ref QCPAbstractPlottable :: selectionChanged입니다. 이 신호들
  프로그래밍에 의해 선택 상태가 변경 되어도 방출됩니다.
  
  선택 메커니즘에 대한 자세한 내용은 \ ref setInteractions 문서를 참조하십시오.
  
  \ selectedPlottables, selectedGraphs, selectedItems, selectedAxes, selectedLegends를 참조하십시오.
*/


/*! \fn void QCustomPlot::beforeReplot()
  
  This signal is emitted immediately before a replot takes place (caused by a call to the slot \ref
  replot).
  
  It is safe to mutually connect the replot slot with this signal on two QCustomPlots to make them
  replot synchronously, it won't cause an infinite recursion.
  
  \see replot, afterReplot
*/
/*! \ fn void QCustomPlot :: beforeReplot ()
  
  이 신호는 replot이 발생하기 직전에 방출됩니다 (슬롯 \ ref에 대한 호출로 인해 발생 함).
  replot).
  
  2 개의 QCustomPlots에서 replot 슬롯을이 신호와 상호 연결하여 안전하게 만들 수 있습니다
  동기식으로 재 복사하면 무한 재귀가 발생하지 않습니다.
  
  \ replot, afterReplot을 보아라.
*/

/*! \fn void QCustomPlot::afterReplot()
  
  This signal is emitted immediately after a replot has taken place (caused by a call to the slot \ref
  replot).
  
  It is safe to mutually connect the replot slot with this signal on two QCustomPlots to make them
  replot synchronously, it won't cause an infinite recursion.
  
  \see replot, beforeReplot
*/
/*! \ fn void QCustomPlot :: afterReplot ()
  
  이 신호는 replot이 발생한 직후에 방출됩니다 (\ ref의 호출로 인해 발생 함).
  replot).
  
  2 개의 QCustomPlots에서 replot 슬롯을이 신호와 상호 연결하여 안전하게 만들 수 있습니다
  동기식으로 재 복사하면 무한 재귀가 발생하지 않습니다.
  
  \ replot, beforeReplot을 보아라.
*/

/* end of documentation of signals */
/* start of documentation of public members */
/* 신호의 문서화 끝 */
/* 공개 회원 문서화 */

/*! \var QCPAxis *QCustomPlot::xAxis

  A pointer to the primary x Axis (bottom) of the main axis rect of the plot.
  
  QCustomPlot offers convenient pointers to the axes (\ref xAxis, \ref yAxis, \ref xAxis2, \ref
  yAxis2) and the \ref legend. They make it very easy working with plots that only have a single
  axis rect and at most one axis at each axis rect side. If you use \link thelayoutsystem the
  layout system\endlink to add multiple axis rects or multiple axes to one side, use the \ref
  QCPAxisRect::axis interface to access the new axes. If one of the four default axes or the
  default legend is removed due to manipulation of the layout system (e.g. by removing the main
  axis rect), the corresponding pointers become 0.
  
  If an axis convenience pointer is currently zero and a new axis rect or a corresponding axis is
  added in the place of the main axis rect, QCustomPlot resets the convenience pointers to the
  according new axes. Similarly the \ref legend convenience pointer will be reset if a legend is
  added after the main legend was removed before.
*/
/*! \ var QCPAxis * QCustomPlot :: xAxis

  플롯의 주축 rect의 기본 x 축 (아래)에 대한 포인터입니다.
  
  QCustomPlot은 축에 편리한 포인터를 제공합니다 (\ ref xAxis, \ ref yAxis, \ ref xAxis2, \ ref
  yAxis2) 및 \ ref 범례. 그것들은 단지 하나의
  각 축 rect 측에서 기껏해야 하나의 축에 위치한다. \ link thelayoutsystem을 사용한다면
  layout system \ endlink 여러 축 rect 또는 여러 축을 한쪽에 추가하려면 \ ref
  QCPAxisRect :: 축 인터페이스를 사용하여 새 축에 액세스합니다. 네 개의 기본 축 중 하나 또는
  기본 범례는 레이아웃 시스템의 조작으로 인해 제거됩니다 (예 : 기본
  축 rect), 해당 포인터가 0이됩니다.
  
  축 편리한 포인터가 현재 0이고 새 축 rect 또는 해당 축이
  QCustomPlot은 주축 rect 대신에 추가 된 편의 포인터를
  새로운 축에 따라. 비슷하게 \ 범례 편의 포인터는 범례가
  주요 전설이 전에 제거 된 후에 추가되었습니다.
*/

/*! \var QCPAxis *QCustomPlot::yAxis

  A pointer to the primary y Axis (left) of the main axis rect of the plot.
  
  QCustomPlot offers convenient pointers to the axes (\ref xAxis, \ref yAxis, \ref xAxis2, \ref
  yAxis2) and the \ref legend. They make it very easy working with plots that only have a single
  axis rect and at most one axis at each axis rect side. If you use \link thelayoutsystem the
  layout system\endlink to add multiple axis rects or multiple axes to one side, use the \ref
  QCPAxisRect::axis interface to access the new axes. If one of the four default axes or the
  default legend is removed due to manipulation of the layout system (e.g. by removing the main
  axis rect), the corresponding pointers become 0.
  
  If an axis convenience pointer is currently zero and a new axis rect or a corresponding axis is
  added in the place of the main axis rect, QCustomPlot resets the convenience pointers to the
  according new axes. Similarly the \ref legend convenience pointer will be reset if a legend is
  added after the main legend was removed before.
*/
/*! \ var QCPAxis * QCustomPlot :: yAxis

  기본 y에 대한 포인터 y 플롯의 주축 rect의 축 (왼쪽).
  
  QCustomPlot은 축에 편리한 포인터를 제공합니다 (\ ref xAxis, \ ref yAxis, \ ref xAxis2, \ ref
  yAxis2) 및 \ ref 범례. 그것들은 단지 하나의
  각 축 rect 측에서 기껏해야 하나의 축에 위치한다. \ link thelayoutsystem을 사용한다면
  layout system \ endlink 여러 축 rect 또는 여러 축을 한쪽에 추가하려면 \ ref
  QCPAxisRect :: 축 인터페이스를 사용하여 새 축에 액세스합니다. 네 개의 기본 축 중 하나 또는
  기본 범례는 레이아웃 시스템의 조작으로 인해 제거됩니다 (예 : 기본
  축 rect), 해당 포인터가 0이됩니다.
  
  축 편리한 포인터가 현재 0이고 새 축 rect 또는 해당 축이
  QCustomPlot은 주축 rect 대신에 추가 된 편의 포인터를
  새로운 축에 따라. 비슷하게 \ 범례 편의 포인터는 범례가
  주요 전설이 전에 제거 된 후에 추가되었습니다.
*/

/*! \var QCPAxis *QCustomPlot::xAxis2

  A pointer to the secondary x Axis (top) of the main axis rect of the plot. Secondary axes are
  invisible by default. Use QCPAxis::setVisible to change this (or use \ref
  QCPAxisRect::setupFullAxesBox).
  
  QCustomPlot offers convenient pointers to the axes (\ref xAxis, \ref yAxis, \ref xAxis2, \ref
  yAxis2) and the \ref legend. They make it very easy working with plots that only have a single
  axis rect and at most one axis at each axis rect side. If you use \link thelayoutsystem the
  layout system\endlink to add multiple axis rects or multiple axes to one side, use the \ref
  QCPAxisRect::axis interface to access the new axes. If one of the four default axes or the
  default legend is removed due to manipulation of the layout system (e.g. by removing the main
  axis rect), the corresponding pointers become 0.
  
  If an axis convenience pointer is currently zero and a new axis rect or a corresponding axis is
  added in the place of the main axis rect, QCustomPlot resets the convenience pointers to the
  according new axes. Similarly the \ref legend convenience pointer will be reset if a legend is
  added after the main legend was removed before.
*/
/*! \ var QCPAxis * QCustomPlot :: xAxis2

  플롯의 주축 rect의 2 차 x 축 (상단)에 대한 포인터입니다. 보조 축은
  기본적으로 표시되지 않습니다. 이 값을 변경하려면 QCPAxis :: setVisible을 사용하십시오 (또는 \ ref
  QCPAxisRect :: setupFullAxesBox).
  
  QCustomPlot은 축에 편리한 포인터를 제공합니다 (\ ref xAxis, \ ref yAxis, \ ref xAxis2, \ ref
  yAxis2) 및 \ ref 범례. 그것들은 단지 하나의
  각 축 rect 측에서 기껏해야 하나의 축에 위치한다. \ link thelayoutsystem을 사용한다면
  layout system \ endlink 여러 축 rect 또는 여러 축을 한쪽에 추가하려면 \ ref
  QCPAxisRect :: 축 인터페이스를 사용하여 새 축에 액세스합니다. 네 개의 기본 축 중 하나 또는
  기본 범례는 레이아웃 시스템의 조작으로 인해 제거됩니다 (예 : 기본
  축 rect), 해당 포인터가 0이됩니다.
  
  축 편리한 포인터가 현재 0이고 새 축 rect 또는 해당 축이
  QCustomPlot은 주축 rect 대신에 추가 된 편의 포인터를
  새로운 축에 따라. 비슷하게 \ 범례 편의 포인터는 범례가
  주요 전설이 전에 제거 된 후에 추가되었습니다.
*/

/*! \var QCPAxis *QCustomPlot::yAxis2

  A pointer to the secondary y Axis (right) of the main axis rect of the plot. Secondary axes are
  invisible by default. Use QCPAxis::setVisible to change this (or use \ref
  QCPAxisRect::setupFullAxesBox).
  
  QCustomPlot offers convenient pointers to the axes (\ref xAxis, \ref yAxis, \ref xAxis2, \ref
  yAxis2) and the \ref legend. They make it very easy working with plots that only have a single
  axis rect and at most one axis at each axis rect side. If you use \link thelayoutsystem the
  layout system\endlink to add multiple axis rects or multiple axes to one side, use the \ref
  QCPAxisRect::axis interface to access the new axes. If one of the four default axes or the
  default legend is removed due to manipulation of the layout system (e.g. by removing the main
  axis rect), the corresponding pointers become 0.
  
  If an axis convenience pointer is currently zero and a new axis rect or a corresponding axis is
  added in the place of the main axis rect, QCustomPlot resets the convenience pointers to the
  according new axes. Similarly the \ref legend convenience pointer will be reset if a legend is
  added after the main legend was removed before.
*/
/*! \ var QCPAxis * QCustomPlot :: yAxis2

  플롯의 주축 rect의 2 차 y 축 (오른쪽)에 대한 포인터입니다. 보조 축은
  기본적으로 표시되지 않습니다. 이 값을 변경하려면 QCPAxis :: setVisible을 사용하십시오 (또는 \ ref
  QCPAxisRect :: setupFullAxesBox).
  
  QCustomPlot은 축에 편리한 포인터를 제공합니다 (\ ref xAxis, \ ref yAxis, \ ref xAxis2, \ ref
  yAxis2) 및 \ ref 범례. 그것들은 단지 하나의
  각 축 rect 측에서 기껏해야 하나의 축에 위치한다. \ link thelayoutsystem을 사용한다면
  layout system \ endlink 여러 축 rect 또는 여러 축을 한쪽에 추가하려면 \ ref
  QCPAxisRect :: 축 인터페이스를 사용하여 새 축에 액세스합니다. 네 개의 기본 축 중 하나 또는
  기본 범례는 레이아웃 시스템의 조작으로 인해 제거됩니다 (예 : 기본
  축 rect), 해당 포인터가 0이됩니다.
  
  축 편리한 포인터가 현재 0이고 새 축 rect 또는 해당 축이
  QCustomPlot은 주축 rect 대신에 추가 된 편의 포인터를
  새로운 축에 따라. 비슷하게 \ 범례 편의 포인터는 범례가
  주요 전설이 전에 제거 된 후에 추가되었습니다.
*/

/*! \var QCPLegend *QCustomPlot::legend

  A pointer to the default legend of the main axis rect. The legend is invisible by default. Use
  QCPLegend::setVisible to change this.
  
  QCustomPlot offers convenient pointers to the axes (\ref xAxis, \ref yAxis, \ref xAxis2, \ref
  yAxis2) and the \ref legend. They make it very easy working with plots that only have a single
  axis rect and at most one axis at each axis rect side. If you use \link thelayoutsystem the
  layout system\endlink to add multiple legends to the plot, use the layout system interface to
  access the new legend. For example, legends can be placed inside an axis rect's \ref
  QCPAxisRect::insetLayout "inset layout", and must then also be accessed via the inset layout. If
  the default legend is removed due to manipulation of the layout system (e.g. by removing the main
  axis rect), the corresponding pointer becomes 0.
  
  If an axis convenience pointer is currently zero and a new axis rect or a corresponding axis is
  added in the place of the main axis rect, QCustomPlot resets the convenience pointers to the
  according new axes. Similarly the \ref legend convenience pointer will be reset if a legend is
  added after the main legend was removed before.
*/
/*! \ var QCPLegend * QCustomPlot :: 범례

  주축 rect의 기본 범례에 대한 포인터입니다. 범례는 기본적으로 보이지 않습니다. 용도
  이것을 변경하려면 QCPLegend :: setVisible.
  
  QCustomPlot은 축에 편리한 포인터를 제공합니다 (\ ref xAxis, \ ref yAxis, \ ref xAxis2, \ ref
  yAxis2) 및 \ ref 범례. 그것들은 단지 하나의
  각 축 rect 측에서 기껏해야 하나의 축에 위치한다. \ link thelayoutsystem을 사용한다면
  레이아웃 시스템 \ endlink를 사용하여 여러 범례를 플롯에 추가하려면 레이아웃 시스템 인터페이스를 사용하여
  새로운 범례에 액세스하십시오. 예를 들어, 범례는 축 rect의 \ ref 내부에 배치 될 수 있습니다.
  QCPAxisRect :: insetLayout "inset layout"으로 변경해야하며 삽입 레이아웃을 통해 액세스해야합니다. 만약
  기본 범례는 레이아웃 시스템의 조작으로 인해 제거됩니다 (예 : 메인
  축 rect), 해당 포인터는 0이됩니다.
  
  축 편리한 포인터가 현재 0이고 새 축 rect 또는 해당 축이
  QCustomPlot은 주축 rect 대신에 추가 된 편의 포인터를
  새로운 축에 따라. 비슷하게 \ 범례 편의 포인터는 범례가
  주요 전설이 전에 제거 된 후에 추가되었습니다.
*/

/* end of documentation of public members */
/* 공개 회원 문서의 끝 */

/*!
  Constructs a QCustomPlot and sets reasonable default values.
*/
/*!
  QCustomPlot을 구축하고 적절한 기본값을 설정합니다.
*/
QCustomPlot::QCustomPlot(QWidget *parent) :
  QWidget(parent),
  xAxis(0),
  yAxis(0),
  xAxis2(0),
  yAxis2(0),
  legend(0),
  mBufferDevicePixelRatio(1.0), // will be adapted to primary screen below
                                // 아래의 기본 화면에 적용됩니다.
  mPlotLayout(0),
  mAutoAddPlottableToLegend(true),
  mAntialiasedElements(QCP::aeNone),
  mNotAntialiasedElements(QCP::aeNone),
  mInteractions(0),
  mSelectionTolerance(8),
  mNoAntialiasingOnDrag(false),
  mBackgroundBrush(Qt::white, Qt::SolidPattern),
  mBackgroundScaled(true),
  mBackgroundScaledMode(Qt::KeepAspectRatioByExpanding),
  mCurrentLayer(0),
  mPlottingHints(QCP::phCacheLabels|QCP::phImmediateRefresh),
  mMultiSelectModifier(Qt::ControlModifier),
  mSelectionRectMode(QCP::srmNone),
  mSelectionRect(0),
  mOpenGl(false),
  mMouseHasMoved(false),
  mMouseEventLayerable(0),
  mMouseSignalLayerable(0),
  mReplotting(false),
  mReplotQueued(false),
  mOpenGlMultisamples(16),
  mOpenGlAntialiasedElementsBackup(QCP::aeNone),
  mOpenGlCacheLabelsBackup(true)
{
  setAttribute(Qt::WA_NoMousePropagation);
  setAttribute(Qt::WA_OpaquePaintEvent);
  setFocusPolicy(Qt::ClickFocus);
  setMouseTracking(true);
  QLocale currentLocale = locale();
  currentLocale.setNumberOptions(QLocale::OmitGroupSeparator);
  setLocale(currentLocale);
#ifdef QCP_DEVICEPIXELRATIO_SUPPORTED
#  ifdef QCP_DEVICEPIXELRATIO_FLOAT
  setBufferDevicePixelRatio(QWidget::devicePixelRatioF());
#  else
  setBufferDevicePixelRatio(QWidget::devicePixelRatio());
#  endif
#endif
  
  mOpenGlAntialiasedElementsBackup = mAntialiasedElements;
  mOpenGlCacheLabelsBackup = mPlottingHints.testFlag(QCP::phCacheLabels);
  // create initial layers:
  // 초기 레이어 만들기 :
  mLayers.append(new QCPLayer(this, QLatin1String("background")));
  mLayers.append(new QCPLayer(this, QLatin1String("grid")));
  mLayers.append(new QCPLayer(this, QLatin1String("main")));
  mLayers.append(new QCPLayer(this, QLatin1String("axes")));
  mLayers.append(new QCPLayer(this, QLatin1String("legend")));
  mLayers.append(new QCPLayer(this, QLatin1String("overlay")));
  updateLayerIndices();
  setCurrentLayer(QLatin1String("main"));
  layer(QLatin1String("overlay"))->setMode(QCPLayer::lmBuffered);
  
  // create initial layout, axis rect and legend:
  // 초기 레이아웃, 축 rect 및 범례 만들기 :
  mPlotLayout = new QCPLayoutGrid;
  mPlotLayout->initializeParentPlot(this);
  mPlotLayout->setParent(this);
// important because if parent is QWidget, QCPLayout::sizeConstraintsChanged will call QWidget::updateGeometry
// 중요 : 부모가 QWidget 인 경우 QCPLayout :: sizeConstraintsChanged는 QWidget :: updateGeometry를 호출하므로 중요합니다.
  mPlotLayout->setLayer(QLatin1String("main"));
  QCPAxisRect *defaultAxisRect = new QCPAxisRect(this, true);
  mPlotLayout->addElement(0, 0, defaultAxisRect);
  xAxis = defaultAxisRect->axis(QCPAxis::atBottom);
  yAxis = defaultAxisRect->axis(QCPAxis::atLeft);
  xAxis2 = defaultAxisRect->axis(QCPAxis::atTop);
  yAxis2 = defaultAxisRect->axis(QCPAxis::atRight);
  legend = new QCPLegend;
  legend->setVisible(false);
  defaultAxisRect->insetLayout()->addElement(legend, Qt::AlignRight|Qt::AlignTop);
  defaultAxisRect->insetLayout()->setMargins(QMargins(12, 12, 12, 12));
  
  defaultAxisRect->setLayer(QLatin1String("background"));
  xAxis->setLayer(QLatin1String("axes"));
  yAxis->setLayer(QLatin1String("axes"));
  xAxis2->setLayer(QLatin1String("axes"));
  yAxis2->setLayer(QLatin1String("axes"));
  xAxis->grid()->setLayer(QLatin1String("grid"));
  yAxis->grid()->setLayer(QLatin1String("grid"));
  xAxis2->grid()->setLayer(QLatin1String("grid"));
  yAxis2->grid()->setLayer(QLatin1String("grid"));
  legend->setLayer(QLatin1String("legend"));
  
  // create selection rect instance:
  // 선택 rect 인스턴스를 만듭니다.
  mSelectionRect = new QCPSelectionRect(this);
  mSelectionRect->setLayer(QLatin1String("overlay"));
  
  setViewport(rect()); // needs to be called after mPlotLayout has been created
                       // mPlotLayout을 만든 후에 호출해야합니다.
  
  replot(rpQueuedReplot);
}

QCustomPlot::~QCustomPlot()
{
  clearPlottables();
  clearItems();

  if (mPlotLayout)
  {
    delete mPlotLayout;
    mPlotLayout = 0;
  }
  
  mCurrentLayer = 0;
  qDeleteAll(mLayers); // don't use removeLayer, because it would prevent the last layer to be removed
                       // removeLayer를 사용하지 마십시오. 마지막 레이어가 제거되지 않도록하기 때문입니다.
  mLayers.clear();     
}

/*!
  Sets which elements are forcibly drawn antialiased as an \a or combination of QCP::AntialiasedElement.
  
  This overrides the antialiasing settings for whole element groups, normally controlled with the
  \a setAntialiasing function on the individual elements. If an element is neither specified in
  \ref setAntialiasedElements nor in \ref setNotAntialiasedElements, the antialiasing setting on
  each individual element instance is used.
  
  For example, if \a antialiasedElements contains \ref QCP::aePlottables, all plottables will be
  drawn antialiased, no matter what the specific QCPAbstractPlottable::setAntialiased value was set
  to.
  
  if an element in \a antialiasedElements is already set in \ref setNotAntialiasedElements, it is
  removed from there.
  
  \see setNotAntialiasedElements
*/
/*!
  강제로 그려지는 엘리먼트를 \ a 또는 QCP :: AntialiasedElement의 조합으로 앤티 앨리어스로 설정합니다.
  
  이 기능은 전체 요소 그룹에 대한 앤티 앨리어싱 설정을 재정의합니다.
  \ 개별 요소에 대한 setAntialiasing 함수. 요소가에서 지정되지 않은 경우
  \ ref setAntialiasedElements 또는 \ ref setNotAntialiasedElements에있는 앤티 엘리 어싱 설정은 다음과 같습니다.
  각 요소 인스턴스가 사용됩니다.
  
  예를 들어 \ antialiasedElements에 \ ref QCP :: aePlottables가 포함되어 있으면 모든 플롯 테이블이
  특정 QCPAbstractPlottable :: setAntialiased 값이 설정되었는지 여부에 관계없이 그려진 앤티 엘리 어싱 된
  에.
  
  AntialiasedElements의 요소가 이미 \ ref setNotAntialiasedElements에 설정되어있는 경우
  거기에서 제거되었습니다.
  
  \ setNotAntialiasedElements를 참조하십시오.
*/
void QCustomPlot::setAntialiasedElements(const QCP::AntialiasedElements &antialiasedElements)
{
  mAntialiasedElements = antialiasedElements;
  
  // make sure elements aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously:
  // 요소가 mNotAntialiasedElements와 mAntialiasedElements에 동시에 존재하지 않는지 확인하십시오 :
  if ((mNotAntialiasedElements & mAntialiasedElements) != 0)
    mNotAntialiasedElements |= ~mAntialiasedElements;
}

/*!
  Sets whether the specified \a antialiasedElement is forcibly drawn antialiased.
  
  See \ref setAntialiasedElements for details.
  
  \see setNotAntialiasedElement
*/
/*!
  지정된 \ antialiasedElement가 강제로 앤티 앨리어스로 그려지는지 여부를 설정합니다.
  
  자세한 내용은 \ ref setAntialiasedElements를 참조하십시오.
  
  \ setNotAntialiasedElement를 참조하십시오.
*/
void QCustomPlot::setAntialiasedElement(QCP::AntialiasedElement antialiasedElement, bool enabled)
{
  if (!enabled && mAntialiasedElements.testFlag(antialiasedElement))
    mAntialiasedElements &= ~antialiasedElement;
  else if (enabled && !mAntialiasedElements.testFlag(antialiasedElement))
    mAntialiasedElements |= antialiasedElement;
  
  // make sure elements aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously:
  // 요소가 mNotAntialiasedElements와 mAntialiasedElements에 동시에 존재하지 않는지 확인하십시오 :
  if ((mNotAntialiasedElements & mAntialiasedElements) != 0)
    mNotAntialiasedElements |= ~mAntialiasedElements;
}

/*!
  Sets which elements are forcibly drawn not antialiased as an \a or combination of
  QCP::AntialiasedElement.
  
  This overrides the antialiasing settings for whole element groups, normally controlled with the
  \a setAntialiasing function on the individual elements. If an element is neither specified in
  \ref setAntialiasedElements nor in \ref setNotAntialiasedElements, the antialiasing setting on
  each individual element instance is used.
  
  For example, if \a notAntialiasedElements contains \ref QCP::aePlottables, no plottables will be
  drawn antialiased, no matter what the specific QCPAbstractPlottable::setAntialiased value was set
  to.
  
  if an element in \a notAntialiasedElements is already set in \ref setAntialiasedElements, it is
  removed from there.
  
  \see setAntialiasedElements
*/
/*!
  강제로 그려지는 요소를 앤티 앨리어스가 아닌 \ a 또는 그 조합으로 설정합니다.
  QCP :: AntialiasedElement.
  
  이 기능은 전체 요소 그룹에 대한 앤티 앨리어싱 설정을 재정의합니다.
  \ 개별 요소에 대한 setAntialiasing 함수. 요소가에서 지정되지 않은 경우
  \ ref setAntialiasedElements 또는 \ ref setNotAntialiasedElements에있는 앤티 엘리 어싱 설정은 다음과 같습니다.
  각 요소 인스턴스가 사용됩니다.
  
  예를 들어 \ notAntialiasedElements에 \ ref QCP :: aePlottables가 포함되어있는 경우 plottables는 없습니다.
  특정 QCPAbstractPlottable :: setAntialiased 값이 설정되었는지 여부에 관계없이 그려진 앤티 엘리 어싱 된
  에.
  
  \ notAntialiasedElements에있는 요소가 이미 \ ref setAntialiasedElements에 설정되어 있다면, 그것은
  거기에서 제거되었습니다.
  
  \ setAntialiasedElements를 참조하십시오.
*/
void QCustomPlot::setNotAntialiasedElements(const QCP::AntialiasedElements &notAntialiasedElements)
{
  mNotAntialiasedElements = notAntialiasedElements;
  
  // make sure elements aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously:
  // 요소가 mNotAntialiasedElements와 mAntialiasedElements에 동시에 존재하지 않는지 확인하십시오 :
  if ((mNotAntialiasedElements & mAntialiasedElements) != 0)
    mAntialiasedElements |= ~mNotAntialiasedElements;
}

/*!
  Sets whether the specified \a notAntialiasedElement is forcibly drawn not antialiased.
  
  See \ref setNotAntialiasedElements for details.
  
  \see setAntialiasedElement
*/
/*!
  지정된 \ a notAntialiasedElement가 앤티 앨리어스가 아닌 강제로 그려지는지 여부를 설정합니다.
  
  자세한 내용은 \ ref setNotAntialiasedElements를 참조하십시오.
  
  \ setAntialiasedElement를 참조하십시오.
*/
void QCustomPlot::setNotAntialiasedElement(QCP::AntialiasedElement notAntialiasedElement, bool enabled)
{
  if (!enabled && mNotAntialiasedElements.testFlag(notAntialiasedElement))
    mNotAntialiasedElements &= ~notAntialiasedElement;
  else if (enabled && !mNotAntialiasedElements.testFlag(notAntialiasedElement))
    mNotAntialiasedElements |= notAntialiasedElement;
  
  // make sure elements aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously:
  // 요소가 mNotAntialiasedElements와 mAntialiasedElements에 동시에 존재하지 않는지 확인하십시오 :
  if ((mNotAntialiasedElements & mAntialiasedElements) != 0)
    mAntialiasedElements |= ~mNotAntialiasedElements;
}

/*!
  If set to true, adding a plottable (e.g. a graph) to the QCustomPlot automatically also adds the
  plottable to the legend (QCustomPlot::legend).
  
  \see addGraph, QCPLegend::addItem
*/
/*!
  true로 설정하면 QCustomPlot에 플롯 테이블 (예 : 그래프)을 추가하면 자동으로
  전설 (QCustomPlot :: legend)에 플롯 할 수 있습니다.
  
  \ addGraph 참조, QCPLegend :: addItem
*/
void QCustomPlot::setAutoAddPlottableToLegend(bool on)
{
  mAutoAddPlottableToLegend = on;
}

/*!
  Sets the possible interactions of this QCustomPlot as an or-combination of \ref QCP::Interaction
  enums. There are the following types of interactions:
  
  <b>Axis range manipulation</b> is controlled via \ref QCP::iRangeDrag and \ref QCP::iRangeZoom. When the
  respective interaction is enabled, the user may drag axes ranges and zoom with the mouse wheel.
  For details how to control which axes the user may drag/zoom and in what orientations, see \ref
  QCPAxisRect::setRangeDrag, \ref QCPAxisRect::setRangeZoom, \ref QCPAxisRect::setRangeDragAxes,
  \ref QCPAxisRect::setRangeZoomAxes.
  
  <b>Plottable data selection</b> is controlled by \ref QCP::iSelectPlottables. If \ref
  QCP::iSelectPlottables is set, the user may select plottables (graphs, curves, bars,...) and
  their data by clicking on them or in their vicinity (\ref setSelectionTolerance). Whether the
  user can actually select a plottable and its data can further be restricted with the \ref
  QCPAbstractPlottable::setSelectable method on the specific plottable. For details, see the
  special page about the \ref dataselection "data selection mechanism". To retrieve a list of all
  currently selected plottables, call \ref selectedPlottables. If you're only interested in
  QCPGraphs, you may use the convenience function \ref selectedGraphs.
  
  <b>Item selection</b> is controlled by \ref QCP::iSelectItems. If \ref QCP::iSelectItems is set, the user
  may select items (QCPItemLine, QCPItemText,...) by clicking on them or in their vicinity. To find
  out whether a specific item is selected, call QCPAbstractItem::selected(). To retrieve a list of
  all currently selected items, call \ref selectedItems.
  
  <b>Axis selection</b> is controlled with \ref QCP::iSelectAxes. If \ref QCP::iSelectAxes is set, the user
  may select parts of the axes by clicking on them. What parts exactly (e.g. Axis base line, tick
  labels, axis label) are selectable can be controlled via \ref QCPAxis::setSelectableParts for
  each axis. To retrieve a list of all axes that currently contain selected parts, call \ref
  selectedAxes. Which parts of an axis are selected, can be retrieved with QCPAxis::selectedParts().
  
  <b>Legend selection</b> is controlled with \ref QCP::iSelectLegend. If this is set, the user may
  select the legend itself or individual items by clicking on them. What parts exactly are
  selectable can be controlled via \ref QCPLegend::setSelectableParts. To find out whether the
  legend or any of its child items are selected, check the value of QCPLegend::selectedParts. To
  find out which child items are selected, call \ref QCPLegend::selectedItems.
  
  <b>All other selectable elements</b> The selection of all other selectable objects (e.g.
  QCPTextElement, or your own layerable subclasses) is controlled with \ref QCP::iSelectOther. If set, the
  user may select those objects by clicking on them. To find out which are currently selected, you
  need to check their selected state explicitly.
  
  If the selection state has changed by user interaction, the \ref selectionChangedByUser signal is
  emitted. Each selectable object additionally emits an individual selectionChanged signal whenever
  their selection state has changed, i.e. not only by user interaction.
  
  To allow multiple objects to be selected by holding the selection modifier (\ref
  setMultiSelectModifier), set the flag \ref QCP::iMultiSelect.
  
  \note In addition to the selection mechanism presented here, QCustomPlot always emits
  corresponding signals, when an object is clicked or double clicked. see \ref plottableClick and
  \ref plottableDoubleClick for example.
  
  \see setInteraction, setSelectionTolerance
*/
/*!
  true로 설정하면 QCustomPlot에 플롯 테이블 (예 : 그래프)을 추가하면 자동으로
  전설 (QCustomPlot :: legend)에 플롯 할 수 있습니다.
  
  \ addGraph 참조, QCPLegend :: addItem
* /
void QCustomPlot :: setAutoAddPlottableToLegend (불투명)
{
  mAutoAddPlottableToLegend = 설정;
}

/ *!
  이 QCustomPlot의 가능한 상호 작용을 \ ref QCP :: Interaction의 조합으로 설정합니다.
  enums. 상호 작용에는 다음과 같은 유형이 있습니다.
  
  <b> 축 범위 조작 </ b>은 \ ref QCP :: iRangeDrag 및 \ ref QCP :: iRangeZoom을 통해 제어됩니다. 때
  각 상호 작용이 활성화 된 경우 사용자는 축 범위를 드래그하고 마우스 휠로 확대 / 축소 할 수 있습니다.
  사용자가 드래그 / 줌할 수있는 축과 방향을 제어하는 ​​방법에 대한 자세한 내용은 \ ref를 참조하십시오.
  QCPAxisRect :: setRangeDrag, \ ref QCPAxisRect :: setRangeZoom, \ ref QCPAxisRect :: setRangeDragAxes,
  \ ref QCPAxisRect :: setRangeZoomAxes.
  
  <b> 플롯 데이터 선택 </ b>은 \ ref QCP :: iSelectPlottables에 의해 제어됩니다. \ ref 인 경우
  QCP :: iSelectPlottables가 설정되면, 사용자는 plottables (그래프, 커브, 바, ...) 및
  데이터를 클릭하거나 주변에서 클릭하여 (\ ref setSelectionTolerance). 여부
  사용자는 실제로 플롯 테이블을 선택할 수 있으며 그 데이터는 \ ref로 더 제한 될 수 있습니다.
  특정 플롯 테이블의 QCPAbstractPlottable :: setSelectable 메소드입니다. 자세한 내용은
  \ ref dataselection "데이터 선택 메커니즘"에 대한 특별 페이지. 모든 목록을 검색하려면
  현재 선택된 플롯 테이블은 \ ref selectedPlottables를 호출합니다. 관심이있는 경우
  QCPGraphs에서 편의 기능 \ ref selectedGraphs를 사용할 수 있습니다.
  
  <b> 항목 선택 </ b>은 \ ref QCP :: iSelectItems에 의해 제어됩니다. \ ref QCP :: iSelectItems가 설정되면, 사용자는
  (QCPItemLine, QCPItemText, ...) 항목을 선택할 수 있습니다. 찾다
  특정 항목이 선택되었는지 여부를 확인하려면 QCPAbstractItem :: selected ()를 호출하십시오. 목록을 검색하려면
  현재 선택된 모든 항목은 \ ref selectedItems를 호출합니다.
  
  <b> 축 선택 </ b>은 \ ref QCP :: iSelectAxes로 제어됩니다. \ ref QCP :: iSelectAxes가 설정되면, 사용자는
  그것들을 클릭함으로써 축의 일부를 선택할 수 있습니다. 정확히 어떤 부분 (예 : 축베이스 라인, 틱
  레이블, 축 레이블)은 \ ref QCPAxis :: setSelectableParts를 통해 제어 할 수 있습니다.
  각 축. 현재 선택된 파트가 포함 된 모든 축의 목록을 검색하려면 \ ref를 호출하십시오.
  selectedAxes. 축의 어느 부분을 선택했는지는 QCPAxis :: selectedParts ()를 사용하여 검색 할 수 있습니다.
  
  <b> 범례 선택 </ b>은 \ ref QCP :: iSelectLegend로 제어됩니다. 이것이 설정되면 사용자는
  범례 자체 또는 개별 항목을 클릭하여 선택하십시오. 정확히 어떤 부분이
  selectable은 \ ref QCPLegend :: setSelectableParts를 통해 제어 할 수 있습니다. 여부를 확인하려면
  범례 또는 하위 항목 중 하나가 선택되면 QCPLegend :: selectedParts의 값을 확인하십시오. 에
  어떤 하위 항목이 선택되었는지 확인하려면 \ ref QCPLegend :: selectedItems를 호출하십시오.
  
  <b> 다른 모든 선택 가능한 요소 </ b> 선택 가능한 다른 모든 개체 (예 :
  QCPTextElement 또는 계층화 할 수있는 하위 클래스)는 \ ref QCP :: iSelectOther로 제어됩니다. 설정된 경우
  사용자는 그 객체들을 클릭함으로써 선택할 수있다. 현재 선택되어있는 항목을 찾으려면
  선택한 상태를 명시 적으로 확인해야합니다.
  
  사용자 상호 작용에 의해 선택 상태가 변경된 경우 \ ref selectionChangedByUser 신호는 다음과 같습니다.
  방출. 각 선택 가능한 객체는 개별 selectionChanged 신호를 추가로 방출합니다.
  그들의 선택 상태는 사용자 상호 작용에 의해서뿐만 아니라 바뀌었다.
  
  선택 수정 자 (\ ref)를 눌러 여러 객체를 선택할 수있게하려면
  setMultiSelectModifier), 플래그 \ ref QCP :: iMultiSelect를 설정하십시오.
  
  \ note 여기에 제시된 선택 메커니즘 외에도 QCustomPlot은 항상 방출합니다
  객체를 클릭하거나 두 번 클릭하면 해당 신호가 나타납니다. \ ref plottableClick 및 참조
  예를 들어 \ ref plottableDoubleClick입니다.
  
  \ setInteraction, setSelectionTolerance를 참조하십시오.
*/
void QCustomPlot::setInteractions(const QCP::Interactions &interactions)
{
  mInteractions = interactions;
}

/*!
  Sets the single \a interaction of this QCustomPlot to \a enabled.
  
  For details about the interaction system, see \ref setInteractions.
  
  \see setInteractions
*/
/*!
  이 QCustomPlot의 단일 상호 작용을 \ a로 설정합니다.
  
  상호 작용 시스템에 대한 자세한 내용은 \ ref setInteractions를 참조하십시오.
  
  \ 참조 setInteractions
*/
void QCustomPlot::setInteraction(const QCP::Interaction &interaction, bool enabled)
{
  if (!enabled && mInteractions.testFlag(interaction))
    mInteractions &= ~interaction;
  else if (enabled && !mInteractions.testFlag(interaction))
    mInteractions |= interaction;
}

/*!
  Sets the tolerance that is used to decide whether a click selects an object (e.g. a plottable) or
  not.
  
  If the user clicks in the vicinity of the line of e.g. a QCPGraph, it's only regarded as a
  potential selection when the minimum distance between the click position and the graph line is
  smaller than \a pixels. Objects that are defined by an area (e.g. QCPBars) only react to clicks
  directly inside the area and ignore this selection tolerance. In other words, it only has meaning
  for parts of objects that are too thin to exactly hit with a click and thus need such a
  tolerance.
  
  \see setInteractions, QCPLayerable::selectTest
*/
/*!
  클릭이 오브젝트 (예 : 플롯 테이블)를 선택하는지 또는 플럽 (예 : 플롯)을 선택 할지를 결정하는 데 사용되는 공차를 설정합니다.
  아니.
  
  사용자가 예를 들어 QCPGraph의 라인 부근을 클릭하면
  클릭 위치와 그래프 선 사이의 최소 거리가
  \ a 픽셀보다 작습니다. 영역 (예 : QCPBars)에 의해 정의 된 객체는 클릭에만 반응합니다.
  이 영역 내에서 직접 선택 허용 오차를 무시하십시오. 다시 말해서, 그것은 단지 의미를 가진다.
  너무 가늘어서 클릭으로 정확히 맞을 수 없으므로
  공차.
  
  \ setInteractions, QCPLayerable :: selectTest 참조
*/
void QCustomPlot::setSelectionTolerance(int pixels)
{
  mSelectionTolerance = pixels;
}

/*!
  Sets whether antialiasing is disabled for this QCustomPlot while the user is dragging axes
  ranges. If many objects, especially plottables, are drawn antialiased, this greatly improves
  performance during dragging. Thus it creates a more responsive user experience. As soon as the
  user stops dragging, the last replot is done with normal antialiasing, to restore high image
  quality.
  
  \see setAntialiasedElements, setNotAntialiasedElements
*/
/*!
  사용자가 축을 드래그하는 동안이 QCustomPlot에 대한 앤티 엘리 어싱이 비활성화되는지 여부를 설정합니다.
  범위. 많은 객체, 특히 플래티 블이 앤티 앨리어스로 그려진 경우 크게 향상됩니다.
  드래그하는 동안 성능. 따라서 응답 성이 뛰어난 사용자 환경을 제공합니다. 최대한 빨리
  사용자가 끌기를 멈추고, 마지막 복제본이 정상 안티 앨리어싱으로 완료되어 높은 이미지를 복원합니다.
  품질.
  
  \ setAntialiasedElements, setNotAntialiasedElements를 참조하십시오.
*/
void QCustomPlot::setNoAntialiasingOnDrag(bool enabled)
{
  mNoAntialiasingOnDrag = enabled;
}

/*!
  Sets the plotting hints for this QCustomPlot instance as an \a or combination of QCP::PlottingHint.
  
  \see setPlottingHint
*/
/*!
  이 QCustomPlot 인스턴스의 플롯팅 힌트를 \ a 또는 QCP :: PlottingHint의 조합으로 설정합니다.
  
  \ see setPlottingHint
*/
void QCustomPlot::setPlottingHints(const QCP::PlottingHints &hints)
{
  mPlottingHints = hints;
}

/*!
  Sets the specified plotting \a hint to \a enabled.
  
  \see setPlottingHints
*/
/*!
  지정된 플롯팅 \ 힌트를 \ a로 설정합니다.
  
  \ setPlottingHints를 참조하십시오.
*/
void QCustomPlot::setPlottingHint(QCP::PlottingHint hint, bool enabled)
{
  QCP::PlottingHints newHints = mPlottingHints;
  if (!enabled)
    newHints &= ~hint;
  else
    newHints |= hint;
  
  if (newHints != mPlottingHints)
    setPlottingHints(newHints);
}

/*!
  Sets the keyboard modifier that will be recognized as multi-select-modifier.
  
  If \ref QCP::iMultiSelect is specified in \ref setInteractions, the user may select multiple
  objects (or data points) by clicking on them one after the other while holding down \a modifier.
  
  By default the multi-select-modifier is set to Qt::ControlModifier.
  
  \see setInteractions
*/
/*!
  multi-select-modifier로 인식 될 키보드 수정자를 설정합니다.
  
  \ ref QCP :: iMultiSelect가 \ ref setInteractions에 지정되어있는 경우, 사용자는
  개체 (또는 데이터 요소)를 \ a 수정자를 누른 상태에서 차례로 클릭하여 선택합니다.
  
  기본적으로 다중 선택 수정자는 Qt :: ControlModifier로 설정됩니다.
  
  \ 참조 setInteractions
*/
void QCustomPlot::setMultiSelectModifier(Qt::KeyboardModifier modifier)
{
  mMultiSelectModifier = modifier;
}

/*!
  Sets how QCustomPlot processes mouse click-and-drag interactions by the user.

  If \a mode is \ref QCP::srmNone, the mouse drag is forwarded to the underlying objects. For
  example, QCPAxisRect may process a mouse drag by dragging axis ranges, see \ref
  QCPAxisRect::setRangeDrag. If \a mode is not \ref QCP::srmNone, the current selection rect (\ref
  selectionRect) becomes activated and allows e.g. rect zooming and data point selection.
  
  If you wish to provide your user both with axis range dragging and data selection/range zooming,
  use this method to switch between the modes just before the interaction is processed, e.g. in
  reaction to the \ref mousePress or \ref mouseMove signals. For example you could check whether
  the user is holding a certain keyboard modifier, and then decide which \a mode shall be set.
  
  If a selection rect interaction is currently active, and \a mode is set to \ref QCP::srmNone, the
  interaction is canceled (\ref QCPSelectionRect::cancel). Switching between any of the other modes
  will keep the selection rect active. Upon completion of the interaction, the behaviour is as
  defined by the currently set \a mode, not the mode that was set when the interaction started.
  
  \see setInteractions, setSelectionRect, QCPSelectionRect
*/
/*!
  사용자가 QCustomPlot에서 마우스 클릭 및 드래그 상호 작용을 처리하는 방법을 설정합니다.

  \ mode가 \ ref QCP :: srmNone이면 마우스 끌기가 기본 객체로 전달됩니다. 에 대한
  예를 들어 QCPAxisRect는 축 범위를 드래그하여 마우스 끌기를 처리 할 수 ​​있습니다. \ ref를 참조하십시오.
  QCPAxisRect :: setRangeDrag. \ a 모드가 \ ref QCP :: srmNone이 아닌 경우 현재 선택 rect (\ ref
  selectionRect)가 활성화되고 직사각형 확대 / 축소 및 데이터 포인트 선택이 가능합니다.
  
  사용자가 축 범위 드래그와 데이터 선택 / 범위 확대를 모두 제공하려는 경우,
  이 메소드를 사용하여 상호 작용이 처리되기 직전의 모드 사이를 전환하십시오. 예 :
  \ ref mousePress 또는 \ ref mouseMove 신호에 대한 반응. 예를 들어,
  사용자가 특정 키보드 수정자를 누른 다음 어떤 모드를 설정할지 결정합니다.
  
  선택 영 역 상호 작용이 현재 활성화되어 있고 \ mode가 \ ref QCP :: srmNone으로 설정된 경우
  상호 작용이 취소됩니다 (\ ref QCPSelectionRect :: cancel). 다른 모드들 사이에서 전환하기
  선택 항목을 활성화 상태로 유지합니다. 상호 작용이 완료되면 동작은 다음과 같습니다.
  상호 작용이 시작될 때 설정된 모드가 아니라 현재 설정된 \ a 모드에 의해 정의됩니다.
  
  \ setInteractions, setSelectionRect, QCPSelectionRect를 참조하십시오.
*/
void QCustomPlot::setSelectionRectMode(QCP::SelectionRectMode mode)
{
  if (mSelectionRect)
  {
    if (mode == QCP::srmNone)
      mSelectionRect->cancel(); 
// when switching to none, we immediately want to abort a potentially active selection rect
// none으로 전환하면 즉시 활성 선택 항목 rect를 중단하려고합니다.
    
    // disconnect old connections:
    // 이전 연결을 끊습니다.
    if (mSelectionRectMode == QCP::srmSelect)
      disconnect(mSelectionRect, SIGNAL(accepted(QRect,QMouseEvent*)), this, SLOT(processRectSelection(QRect,QMouseEvent*)));
    else if (mSelectionRectMode == QCP::srmZoom)
      disconnect(mSelectionRect, SIGNAL(accepted(QRect,QMouseEvent*)), this, SLOT(processRectZoom(QRect,QMouseEvent*)));
    
    // establish new ones:
    // 새로 설정 :
    if (mode == QCP::srmSelect)
      connect(mSelectionRect, SIGNAL(accepted(QRect,QMouseEvent*)), this, SLOT(processRectSelection(QRect,QMouseEvent*)));
    else if (mode == QCP::srmZoom)
      connect(mSelectionRect, SIGNAL(accepted(QRect,QMouseEvent*)), this, SLOT(processRectZoom(QRect,QMouseEvent*)));
  }
  
  mSelectionRectMode = mode;
}

/*!
  Sets the \ref QCPSelectionRect instance that QCustomPlot will use if \a mode is not \ref
  QCP::srmNone and the user performs a click-and-drag interaction. QCustomPlot takes ownership of
  the passed \a selectionRect. It can be accessed later via \ref selectionRect.
  
  This method is useful if you wish to replace the default QCPSelectionRect instance with an
  instance of a QCPSelectionRect subclass, to introduce custom behaviour of the selection rect.
  
  \see setSelectionRectMode
*/
/*!
  모드가 \ ref가 아닌 경우 QCustomPlot이 사용할 \ ref QCPSelectionRect 인스턴스를 설정합니다.
  QCP :: srmNone이고 사용자는 클릭 앤 드래그 상호 작용을 수행합니다. QCustomPlot은 다음 중 소유권을가집니다.
  건네받은 \ SelectionRect 나중에 \ ref selectionRect를 통해 액세스 할 수 있습니다.
  
  이 방법은 기본 QCPSelectionRect 인스턴스를
  QCPSelectionRect 하위 클래스의 인스턴스를 사용하여 선택 rect의 사용자 지정 동작을 소개합니다.
  
  \ setSelectionRectMode를 참조하십시오.
*/
void QCustomPlot::setSelectionRect(QCPSelectionRect *selectionRect)
{
  if (mSelectionRect)
    delete mSelectionRect;
  
  mSelectionRect = selectionRect;
  
  if (mSelectionRect)
  {
    // establish connections with new selection rect:
    // 새 선택 항목 rect와 연결을 설정합니다.
    if (mSelectionRectMode == QCP::srmSelect)
      connect(mSelectionRect, SIGNAL(accepted(QRect,QMouseEvent*)), this, SLOT(processRectSelection(QRect,QMouseEvent*)));
    else if (mSelectionRectMode == QCP::srmZoom)
      connect(mSelectionRect, SIGNAL(accepted(QRect,QMouseEvent*)), this, SLOT(processRectZoom(QRect,QMouseEvent*)));
  }
}

/*!
  \warning This is still an experimental feature and its performance depends on the system that it
  runs on. Having multiple QCustomPlot widgets in one application with enabled OpenGL rendering
  might cause context conflicts on some systems.
  
  This method allows to enable OpenGL plot rendering, for increased plotting performance of
  graphically demanding plots (thick lines, translucent fills, etc.).

  If \a enabled is set to true, QCustomPlot will try to initialize OpenGL and, if successful,
  continue plotting with hardware acceleration. The parameter \a multisampling controls how many
  samples will be used per pixel, it essentially controls the antialiasing quality. If \a
  multisampling is set too high for the current graphics hardware, the maximum allowed value will
  be used.

  You can test whether switching to OpenGL rendering was successful by checking whether the
  according getter \a QCustomPlot::openGl() returns true. If the OpenGL initialization fails,
  rendering continues with the regular software rasterizer, and an according qDebug output is
  generated.

  If switching to OpenGL was successful, this method disables label caching (\ref setPlottingHint
  "setPlottingHint(QCP::phCacheLabels, false)") and turns on QCustomPlot's antialiasing override
  for all elements (\ref setAntialiasedElements "setAntialiasedElements(QCP::aeAll)"), leading to a
  higher quality output. The antialiasing override allows for pixel-grid aligned drawing in the
  OpenGL paint device. As stated before, in OpenGL rendering the actual antialiasing of the plot is
  controlled with \a multisampling. If \a enabled is set to false, the antialiasing/label caching
  settings are restored to what they were before OpenGL was enabled, if they weren't altered in the
  meantime.

  \note OpenGL support is only enabled if QCustomPlot is compiled with the macro \c QCUSTOMPLOT_USE_OPENGL
  defined. This define must be set before including the QCustomPlot header both during compilation
  of the QCustomPlot library as well as when compiling your application. It is best to just include
  the line <tt>DEFINES += QCUSTOMPLOT_USE_OPENGL</tt> in the respective qmake project files.
  \note If you are using a Qt version before 5.0, you must also add the module "opengl" to your \c
  QT variable in the qmake project files. For Qt versions 5.0 and higher, QCustomPlot switches to a
  newer OpenGL interface which is already in the "gui" module.
*/
/*!
  \ warning 이것은 여전히 ​​시험적인 기능이며 성능은 시스템에 따라 다릅니다
  계속된다. OpenGL 렌더링을 사용하는 하나의 애플리케이션에 QCustomPlot 위젯을 여러 개 보유
  일부 시스템에서 컨텍스트 충돌이 발생할 수 있습니다.
  
  이 방법을 사용하면 OpenGL 플롯 렌더링을 활성화하여 플로팅 성능을 향상시킬 수 있습니다.
  그래픽이 요구되는 플롯 (두꺼운 선, 반투명 채우기 등).

  \ a enabled가 true로 설정된 경우 QCustomPlot은 OpenGL을 초기화하려고 시도하고,
  하드웨어 가속으로 플로팅을 계속하십시오. 매개 변수 \ a 멀티 샘플링은
  샘플은 픽셀 당 사용되며 기본적으로 앤티 앨리어싱 품질을 제어합니다. 만약
  멀티 샘플링이 현재 그래픽 하드웨어에 비해 너무 높게 설정되어 있으면 허용되는 최대 값은
  사용하십시오.

  OpenGL 렌더링으로의 전환이 성공했는지 테스트하려면
  getter \ a에 따라 QCustomPlot :: openGl ()은 true를 반환합니다. OpenGL 초기화가 실패하면,
  렌더링은 일반 소프트웨어 래스터 라이저에서 계속되고 qDebug 출력은 다음과 같습니다.
  생성됩니다.

  OpenGL 로의 전환이 성공하면이 메서드는 레이블 캐싱을 사용하지 않도록 설정합니다 (\ ref setPlottingHint
  "setPlottingHint (QCP :: phCacheLabels, false)") QCustomPlot의 앤티 앨리어싱 재정의를 켭니다
  모든 요소에 대해 (\ ref setAntialiasedElements "setAntialiasedElements (QCP :: aeAll)"),
  고품질 출력. 앤티 엘리 어싱 오버라이드를 사용하면 픽셀 격자를
  OpenGL 페인트 장치. 앞에서 설명한 것처럼 OpenGL 렌더링에서 플롯의 실제 앤티 앨리어싱은
  멀티 샘플링으로 제어된다. \ a enabled가 false로 설정된 경우 앤티 앨리어싱 / 레이블 캐싱
  설정이 OpenGL을 사용하도록 설정되기 전의 상태로 복원됩니다.
  그 동안에.

  \ note QCustomPlot을 매크로 \ c로 컴파일하면 OpenGL 지원이 활성화됩니다. QCUSTOMPLOT_USE_OPENGL
  한정된. 이 정의는 컴파일하는 동안 QCustomPlot 헤더를 모두 포함하기 전에 설정해야합니다.
  응용 프로그램을 컴파일 할 때뿐만 아니라 QCustomPlot 라이브러리의. 포함하는 것이 가장 좋습니다.
  각각의 qmake 프로젝트 파일에 <tt> DEFINES + = QCUSTOMPLOT_USE_OPENGL </ tt> 줄이 있습니다.
  \ note 5.0 이전의 Qt 버전을 사용한다면 \ c 모듈에 "opengl"을 추가해야합니다.
  Qmake 프로젝트 파일의 QT 변수. Qt 버전 5.0 이상에서는 QCustomPlot이
  이미 "GUI"모듈에있는 새로운 OpenGL 인터페이스.
*/
void QCustomPlot::setOpenGl(bool enabled, int multisampling)
{
  mOpenGlMultisamples = qMax(0, multisampling);
#ifdef QCUSTOMPLOT_USE_OPENGL
  mOpenGl = enabled;
  if (mOpenGl)
  {
    if (setupOpenGl())
    {
      // backup antialiasing override and labelcaching setting so we can restore upon disabling OpenGL
      // OpenGL을 비활성화 할 때 복원 할 수 있도록 안티 앨리어싱 오버라이드 및 레이블 캐싱 설정을 백업합니다.
      mOpenGlAntialiasedElementsBackup = mAntialiasedElements;
      mOpenGlCacheLabelsBackup = mPlottingHints.testFlag(QCP::phCacheLabels);
      // set antialiasing override to antialias all (aligns gl pixel grid properly), and disable label caching (would use software rasterizer for pixmap caches):
      // 앤티 엘리 어싱 오버라이드를 모두 앤티 앨리어스로 설정하고 (픽셀 격자를 적절히 정렬), 레이블 캐싱을 비활성화합니다 (픽스맵 캐시의 소프트웨어 래스터 라이저 사용).
      setAntialiasedElements(QCP::aeAll);
      setPlottingHint(QCP::phCacheLabels, false);
    } else
    {
      qDebug() << Q_FUNC_INFO << "Failed to enable OpenGL, continuing plotting without hardware acceleration.";
      mOpenGl = false;
    }
  } else
  {
    // restore antialiasing override and labelcaching to what it was before enabling OpenGL, if nobody changed it in the meantime:
// 그 동안 아무도 변경하지 않았다면 OpenGL을 활성화하기 전에 안티 앨리어싱 오버라이드와 labelcaching을 복원하십시오.
    if (mAntialiasedElements == QCP::aeAll)
      setAntialiasedElements(mOpenGlAntialiasedElementsBackup);
    if (!mPlottingHints.testFlag(QCP::phCacheLabels))
      setPlottingHint(QCP::phCacheLabels, mOpenGlCacheLabelsBackup);
    freeOpenGl();
  }
  // recreate all paint buffers:
  // 모든 페인트 버퍼를 다시 만듭니다.
  mPaintBuffers.clear();
  setupPaintBuffers();
#else
  Q_UNUSED(enabled)
  qDebug() << Q_FUNC_INFO << "QCustomPlot can't use OpenGL because QCUSTOMPLOT_USE_OPENGL was not defined during compilation (add 'DEFINES += QCUSTOMPLOT_USE_OPENGL' to your qmake .pro file)";
#endif
}

/*!
  Sets the viewport of this QCustomPlot. Usually users of QCustomPlot don't need to change the
  viewport manually.

  The viewport is the area in which the plot is drawn. All mechanisms, e.g. margin caluclation take
  the viewport to be the outer border of the plot. The viewport normally is the rect() of the
  QCustomPlot widget, i.e. a rect with top left (0, 0) and size of the QCustomPlot widget.

  Don't confuse the viewport with the axis rect (QCustomPlot::axisRect). An axis rect is typically
  an area enclosed by four axes, where the graphs/plottables are drawn in. The viewport is larger
  and contains also the axes themselves, their tick numbers, their labels, or even additional axis
  rects, color scales and other layout elements.

  This function is used to allow arbitrary size exports with \ref toPixmap, \ref savePng, \ref
  savePdf, etc. by temporarily changing the viewport size.
*/
/*!
  이 QCustomPlot의 뷰포트를 설정합니다. 일반적으로 QCustomPlot의 사용자는
  뷰포트를 수동으로.

  뷰포트는 플롯이 그려지는 영역입니다. 모든 메커니즘, 예 : 마진 측정
  뷰포트가 플롯의 바깥 쪽 경계가되도록합니다. 일반적으로 뷰포트는 ()의 rect ()입니다.
  QCustomPlot 위젯, 즉 QCustomPlot 위젯의 왼쪽 위 (0, 0) 및 크기가있는 rect입니다.

  뷰포트를 축 rect (QCustomPlot :: axisRect)와 혼동하지 마십시오. 축 rect는 일반적으로
  그래프 / 플롯 테이블이 그려지는 4 개의 축으로 둘러싸인 영역입니다. 뷰포트가 더 큽니다.
  또한 축 자체, 틱 번호, 레이블 또는 추가 축을 포함합니다.
  직사각형, 색 눈금 및 기타 레이아웃 요소.

  이 함수는 \ ref를 픽스맵, \ ref savePng, \ ref와 함께 임의의 크기로 내보낼 수있게합니다
  savePdf 등을 일시적으로 변경할 수 있습니다.
*/
void QCustomPlot::setViewport(const QRect &rect)
{
  mViewport = rect;
  if (mPlotLayout)
    mPlotLayout->setOuterRect(mViewport);
}

/*!
  Sets the device pixel ratio used by the paint buffers of this QCustomPlot instance.

  Normally, this doesn't need to be set manually, because it is initialized with the regular \a
  QWidget::devicePixelRatio which is configured by Qt to fit the display device (e.g. 1 for normal
  displays, 2 for High-DPI displays).

  Device pixel ratios are supported by Qt only for Qt versions since 5.4. If this method is called
  when QCustomPlot is being used with older Qt versions, outputs an according qDebug message and
  leaves the internal buffer device pixel ratio at 1.0.
*/
/*!
  이 QCustomPlot 인스턴스의 페인트 버퍼에 사용되는 장치 픽셀 비율을 설정합니다.

  보통 \ a로 초기화되기 때문에 수동으로 설정할 필요는 없습니다.
  디스플레이 장치에 맞게 Qt에 의해 구성된 QWidget :: devicePixelRatio (예 : 보통의 경우 1
  디스플레이, High-DPI 디스플레이의 경우 2).

  장치 픽셀 비율은 5.4 이후 Qt 버전에 대해서만 Qt에서 지원됩니다. 이 메소드가 불려 갔을 경우
  이전 버전의 Qt에서 QCustomPlot을 사용하면 qDebug 메시지를 출력하고
  1.0에서 내부 버퍼 장치 픽셀 비율을 유지합니다.
*/
void QCustomPlot::setBufferDevicePixelRatio(double ratio)
{
  if (!qFuzzyCompare(ratio, mBufferDevicePixelRatio))
  {
#ifdef QCP_DEVICEPIXELRATIO_SUPPORTED
    mBufferDevicePixelRatio = ratio;
    for (int i=0; i<mPaintBuffers.size(); ++i)
      mPaintBuffers.at(i)->setDevicePixelRatio(mBufferDevicePixelRatio);
 // Note: axis label cache has devicePixelRatio as part of cache hash, so no need to manually clear cache here
 // 참고 : 축 레이블 캐시에는 cache 해시의 일부로 devicePixelRatio가 있으므로 여기서 수동으로 캐시를 지울 필요가 없습니다.
#else
    qDebug() << Q_FUNC_INFO << "Device pixel ratios not supported for Qt versions before 5.4";
    mBufferDevicePixelRatio = 1.0;
#endif
  }
}

/*!
  Sets \a pm as the viewport background pixmap (see \ref setViewport). The pixmap is always drawn
  below all other objects in the plot.

  For cases where the provided pixmap doesn't have the same size as the viewport, scaling can be
  enabled with \ref setBackgroundScaled and the scaling mode (whether and how the aspect ratio is
  preserved) can be set with \ref setBackgroundScaledMode. To set all these options in one call,
  consider using the overloaded version of this function.
  
  If a background brush was set with \ref setBackground(const QBrush &brush), the viewport will
  first be filled with that brush, before drawing the background pixmap. This can be useful for
  background pixmaps with translucent areas.

  \see setBackgroundScaled, setBackgroundScaledMode
*/
/*!
  \ pm을 뷰포트 배경 pixmap으로 설정합니다 (\ ref setViewport 참조). 픽스맵은 항상 그려진다.
  플롯의 다른 모든 오브젝트 아래에 있습니다.

  제공된 픽스맵이 뷰포트와 크기가 같지 않은 경우 크기 조정이 가능합니다.
  \ ref setBackgroundScaled 및 배율 모드 (가로 세로 비율이
  보존)은 \ ref setBackgroundScaledMode로 설정할 수 있습니다. 이러한 모든 옵션을 하나의 호출로 설정하려면,
  이 함수의 오버로드 된 버전 사용을 고려하십시오.
  
  배경 브러시가 \ ref setBackground (const QBrush & brush)로 설정되면 뷰포트는
  배경 pixmap을 그리기 전에 먼저 브러쉬로 채워야합니다. 이것은 유용 할 수 있습니다.
  반투명 영역이있는 배경 pixmaps.

  \ setBackgroundScaled 참조, setBackgroundScaledMode
*/
void QCustomPlot::setBackground(const QPixmap &pm)
{
  mBackgroundPixmap = pm;
  mScaledBackgroundPixmap = QPixmap();
}

/*!
  Sets the background brush of the viewport (see \ref setViewport).

  Before drawing everything else, the background is filled with \a brush. If a background pixmap
  was set with \ref setBackground(const QPixmap &pm), this brush will be used to fill the viewport
  before the background pixmap is drawn. This can be useful for background pixmaps with translucent
  areas.
  
  Set \a brush to Qt::NoBrush or Qt::Transparent to leave background transparent. This can be
  useful for exporting to image formats which support transparency, e.g. \ref savePng.

  \see setBackgroundScaled, setBackgroundScaledMode
*/
/*!
  뷰포트의 배경 브러시를 설정합니다 (\ ref setViewport 참조).

  그 밖의 모든 것을 그리기 전에 배경은 브러쉬로 채워집니다. 배경 픽스맵
  \ ref setBackground (const QPixmap & pm)로 설정 한 경우이 브러시는 뷰포트를 채우는 데 사용됩니다
  배경 pixmap이 그려지기 전에. 반투명의 배경 pixmap에 유용 할 수 있습니다.
  지역.
  
  \ brush를 Qt :: NoBrush 또는 Qt :: Transparent로 설정하여 배경을 투명하게 유지하십시오. 이것은 될 수있다
  \ ref savePng와 같이 투명도를 지원하는 이미지 형식으로 내보내는 데 유용합니다.

  \ setBackgroundScaled 참조, setBackgroundScaledMode
*/
void QCustomPlot::setBackground(const QBrush &brush)
{
  mBackgroundBrush = brush;
}

/*! \overload
  
  Allows setting the background pixmap of the viewport, whether it shall be scaled and how it
  shall be scaled in one call.

  \see setBackground(const QPixmap &pm), setBackgroundScaled, setBackgroundScaledMode
*/
/*! \초과 적재
  
  뷰포트의 배경 픽스맵을 스케일 할 것인지, 어떻게 조정할 것인지를 설정할 수 있습니다.
  하나의 호출로 확장되어야한다.

  \ setBackground (const QPixmap & pm), setBackgroundScaled, setBackgroundScaledMode를 참조하십시오.
*/
void QCustomPlot::setBackground(const QPixmap &pm, bool scaled, Qt::AspectRatioMode mode)
{
  mBackgroundPixmap = pm;
  mScaledBackgroundPixmap = QPixmap();
  mBackgroundScaled = scaled;
  mBackgroundScaledMode = mode;
}

/*!
  Sets whether the viewport background pixmap shall be scaled to fit the viewport. If \a scaled is
  set to true, control whether and how the aspect ratio of the original pixmap is preserved with
  \ref setBackgroundScaledMode.
  
  Note that the scaled version of the original pixmap is buffered, so there is no performance
  penalty on replots. (Except when the viewport dimensions are changed continuously.)
  
  \see setBackground, setBackgroundScaledMode
*/
/*!
  뷰포트 배경 pixmap이 뷰포트에 맞게 조절되는지 여부를 설정합니다. \ a 배율이
  true로 설정하면 원래 픽스맵의 종횡비를 보존할지 여부 및 방법을 제어합니다.
  \ ref setBackgroundScaledMode.
  
  원본 pixmap의 크기가 조정 된 버전은 버퍼링되므로 성능이 없습니다.
  replots에 페널티. 뷰포트 크기가 연속적으로 변경된 경우는 제외합니다.
  
  \ setBackground, setBackgroundScaledMode를 참조하십시오.
*/
void QCustomPlot::setBackgroundScaled(bool scaled)
{
  mBackgroundScaled = scaled;
}

/*!
  If scaling of the viewport background pixmap is enabled (\ref setBackgroundScaled), use this
  function to define whether and how the aspect ratio of the original pixmap is preserved.
  
  \see setBackground, setBackgroundScaled
*/
/*!
  뷰포트 배경 pixmap의 배율이 활성화 된 경우 (\ ref setBackgroundScaled), 다음을 사용하십시오.
  함수는 원래 픽스맵의 종횡비가 유지되는지 여부 및 그 방식을 정의합니다.
  
  \ setBackground, setBackgroundScaled를 참조하십시오.
*/
void QCustomPlot::setBackgroundScaledMode(Qt::AspectRatioMode mode)
{
  mBackgroundScaledMode = mode;
}

/*!
  Returns the plottable with \a index. If the index is invalid, returns 0.
  
  There is an overloaded version of this function with no parameter which returns the last added
  plottable, see QCustomPlot::plottable()
  
  \see plottableCount
*/
/*!
  \ a 인덱스로 플롯 테이블을 반환합니다. 색인이 유효하지 않으면 0을 리턴합니다.
  
  마지막으로 추가 된 항목을 반환하는 매개 변수가없는이 함수의 오버로드 된 버전이 있습니다.
  QCustomPlot :: plottable ()을 참조하십시오.
  
  \ plottableCount 참조
*/
QCPAbstractPlottable *QCustomPlot::plottable(int index)
{
  if (index >= 0 && index < mPlottables.size())
  {
    return mPlottables.at(index);
  } else
  {
    qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;
    return 0;
  }
}

/*! \overload
  
  Returns the last plottable that was added to the plot. If there are no plottables in the plot,
  returns 0.
  
  \see plottableCount
*/
/*! \초과 적재
  
  플롯에 추가 된 마지막 플롯 테이블을 반환합니다. 플롯에 플롯이없는 경우,
  0을 반환합니다.
  
  \ plottableCount 참조
*/
QCPAbstractPlottable *QCustomPlot::plottable()
{
  if (!mPlottables.isEmpty())
  {
    return mPlottables.last();
  } else
    return 0;
}

/*!
  Removes the specified plottable from the plot and deletes it. If necessary, the corresponding
  legend item is also removed from the default legend (QCustomPlot::legend).
  
  Returns true on success.
  
  \see clearPlottables
*/
/*!
  지정된 플롯을 플롯에서 제거하고 삭제합니다. 필요한 경우 해당하는
  범례 항목은 기본 범례 (QCustomPlot :: legend)에서도 제거됩니다.
  
  성공하면 true를 반환합니다.
  
  \ see clearPlottables \ see
*/
bool QCustomPlot::removePlottable(QCPAbstractPlottable *plottable)
{
  if (!mPlottables.contains(plottable))
  {
    qDebug() << Q_FUNC_INFO << "plottable not in list:" << reinterpret_cast<quintptr>(plottable);
    return false;
  }
  
  // remove plottable from legend:
  // 범례에서 플롯을 제거합니다.
  plottable->removeFromLegend();
  // special handling for QCPGraphs to maintain the simple graph interface:
  // 간단한 그래프 인터페이스를 유지하기위한 QCPGraphs를위한 특별한 처리 :
  if (QCPGraph *graph = qobject_cast<QCPGraph*>(plottable))
    mGraphs.removeOne(graph);
  // remove plottable:
  // 플롯 테이블 제거 :
  delete plottable;
  mPlottables.removeOne(plottable);
  return true;
}

/*! \overload
  
  Removes and deletes the plottable by its \a index.
*/
/*! \초과 적재
  
  플롯 테이블을 \ a 인덱스로 제거하고 삭제합니다.
*/
bool QCustomPlot::removePlottable(int index)
{
  if (index >= 0 && index < mPlottables.size())
    return removePlottable(mPlottables[index]);
  else
  {
    qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;
    return false;
  }
}

/*!
  Removes all plottables from the plot and deletes them. Corresponding legend items are also
  removed from the default legend (QCustomPlot::legend).
  
  Returns the number of plottables removed.
  
  \see removePlottable
*/
/*!
  플롯에서 모든 플롯 테이블을 제거하고 삭제합니다. 해당 범례 항목도 있습니다.
  기본 범례 (QCustomPlot :: legend)에서 제거되었습니다.
  
  제거 된 plottables의 수를 반환합니다.
  
  \ see removePlottable
*/
int QCustomPlot::clearPlottables()
{
  int c = mPlottables.size();
  for (int i=c-1; i >= 0; --i)
    removePlottable(mPlottables[i]);
  return c;
}

/*!
  Returns the number of currently existing plottables in the plot
  
  \see plottable
*/
/*!
  플롯에서 현재 존재하는 플롯 테이블의 수를 반환합니다.
  
  \ plottable을 참조하십시오.
*/
int QCustomPlot::plottableCount() const
{
  return mPlottables.size();
}

/*!
  Returns a list of the selected plottables. If no plottables are currently selected, the list is empty.
  
  There is a convenience function if you're only interested in selected graphs, see \ref selectedGraphs.
  
  \see setInteractions, QCPAbstractPlottable::setSelectable, QCPAbstractPlottable::setSelection
*/
/*!
  선택한 플롯 테이블의 목록을 반환합니다. 현재 선택된 플롯 테이블이 없으면 목록은 비어 있습니다.
  
  선택된 그래프에만 관심이 있다면 편의 함수가있다. \ ref selectedGraphs를 보라.
  
  \ setInteractions, QCPAbstractPlottable :: setSelectable, QCPAbstractPlottable :: setSelection을 참조하십시오.
*/
QList<QCPAbstractPlottable*> QCustomPlot::selectedPlottables() const
{
  QList<QCPAbstractPlottable*> result;
  foreach (QCPAbstractPlottable *plottable, mPlottables)
  {
    if (plottable->selected())
      result.append(plottable);
  }
  return result;
}

/*!
  Returns the plottable at the pixel position \a pos. Plottables that only consist of single lines
  (like graphs) have a tolerance band around them, see \ref setSelectionTolerance. If multiple
  plottables come into consideration, the one closest to \a pos is returned.
  
  If \a onlySelectable is true, only plottables that are selectable
  (QCPAbstractPlottable::setSelectable) are considered.
  
  If there is no plottable at \a pos, the return value is 0.
  
  \see itemAt, layoutElementAt
*/
/*!
  픽셀 위치 \ a pos에있는 plottable을 반환합니다. 단일 라인으로 만 구성된 Plotables
  (그래프 등) 주위에 공차 밴드가 있습니다. \ ref setSelectionTolerance를 참조하십시오. 다중
  plottables가 고려되면 \ pos에 가장 가까운 것이 반환됩니다.
  
  \ a onlySelectable이 true이면 선택할 수있는 plottables 만
  (QCPAbstractPlottable :: setSelectable)이 고려됩니다.
  
  \ a pos에 plottable가없는 경우 반환 값은 0입니다.
  
  \ itemAt, layoutElementAt를 참조하십시오.
*/
QCPAbstractPlottable *QCustomPlot::plottableAt(const QPointF &pos, bool onlySelectable) const
{
  QCPAbstractPlottable *resultPlottable = 0;
  double resultDistance = mSelectionTolerance; 
// only regard clicks with distances smaller than mSelectionTolerance as selections, so initialize with that value
// mSelectionTolerance보다 작은 거리의 클릭 만 선택으로 간주하므로 해당 값으로 초기화하십시오.
  
  foreach (QCPAbstractPlottable *plottable, mPlottables)
  {
    if (onlySelectable && !plottable->selectable()) // we could have also passed onlySelectable to the selectTest function, but checking here is faster, because we have access to QCPabstractPlottable::selectable
// selectTest 함수에만 selectSelectable을 전달할 수도 있었지만 QCPabstractPlottable :: selectable에 대한 액세스 권한이 있기 때문에 여기를 확인하는 것이 더 빠릅니다.
      continue;
    if ((plottable->keyAxis()->axisRect()->rect() & plottable->valueAxis()->axisRect()->rect()).contains(pos.toPoint())) // only consider clicks inside the rect that is spanned by the plottable's key/value axes
     // 단지 (plottable-> keyAxis () 플롯 테이블의 키 / 값 축에 걸쳐있는 사각형 내부의 클릭을 고려하십시오.
    {
      double currentDistance = plottable->selectTest(pos, false);
      if (currentDistance >= 0 && currentDistance < resultDistance)
      {
        resultPlottable = plottable;
        resultDistance = currentDistance;
      }
    }
  }
  
  return resultPlottable;
}

/*!
  Returns whether this QCustomPlot instance contains the \a plottable.
*/
/*!
  이 QCustomPlot 인스턴스에 \ a 플롯 테이블이 포함되는지 여부를 반환합니다.
*/
bool QCustomPlot::hasPlottable(QCPAbstractPlottable *plottable) const
{
  return mPlottables.contains(plottable);
}

/*!
  Returns the graph with \a index. If the index is invalid, returns 0.
  
  There is an overloaded version of this function with no parameter which returns the last created
  graph, see QCustomPlot::graph()
  
  \see graphCount, addGraph
*/
/*!
  \ a 인덱스를 가지는 그래프를 돌려줍니다. 색인이 유효하지 않으면 0을 리턴합니다.
  
  마지막으로 생성 된 매개 변수를 반환하는 매개 변수없이이 함수가 오버로드 된 버전이 있습니다.
  그래프, QCustomPlot :: graph ()를 참조하십시오.
  
  \ 그래프 카운트보기, addGraph
*/
QCPGraph *QCustomPlot::graph(int index) const
{
  if (index >= 0 && index < mGraphs.size())
  {
    return mGraphs.at(index);
  } else
  {
    qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;
    return 0;
  }
}

/*! \overload
  
  Returns the last graph, that was created with \ref addGraph. If there are no graphs in the plot,
  returns 0.
  
  \see graphCount, addGraph
*/
/*! \초과 적재
  
  \ ref addGraph로 생성 된 마지막 그래프를 반환합니다. 그래프에 그래프가없는 경우,
  0을 반환합니다.
  
  \ 그래프 카운트보기, addGraph
*/
QCPGraph *QCustomPlot::graph() const
{
  if (!mGraphs.isEmpty())
  {
    return mGraphs.last();
  } else
    return 0;
}

/*!
  Creates a new graph inside the plot. If \a keyAxis and \a valueAxis are left unspecified (0), the
  bottom (xAxis) is used as key and the left (yAxis) is used as value axis. If specified, \a
  keyAxis and \a valueAxis must reside in this QCustomPlot.
  
  \a keyAxis will be used as key axis (typically "x") and \a valueAxis as value axis (typically
  "y") for the graph.
  
  Returns a pointer to the newly created graph, or 0 if adding the graph failed.
  
  \see graph, graphCount, removeGraph, clearGraphs
*/
/*!
  플롯 안에 새로운 그래프를 만듭니다. \ a keyAxis 및 \ a valueAxis를 지정하지 않으면 (0),
  하단 (xAxis)은 키로 사용되고 왼쪽 (yAxis)은 값 축으로 사용됩니다. 지정되면 \ a
  keyAxis 및 \ valueAxis는이 QCustomPlot에 있어야합니다.
  
  \ keyAxis는 키 축 (일반적으로 "x")으로 사용되며 \ a valueAx는 값 축 (일반적으로 "
  "y").
  
  새로 생성 된 그래프에 대한 포인터를 반환합니다. 그래프를 추가하지 않으면 0을 반환합니다.
  
  \ 그래프보기, graphCount, removeGraph, clearGraphs
*/
QCPGraph *QCustomPlot::addGraph(QCPAxis *keyAxis, QCPAxis *valueAxis)
{
  if (!keyAxis) keyAxis = xAxis;
  if (!valueAxis) valueAxis = yAxis;
  if (!keyAxis || !valueAxis)
  {
    qDebug() << Q_FUNC_INFO << "can't use default QCustomPlot xAxis or yAxis, because at least one is invalid (has been deleted)";
    return 0;
  }
  if (keyAxis->parentPlot() != this || valueAxis->parentPlot() != this)
  {
    qDebug() << Q_FUNC_INFO << "passed keyAxis or valueAxis doesn't have this QCustomPlot as parent";
    return 0;
  }
  
  QCPGraph *newGraph = new QCPGraph(keyAxis, valueAxis);
  newGraph->setName(QLatin1String("Graph ")+QString::number(mGraphs.size()));
  return newGraph;
}

/*!
  Removes the specified \a graph from the plot and deletes it. If necessary, the corresponding
  legend item is also removed from the default legend (QCustomPlot::legend). If any other graphs in
  the plot have a channel fill set towards the removed graph, the channel fill property of those
  graphs is reset to zero (no channel fill).
  
  Returns true on success.
  
  \see clearGraphs
*/
/*!
  플롯에서 지정된 \ 그래프를 제거하고 삭제합니다. 필요한 경우 해당하는
  범례 항목은 기본 범례 (QCustomPlot :: legend)에서도 제거됩니다. 다른 그래프가
  그 플롯은 제거 된 그래프쪽으로 채널 채우기 세트를 가지며, 채널 채우기 속성은
  그래프는 0으로 재설정됩니다 (채널 채우기 없음).
  
  성공하면 true를 반환합니다.
  
  \ clearGraphs보기
*/
bool QCustomPlot::removeGraph(QCPGraph *graph)
{
  return removePlottable(graph);
}

/*! \overload
  
  Removes and deletes the graph by its \a index.
*/
/*! \초과 적재
  
  \ a 인덱스에 의해 그래프를 삭제 해, 삭제합니다.
*/
bool QCustomPlot::removeGraph(int index)
{
  if (index >= 0 && index < mGraphs.size())
    return removeGraph(mGraphs[index]);
  else
    return false;
}

/*!
  Removes all graphs from the plot and deletes them. Corresponding legend items are also removed
  from the default legend (QCustomPlot::legend).

  Returns the number of graphs removed.
  
  \see removeGraph
*/
/*!
  플롯에서 모든 그래프를 제거하고 그래프를 삭제합니다. 해당 범례 항목도 제거됩니다.
  기본 범례 (QCustomPlot :: legend)에서 가져옵니다.

  삭제 된 그래프의 수를 돌려줍니다.
  
  \ removeGraph를 보아라.
*/
int QCustomPlot::clearGraphs()
{
  int c = mGraphs.size();
  for (int i=c-1; i >= 0; --i)
    removeGraph(mGraphs[i]);
  return c;
}

/*!
  Returns the number of currently existing graphs in the plot
  
  \see graph, addGraph
*/
/*!
  플롯에서 현재 존재하는 그래프의 수를 반환합니다.
  
  \ 그래프 그래프보기, addGraph
*/
int QCustomPlot::graphCount() const
{
  return mGraphs.size();
}

/*!
  Returns a list of the selected graphs. If no graphs are currently selected, the list is empty.
  
  If you are not only interested in selected graphs but other plottables like QCPCurve, QCPBars,
  etc., use \ref selectedPlottables.
  
  \see setInteractions, selectedPlottables, QCPAbstractPlottable::setSelectable, QCPAbstractPlottable::setSelection
*/
/*!
  선택된 그래프의리스트를 돌려줍니다. 현재 선택된 그래프가 없으면 목록은 비어 있습니다.
  
  선택된 그래프에 관심이있을뿐만 아니라 QCPCurve, QCPBars,
  \ ref selectedPlottables를 사용하십시오.
  
  \ setInteractions, selectedPlottables, QCPAbstractPlottable :: setSelectable, QCPAbstractPlottable :: setSelection을 참조하십시오.
*/
QList<QCPGraph*> QCustomPlot::selectedGraphs() const
{
  QList<QCPGraph*> result;
  foreach (QCPGraph *graph, mGraphs)
  {
    if (graph->selected())
      result.append(graph);
  }
  return result;
}

/*!
  Returns the item with \a index. If the index is invalid, returns 0.
  
  There is an overloaded version of this function with no parameter which returns the last added
  item, see QCustomPlot::item()
  
  \see itemCount
*/
/*!
  \ a 인덱스가있는 항목을 반환합니다. 색인이 유효하지 않으면 0을 리턴합니다.
  
  마지막으로 추가 된 항목을 반환하는 매개 변수가없는이 함수의 오버로드 된 버전이 있습니다.
  QCustomPlot :: item ()을 (를) 참조하십시오.
  
  \ 참조 itemCount
*/
QCPAbstractItem *QCustomPlot::item(int index) const
{
  if (index >= 0 && index < mItems.size())
  {
    return mItems.at(index);
  } else
  {
    qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;
    return 0;
  }
}

/*! \overload
  
  Returns the last item that was added to this plot. If there are no items in the plot,
  returns 0.
  
  \see itemCount
*/
/*! \초과 적재
  
  이 플롯에 추가 된 마지막 항목을 리턴합니다. 플롯에 항목이없는 경우,
  0을 반환합니다.
  
  \ 참조 itemCount
*/
QCPAbstractItem *QCustomPlot::item() const
{
  if (!mItems.isEmpty())
  {
    return mItems.last();
  } else
    return 0;
}

/*!
  Removes the specified item from the plot and deletes it.
  
  Returns true on success.
  
  \see clearItems
*/
/*!
  플롯에서 지정된 항목을 제거하고 삭제합니다.
  
  성공하면 true를 반환합니다.
  
  \ see clearItems
*/
bool QCustomPlot::removeItem(QCPAbstractItem *item)
{
  if (mItems.contains(item))
  {
    delete item;
    mItems.removeOne(item);
    return true;
  } else
  {
    qDebug() << Q_FUNC_INFO << "item not in list:" << reinterpret_cast<quintptr>(item);
    return false;
  }
}

/*! \overload
  
  Removes and deletes the item by its \a index.
*/
/*! \초과 적재
  
  \ a 인덱스로 항목을 제거하고 삭제합니다.
*/
bool QCustomPlot::removeItem(int index)
{
  if (index >= 0 && index < mItems.size())
    return removeItem(mItems[index]);
  else
  {
    qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;
    return false;
  }
}

/*!
  Removes all items from the plot and deletes them.
  
  Returns the number of items removed.
  
  \see removeItem
*/
/*!
  플롯에서 모든 항목을 제거하고 삭제합니다.
  
  삭제 된 항목의 수를 돌려줍니다.
  
  \ see removeItem
*/
int QCustomPlot::clearItems()
{
  int c = mItems.size();
  for (int i=c-1; i >= 0; --i)
    removeItem(mItems[i]);
  return c;
}

/*!
  Returns the number of currently existing items in the plot
  
  \see item
*/
/*!
  플롯에서 현재 존재하는 항목의 수를 반환합니다.
  
  \ 항목보기
*/
int QCustomPlot::itemCount() const
{
  return mItems.size();
}

/*!
  Returns a list of the selected items. If no items are currently selected, the list is empty.
  
  \see setInteractions, QCPAbstractItem::setSelectable, QCPAbstractItem::setSelected
*/
/*!
  선택한 항목의 목록을 반환합니다. 현재 선택된 항목이 없으면 목록은 비어 있습니다.
  
  \ setInteractions, QCPAbstractItem :: setSelectable, QCPAbstractItem :: setSelected를 참조하십시오.
*/
QList<QCPAbstractItem*> QCustomPlot::selectedItems() const
{
  QList<QCPAbstractItem*> result;
  foreach (QCPAbstractItem *item, mItems)
  {
    if (item->selected())
      result.append(item);
  }
  return result;
}

/*!
  Returns the item at the pixel position \a pos. Items that only consist of single lines (e.g. \ref
  QCPItemLine or \ref QCPItemCurve) have a tolerance band around them, see \ref
  setSelectionTolerance. If multiple items come into consideration, the one closest to \a pos is
  returned.
  
  If \a onlySelectable is true, only items that are selectable (QCPAbstractItem::setSelectable) are
  considered.
  
  If there is no item at \a pos, the return value is 0.
  
  \see plottableAt, layoutElementAt

*/
/*!
  픽셀 위치 \ a pos에있는 항목을 반환합니다. 한 줄로 만 구성된 항목 (예 : \ ref
  QCPItemLine 또는 \ ref QCPItemCurve)에 공백이 있습니다. \ ref
  setSelectionTolerance. 여러 항목이 고려되면 \ a pos에 가장 가까운 항목이
  반환되었습니다.
  
  \ a onlySelectable이 true이면 선택할 수있는 항목 (QCPAbstractItem :: setSelectable) 만
  깊이 생각한.
  
  \ a pos에 항목이 없으면 반환 값은 0입니다.
  
  \ plottableAt, layoutElementAt를 참조하십시오.
*/
QCPAbstractItem *QCustomPlot::itemAt(const QPointF &pos, bool onlySelectable) const
{
  QCPAbstractItem *resultItem = 0;
  double resultDistance = mSelectionTolerance; 
// only regard clicks with distances smaller than mSelectionTolerance as selections, so initialize with that value
// mSelectionTolerance보다 작은 거리의 클릭 만 선택으로 간주하므로 해당 값으로 초기화하십시오.
  
  foreach (QCPAbstractItem *item, mItems)
  {
    if (onlySelectable && !item->selectable()) // we could have also passed onlySelectable to the selectTest function, but checking here is faster, because we have access to QCPAbstractItem::selectable
// selectTest 함수에 onlySelectable을 전달할 수도 있었지만 QCPAbstractItem :: selectable에 대한 액세스 권한이 있기 때문에 여기를 검사하는 것이 더 빠릅니다.
      continue;
    if (!item->clipToAxisRect() || item->clipRect().contains(pos.toPoint())) 
// only consider clicks inside axis cliprect of the item if actually clipped to it
// 실제로 클리핑 된 경우 항목의 축 클립 고정 내부의 클릭 만 고려합니다
    {
      double currentDistance = item->selectTest(pos, false);
      if (currentDistance >= 0 && currentDistance < resultDistance)
      {
        resultItem = item;
        resultDistance = currentDistance;
      }
    }
  }
  
  return resultItem;
}

/*!
  Returns whether this QCustomPlot contains the \a item.
  
  \see item
*/
/*!
  이 QCustomPlot에 \ a 항목이 포함되어 있는지 여부를 반환합니다.
  
  \ 항목보기
*/
bool QCustomPlot::hasItem(QCPAbstractItem *item) const
{
  return mItems.contains(item);
}

/*!
  Returns the layer with the specified \a name. If there is no layer with the specified name, 0 is
  returned.
  
  Layer names are case-sensitive.
  
  \see addLayer, moveLayer, removeLayer
*/
/*!
  지정된 \ a 이름을 가진 레이어를 반환합니다. 지정된 이름의 레이어가없는 경우 0입니다.
  반환되었습니다.
  
  레이어 이름은 대소 문자를 구분합니다.
  
  \ addLayer, moveLayer, removeLayer를 참조하십시오.
*/
QCPLayer *QCustomPlot::layer(const QString &name) const
{
  foreach (QCPLayer *layer, mLayers)
  {
    if (layer->name() == name)
      return layer;
  }
  return 0;
}

/*! \overload
  
  Returns the layer by \a index. If the index is invalid, 0 is returned.
  
  \see addLayer, moveLayer, removeLayer
*/
/*! \초과 적재
  
  \ a 인덱스로 레이어를 반환합니다. 색인이 유효하지 않으면 0이 리턴됩니다.
  
  \ addLayer, moveLayer, removeLayer를 참조하십시오.
*/
QCPLayer *QCustomPlot::layer(int index) const
{
  if (index >= 0 && index < mLayers.size())
  {
    return mLayers.at(index);
  } else
  {
    qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;
    return 0;
  }
}

/*!
  Returns the layer that is set as current layer (see \ref setCurrentLayer).
*/
/*!
  현재 레이어로 설정된 레이어를 반환합니다 (\ ref setCurrentLayer 참조).
*/
QCPLayer *QCustomPlot::currentLayer() const
{
  return mCurrentLayer;
}

/*!
  Sets the layer with the specified \a name to be the current layer. All layerables (\ref
  QCPLayerable), e.g. plottables and items, are created on the current layer.
  
  Returns true on success, i.e. if there is a layer with the specified \a name in the QCustomPlot.
  
  Layer names are case-sensitive.
  
  \see addLayer, moveLayer, removeLayer, QCPLayerable::setLayer
*/
/*!
  지정된 \ a 이름을 가진 레이어를 현재 레이어로 설정합니다. 모든 레이어 가능 파일 (\ ref
  QCPLayerable) (예 : 플롯 테이블 및 항목)은 현재 레이어에 만들어집니다.
  
  성공시, 즉 QCustomPlot에 지정된 \ a 이름을 가진 레이어가있는 경우 true를 반환합니다.
  
  레이어 이름은 대소 문자를 구분합니다.
  
  \ addLayer, moveLayer, removeLayer, QCPLayerable :: setLayer를 참조하십시오.
*/

bool QCustomPlot::setCurrentLayer(const QString &name)
{
  if (QCPLayer *newCurrentLayer = layer(name))
  {
    return setCurrentLayer(newCurrentLayer);
  } else
  {
    qDebug() << Q_FUNC_INFO << "layer with name doesn't exist:" << name;
    return false;
  }
}

/*! \overload
  
  Sets the provided \a layer to be the current layer.
  
  Returns true on success, i.e. when \a layer is a valid layer in the QCustomPlot.
  
  \see addLayer, moveLayer, removeLayer
*/
/*! \초과 적재
  
  제공된 \ a 레이어를 현재 레이어로 설정합니다.
  
  성공하면 true를 반환합니다. 즉, 레이어가 QCustomPlot의 유효한 레이어 인 경우를 반환합니다.
  
  \ addLayer, moveLayer, removeLayer를 참조하십시오.
*/
bool QCustomPlot::setCurrentLayer(QCPLayer *layer)
{
  if (!mLayers.contains(layer))
  {
    qDebug() << Q_FUNC_INFO << "layer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(layer);
    return false;
  }
  
  mCurrentLayer = layer;
  return true;
}

/*!
  Returns the number of currently existing layers in the plot
  
  \see layer, addLayer
*/
/*!
  플롯에서 현재 존재하는 레이어의 수를 반환합니다.
  
  \ see layer, addLayer
*/
int QCustomPlot::layerCount() const
{
  return mLayers.size();
}

/*!
  Adds a new layer to this QCustomPlot instance. The new layer will have the name \a name, which
  must be unique. Depending on \a insertMode, it is positioned either below or above \a otherLayer.
  
  Returns true on success, i.e. if there is no other layer named \a name and \a otherLayer is a
  valid layer inside this QCustomPlot.
  
  If \a otherLayer is 0, the highest layer in the QCustomPlot will be used.
  
  For an explanation of what layers are in QCustomPlot, see the documentation of \ref QCPLayer.
  
  \see layer, moveLayer, removeLayer
*/
/*!
  이 QCustomPlot 인스턴스에 새 레이어를 추가합니다. 새 레이어의 이름은 \ a이며,
  특별해야 해. \ insertMode에 따라 \ otherLayer 아래 또는 위에 배치됩니다.
  
  성공하면 true를 반환합니다. 즉, \ a라는 이름의 다른 레이어가없고 \ a otherLayer가
  이 QCustomPlot 내부의 유효한 레이어
  
  \ otherLayer가 0이면 QCustomPlot의 최상위 계층이 사용됩니다.
  
  QCustomPlot의 레이어에 대한 설명은 \ ref QCPLayer의 설명서를 참조하십시오.
  
  \ see layer, moveLayer, removeLayer
*/
bool QCustomPlot::addLayer(const QString &name, QCPLayer *otherLayer, QCustomPlot::LayerInsertMode insertMode)
{
  if (!otherLayer)
    otherLayer = mLayers.last();
  if (!mLayers.contains(otherLayer))
  {
    qDebug() << Q_FUNC_INFO << "otherLayer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(otherLayer);
    return false;
  }
  if (layer(name))
  {
    qDebug() << Q_FUNC_INFO << "A layer exists already with the name" << name;
    return false;
  }
    
  QCPLayer *newLayer = new QCPLayer(this, name);
  mLayers.insert(otherLayer->index() + (insertMode==limAbove ? 1:0), newLayer);
  updateLayerIndices();
  setupPaintBuffers(); // associates new layer with the appropriate paint buffer
                       // 새로운 레이어를 적절한 페인트 버퍼와 연관시킨다.
  return true;   
}

/*!
  Removes the specified \a layer and returns true on success.
  
  All layerables (e.g. plottables and items) on the removed layer will be moved to the layer below
  \a layer. If \a layer is the bottom layer, the layerables are moved to the layer above. In both
  cases, the total rendering order of all layerables in the QCustomPlot is preserved.
  
  If \a layer is the current layer (\ref setCurrentLayer), the layer below (or above, if bottom
  layer) becomes the new current layer.
  
  It is not possible to remove the last layer of the plot.
  
  \see layer, addLayer, moveLayer
*/
/*!
  지정된 \ a 레이어를 제거하고 성공하면 true를 반환합니다.
  
  제거 된 레이어의 모든 레이어 가능 항목 (예 : 플롯 테이블 및 항목)은 아래 레이어로 이동합니다.
  \ 레이어. 레이어가 맨 아래 레이어 인 경우 레이어 가능 항목이 위의 레이어로 이동합니다. 둘다
  QCustomPlot의 모든 레이어 가능 요소의 전체 렌더링 순서가 유지됩니다.
  
  \ a 레이어가 현재 레이어 (\ ref setCurrentLayer) 인 경우, 아래 레이어 (또는 위
  레이어)가 새로운 현재 레이어가됩니다.
  
  플롯의 마지막 레이어를 제거 할 수 없습니다.
  
  \ see layer, addLayer, moveLayer
*/
bool QCustomPlot::removeLayer(QCPLayer *layer)
{
  if (!mLayers.contains(layer))
  {
    qDebug() << Q_FUNC_INFO << "layer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(layer);
    return false;
  }
  if (mLayers.size() < 2)
  {
    qDebug() << Q_FUNC_INFO << "can't remove last layer";
    return false;
  }
  
  // append all children of this layer to layer below (if this is lowest layer, prepend to layer above)
  //이 레이어의 모든 자식을 아래의 레이어에 추가합니다 (이 레이어가 최하위 레이어 인 경우 위의 레이어 앞에 추가).
  int removedIndex = layer->index();
  bool isFirstLayer = removedIndex==0;
  QCPLayer *targetLayer = isFirstLayer ? mLayers.at(removedIndex+1) : mLayers.at(removedIndex-1);
  QList<QCPLayerable*> children = layer->children();
  if (isFirstLayer) // prepend in reverse order (so order relative to each other stays the same)
                    // 반대 순서로 앞에 붙입니다. (서로 상대적인 순서는 동일하게 유지됩니다)
  {
    for (int i=children.size()-1; i>=0; --i)
      children.at(i)->moveToLayer(targetLayer, true);
  } else  // append normally
          // 정상적으로 추가
  {
    for (int i=0; i<children.size(); ++i)
      children.at(i)->moveToLayer(targetLayer, false);
  }
  // if removed layer is current layer, change current layer to layer below/above:
  // 제거 된 레이어가 현재 레이어 인 경우 현재 레이어를 아래 / 위의 레이어로 변경합니다.
  if (layer == mCurrentLayer)
    setCurrentLayer(targetLayer);
  // invalidate the paint buffer that was responsible for this layer:
  //이 레이어를 담당 한 페인트 버퍼를 무효화합니다.
  if (!layer->mPaintBuffer.isNull())
    layer->mPaintBuffer.data()->setInvalidated();
  // remove layer:
  // 레이어 삭제 :
  delete layer;
  mLayers.removeOne(layer);
  updateLayerIndices();
  return true;
}

/*!
  Moves the specified \a layer either above or below \a otherLayer. Whether it's placed above or
  below is controlled with \a insertMode.
  
  Returns true on success, i.e. when both \a layer and \a otherLayer are valid layers in the
  QCustomPlot.
  
  \see layer, addLayer, moveLayer
*/
/*!
  지정된 \ a 레이어를 \ otherLayer 위나 아래로 이동합니다. 그것이 위 또는
  아래는 \ a insertMode로 제어됩니다.
  
  성공시 true를 반환합니다. 즉, \ a layer와 \ otherLayer가 둘 다 유효한 레이어 인 경우
  QCustomPlot.
  
  \ see layer, addLayer, moveLayer
*/
bool QCustomPlot::moveLayer(QCPLayer *layer, QCPLayer *otherLayer, QCustomPlot::LayerInsertMode insertMode)
{
  if (!mLayers.contains(layer))
  {
    qDebug() << Q_FUNC_INFO << "layer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(layer);
    return false;
  }
  if (!mLayers.contains(otherLayer))
  {
    qDebug() << Q_FUNC_INFO << "otherLayer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(otherLayer);
    return false;
  }
  
  if (layer->index() > otherLayer->index())
    mLayers.move(layer->index(), otherLayer->index() + (insertMode==limAbove ? 1:0));
  else if (layer->index() < otherLayer->index())
    mLayers.move(layer->index(), otherLayer->index() + (insertMode==limAbove ? 0:-1));
  
  // invalidate the paint buffers that are responsible for the layers:
  // 레이어를 담당하는 페인트 버퍼를 무효화합니다.
  if (!layer->mPaintBuffer.isNull())
    layer->mPaintBuffer.data()->setInvalidated();
  if (!otherLayer->mPaintBuffer.isNull())
    otherLayer->mPaintBuffer.data()->setInvalidated();
  
  updateLayerIndices();
  return true;
}

/*!
  Returns the number of axis rects in the plot.
  
  All axis rects can be accessed via QCustomPlot::axisRect().
  
  Initially, only one axis rect exists in the plot.
  
  \see axisRect, axisRects
*/
/*!
  플롯에서 축 rect의 수를 반환합니다.
  
  QCustomPlot :: axisRect ()를 통해 모든 축 rect에 액세스 할 수 있습니다.
  
  처음에는 플롯에 하나의 축 rect 만 존재합니다.
  
  \ see axisRect, axisRects
*/
int QCustomPlot::axisRectCount() const
{
  return axisRects().size();
}

/*!
  Returns the axis rect with \a index.
  
  Initially, only one axis rect (with index 0) exists in the plot. If multiple axis rects were
  added, all of them may be accessed with this function in a linear fashion (even when they are
  nested in a layout hierarchy or inside other axis rects via QCPAxisRect::insetLayout).
  
  \see axisRectCount, axisRects
*/
/*!
  \ a 인덱스를 가지는 축 rect를 돌려줍니다.
  
  처음에는 플롯에 하나의 축 rect (인덱스 0 포함) 만 존재합니다. 여러 축 rect가있는 경우
  추가 된 모든 함수는 선형 함수 (이 함수를 사용하여 액세스 할 수 있습니다.
  QCPAxisRect :: insetLayout을 통해 레이아웃 계층 또는 다른 축 내부에 중첩됩니다.
  
  \ see axisRectCount, axisRects
*/
QCPAxisRect *QCustomPlot::axisRect(int index) const
{
  const QList<QCPAxisRect*> rectList = axisRects();
  if (index >= 0 && index < rectList.size())
  {
    return rectList.at(index);
  } else
  {
    qDebug() << Q_FUNC_INFO << "invalid axis rect index" << index;
    return 0;
  }
}

/*!
  Returns all axis rects in the plot.
  
  \see axisRectCount, axisRect
*/
/*!
  플롯에서 모든 축 rects를 반환합니다.
  
  \ see axisRectCount, axisRect
*/
QList<QCPAxisRect*> QCustomPlot::axisRects() const
{
  QList<QCPAxisRect*> result;
  QStack<QCPLayoutElement*> elementStack;
  if (mPlotLayout)
    elementStack.push(mPlotLayout);
  
  while (!elementStack.isEmpty())
  {
    foreach (QCPLayoutElement *element, elementStack.pop()->elements(false))
    {
      if (element)
      {
        elementStack.push(element);
        if (QCPAxisRect *ar = qobject_cast<QCPAxisRect*>(element))
          result.append(ar);
      }
    }
  }
  
  return result;
}

/*!
  Returns the layout element at pixel position \a pos. If there is no element at that position,
  returns 0.
  
  Only visible elements are used. If \ref QCPLayoutElement::setVisible on the element itself or on
  any of its parent elements is set to false, it will not be considered.
  
  \see itemAt, plottableAt
*/
/*!
  픽셀 위치 \ a pos에있는 레이아웃 요소를 반환합니다. 그 위치에 요소가없는 경우,
  0을 반환합니다.
  
  표시되는 요소 만 사용됩니다. 요소 자체의 \ ref QCPLayoutElement :: setVisible 또는
  부모 요소 중 하나라도 false로 설정되면 고려되지 않습니다.
  
  \ itemAt, plottableAt를 참조하십시오.
*/
QCPLayoutElement *QCustomPlot::layoutElementAt(const QPointF &pos) const
{
  QCPLayoutElement *currentElement = mPlotLayout;
  bool searchSubElements = true;
  while (searchSubElements && currentElement)
  {
    searchSubElements = false;
    foreach (QCPLayoutElement *subElement, currentElement->elements(false))
    {
      if (subElement && subElement->realVisibility() && subElement->selectTest(pos, false) >= 0)
      {
        currentElement = subElement;
        searchSubElements = true;
        break;
      }
    }
  }
  return currentElement;
}

/*!
  Returns the layout element of type \ref QCPAxisRect at pixel position \a pos. This method ignores
  other layout elements even if they are visually in front of the axis rect (e.g. a \ref
  QCPLegend). If there is no axis rect at that position, returns 0.

  Only visible axis rects are used. If \ref QCPLayoutElement::setVisible on the axis rect itself or
  on any of its parent elements is set to false, it will not be considered.

  \see layoutElementAt
*/
/*!
  픽셀 위치 \ a pos에있는 \ ref QCPAxisRect 유형의 레이아웃 요소를 반환합니다. 이 메소드는 무시한다.
  다른 레이아웃 요소가 축 rect 앞에 시각적으로 있어도 (예 : \ ref
  QCPLegend). 그 위치에 축 rect가없는 경우는 0을 돌려줍니다.

  가시 축 rect 만 사용됩니다. 축의 rect 자체에 \ ref QCPLayoutElement :: setVisible이 있거나
  부모 요소 중 하나라도 false로 설정하면 고려되지 않습니다.

  \ layoutElementAt 참조
*/
QCPAxisRect *QCustomPlot::axisRectAt(const QPointF &pos) const
{
  QCPAxisRect *result = 0;
  QCPLayoutElement *currentElement = mPlotLayout;
  bool searchSubElements = true;
  while (searchSubElements && currentElement)
  {
    searchSubElements = false;
    foreach (QCPLayoutElement *subElement, currentElement->elements(false))
    {
      if (subElement && subElement->realVisibility() && subElement->selectTest(pos, false) >= 0)
      {
        currentElement = subElement;
        searchSubElements = true;
        if (QCPAxisRect *ar = qobject_cast<QCPAxisRect*>(currentElement))
          result = ar;
        break;
      }
    }
  }
  return result;
}

/*!
  Returns the axes that currently have selected parts, i.e. whose selection state is not \ref
  QCPAxis::spNone.
  
  \see selectedPlottables, selectedLegends, setInteractions, QCPAxis::setSelectedParts,
  QCPAxis::setSelectableParts
*/
/*!
  현재 부품을 선택한 축을 반환합니다. 즉 선택 상태가 \ ref가 아닌 축을 반환합니다.
  QCPAxis :: spNone.
  
  \ selectedPlottables, selectedLegends, setInteractions, QCPAxis :: setSelectedParts,
  QCPAxis :: setSelectableParts
*/
QList<QCPAxis*> QCustomPlot::selectedAxes() const
{
  QList<QCPAxis*> result, allAxes;
  foreach (QCPAxisRect *rect, axisRects())
    allAxes << rect->axes();
  
  foreach (QCPAxis *axis, allAxes)
  {
    if (axis->selectedParts() != QCPAxis::spNone)
      result.append(axis);
  }
  
  return result;
}

/*!
  Returns the legends that currently have selected parts, i.e. whose selection state is not \ref
  QCPLegend::spNone.
  
  \see selectedPlottables, selectedAxes, setInteractions, QCPLegend::setSelectedParts,
  QCPLegend::setSelectableParts, QCPLegend::selectedItems
*/
/*!
  현재 부품을 선택한 범례, 즉 선택 상태가 \ ref가 아닌 범례를 반환합니다.
  QCPLegend :: spNone.
  
  \ selectedPlottables, selectedAxes, setInteractions, QCPLegend :: setSelectedParts,
  QCPLegend :: setSelectableParts, QCPLegend :: selectedItems
*/
QList<QCPLegend*> QCustomPlot::selectedLegends() const
{
  QList<QCPLegend*> result;
  
  QStack<QCPLayoutElement*> elementStack;
  if (mPlotLayout)
    elementStack.push(mPlotLayout);
  
  while (!elementStack.isEmpty())
  {
    foreach (QCPLayoutElement *subElement, elementStack.pop()->elements(false))
    {
      if (subElement)
      {
        elementStack.push(subElement);
        if (QCPLegend *leg = qobject_cast<QCPLegend*>(subElement))
        {
          if (leg->selectedParts() != QCPLegend::spNone)
            result.append(leg);
        }
      }
    }
  }
  
  return result;
}

/*!
  Deselects all layerables (plottables, items, axes, legends,...) of the QCustomPlot.
  
  Since calling this function is not a user interaction, this does not emit the \ref
  selectionChangedByUser signal. The individual selectionChanged signals are emitted though, if the
  objects were previously selected.
  
  \see setInteractions, selectedPlottables, selectedItems, selectedAxes, selectedLegends
*/
/*!
  QCustomPlot의 모든 레이어 가능 요소 (플롯 테이블, 항목, 축, 범례 등)를 선택 취소합니다.
  
  이 함수를 호출하는 것은 사용자 상호 작용이 아니기 때문에 \ ref를 내 보내지 않습니다.
  selectionChangedByUser 신호입니다. 개별 selectionChanged 신호가 방출됩니다.
  개체가 이전에 선택되었습니다.
  
  \ setInteractions, selectedPlottables, selectedItems, selectedAxes, selectedLegends를 참조하십시오.
*/
void QCustomPlot::deselectAll()
{
  foreach (QCPLayer *layer, mLayers)
  {
    foreach (QCPLayerable *layerable, layer->children())
      layerable->deselectEvent(0);
  }
}

/*!
  Causes a complete replot into the internal paint buffer(s). Finally, the widget surface is
  refreshed with the new buffer contents. This is the method that must be called to make changes to
  the plot, e.g. on the axis ranges or data points of graphs, visible.

  The parameter \a refreshPriority can be used to fine-tune the timing of the replot. For example
  if your application calls \ref replot very quickly in succession (e.g. multiple independent
  functions change some aspects of the plot and each wants to make sure the change gets replotted),
  it is advisable to set \a refreshPriority to \ref QCustomPlot::rpQueuedReplot. This way, the
  actual replotting is deferred to the next event loop iteration. Multiple successive calls of \ref
  replot with this priority will only cause a single replot, avoiding redundant replots and
  improving performance.

  Under a few circumstances, QCustomPlot causes a replot by itself. Those are resize events of the
  QCustomPlot widget and user interactions (object selection and range dragging/zooming).

  Before the replot happens, the signal \ref beforeReplot is emitted. After the replot, \ref
  afterReplot is emitted. It is safe to mutually connect the replot slot with any of those two
  signals on two QCustomPlots to make them replot synchronously, it won't cause an infinite
  recursion.

  If a layer is in mode \ref QCPLayer::lmBuffered (\ref QCPLayer::setMode), it is also possible to
  replot only that specific layer via \ref QCPLayer::replot. See the documentation there for
  details.
*/
/*!
  내부 페인트 버퍼에 완전한 replot를 발생시킵니다. 마지막으로 위젯 표면은
  새 버퍼 내용으로 새로 고쳐집니다. 변경하기 위해 호출해야하는 메소드입니다.
  그래프의 축 범위 또는 데이터 포인트에 대한 플롯 (plot).

  \ refreshPriority 매개 변수를 사용하여 복제본의 타이밍을 미세 조정할 수 있습니다. 예를 들어
  응용 프로그램에서 \ ref replot을 매우 빠르게 연속적으로 호출하는 경우 (예 : 여러 독립형
  함수는 플롯의 일부 측면을 변경하고 각각은 변경 사항이 다시 채워지 길 원함)
  \ refreshPriority를 ​​\ ref QCustomPlot :: rpQueuedReplot로 설정하는 것이 좋습니다. 이렇게하면
  실제 리포팅은 다음 이벤트 루프 반복으로 연기됩니다. \ ref의 여러 차례 연속 호출
  이 우선 순위를 가진 replot은 중복 replot을 피하면서 하나의 replot을 일으키고,
  성능 향상.

  몇 가지 상황에서 QCustomPlot은 자체적으로 replot을 발생시킵니다. 그것들은 크기 조정 이벤트입니다.
  QCustomPlot 위젯 및 사용자 상호 작용 (객체 선택 및 범위 드래그 / 확대 / 축소).

  replot이 발생하기 전에 \ ref beforeReplot 신호가 방출됩니다. replot 다음에 \ ref
  afterReplot가 발생합니다. replot 슬롯을 그 둘 중 하나와 상호 연결하는 것이 안전합니다
  두 개의 QCustomPlot에 신호를 보내어 동기식으로 복제하면 무한대가 발생하지 않습니다.
  재귀.

  레이어가 모드 \ ref QCPLayer :: lmBuffered (\ ref QCPLayer :: setMode) 모드 인 경우,
  \ ref QCPLayer :: replot을 통해 특정 레이어 만 다시 채 웁니다. 해당 설명서를 참조하십시오.
  세부.
*/
void QCustomPlot::replot(QCustomPlot::RefreshPriority refreshPriority)
{
  if (refreshPriority == QCustomPlot::rpQueuedReplot)
  {
    if (!mReplotQueued)
    {
      mReplotQueued = true;
      QTimer::singleShot(0, this, SLOT(replot()));
    }
    return;
  }
  
  if (mReplotting) // incase signals loop back to replot slot
                   // 신호를 replot 슬롯으로 루프 백합니다.
    return;
  mReplotting = true;
  mReplotQueued = false;
  emit beforeReplot();
  
  updateLayout();
  // draw all layered objects (grid, axes, plottables, items, legend,...) into their buffers:
  // 모든 계층화 된 객체 (격자, 축, 플롯 테이블, 항목, 범례 등)를 버퍼로 그립니다.
  setupPaintBuffers();
  foreach (QCPLayer *layer, mLayers)
    layer->drawToPaintBuffer();
  for (int i=0; i<mPaintBuffers.size(); ++i)
    mPaintBuffers.at(i)->setInvalidated(false);
  
  if ((refreshPriority == rpRefreshHint && mPlottingHints.testFlag(QCP::phImmediateRefresh)) || refreshPriority==rpImmediateRefresh)
    repaint();
  else
    update();
  
  emit afterReplot();
  mReplotting = false;
}

/*!
  Rescales the axes such that all plottables (like graphs) in the plot are fully visible.
  
  if \a onlyVisiblePlottables is set to true, only the plottables that have their visibility set to true
  (QCPLayerable::setVisible), will be used to rescale the axes.
  
  \see QCPAbstractPlottable::rescaleAxes, QCPAxis::rescale
*/
/*!
  플롯의 모든 플롯 테이블 (그래프와 같은)이 전체적으로 표시 되도록 축을 다시 계산합니다 .
  
  \ a onlyVisiblePlottables가 true로 설정된 경우 가시성이 true로 설정된 플롯 테이블 만
  (QCPLayerable :: setVisible)은 축을 다시 스케일하는 데 사용됩니다.
  
  \ see QCPAbstractPlottable :: rescaleAxes, QCPAxis :: rescale
*/
void QCustomPlot::rescaleAxes(bool onlyVisiblePlottables)
{
  QList<QCPAxis*> allAxes;
  foreach (QCPAxisRect *rect, axisRects())
    allAxes << rect->axes();
  
  foreach (QCPAxis *axis, allAxes)
    axis->rescale(onlyVisiblePlottables);
}

/*!
  Saves a PDF with the vectorized plot to the file \a fileName. The axis ratio as well as the scale
  of texts and lines will be derived from the specified \a width and \a height. This means, the
  output will look like the normal on-screen output of a QCustomPlot widget with the corresponding
  pixel width and height. If either \a width or \a height is zero, the exported image will have the
  same dimensions as the QCustomPlot widget currently has.

  Setting \a exportPen to \ref QCP::epNoCosmetic allows to disable the use of cosmetic pens when
  drawing to the PDF file. Cosmetic pens are pens with numerical width 0, which are always drawn as
  a one pixel wide line, no matter what zoom factor is set in the PDF-Viewer. For more information
  about cosmetic pens, see the QPainter and QPen documentation.

  The objects of the plot will appear in the current selection state. If you don't want any
  selected objects to be painted in their selected look, deselect everything with \ref deselectAll
  before calling this function.

  Returns true on success.

  \warning
  \li If you plan on editing the exported PDF file with a vector graphics editor like Inkscape, it
  is advised to set \a exportPen to \ref QCP::epNoCosmetic to avoid losing those cosmetic lines
  (which might be quite many, because cosmetic pens are the default for e.g. axes and tick marks).
  \li If calling this function inside the constructor of the parent of the QCustomPlot widget
  (i.e. the MainWindow constructor, if QCustomPlot is inside the MainWindow), always provide
  explicit non-zero widths and heights. If you leave \a width or \a height as 0 (default), this
  function uses the current width and height of the QCustomPlot widget. However, in Qt, these
  aren't defined yet inside the constructor, so you would get an image that has strange
  widths/heights.

  \a pdfCreator and \a pdfTitle may be used to set the according metadata fields in the resulting
  PDF file.

  \note On Android systems, this method does nothing and issues an according qDebug warning
  message. This is also the case if for other reasons the define flag \c QT_NO_PRINTER is set.

  \see savePng, saveBmp, saveJpg, saveRastered
*/
/*!
  벡터화 된 플롯이있는 PDF를 \ fileName 파일에 저장합니다. 축 비뿐만 아니라 축척
  글자와 줄은 지정된 \ a 너비와 \ a 높이에서 파생됩니다. 즉,
  출력은 QCustomPlot 위젯의 정상적인 화면 출력과 유사합니다.
  픽셀 너비와 높이. \ a width 또는 \ a height가 0이면 내 보낸 이미지에
  현재 QCustomPlot 위젯과 동일한 크기입니다.

  \ exportpen을 \ ref로 설정 QCP :: epNoCosmetic는 화장품 펜을 사용하지 못하게 할 수 있습니다.
  PDF 파일로 그리기. 화장 용 펜은 숫자 폭 0 인 펜으로, 항상 0으로 그려집니다.
  PDF 뷰어에서 어떤 확대 / 축소 배율이 설정 되더라도 상관 없습니다. 자세한 내용은
  화장품 펜에 대한 내용은 QPainter 및 QPen 설명서를 참조하십시오.

  플롯의 객체가 현재 선택 상태로 나타납니다. 당신이 원하지 않는다면
  선택한 객체를 선택한 모양으로 그릴 때 \ ref 선택을 사용하여 모든 항목을 선택 취소하십시오.
  이 함수를 호출하기 전에.

  성공하면 true를 반환합니다.

  \경고
  \ li Inkscape와 같은 벡터 그래픽 편집기를 사용하여 내 보낸 PDF 파일을 편집하려는 경우
  그 화장품 라인을 잃지 않도록 \ exportpen을 \ ref QCP :: epNoCosmetic로 설정하는 것이 좋습니다
  (화장품 펜이 예를 들어 축과 눈금의 기본값이기 때문에 상당히 많을 수 있습니다).
  \ li QCustomPlot 위젯의 부모 생성자 안에서이 함수를 호출하면
  (즉, QCustomPlot이 MainWindow 내에있는 경우 MainWindow 생성자)는 항상 제공합니다
  명시적인 0이 아닌 너비와 높이. \ a 너비 또는 \ 높이를 0 (기본값)으로두면이
  함수는 QCustomPlot 위젯의 현재 폭과 높이를 사용합니다. 그러나 Qt에서는
  아직 생성자 안에 정의되어 있지 않으므로 이상한 이미지를 얻을 수 있습니다.
  너비 / 높이.

  \ pdfCreator 및 \ pdfTitle은 결과 메타 데이터 필드를 설정하는 데 사용할 수 있습니다
  PDF 파일.

  \ note 안드로이드 시스템에서,이 메소드는 아무것도하지 않고 qDebug 경고를 발행합니다.
  메시지. 다른 이유로 인해 플래그 \ c QT_NO_PRINTER가 설정되어있는 경우에도 마찬가지입니다.

  \ savePng, saveBmp, saveJpg, saveRastered를 참조하십시오.
*/
bool QCustomPlot::savePdf(const QString &fileName, int width, int height, QCP::ExportPen exportPen, const QString &pdfCreator, const QString &pdfTitle)
{
  bool success = false;
#ifdef QT_NO_PRINTER
  Q_UNUSED(fileName)
  Q_UNUSED(exportPen)
  Q_UNUSED(width)
  Q_UNUSED(height)
  Q_UNUSED(pdfCreator)
  Q_UNUSED(pdfTitle)
  qDebug() << Q_FUNC_INFO << "Qt was built without printer support (QT_NO_PRINTER). PDF not created.";
#else
  int newWidth, newHeight;
  if (width == 0 || height == 0)
  {
    newWidth = this->width();
    newHeight = this->height();
  } else
  {
    newWidth = width;
    newHeight = height;
  }
  
  QPrinter printer(QPrinter::ScreenResolution);
  printer.setOutputFileName(fileName);
  printer.setOutputFormat(QPrinter::PdfFormat);
  printer.setColorMode(QPrinter::Color);
  printer.printEngine()->setProperty(QPrintEngine::PPK_Creator, pdfCreator);
  printer.printEngine()->setProperty(QPrintEngine::PPK_DocumentName, pdfTitle);
  QRect oldViewport = viewport();
  setViewport(QRect(0, 0, newWidth, newHeight));
#if QT_VERSION < QT_VERSION_CHECK(5, 3, 0)
  printer.setFullPage(true);
  printer.setPaperSize(viewport().size(), QPrinter::DevicePixel);
#else
  QPageLayout pageLayout;
  pageLayout.setMode(QPageLayout::FullPageMode);
  pageLayout.setOrientation(QPageLayout::Portrait);
  pageLayout.setMargins(QMarginsF(0, 0, 0, 0));
  pageLayout.setPageSize(QPageSize(viewport().size(), QPageSize::Point, QString(), QPageSize::ExactMatch));
  printer.setPageLayout(pageLayout);
#endif
  QCPPainter printpainter;
  if (printpainter.begin(&printer))
  {
    printpainter.setMode(QCPPainter::pmVectorized);
    printpainter.setMode(QCPPainter::pmNoCaching);
    printpainter.setMode(QCPPainter::pmNonCosmetic, exportPen==QCP::epNoCosmetic);
    printpainter.setWindow(mViewport);
    if (mBackgroundBrush.style() != Qt::NoBrush &&
        mBackgroundBrush.color() != Qt::white &&
        mBackgroundBrush.color() != Qt::transparent &&
        mBackgroundBrush.color().alpha() > 0) // draw pdf background color if not white/transparent
                                              // 흰색 / 투명하지 않으면 pdf 배경색을 그립니다.
      printpainter.fillRect(viewport(), mBackgroundBrush);
    draw(&printpainter);
    printpainter.end();
    success = true;
  }
  setViewport(oldViewport);
#endif // QT_NO_PRINTER
  return success;
}

/*!
  Saves a PNG image file to \a fileName on disc. The output plot will have the dimensions \a width
  and \a height in pixels, multiplied by \a scale. If either \a width or \a height is zero, the
  current width and height of the QCustomPlot widget is used instead. Line widths and texts etc.
  are not scaled up when larger widths/heights are used. If you want that effect, use the \a scale
  parameter.

  For example, if you set both \a width and \a height to 100 and \a scale to 2, you will end up with an
  image file of size 200*200 in which all graphical elements are scaled up by factor 2 (line widths,
  texts, etc.). This scaling is not done by stretching a 100*100 image, the result will have full
  200*200 pixel resolution.

  If you use a high scaling factor, it is recommended to enable antialiasing for all elements by
  temporarily setting \ref QCustomPlot::setAntialiasedElements to \ref QCP::aeAll as this allows
  QCustomPlot to place objects with sub-pixel accuracy.

  image compression can be controlled with the \a quality parameter which must be between 0 and 100
  or -1 to use the default setting.

  The \a resolution will be written to the image file header and has no direct consequence for the
  quality or the pixel size. However, if opening the image with a tool which respects the metadata,
  it will be able to scale the image to match either a given size in real units of length (inch,
  centimeters, etc.), or the target display DPI. You can specify in which units \a resolution is
  given, by setting \a resolutionUnit. The \a resolution is converted to the format's expected
  resolution unit internally.

  Returns true on success. If this function fails, most likely the PNG format isn't supported by
  the system, see Qt docs about QImageWriter::supportedImageFormats().

  The objects of the plot will appear in the current selection state. If you don't want any selected
  objects to be painted in their selected look, deselect everything with \ref deselectAll before calling
  this function.

  If you want the PNG to have a transparent background, call \ref setBackground(const QBrush &brush)
  with no brush (Qt::NoBrush) or a transparent color (Qt::transparent), before saving.

  \warning If calling this function inside the constructor of the parent of the QCustomPlot widget
  (i.e. the MainWindow constructor, if QCustomPlot is inside the MainWindow), always provide
  explicit non-zero widths and heights. If you leave \a width or \a height as 0 (default), this
  function uses the current width and height of the QCustomPlot widget. However, in Qt, these
  aren't defined yet inside the constructor, so you would get an image that has strange
  widths/heights.

  \see savePdf, saveBmp, saveJpg, saveRastered
*/
/*!
  PNG 이미지 파일을 디스크의 \ fileName에 저장합니다. 출력 플롯의 크기는 \ a width입니다.
  및 픽셀 단위의 높이 (\ a 배율). \ a width 또는 \ a height가 0이면,
  대신 QCustomPlot 위젯의 현재 폭과 높이가 사용됩니다. 선 너비 및 텍스트 등
  더 큰 너비 / 높이가 사용될 때 크기가 조정되지 않습니다. 그 효과를 원하면 \ a 척도를 사용하십시오.
  매개 변수.

  예를 들어, \ a width와 \ a height를 모두 100으로 설정하고 \ a scale을 2로 설정하면 결국
  모든 그래픽 요소가 요소 2 (선 너비,
  텍스트 등). 이 비율 조정은 100 * 100 이미지를 늘리면 수행되지 않고 결과가 꽉 차게됩니다.
  200 * 200 픽셀 해상도.

  높은 배율 인수를 사용하는 경우 모든 요소에 대해 앤티 앨리어싱을 사용하는 것이 좋습니다.
  일시적으로 \ ref QCustomPlot :: setAntialiasedElements를 \ ref QCP :: aeAll로 설정하면 허용됩니다.
  QCustomPlot은 서브 픽셀 정확도로 객체를 배치합니다.

  이미지 압축은 0과 100 사이의 \ a 품질 매개 변수로 제어 할 수 있습니다.
  기본 설정을 사용하려면 -1을 입력하십시오.

  \ a 해상도는 이미지 파일 헤더에 기록되며 이미지 파일 헤더에 직접적인 영향은 없습니다.
  품질 또는 픽셀 크기. 그러나 메타 데이터를 존중하는 도구로 이미지를 여는 경우,
  이미지의 크기를 실제 크기의 길이 (인치,
  센티미터 등) 또는 대상 디스플레이 DPI. 해상도를 \ 단위로 지정할 수 있습니다.
  \ a resolutionUnit을 설정하여 주어집니다. \ a 해상도가 예상되는 형식으로 변환됩니다.
  내부적으로 분해능 단위.

  성공하면 true를 반환합니다. 이 함수가 실패하면 대부분의 경우 PNG 형식이 지원되지 않습니다.
  QImageWriter :: supportedImageFormats ()에 대한 Qt 문서를 참조하십시오.

  플롯의 객체가 현재 선택 상태로 나타납니다. 선택한 것을 원하지 않으면
  선택한 외양에 그려지는 객체, 호출하기 전에 \ ref 선택 해제로 모든 것을 선택 해제하십시오.
  이 함수.

  PNG에 배경이 투명하게 보이게하려면 \ ref setBackground (const QBrush & brush)를 호출합니다.
  저장하기 전에 브러시 (Qt :: NoBrush) 또는 투명한 색 (Qt :: transparent)이 없어야합니다.

  \ warning QCustomPlot 위젯의 부모 생성자 안에서이 함수를 호출하면
  (즉, QCustomPlot이 MainWindow 내에있는 경우 MainWindow 생성자)는 항상 제공합니다
  명시적인 0이 아닌 너비와 높이. \ a 너비 또는 \ 높이를 0 (기본값)으로두면이
  함수는 QCustomPlot 위젯의 현재 폭과 높이를 사용합니다. 그러나 Qt에서는
  아직 생성자 안에 정의되어 있지 않으므로 이상한 이미지를 얻을 수 있습니다.
  너비 / 높이.

  \ savePdf, saveBmp, saveJpg, saveRastered를 참조하십시오.
*/
bool QCustomPlot::savePng(const QString &fileName, int width, int height, double scale, int quality, int resolution, QCP::ResolutionUnit resolutionUnit)
{
  return saveRastered(fileName, width, height, scale, "PNG", quality, resolution, resolutionUnit);
}

/*!
  Saves a JPEG image file to \a fileName on disc. The output plot will have the dimensions \a width
  and \a height in pixels, multiplied by \a scale. If either \a width or \a height is zero, the
  current width and height of the QCustomPlot widget is used instead. Line widths and texts etc.
  are not scaled up when larger widths/heights are used. If you want that effect, use the \a scale
  parameter.

  For example, if you set both \a width and \a height to 100 and \a scale to 2, you will end up with an
  image file of size 200*200 in which all graphical elements are scaled up by factor 2 (line widths,
  texts, etc.). This scaling is not done by stretching a 100*100 image, the result will have full
  200*200 pixel resolution.

  If you use a high scaling factor, it is recommended to enable antialiasing for all elements by
  temporarily setting \ref QCustomPlot::setAntialiasedElements to \ref QCP::aeAll as this allows
  QCustomPlot to place objects with sub-pixel accuracy.

  image compression can be controlled with the \a quality parameter which must be between 0 and 100
  or -1 to use the default setting.

  The \a resolution will be written to the image file header and has no direct consequence for the
  quality or the pixel size. However, if opening the image with a tool which respects the metadata,
  it will be able to scale the image to match either a given size in real units of length (inch,
  centimeters, etc.), or the target display DPI. You can specify in which units \a resolution is
  given, by setting \a resolutionUnit. The \a resolution is converted to the format's expected
  resolution unit internally.

  Returns true on success. If this function fails, most likely the JPEG format isn't supported by
  the system, see Qt docs about QImageWriter::supportedImageFormats().

  The objects of the plot will appear in the current selection state. If you don't want any selected
  objects to be painted in their selected look, deselect everything with \ref deselectAll before calling
  this function.

  \warning If calling this function inside the constructor of the parent of the QCustomPlot widget
  (i.e. the MainWindow constructor, if QCustomPlot is inside the MainWindow), always provide
  explicit non-zero widths and heights. If you leave \a width or \a height as 0 (default), this
  function uses the current width and height of the QCustomPlot widget. However, in Qt, these
  aren't defined yet inside the constructor, so you would get an image that has strange
  widths/heights.

  \see savePdf, savePng, saveBmp, saveRastered
*/
/*!
  JPEG 이미지 파일을 디스크의 \ fileName에 저장합니다. 출력 플롯의 크기는 \ a width입니다.
  및 픽셀 단위의 높이 (\ a 배율). \ a width 또는 \ a height가 0이면,
  대신 QCustomPlot 위젯의 현재 폭과 높이가 사용됩니다. 선 너비 및 텍스트 등
  더 큰 너비 / 높이가 사용될 때 크기가 조정되지 않습니다. 그 효과를 원하면 \ a 척도를 사용하십시오.
  매개 변수.

  예를 들어, \ a width와 \ a height를 모두 100으로 설정하고 \ a scale을 2로 설정하면 결국
  모든 그래픽 요소가 요소 2 (선 너비,
  텍스트 등). 이 비율 조정은 100 * 100 이미지를 늘리면 수행되지 않고 결과가 꽉 차게됩니다.
  200 * 200 픽셀 해상도.

  높은 배율 인수를 사용하는 경우 모든 요소에 대해 앤티 앨리어싱을 사용하는 것이 좋습니다.
  일시적으로 \ ref QCustomPlot :: setAntialiasedElements를 \ ref QCP :: aeAll로 설정하면 허용됩니다.
  QCustomPlot은 서브 픽셀 정확도로 객체를 배치합니다.

  이미지 압축은 0과 100 사이의 \ a 품질 매개 변수로 제어 할 수 있습니다.
  기본 설정을 사용하려면 -1을 입력하십시오.

  \ a 해상도는 이미지 파일 헤더에 기록되며 이미지 파일 헤더에 직접적인 영향은 없습니다.
  품질 또는 픽셀 크기. 그러나 메타 데이터를 존중하는 도구로 이미지를 여는 경우,
  이미지의 크기를 실제 크기의 길이 (인치,
  센티미터 등) 또는 대상 디스플레이 DPI. 해상도를 \ 단위로 지정할 수 있습니다.
  \ a resolutionUnit을 설정하여 주어집니다. \ a 해상도가 예상되는 형식으로 변환됩니다.
  내부적으로 분해능 단위.

  성공하면 true를 반환합니다. 이 함수가 실패하면 JPEG 형식이
  QImageWriter :: supportedImageFormats ()에 대한 Qt 문서를 참조하십시오.

  플롯의 객체가 현재 선택 상태로 나타납니다. 선택한 것을 원하지 않으면
  선택한 외양에 그려지는 객체, 호출하기 전에 \ ref 선택 해제로 모든 것을 선택 해제하십시오.
  이 함수.

  \ warning QCustomPlot 위젯의 부모 생성자 안에서이 함수를 호출하면
  (즉, QCustomPlot이 MainWindow 내에있는 경우 MainWindow 생성자)는 항상 제공합니다
  명시적인 0이 아닌 너비와 높이. \ a 너비 또는 \ 높이를 0 (기본값)으로두면이
  함수는 QCustomPlot 위젯의 현재 폭과 높이를 사용합니다. 그러나 Qt에서는
  아직 생성자 안에 정의되어 있지 않으므로 이상한 이미지를 얻을 수 있습니다.
  너비 / 높이.

  \ savePdf, savePng, saveBmp, saveRastered를 참조하십시오.
*/
bool QCustomPlot::saveJpg(const QString &fileName, int width, int height, double scale, int quality, int resolution, QCP::ResolutionUnit resolutionUnit)
{
  return saveRastered(fileName, width, height, scale, "JPG", quality, resolution, resolutionUnit);
}

/*!
  Saves a BMP image file to \a fileName on disc. The output plot will have the dimensions \a width
  and \a height in pixels, multiplied by \a scale. If either \a width or \a height is zero, the
  current width and height of the QCustomPlot widget is used instead. Line widths and texts etc.
  are not scaled up when larger widths/heights are used. If you want that effect, use the \a scale
  parameter.

  For example, if you set both \a width and \a height to 100 and \a scale to 2, you will end up with an
  image file of size 200*200 in which all graphical elements are scaled up by factor 2 (line widths,
  texts, etc.). This scaling is not done by stretching a 100*100 image, the result will have full
  200*200 pixel resolution.

  If you use a high scaling factor, it is recommended to enable antialiasing for all elements by
  temporarily setting \ref QCustomPlot::setAntialiasedElements to \ref QCP::aeAll as this allows
  QCustomPlot to place objects with sub-pixel accuracy.

  The \a resolution will be written to the image file header and has no direct consequence for the
  quality or the pixel size. However, if opening the image with a tool which respects the metadata,
  it will be able to scale the image to match either a given size in real units of length (inch,
  centimeters, etc.), or the target display DPI. You can specify in which units \a resolution is
  given, by setting \a resolutionUnit. The \a resolution is converted to the format's expected
  resolution unit internally.

  Returns true on success. If this function fails, most likely the BMP format isn't supported by
  the system, see Qt docs about QImageWriter::supportedImageFormats().

  The objects of the plot will appear in the current selection state. If you don't want any selected
  objects to be painted in their selected look, deselect everything with \ref deselectAll before calling
  this function.

  \warning If calling this function inside the constructor of the parent of the QCustomPlot widget
  (i.e. the MainWindow constructor, if QCustomPlot is inside the MainWindow), always provide
  explicit non-zero widths and heights. If you leave \a width or \a height as 0 (default), this
  function uses the current width and height of the QCustomPlot widget. However, in Qt, these
  aren't defined yet inside the constructor, so you would get an image that has strange
  widths/heights.

  \see savePdf, savePng, saveJpg, saveRastered
*/
/*!
  BMP 이미지 파일을 디스크의 \ fileName에 저장합니다. 출력 플롯의 크기는 \ a width입니다.
  및 픽셀 단위의 높이 (\ a 배율). \ a width 또는 \ a height가 0이면,
  대신 QCustomPlot 위젯의 현재 폭과 높이가 사용됩니다. 선 너비 및 텍스트 등
  더 큰 너비 / 높이가 사용될 때 크기가 조정되지 않습니다. 그 효과를 원하면 \ a 척도를 사용하십시오.
  매개 변수.

  예를 들어, \ a width와 \ a height를 모두 100으로 설정하고 \ a scale을 2로 설정하면 결국
  모든 그래픽 요소가 요소 2 (선 너비,
  텍스트 등). 이 비율 조정은 100 * 100 이미지를 늘리면 수행되지 않고 결과가 꽉 차게됩니다.
  200 * 200 픽셀 해상도.

  높은 배율 인수를 사용하는 경우 모든 요소에 대해 앤티 앨리어싱을 사용하는 것이 좋습니다.
  일시적으로 \ ref QCustomPlot :: setAntialiasedElements를 \ ref QCP :: aeAll로 설정하면 허용됩니다.
  QCustomPlot은 서브 픽셀 정확도로 객체를 배치합니다.

  \ a 해상도는 이미지 파일 헤더에 기록되며 이미지 파일 헤더에 직접적인 영향은 없습니다.
  품질 또는 픽셀 크기. 그러나 메타 데이터를 존중하는 도구로 이미지를 여는 경우,
  이미지의 크기를 실제 크기의 길이 (인치,
  센티미터 등) 또는 대상 디스플레이 DPI. 해상도를 \ 단위로 지정할 수 있습니다.
  \ a resolutionUnit을 설정하여 주어집니다. \ a 해상도가 예상되는 형식으로 변환됩니다.
  내부적으로 분해능 단위.

  성공하면 true를 반환합니다. 이 함수가 실패하면 BMP 형식이
  QImageWriter :: supportedImageFormats ()에 대한 Qt 문서를 참조하십시오.

  플롯의 객체가 현재 선택 상태로 나타납니다. 선택한 것을 원하지 않으면
  선택한 외양에 그려지는 객체, 호출하기 전에 \ ref 선택 해제로 모든 것을 선택 해제하십시오.
  이 함수.

  \ warning QCustomPlot 위젯의 부모 생성자 안에서이 함수를 호출하면
  (즉, QCustomPlot이 MainWindow 내에있는 경우 MainWindow 생성자)는 항상 제공합니다
  명시적인 0이 아닌 너비와 높이. \ a 너비 또는 \ 높이를 0 (기본값)으로두면이
  함수는 QCustomPlot 위젯의 현재 폭과 높이를 사용합니다. 그러나 Qt에서는
  아직 생성자 안에 정의되어 있지 않으므로 이상한 이미지를 얻을 수 있습니다.
  너비 / 높이.

  \ savePdf, savePng, saveJpg, saveRastered를 참조하십시오.
*/
bool QCustomPlot::saveBmp(const QString &fileName, int width, int height, double scale, int resolution, QCP::ResolutionUnit resolutionUnit)
{
  return saveRastered(fileName, width, height, scale, "BMP", -1, resolution, resolutionUnit);
}

/*! \internal
  
  Returns a minimum size hint that corresponds to the minimum size of the top level layout
  (\ref plotLayout). To prevent QCustomPlot from being collapsed to size/width zero, set a minimum
  size (setMinimumSize) either on the whole QCustomPlot or on any layout elements inside the plot.
  This is especially important, when placed in a QLayout where other components try to take in as
  much space as possible (e.g. QMdiArea).
*/
/*! \내부의
  
  톱 레벨의 레이아웃의 최소 사이즈에 대응하는 최소 사이즈 힌트를 돌려줍니다.
  (\ ref plotLayout). QCustomPlot이 크기 / 너비 0으로 축소되지 않도록하려면 최소 크기
  크기 (setMinimumSize)는 전체 QCustomPlot 또는 플롯 안의 모든 레이아웃 요소에 적용됩니다.
  다른 구성 요소가 QLayout에 배치 될 때 특히 중요합니다.
  가능한 많은 공간 (예 : QMdiArea).
*/
QSize QCustomPlot::minimumSizeHint() const
{
  return mPlotLayout->minimumOuterSizeHint();
}

/*! \internal
  
  Returns a size hint that is the same as \ref minimumSizeHint.
  
*/
/*! \내부의
  
  \ ref minimumSizeHint와 같은 사이즈 힌트를 돌려줍니다.
  
*/
QSize QCustomPlot::sizeHint() const
{
  return mPlotLayout->minimumOuterSizeHint();
}

/*! \internal
  
  Event handler for when the QCustomPlot widget needs repainting. This does not cause a \ref replot, but
  draws the internal buffer on the widget surface.
*/
/*! \내부의
  
  QCustomPlot 위젯이 다시 칠해야하는 경우에 대한 이벤트 핸들러입니다. 이것은 \ ref replot을 발생시키지 않지만
  위젯 표면에 내부 버퍼를 그립니다.
*/
void QCustomPlot::paintEvent(QPaintEvent *event)
{
  Q_UNUSED(event);
  QCPPainter painter(this);
  if (painter.isActive())
  {
    painter.setRenderHint(QPainter::HighQualityAntialiasing); 
// to make Antialiasing look good if using the OpenGL graphicssystem
// OpenGL 그래픽 시스템을 사용하면 앤티 앨리어싱이 잘 보이게 만듭니다.
    if (mBackgroundBrush.style() != Qt::NoBrush)
      painter.fillRect(mViewport, mBackgroundBrush);
    drawBackground(&painter);
    for (int bufferIndex = 0; bufferIndex < mPaintBuffers.size(); ++bufferIndex)
      mPaintBuffers.at(bufferIndex)->draw(&painter);
  }
}

/*! \internal
  
  Event handler for a resize of the QCustomPlot widget. The viewport (which becomes the outer rect
  of mPlotLayout) is resized appropriately. Finally a \ref replot is performed.
*/
/*! \내부의
  
  QCustomPlot 위젯의 크기 조정을위한 이벤트 핸들러입니다. 뷰포트 (바깥 쪽 rect
  mPlotLayout)의 크기가 적절하게 조정됩니다. 마지막으로 \ ref replot이 수행됩니다.
*/
void QCustomPlot::resizeEvent(QResizeEvent *event)
{
  Q_UNUSED(event)
  // resize and repaint the buffer:
  // 버퍼의 크기를 변경하고 다시 채 웁니다.
  setViewport(rect());
  replot(rpQueuedRefresh); 
// queued refresh is important here, to prevent painting issues in some contexts (e.g. MDI subwindow)
// 일부 상황 (예 : MDI 하위 창)에서 그림 문제를 방지하기 위해 여기에서 대기열 새로 고침이 중요합니다.
}

/*! \internal
  
 Event handler for when a double click occurs. Emits the \ref mouseDoubleClick signal, then
 determines the layerable under the cursor and forwards the event to it. Finally, emits the
 specialized signals when certain objecs are clicked (e.g. \ref plottableDoubleClick, \ref
 axisDoubleClick, etc.).
 
 \see mousePressEvent, mouseReleaseEvent
*/
/*! \내부의
  
 더블 클릭이 발생한 경우의 이벤트 핸들러입니다. \ ref mouseDoubleClick 신호를 내 보낸 다음
 커서 아래의 레이어 가능을 결정하고 이벤트를 이벤트에 전달합니다. 마지막으로
 특정 객체가 클릭되면 특수 신호 (예 : \ ref plottableDoubleClick, \ ref
 axisDoubleClick 등).
 
 \ see mousePressEvent, mouseReleaseEvent
*/
void QCustomPlot::mouseDoubleClickEvent(QMouseEvent *event)
{
  emit mouseDoubleClick(event);
  mMouseHasMoved = false;
  mMousePressPos = event->pos();
  
  // determine layerable under the cursor (this event is called instead of the second press event in a double-click):
  // 커서 아래에 레이어 가능을 결정합니다 (이 이벤트는 두 번 클릭 이벤트에서 두 번째 누를 이벤트 대신 호출됩니다).
  QList<QVariant> details;
  QList<QCPLayerable*> candidates = layerableListAt(mMousePressPos, false, &details);
  for (int i=0; i<candidates.size(); ++i)
  {
    event->accept();
 // default impl of QCPLayerable's mouse events ignore the event, in that case propagate to next candidate in list
 // QCPLayerable의 마우스 이벤트의 기본 impl은 이벤트를 무시합니다.이 경우 목록의 다음 후보로 전파됩니다.
    candidates.at(i)->mouseDoubleClickEvent(event, details.at(i));
    if (event->isAccepted())
    {
      mMouseEventLayerable = candidates.at(i);
      mMouseEventLayerableDetails = details.at(i);
      break;
    }
  }
  
  // emit specialized object double click signals:
  // 특수 객체를 두 번 클릭하여 신호를 내 보냅니다.
  if (!candidates.isEmpty())
  {
    if (QCPAbstractPlottable *ap = qobject_cast<QCPAbstractPlottable*>(candidates.first()))
    {
      int dataIndex = 0;
      if (!details.first().value<QCPDataSelection>().isEmpty())
        dataIndex = details.first().value<QCPDataSelection>().dataRange().begin();
      emit plottableDoubleClick(ap, dataIndex, event);
    } else if (QCPAxis *ax = qobject_cast<QCPAxis*>(candidates.first()))
      emit axisDoubleClick(ax, details.first().value<QCPAxis::SelectablePart>(), event);
    else if (QCPAbstractItem *ai = qobject_cast<QCPAbstractItem*>(candidates.first()))
      emit itemDoubleClick(ai, event);
    else if (QCPLegend *lg = qobject_cast<QCPLegend*>(candidates.first()))
      emit legendDoubleClick(lg, 0, event);
    else if (QCPAbstractLegendItem *li = qobject_cast<QCPAbstractLegendItem*>(candidates.first()))
      emit legendDoubleClick(li->parentLegend(), li, event);
  }
  
  event->accept(); // in case QCPLayerable reimplementation manipulates event accepted state. In QWidget event system, QCustomPlot wants to accept the event.
// QCPLayerable 재 구현이 이벤트 허용 상태를 조작하는 경우에 사용합니다. QWidget 이벤트 시스템에서 QCustomPlot은 이벤트를 승인하려고합니다.

}

/*! \internal
  
  Event handler for when a mouse button is pressed. Emits the mousePress signal.

  If the current \ref setSelectionRectMode is not \ref QCP::srmNone, passes the event to the
  selection rect. Otherwise determines the layerable under the cursor and forwards the event to it.
  
  \see mouseMoveEvent, mouseReleaseEvent
*/
/*! \내부의
  
  마우스 버튼을 눌렀을 때의 이벤트 핸들러입니다. mousePress 신호를 내 보냅니다.

  현재의 \ ref setSelectionRectMode가 \ ref QCP :: srmNone이 아닌 경우, 이벤트를
  선택 rect. 그렇지 않으면 커서 아래의 레이어 가능을 결정하고 이벤트를 이벤트에 전달합니다.
  
  \ see mouseMoveEvent, mouseReleaseEvent
*/
void QCustomPlot::mousePressEvent(QMouseEvent *event)
{
  emit mousePress(event);
  // save some state to tell in releaseEvent whether it was a click:
  // release인지 여부를 알려주는 상태를 저장합니다.
  mMouseHasMoved = false;
  mMousePressPos = event->pos();
  
  if (mSelectionRect && mSelectionRectMode != QCP::srmNone)
  {
    if (mSelectionRectMode != QCP::srmZoom || qobject_cast<QCPAxisRect*>(axisRectAt(mMousePressPos))) 
// in zoom mode only activate selection rect if on an axis rect
// 확대 / 축소 모드에서 축 rect의 경우에만 선택 rect 활성화
      mSelectionRect->startSelection(event);
  } else
  {
    // no selection rect interaction, prepare for click signal emission and forward event to layerable under the cursor:
 // 선택 영역 상호 작용 없음, 클릭 신호 방출 준비 및 커서 아래의 레이어 가능 이벤트 전달 :
    QList<QVariant> details;
    QList<QCPLayerable*> candidates = layerableListAt(mMousePressPos, false, &details);
    if (!candidates.isEmpty())
    {
      mMouseSignalLayerable = candidates.first(); 
// candidate for signal emission is always topmost hit layerable (signal emitted in release event)
// 신호 방출 후보는 항상 최상위 히트 레이어 가능 (릴리스 이벤트에서 방출되는 신호)
      mMouseSignalLayerableDetails = details.first();
    }
    // forward event to topmost candidate which accepts the event:
    // 이벤트를 받아들이는 최상위 후보로 이벤트 전달 :
    for (int i=0; i<candidates.size(); ++i)
    {
      event->accept(); // default impl of QCPLayerable's mouse events call ignore() on the event, in that case propagate to next candidate in list
// QCPLayerable 마우스 이벤트의 기본 impl () 이벤트에서 ignore ()를 호출합니다.이 경우 목록의 다음 후보로 전파됩니다.
      candidates.at(i)->mousePressEvent(event, details.at(i));
      if (event->isAccepted())
      {
        mMouseEventLayerable = candidates.at(i);
        mMouseEventLayerableDetails = details.at(i);
        break;
      }
    }
  }
  
  event->accept(); // in case QCPLayerable reimplementation manipulates event accepted state. In QWidget event system, QCustomPlot wants to accept the event.
 // QCPLayerable 재 구현이 이벤트 허용 상태를 조작하는 경우에 사용합니다. QWidget 이벤트 시스템에서 QCustomPlot은 이벤트를 승인하려고합니다.
}

/*! \internal
  
  Event handler for when the cursor is moved. Emits the \ref mouseMove signal.

  If the selection rect (\ref setSelectionRect) is currently active, the event is forwarded to it
  in order to update the rect geometry.
  
  Otherwise, if a layout element has mouse capture focus (a mousePressEvent happened on top of the
  layout element before), the mouseMoveEvent is forwarded to that element.
  
  \see mousePressEvent, mouseReleaseEvent
*/
/*! \내부의
  
  커서가 이동 될 때 사용할 이벤트 핸들러입니다. \ ref mouseMove 신호를 내 보냅니다.

  선택 rect (\ ref setSelectionRect)가 현재 활성화되어 있으면 해당 이벤트가 전달됩니다
  rect 지오메트리를 업데이트합니다.
  
  그렇지 않으면 레이아웃 요소에 마우스 캡처 포커스가있는 경우 (mousePressEvent가
  layout 요소 이전에) mouseMoveEvent는 해당 요소로 전달됩니다.
  
  \ see mousePressEvent, mouseReleaseEvent
*/
void QCustomPlot::mouseMoveEvent(QMouseEvent *event)
{
  emit mouseMove(event);
  
  if (!mMouseHasMoved && (mMousePressPos-event->pos()).manhattanLength() > 3)
    mMouseHasMoved = true; // moved too far from mouse press position, don't handle as click on mouse release
                           // 마우스 누름 위치에서 너무 멀리 이동했습니다. 마우스를 놓을 때 클릭으로 처리하지 않습니다.
  if (mSelectionRect && mSelectionRect->isActive())
    mSelectionRect->moveSelection(event);
  else if (mMouseEventLayerable) // call event of affected layerable:
                                 // 영향을받은 레이어의 이벤트를 호출합니다.
    mMouseEventLayerable->mouseMoveEvent(event, mMousePressPos);
  
  event->accept(); // in case QCPLayerable reimplementation manipulates event accepted state. In QWidget event system, QCustomPlot wants to accept the event.
// QCPLayerable 재 구현이 이벤트 허용 상태를 조작하는 경우에 사용합니다. QWidget 이벤트 시스템에서 QCustomPlot은 이벤트를 승인하려고합니다.
}

/*! \internal

  Event handler for when a mouse button is released. Emits the \ref mouseRelease signal.

  If the mouse was moved less than a certain threshold in any direction since the \ref
  mousePressEvent, it is considered a click which causes the selection mechanism (if activated via
  \ref setInteractions) to possibly change selection states accordingly. Further, specialized mouse
  click signals are emitted (e.g. \ref plottableClick, \ref axisClick, etc.)

  If a layerable is the mouse capturer (a \ref mousePressEvent happened on top of the layerable
  before), the \ref mouseReleaseEvent is forwarded to that element.

  \see mousePressEvent, mouseMoveEvent
*/
/*! \내부의

  마우스 단추를 놓을 때 사용하는 이벤트 핸들러입니다. \ ref mouseRelease 신호를 내 보냅니다.

  \ ref 이후 어떤 방향 으로든 마우스가 특정 임계 값보다 작게 이동하면
  mousePressEvent, 선택 메커니즘을 유발하는 클릭으로 간주됩니다 (를 통해 활성화 된 경우).
  \ ref setInteractions) 선택 상태를 적절히 변경합니다. 또한, 특수 마우스
  클릭 신호가 방출됩니다 (예 : \ ref plottableClick, \ ref axisClick 등)

  레이어 가능 요소가 마우스 캡처자인 경우 (\ ref mousePressEvent가 레이어 가능 요소 위에 발생 함)
  before), \ ref mouseReleaseEvent는 해당 요소로 전달됩니다.

  \ see mousePressEvent, mouseMoveEvent
*/
void QCustomPlot::mouseReleaseEvent(QMouseEvent *event)
{
  emit mouseRelease(event);
  
  if (!mMouseHasMoved) // mouse hasn't moved (much) between press and release, so handle as click
                       // 마우스가 눌렀다 놓을 때 (많이) 움직이지 않았으므로 클릭으로 처리합니다.
  {
    if (mSelectionRect && mSelectionRect->isActive())
 // a simple click shouldn't successfully finish a selection rect, so cancel it here
 // 간단한 클릭으로 선택 영역을 끝내지 않아야하므로 여기에서 취소하십시오
      mSelectionRect->cancel();
    if (event->button() == Qt::LeftButton)
      processPointSelection(event);
    
    // emit specialized click signals of QCustomPlot instance:
    // QCustomPlot 인스턴스의 특수 클릭 신호를 내 보냅니다.
    if (QCPAbstractPlottable *ap = qobject_cast<QCPAbstractPlottable*>(mMouseSignalLayerable))
    {
      int dataIndex = 0;
      if (!mMouseSignalLayerableDetails.value<QCPDataSelection>().isEmpty())
        dataIndex = mMouseSignalLayerableDetails.value<QCPDataSelection>().dataRange().begin();
      emit plottableClick(ap, dataIndex, event);
    } else if (QCPAxis *ax = qobject_cast<QCPAxis*>(mMouseSignalLayerable))
      emit axisClick(ax, mMouseSignalLayerableDetails.value<QCPAxis::SelectablePart>(), event);
    else if (QCPAbstractItem *ai = qobject_cast<QCPAbstractItem*>(mMouseSignalLayerable))
      emit itemClick(ai, event);
    else if (QCPLegend *lg = qobject_cast<QCPLegend*>(mMouseSignalLayerable))
      emit legendClick(lg, 0, event);
    else if (QCPAbstractLegendItem *li = qobject_cast<QCPAbstractLegendItem*>(mMouseSignalLayerable))
      emit legendClick(li->parentLegend(), li, event);
    mMouseSignalLayerable = 0;
  }
  
  if (mSelectionRect && mSelectionRect->isActive()) 
// Note: if a click was detected above, the selection rect is canceled there
// 참고 : 위에서 클릭이 감지되면 선택 상자가 취소됩니다
  {
 // finish selection rect, the appropriate action will be taken via signal-slot connection:
 // 선택 영역을 마침으로써 신호 슬롯 연결을 통해 적절한 동작이 취해집니다.
    mSelectionRect->endSelection(event);
  } else
  {
    // call event of affected layerable:
    // 영향을받은 layerable의 이벤트를 호출합니다.
    if (mMouseEventLayerable)
    {
      mMouseEventLayerable->mouseReleaseEvent(event, mMousePressPos);
      mMouseEventLayerable = 0;
    }
  }
  
  if (noAntialiasingOnDrag())
    replot(rpQueuedReplot);
  
  event->accept(); // in case QCPLayerable reimplementation manipulates event accepted state. In QWidget event system, QCustomPlot wants to accept the event.
 // QCPLayerable 재 구현이 이벤트 허용 상태를 조작하는 경우에 사용합니다. QWidget 이벤트 시스템에서 QCustomPlot은 이벤트를 승인하려고합니다.
}

/*! \internal

  Event handler for mouse wheel events. First, the \ref mouseWheel signal is emitted. Then
  determines the affected layerable and forwards the event to it.
*/
/*! \내부의

  마우스 휠 이벤트의 이벤트 핸들러입니다. 먼저 \ ref mouseWheel 신호가 방출됩니다. 그때
  영향을받는 레이어 작성 가능을 판별하고 이벤트를 전달합니다.
*/
void QCustomPlot::wheelEvent(QWheelEvent *event)
{
  emit mouseWheel(event);
  // forward event to layerable under cursor:
  // 이벤트를 커서 아래의 레이어 가능으로 전달합니다.
  QList<QCPLayerable*> candidates = layerableListAt(event->pos(), false);
  for (int i=0; i<candidates.size(); ++i)
  {
    event->accept();
 // default impl of QCPLayerable's mouse events ignore the event, in that case propagate to next candidate in list
 // QCPLayerable의 마우스 이벤트의 기본 impl은 이벤트를 무시합니다.이 경우 목록의 다음 후보로 전파됩니다.
    candidates.at(i)->wheelEvent(event);
    if (event->isAccepted())
      break;
  }
  event->accept(); // in case QCPLayerable reimplementation manipulates event accepted state. In QWidget event system, QCustomPlot wants to accept the event.
 // QCPLayerable 재 구현이 이벤트 허용 상태를 조작하는 경우에 사용합니다. QWidget 이벤트 시스템에서 QCustomPlot은 이벤트를 승인하려고합니다.
}

/*! \internal
  
  This function draws the entire plot, including background pixmap, with the specified \a painter.
  It does not make use of the paint buffers like \ref replot, so this is the function typically
  used by saving/exporting methods such as \ref savePdf or \ref toPainter.

  Note that it does not fill the background with the background brush (as the user may specify with
  \ref setBackground(const QBrush &brush)), this is up to the respective functions calling this
  method.
*/
/*! \내부의
  
  이 함수는 background pixmap을 포함한 전체 그림을 지정된 \ painter로 그립니다.
  \ ref replot과 같은 페인트 버퍼는 사용하지 않으므로 일반적으로이 함수가 사용됩니다
  \ ref savePdf 또는 \ ref toPainter와 같은 메소드를 저장 / 내보내기하여 사용됩니다.

  배경 브러시로 배경을 채우지 않습니다 (사용자가
  \ ref setBackground (const QBrush & brush)), 이것은 이것을 호출하는 각각의 함수에 달려있다.
  방법.
*/
void QCustomPlot::draw(QCPPainter *painter)
{
  updateLayout();
  
  // draw viewport background pixmap:
  // 뷰포트 배경을 그립니다. pixmap :
  drawBackground(painter);

  // draw all layered objects (grid, axes, plottables, items, legend,...):
  // 모든 계층화 된 객체 (그리드, 축, 플롯 테이블, 항목, 범례 등)를 그립니다.
  foreach (QCPLayer *layer, mLayers)
    layer->draw(painter);
  
  /* Debug code to draw all layout element rects
  foreach (QCPLayoutElement* el, findChildren<QCPLayoutElement*>())
  {
    painter->setBrush(Qt::NoBrush);
    painter->setPen(QPen(QColor(0, 0, 0, 100), 0, Qt::DashLine));
    painter->drawRect(el->rect());
    painter->setPen(QPen(QColor(255, 0, 0, 100), 0, Qt::DashLine));
    painter->drawRect(el->outerRect());
  }
  */
  /* 모든 레이아웃 요소를 그리기위한 디버그 코드
  foreach (QCPLayoutElement * el, findChildren <QCPLayoutElement *> ())
  {
    painter-> setBrush (Qt :: NoBrush);
    painter-> setPen (QPen (QColor (0, 0, 0, 100), 0, Qt :: DashLine));
    painter-> drawRect (el-> rect ());
    painter-> setPen (QPen (QColor (255, 0, 0, 100), 0, Qt :: DashLine));
    painter-> drawRect (el-> outerRect ());
  }
  */
}

/*! \internal

  Performs the layout update steps defined by \ref QCPLayoutElement::UpdatePhase, by calling \ref
  QCPLayoutElement::update on the main plot layout.

  Here, the layout elements calculate their positions and margins, and prepare for the following
  draw call.
*/
/*! \내부의

  \ ref QCPLayoutElement :: UpdatePhase에 정의 된 레이아웃 업데이트 단계를 \ ref를 호출하여 수행합니다.
  주 플롯 레이아웃에서 QCPLayoutElement :: update.

  여기에서 레이아웃 요소는 위치와 여백을 계산하고 다음을 준비합니다.
  전화 걸기.
*/
void QCustomPlot::updateLayout()
{
  // run through layout phases:
  // 레이아웃 단계를 실행합니다.
  mPlotLayout->update(QCPLayoutElement::upPreparation);
  mPlotLayout->update(QCPLayoutElement::upMargins);
  mPlotLayout->update(QCPLayoutElement::upLayout);
}

/*! \internal
  
  Draws the viewport background pixmap of the plot.
  
  If a pixmap was provided via \ref setBackground, this function buffers the scaled version
  depending on \ref setBackgroundScaled and \ref setBackgroundScaledMode and then draws it inside
  the viewport with the provided \a painter. The scaled version is buffered in
  mScaledBackgroundPixmap to prevent expensive rescaling at every redraw. It is only updated, when
  the axis rect has changed in a way that requires a rescale of the background pixmap (this is
  dependent on the \ref setBackgroundScaledMode), or when a differend axis background pixmap was
  set.
  
  Note that this function does not draw a fill with the background brush
  (\ref setBackground(const QBrush &brush)) beneath the pixmap.
  
  \see setBackground, setBackgroundScaled, setBackgroundScaledMode
*/
/*! \내부의
  
  플롯의 뷰포트 배경 pixmap을 그립니다.
  
  \ ref setBackground를 통해 픽스맵이 제공된 경우이 함수는 크기 조정 된 버전을 버퍼링합니다.
  \ ref setBackgroundScaled 및 \ ref setBackgroundScaledMode에 따라 달라지며 내부에 그려집니다.
  제공된 \ a 페인터가있는 뷰포트. 크기가 조정 된 버전은에서 버퍼링됩니다.
  mScaledBackgroundPixmap은 모든 다시 그리기시 값 비싼 재조정을 방지합니다. 업데이트 될 때만
  축 rect는 백그라운드 pixmap의 크기 조정이 필요한 방식으로 변경되었습니다 (이것은
  \ ref setBackgroundScaledMode에 의존), 또는 differennd 축 배경 pixmap이
  세트.
  
  이 함수는 배경 브러시로 채우기를 그리지 않습니다.
  (\ ref setBackground (const QBrush & brush))를 사용하십시오.
  
  \ setBackground, setBackgroundScaled, setBackgroundScaledMode를 참조하십시오.
*/
void QCustomPlot::drawBackground(QCPPainter *painter)
{
  // Note: background color is handled in individual replot/save functions

  // draw background pixmap (on top of fill, if brush specified):
  // 참고 : 배경색은 개별 replot / save 함수에서 처리됩니다.

  // 배경 pixmap 그리기 (브러쉬가 지정된 경우 채우기 상단에 있음) :
  if (!mBackgroundPixmap.isNull())
  {
    if (mBackgroundScaled)
    {
      // check whether mScaledBackground needs to be updated:
      // mScaledBackground를 업데이트해야하는지 여부를 확인합니다.
      QSize scaledSize(mBackgroundPixmap.size());
      scaledSize.scale(mViewport.size(), mBackgroundScaledMode);
      if (mScaledBackgroundPixmap.size() != scaledSize)
        mScaledBackgroundPixmap = mBackgroundPixmap.scaled(mViewport.size(), mBackgroundScaledMode, Qt::SmoothTransformation);
      painter->drawPixmap(mViewport.topLeft(), mScaledBackgroundPixmap, QRect(0, 0, mViewport.width(), mViewport.height()) & mScaledBackgroundPixmap.rect());
    } else
    {
      painter->drawPixmap(mViewport.topLeft(), mBackgroundPixmap, QRect(0, 0, mViewport.width(), mViewport.height()));
    }
  }
}

/*! \internal

  Goes through the layers and makes sure this QCustomPlot instance holds the correct number of
  paint buffers and that they have the correct configuration (size, pixel ratio, etc.).
  Allocations, reallocations and deletions of paint buffers are performed as necessary. It also
  associates the paint buffers with the layers, so they draw themselves into the right buffer when
  \ref QCPLayer::drawToPaintBuffer is called. This means it associates adjacent \ref
  QCPLayer::lmLogical layers to a mutual paint buffer and creates dedicated paint buffers for
  layers in \ref QCPLayer::lmBuffered mode.

  This method uses \ref createPaintBuffer to create new paint buffers.

  After this method, the paint buffers are empty (filled with \c Qt::transparent) and invalidated
  (so an attempt to replot only a single buffered layer causes a full replot).

  This method is called in every \ref replot call, prior to actually drawing the layers (into their
  associated paint buffer). If the paint buffers don't need changing/reallocating, this method
  basically leaves them alone and thus finishes very fast.
*/
/*! \내부의

  레이어를 통과하여이 QCustomPlot 인스턴스가 올바른 수의
  페인트 버퍼가 있고 올바른 구성 (크기, 픽셀 비율 등)을 가졌는지 확인하십시오.
  페인트 버퍼의 할당, 재 할당 및 삭제는 필요에 따라 수행됩니다. 또한
  페인트 버퍼를 레이어와 연관 시켜서 오른쪽 버퍼에 그릴 때
  \ ref QCPLayer :: drawToPaintBuffer가 호출됩니다. 즉, 인접한 \ ref
  QCPLayer :: lmLogical 레이어를 상호 페인트 버퍼에 연결하고 전용 페인트 버퍼를 만듭니다.
  \ ref QCPLayer :: lmBuffered 모드의 레이어.

  이 메소드는 \ ref createPaintBuffer를 사용하여 새로운 페인트 버퍼를 작성합니다.

  이 메서드 후에는 페인트 버퍼가 비어 있고 (\ c Qt :: transparent로 채워짐) 무효화됩니다.
  (따라서 단일 버퍼링 된 레이어 만 다시 만들려고하면 전체 복제본이 생성됩니다).

  이 메소드는 레이어를 실제로 그리기 전에 모든 \ ref replot 호출에서 호출됩니다.
  연관된 페인트 버퍼). paint 버퍼가 변경 또는 재할인 할 필요가없는 경우,이 메소드
  기본적으로 그들을 혼자두고 매우 빨리 끝납니다.
*/
void QCustomPlot::setupPaintBuffers()
{
  int bufferIndex = 0;
  if (mPaintBuffers.isEmpty())
    mPaintBuffers.append(QSharedPointer<QCPAbstractPaintBuffer>(createPaintBuffer()));
  
  for (int layerIndex = 0; layerIndex < mLayers.size(); ++layerIndex)
  {
    QCPLayer *layer = mLayers.at(layerIndex);
    if (layer->mode() == QCPLayer::lmLogical)
    {
      layer->mPaintBuffer = mPaintBuffers.at(bufferIndex).toWeakRef();
    } else if (layer->mode() == QCPLayer::lmBuffered)
    {
      ++bufferIndex;
      if (bufferIndex >= mPaintBuffers.size())
        mPaintBuffers.append(QSharedPointer<QCPAbstractPaintBuffer>(createPaintBuffer()));
      layer->mPaintBuffer = mPaintBuffers.at(bufferIndex).toWeakRef();
      if (layerIndex < mLayers.size()-1 && mLayers.at(layerIndex+1)->mode() == QCPLayer::lmLogical)
 // not last layer, and next one is logical, so prepare another buffer for next layerables
 // 마지막 레이어가 아니라면, 다음 레이어는 논리적이므로, 다음 레이어를 위해 다른 버퍼를 준비하십시오.
      {
        ++bufferIndex;
        if (bufferIndex >= mPaintBuffers.size())
          mPaintBuffers.append(QSharedPointer<QCPAbstractPaintBuffer>(createPaintBuffer()));
      }
    }
  }
  // remove unneeded buffers:
  // 불필요한 버퍼를 제거하십시오.
  while (mPaintBuffers.size()-1 > bufferIndex)
    mPaintBuffers.removeLast();
  // resize buffers to viewport size and clear contents:
  // 버퍼 크기를 뷰포트 크기와 내용 지우기 :
  for (int i=0; i<mPaintBuffers.size(); ++i)
  {
    mPaintBuffers.at(i)->setSize(viewport().size()); // won't do anything if already correct size
                                                     // 이미 크기가 맞으면 아무것도하지 않습니다.
    mPaintBuffers.at(i)->clear(Qt::transparent);
    mPaintBuffers.at(i)->setInvalidated();
  }
}

/*! \internal

  This method is used by \ref setupPaintBuffers when it needs to create new paint buffers.

  Depending on the current setting of \ref setOpenGl, and the current Qt version, different
  backends (subclasses of \ref QCPAbstractPaintBuffer) are created, initialized with the proper
  size and device pixel ratio, and returned.
*/
/*! \내부의

  이 메소드는 새로운 페인트 버퍼를 생성 할 필요가있을 때 \ ref setupPaintBuffers에 의해 사용됩니다.

  \ ref setOpenGl의 현재 설정과 현재의 Qt 버전에 따라 다르다.
  백엔드 (\ ref QCPAbstractPaintBuffer의 서브 클래스)가 생성되고 적절한
  크기 및 장치 픽셀 비율로 변환되어 반환됩니다.
*/
QCPAbstractPaintBuffer *QCustomPlot::createPaintBuffer()
{
  if (mOpenGl)
  {
#if defined(QCP_OPENGL_FBO)
    return new QCPPaintBufferGlFbo(viewport().size(), mBufferDevicePixelRatio, mGlContext, mGlPaintDevice);
#elif defined(QCP_OPENGL_PBUFFER)
    return new QCPPaintBufferGlPbuffer(viewport().size(), mBufferDevicePixelRatio, mOpenGlMultisamples);
#else
    qDebug() << Q_FUNC_INFO << "OpenGL enabled even though no support for it compiled in, this shouldn't have happened. Falling back to pixmap paint buffer.";
    return new QCPPaintBufferPixmap(viewport().size(), mBufferDevicePixelRatio);
#endif
  } else
    return new QCPPaintBufferPixmap(viewport().size(), mBufferDevicePixelRatio);
}

/*!
  This method returns whether any of the paint buffers held by this QCustomPlot instance are
  invalidated.

  If any buffer is invalidated, a partial replot (\ref QCPLayer::replot) is not allowed and always
  causes a full replot (\ref QCustomPlot::replot) of all layers. This is the case when for example
  the layer order has changed, new layers were added, layers were removed, or layer modes were
  changed (\ref QCPLayer::setMode).

  \see QCPAbstractPaintBuffer::setInvalidated
*/
/*!
  이 메소드는이 QCustomPlot 인스턴스가 보유한 페인트 버퍼가
  무효화 됨.

  버퍼가 무효화되면 부분 복제본 (\ ref QCPLayer :: replot)이 허용되지 않고 항상
  모든 레이어의 전체 replot (\ ref QCustomPlot :: replot)이 발생합니다. 예를 들어,
  레이어 순서가 변경되거나, 새 레이어가 추가되거나, 레이어가 제거되거나, 레이어 모드가 변경되었습니다.
  변경됨 (\ ref QCPLayer :: setMode).

  \ QCPAbstractPaintBuffer :: setInvalidated를 참조하십시오.
*/
bool QCustomPlot::hasInvalidatedPaintBuffers()
{
  for (int i=0; i<mPaintBuffers.size(); ++i)
  {
    if (mPaintBuffers.at(i)->invalidated())
      return true;
  }
  return false;
}

/*! \internal

  When \ref setOpenGl is set to true, this method is used to initialize OpenGL (create a context,
  surface, paint device).

  Returns true on success.

  If this method is successful, all paint buffers should be deleted and then reallocated by calling
  \ref setupPaintBuffers, so the OpenGL-based paint buffer subclasses (\ref
  QCPPaintBufferGlPbuffer, \ref QCPPaintBufferGlFbo) are used for subsequent replots.

  \see freeOpenGl
*/
/*! \내부의

  \ ref setOpenGl이 true로 설정된 경우이 메서드는 OpenGL을 초기화하는 데 사용됩니다 (컨텍스트 만들기,
  표면, 페인트 장치).

  성공하면 true를 반환합니다.

  이 메서드가 성공하면 (자), 모든 paint 버퍼가 삭제되어 호출에 의해 재 할당됩니다.
  \ ref setupPaintBuffers, OpenGL 기반 페인트 버퍼 하위 클래스 (\ ref
  QCPPaintBufferGlPbuffer, \ ref QCPPaintBufferGlFbo)는 후속 복제에 사용됩니다.

  \ freeOpenGl 참조
*/
bool QCustomPlot::setupOpenGl()
{
#ifdef QCP_OPENGL_FBO
  freeOpenGl();
  QSurfaceFormat proposedSurfaceFormat;
  proposedSurfaceFormat.setSamples(mOpenGlMultisamples);
#ifdef QCP_OPENGL_OFFSCREENSURFACE
  QOffscreenSurface *surface = new QOffscreenSurface;
#else
  QWindow *surface = new QWindow;
  surface->setSurfaceType(QSurface::OpenGLSurface);
#endif
  surface->setFormat(proposedSurfaceFormat);
  surface->create();
  mGlSurface = QSharedPointer<QSurface>(surface);
  mGlContext = QSharedPointer<QOpenGLContext>(new QOpenGLContext);
  mGlContext->setFormat(mGlSurface->format());
  if (!mGlContext->create())
  {
    qDebug() << Q_FUNC_INFO << "Failed to create OpenGL context";
    mGlContext.clear();
    mGlSurface.clear();
    return false;
  }
  if (!mGlContext->makeCurrent(mGlSurface.data())) // context needs to be current to create paint device
                                                   // 페인트 장치를 생성하기 위해 context가 최신이어야한다.
  {   
    qDebug() << Q_FUNC_INFO << "Failed to make opengl context current";
    mGlContext.clear();
    mGlSurface.clear();
    return false;
  }
  if (!QOpenGLFramebufferObject::hasOpenGLFramebufferObjects())
  {
    qDebug() << Q_FUNC_INFO << "OpenGL of this system doesn't support frame buffer objects";
    mGlContext.clear();
    mGlSurface.clear();
    return false;
  }
  mGlPaintDevice = QSharedPointer<QOpenGLPaintDevice>(new QOpenGLPaintDevice);
  return true;
#elif defined(QCP_OPENGL_PBUFFER)
  return QGLFormat::hasOpenGL();
#else
  return false;
#endif
}

/*! \internal

  When \ref setOpenGl is set to false, this method is used to deinitialize OpenGL (releases the
  context and frees resources).

  After OpenGL is disabled, all paint buffers should be deleted and then reallocated by calling
  \ref setupPaintBuffers, so the standard software rendering paint buffer subclass (\ref
  QCPPaintBufferPixmap) is used for subsequent replots.

  \see setupOpenGl
*/
/*! \내부의

  \ ref setOpenGl이 false로 설정되면이 메서드는 OpenGL을 초기화 해제하는 데 사용됩니다 (
  컨텍스트 및 리소스를 해제합니다).

  OpenGL을 비활성화 한 후에는 모든 페인트 버퍼를 삭제 한 다음 호출하여 다시 할당해야합니다
  \ ref setupPaintBuffers, 표준 소프트웨어 렌더링 페인트 버퍼 하위 클래스 (\ ref
  QCPPaintBufferPixmap)은 후속 복제에 사용됩니다.

  \ setupOpenGl 참조
*/
void QCustomPlot::freeOpenGl()
{
#ifdef QCP_OPENGL_FBO
  mGlPaintDevice.clear();
  mGlContext.clear();
  mGlSurface.clear();
#endif
}

/*! \internal
  
  This method is used by \ref QCPAxisRect::removeAxis to report removed axes to the QCustomPlot
  so it may clear its QCustomPlot::xAxis, yAxis, xAxis2 and yAxis2 members accordingly.
*/
/*! \내부의
  
  이 메소드는 \ ref QCPAxisRect :: removeAxis에 의해 제거 된 축을 QCustomPlot에보고하기 위해 사용됩니다
  QCustomPlot :: xAxis, yAxis, xAxis2 및 yAxis2 멤버를 적절하게 지울 수 있습니다.
*/
void QCustomPlot::axisRemoved(QCPAxis *axis)
{
  if (xAxis == axis)
    xAxis = 0;
  if (xAxis2 == axis)
    xAxis2 = 0;
  if (yAxis == axis)
    yAxis = 0;
  if (yAxis2 == axis)
    yAxis2 = 0;
  
  // Note: No need to take care of range drag axes and range zoom axes, because they are stored in smart pointers
  // 참고 : 스마트 포인터에 저장되어 있기 때문에 범위 드래그 축 및 범위 줌 축을 처리 할 필요가 없습니다.
}

/*! \internal
  
  This method is used by the QCPLegend destructor to report legend removal to the QCustomPlot so
  it may clear its QCustomPlot::legend member accordingly.
*/
/*! \내부의
  
  이 메서드는 QCPLegend 소멸자가 범례 제거를 QCustomPlot에보고하기 위해 사용됩니다.
  QCustomPlot :: legend 멤버를 적절히 지울 수 있습니다.
*/
void QCustomPlot::legendRemoved(QCPLegend *legend)
{
  if (this->legend == legend)
    this->legend = 0;
}

/*! \internal
  
  This slot is connected to the selection rect's \ref QCPSelectionRect::accepted signal when \ref
  setSelectionRectMode is set to \ref QCP::srmSelect.

  First, it determines which axis rect was the origin of the selection rect judging by the starting
  point of the selection. Then it goes through the plottables (\ref QCPAbstractPlottable1D to be
  precise) associated with that axis rect and finds the data points that are in \a rect. It does
  this by querying their \ref QCPAbstractPlottable1D::selectTestRect method.
  
  Then, the actual selection is done by calling the plottables' \ref
  QCPAbstractPlottable::selectEvent, placing the found selected data points in the \a details
  parameter as <tt>QVariant(\ref QCPDataSelection)</tt>. All plottables that weren't touched by \a
  rect receive a \ref QCPAbstractPlottable::deselectEvent.
  
  \see processRectZoom
*/
/*! \내부의
  
  이 슬롯은 \ ref의 경우 선택 rect의 \ ref QCPSelectionRect :: accepted 신호에 연결됩니다.
  setSelectionRectMode는 \ ref QCP :: srmSelect로 설정됩니다.

  먼저, 시작 축을 기준으로 선택 직사각형의 원점이 어느 축 rect인지를 결정합니다
  선택 지점. 그런 다음 plottables를 통과합니다 (\ ref QCPAbstractPlottable1D는
  정확한) 축 rect에있는 데이터 포인트를 찾습니다. 그렇습니다
  이것은 \ ref QCPAbstractPlottable1D :: selectTestRect 메서드를 쿼리함으로써 가능합니다.
  
  그런 다음 실제 선택은 plottables의 \ ref를 호출하여 수행됩니다.
  QCPAbstractPlottable :: selectEvent, 발견 된 선택된 데이터 포인트를 \ 세부 정보에 배치합니다.
  매개 변수는 <tt> QVariant (\ ref QCPDataSelection) </ tt>입니다. \ a에 의해 수정되지 않은 모든 plottables
  rect는 \ ref QCPAbstractPlottable :: deselectEvent를받습니다.
  
  \ 참조 processRectZoom
*/
void QCustomPlot::processRectSelection(QRect rect, QMouseEvent *event)
{
  bool selectionStateChanged = false;
  
  if (mInteractions.testFlag(QCP::iSelectPlottables))
  {
    QMap<int, QPair<QCPAbstractPlottable*, QCPDataSelection> > potentialSelections;
 // map key is number of selected data points, so we have selections sorted by size
 // map key는 선택된 데이터 포인트의 수이므로 크기별로 정렬 된 선택을 갖습니다.
    QRectF rectF(rect.normalized());
    if (QCPAxisRect *affectedAxisRect = axisRectAt(rectF.topLeft()))
    {
      // determine plottables that were hit by the rect and thus are candidates for selection:
      // rect에 부딪혀 선택 대상이되는 plottables를 결정합니다.
      foreach (QCPAbstractPlottable *plottable, affectedAxisRect->plottables())
      {
        if (QCPPlottableInterface1D *plottableInterface = plottable->interface1D())
        {
          QCPDataSelection dataSel = plottableInterface->selectTestRect(rectF, true);
          if (!dataSel.isEmpty())
            potentialSelections.insertMulti(dataSel.dataPointCount(), QPair<QCPAbstractPlottable*, QCPDataSelection>(plottable, dataSel));
        }
      }
      
      if (!mInteractions.testFlag(QCP::iMultiSelect))
      {
        // only leave plottable with most selected points in map, since we will only select a single plottable:
        // 우리는 하나의 plottable만을 선택하기 때문에지도에서 대부분의 선택된 점들로 plottable을 떠납니다 :
        if (!potentialSelections.isEmpty())
        {
          QMap<int, QPair<QCPAbstractPlottable*, QCPDataSelection> >::iterator it = potentialSelections.begin();
          while (it != potentialSelections.end()-1) // erase all except last element
                                                    // 마지막 요소를 제외한 모두 지우기
            it = potentialSelections.erase(it);
        }
      }
      
      bool additive = event->modifiers().testFlag(mMultiSelectModifier);
      // deselect all other layerables if not additive selection:
      // 추가 선택이 아닌 다른 레이어 가능 항목을 모두 선택 취소합니다.
      if (!additive)
      {
        // emit deselection except to those plottables who will be selected afterwards:
        // 이후에 선택 될 플롯 테이블을 제외하고는 선택 취소를 내 보냅니다.
        foreach (QCPLayer *layer, mLayers)
        {
          foreach (QCPLayerable *layerable, layer->children())
          {
            if ((potentialSelections.isEmpty() || potentialSelections.constBegin()->first != layerable) && mInteractions.testFlag(layerable->selectionCategory()))
            {
              bool selChanged = false;
              layerable->deselectEvent(&selChanged);
              selectionStateChanged |= selChanged;
            }
          }
        }
      }
      
      // go through selections in reverse (largest selection first) and emit select events:
      // 역순으로 선택을 수행하고 (가장 큰 선택부터) 선택 이벤트를 내 보냅니다.
      QMap<int, QPair<QCPAbstractPlottable*, QCPDataSelection> >::const_iterator it = potentialSelections.constEnd();
      while (it != potentialSelections.constBegin())
      {
        --it;
        if (mInteractions.testFlag(it.value().first->selectionCategory()))
        {
          bool selChanged = false;
          it.value().first->selectEvent(event, additive, QVariant::fromValue(it.value().second), &selChanged);
          selectionStateChanged |= selChanged;
        }
      }
    }
  }
  
  if (selectionStateChanged)
  {
    emit selectionChangedByUser();
    replot(rpQueuedReplot);
  } else if (mSelectionRect)
    mSelectionRect->layer()->replot();
}

/*! \internal
  
  This slot is connected to the selection rect's \ref QCPSelectionRect::accepted signal when \ref
  setSelectionRectMode is set to \ref QCP::srmZoom.

  It determines which axis rect was the origin of the selection rect judging by the starting point
  of the selection, and then zooms the axes defined via \ref QCPAxisRect::setRangeZoomAxes to the
  provided \a rect (see \ref QCPAxisRect::zoom).
  
  \see processRectSelection
*/
/*! \내부의
  
  이 슬롯은 \ ref의 경우 선택 rect의 \ ref QCPSelectionRect :: accepted 신호에 연결됩니다.
  setSelectionRectMode는 \ ref QCP :: srmZoom으로 설정됩니다.

  시작점에 의해 판단되는 선택 직사각형의 원점이 어느 축 rect인지를 결정합니다
  를 선택하고, \ ref QCPAxisRect :: setRangeZoomAxes를 통해 정의 된 축을
  제공된 \ rect (\ ref QCPAxisRect :: zoom 참고).
  
  \ 참조 processRectSelection
*/
void QCustomPlot::processRectZoom(QRect rect, QMouseEvent *event)
{
  Q_UNUSED(event)
  if (QCPAxisRect *axisRect = axisRectAt(rect.topLeft()))
  {
    QList<QCPAxis*> affectedAxes = QList<QCPAxis*>() << axisRect->rangeZoomAxes(Qt::Horizontal) << axisRect->rangeZoomAxes(Qt::Vertical);
    affectedAxes.removeAll(static_cast<QCPAxis*>(0));
    axisRect->zoom(QRectF(rect), affectedAxes);
  }
  replot(rpQueuedReplot); // always replot to make selection rect disappear
                          // 항상 선택 항목을 사라지게하려면 replot
}

/*! \internal

  This method is called when a simple left mouse click was detected on the QCustomPlot surface.

  It first determines the layerable that was hit by the click, and then calls its \ref
  QCPLayerable::selectEvent. All other layerables receive a QCPLayerable::deselectEvent (unless the
  multi-select modifier was pressed, see \ref setMultiSelectModifier).

  In this method the hit layerable is determined a second time using \ref layerableAt (after the
  one in \ref mousePressEvent), because we want \a onlySelectable set to true this time. This
  implies that the mouse event grabber (mMouseEventLayerable) may be a different one from the
  clicked layerable determined here. For example, if a non-selectable layerable is in front of a
  selectable layerable at the click position, the front layerable will receive mouse events but the
  selectable one in the back will receive the \ref QCPLayerable::selectEvent.

  \see processRectSelection, QCPLayerable::selectTest
*/
/*! \내부의

  이 메소드는 QCustomPlot 표면에서 마우스 왼쪽 버튼을 클릭했을 때 호출됩니다.

  먼저 클릭에 의해 눌려진 레이어 가능 여부를 확인한 다음 \ ref를 호출합니다.
  QCPLayerable :: selectEvent. 다른 모든 레이어 가능 항목은 QCPLayerable :: deselectEvent를받습니다 (
  multi-select 수정자를 눌렀습니다. \ ref setMultiSelectModifier를 참조하십시오).

  이 방법에서 히트 layerable은 \ ref layerableAt를 사용하여 두 번째로 결정됩니다 (
  \ ref mousePressEvent). 왜냐하면 이번에는 \ a onlySelectable을 true로 설정하기를 원하기 때문입니다. 이
  마우스 이벤트 그래버 (mMouseEventLayerable)가 다른 이벤트 일 수 있음을 의미합니다.
  여기에서 결정된 레이어 화 된 클릭 가능 예를 들어 선택 불가능한 레이어 가능 요소가
  클릭 위치에서 선택 가능한 레이어 가능, 앞 레이어 가능은 마우스 이벤트를 받지만
  뒤쪽에서 선택 가능한 하나는 \ ref QCPLayerable :: selectEvent를 수신합니다.

  \ processRectSelection, QCPLayerable :: selectTest를 참조하십시오.
*/
void QCustomPlot::processPointSelection(QMouseEvent *event)
{
  QVariant details;
  QCPLayerable *clickedLayerable = layerableAt(event->pos(), true, &details);
  bool selectionStateChanged = false;
  bool additive = mInteractions.testFlag(QCP::iMultiSelect) && event->modifiers().testFlag(mMultiSelectModifier);
  // deselect all other layerables if not additive selection:
  // 추가 선택이 아닌 다른 레이어 가능 항목을 모두 선택 취소합니다.
  if (!additive)
  {
    foreach (QCPLayer *layer, mLayers)
    {
      foreach (QCPLayerable *layerable, layer->children())
      {
        if (layerable != clickedLayerable && mInteractions.testFlag(layerable->selectionCategory()))
        {
          bool selChanged = false;
          layerable->deselectEvent(&selChanged);
          selectionStateChanged |= selChanged;
        }
      }
    }
  }
  if (clickedLayerable && mInteractions.testFlag(clickedLayerable->selectionCategory()))
  {
    // a layerable was actually clicked, call its selectEvent:
    // layerable이 실제로 클릭되면 selectEvent를 호출합니다.
    bool selChanged = false;
    clickedLayerable->selectEvent(event, additive, details, &selChanged);
    selectionStateChanged |= selChanged;
  }
  if (selectionStateChanged)
  {
    emit selectionChangedByUser();
    replot(rpQueuedReplot);
  }
}

/*! \internal
  
  Registers the specified plottable with this QCustomPlot and, if \ref setAutoAddPlottableToLegend
  is enabled, adds it to the legend (QCustomPlot::legend). QCustomPlot takes ownership of the
  plottable.
  
  Returns true on success, i.e. when \a plottable isn't already in this plot and the parent plot of
  \a plottable is this QCustomPlot.
  
  This method is called automatically in the QCPAbstractPlottable base class constructor.
*/
/*! \내부의
  
  지정된 Plottable을이 QCustomPlot에 등록하고, if \ ref setAutoAddPlottableToLegend
  (QCustomPlot :: legend) 범례에 추가합니다. QCustomPlot은
  plottable.
  
  성공시 true를 반환합니다. 즉, 플롯이 이미이 플롯에없고 부모 플롯이
  이 QCustomPlot은 plottable입니다.
  
  이 메소드는 QCPAbstractPlottable 기본 클래스 생성자에서 자동으로 호출됩니다.
*/
bool QCustomPlot::registerPlottable(QCPAbstractPlottable *plottable)
{
  if (mPlottables.contains(plottable))
  {
    qDebug() << Q_FUNC_INFO << "plottable already added to this QCustomPlot:" << reinterpret_cast<quintptr>(plottable);
    return false;
  }
  if (plottable->parentPlot() != this)
  {
    qDebug() << Q_FUNC_INFO << "plottable not created with this QCustomPlot as parent:" << reinterpret_cast<quintptr>(plottable);
    return false;
  }
  
  mPlottables.append(plottable);
  // possibly add plottable to legend:
  // 플롯을 범례에 추가 할 수 있습니다.
  if (mAutoAddPlottableToLegend)
    plottable->addToLegend();
  if (!plottable->layer())
  // usually the layer is already set in the constructor of the plottable (via QCPLayerable constructor)
  // 일반적으로 레이어는 이미 (QCPLayerable 생성자를 통해) plottable의 생성자에 설정되어 있습니다.
    plottable->setLayer(currentLayer());
  return true;
}

/*! \internal
  
  In order to maintain the simplified graph interface of QCustomPlot, this method is called by the
  QCPGraph constructor to register itself with this QCustomPlot's internal graph list. Returns true
  on success, i.e. if \a graph is valid and wasn't already registered with this QCustomPlot.
  
  This graph specific registration happens in addition to the call to \ref registerPlottable by the
  QCPAbstractPlottable base class.
*/
/*! \내부의
  
  QCustomPlot의 단순화 된 그래프 인터페이스를 유지하기 위해이 메서드는
  QCPGraph 생성자가이 QCustomPlot의 내부 그래프 목록에 자신을 등록합니다. true를 반환합니다.
  즉, \ 그래프가 유효하고이 QCustomPlot에 이미 등록되지 않은 경우입니다.
  
  이 그래프 특정 등록은 \ ref registerPlottable에 대한 호출 외에도
  QCPAbstractPlottable 기본 클래스입니다.
*/
bool QCustomPlot::registerGraph(QCPGraph *graph)
{
  if (!graph)
  {
    qDebug() << Q_FUNC_INFO << "passed graph is zero";
    return false;
  }
  if (mGraphs.contains(graph))
  {
    qDebug() << Q_FUNC_INFO << "graph already registered with this QCustomPlot";
    return false;
  }
  
  mGraphs.append(graph);
  return true;
}


/*! \internal

  Registers the specified item with this QCustomPlot. QCustomPlot takes ownership of the item.
  
  Returns true on success, i.e. when \a item wasn't already in the plot and the parent plot of \a
  item is this QCustomPlot.
  
  This method is called automatically in the QCPAbstractItem base class constructor.
*/
/*! \내부의

  지정된 항목을이 QCustomPlot에 등록합니다. QCustomPlot은 항목의 소유권을 가져옵니다.
  
  성공하면 true를 반환합니다. 즉, 항목이 아직 플롯에없고 \ a의 부모 플롯이없는 경우
  항목이이 QCustomPlot입니다.
  
  이 메소드는 QCPAbstractItem 기본 클래스 생성자에서 자동으로 호출됩니다.
*/
bool QCustomPlot::registerItem(QCPAbstractItem *item)
{
  if (mItems.contains(item))
  {
    qDebug() << Q_FUNC_INFO << "item already added to this QCustomPlot:" << reinterpret_cast<quintptr>(item);
    return false;
  }
  if (item->parentPlot() != this)
  {
    qDebug() << Q_FUNC_INFO << "item not created with this QCustomPlot as parent:" << reinterpret_cast<quintptr>(item);
    return false;
  }
  
  mItems.append(item);
  if (!item->layer()) // usually the layer is already set in the constructor of the item (via QCPLayerable constructor)
                      // 일반적으로 레이어가 이미 (QCPLayerable 생성자를 통해) 항목의 생성자에 설정되어 있습니다.
    item->setLayer(currentLayer());
  return true;
}

/*! \internal
  
  Assigns all layers their index (QCPLayer::mIndex) in the mLayers list. This method is thus called
  after every operation that changes the layer indices, like layer removal, layer creation, layer
  moving.
*/
/*! \내부의
  
  모든 레이어에 해당 인덱스 (QCPLayer :: mIndex)를 mLayers 목록에 할당합니다. 따라서이 방법은
  레이어 제거, 레이어 생성, 레이어와 같은 레이어 인덱스를 변경하는 모든 작업 후
  움직이는.
*/
void QCustomPlot::updateLayerIndices() const
{
  for (int i=0; i<mLayers.size(); ++i)
    mLayers.at(i)->mIndex = i;
}

/*! \internal

  Returns the top-most layerable at pixel position \a pos. If \a onlySelectable is set to true,
  only those layerables that are selectable will be considered. (Layerable subclasses communicate
  their selectability via the QCPLayerable::selectTest method, by returning -1.)

  \a selectionDetails is an output parameter that contains selection specifics of the affected
  layerable. This is useful if the respective layerable shall be given a subsequent
  QCPLayerable::selectEvent (like in \ref mouseReleaseEvent). \a selectionDetails usually contains
  information about which part of the layerable was hit, in multi-part layerables (e.g.
  QCPAxis::SelectablePart). If the layerable is a plottable, \a selectionDetails contains a \ref
  QCPDataSelection instance with the single data point which is closest to \a pos.
  
  \see layerableListAt, layoutElementAt, axisRectAt
*/
/*! \내부의

  픽셀 위치 \ a pos에서 최상위 레이어 가능 레이어를 반환합니다. \ a onlySelectable가 true로 설정된 경우,
  선택할 수있는 레이어 가능 요소 만 고려됩니다. (레이어 가능 하위 클래스는
  -1을 반환하여 QCPLayerable :: selectTest 메서드를 통해 선택 가능성을 나타냅니다.

  \ a selectionDetails는 영향을받은 사용자의 선택 사항을 포함하는 출력 매개 변수입니다.
  레이어 가능. 이는 각 레이어 가능 요소에 다음 레이어가 주어질 때 유용합니다.
  QCPLayerable :: selectEvent (예 : \ ref mouseReleaseEvent). \ selectionDetails는 일반적으로 다음을 포함합니다.
  계층화 가능 부분의 어떤 부분에 대한 정보가 다중 부분 레이어 가능 (예 :
  QCPAxis :: SelectablePart). layerable이 plottable 인 경우 \ selectionDetails에 \ ref가 포함됩니다.
  \ a pos에 가장 가까운 단일 데이터 요소가있는 QCPDataSelection 인스턴스입니다.
  
  \ layerableListAt, layoutElementAt, axisRectAt를 참조하십시오.
*/
QCPLayerable *QCustomPlot::layerableAt(const QPointF &pos, bool onlySelectable, QVariant *selectionDetails) const
{
  QList<QVariant> details;
  QList<QCPLayerable*> candidates = layerableListAt(pos, onlySelectable, selectionDetails ? &details : 0);
  if (selectionDetails && !details.isEmpty())
    *selectionDetails = details.first();
  if (!candidates.isEmpty())
    return candidates.first();
  else
    return 0;
}

/*! \internal

  Returns the layerables at pixel position \a pos. If \a onlySelectable is set to true, only those
  layerables that are selectable will be considered. (Layerable subclasses communicate their
  selectability via the QCPLayerable::selectTest method, by returning -1.)

  The returned list is sorted by the layerable/drawing order. If you only need to know the top-most
  layerable, rather use \ref layerableAt.

  \a selectionDetails is an output parameter that contains selection specifics of the affected
  layerable. This is useful if the respective layerable shall be given a subsequent
  QCPLayerable::selectEvent (like in \ref mouseReleaseEvent). \a selectionDetails usually contains
  information about which part of the layerable was hit, in multi-part layerables (e.g.
  QCPAxis::SelectablePart). If the layerable is a plottable, \a selectionDetails contains a \ref
  QCPDataSelection instance with the single data point which is closest to \a pos.
  
  \see layerableAt, layoutElementAt, axisRectAt
*/
/*! \내부의

  픽셀 위치 \ a pos에있는 레이어 가능 층을 반환합니다. \ a onlySelectable을 true로 설정하면
  선택할 수있는 레이어 가능 요소가 고려됩니다. 레이어화할 수있는 서브 클래스는
  -1을 반환하여 QCPLayerable :: selectTest 메서드를 통한 선택 가능성.)

  반환 된 목록은 레이어 가능 / 그리기 순서에 따라 정렬됩니다. 가장 많이 알 필요가있는 경우
  layerable, 대신 \ ref layerableAt를 사용하십시오.

  \ a selectionDetails는 영향을받은 사용자의 선택 사항을 포함하는 출력 매개 변수입니다.
  레이어 가능. 이는 각 레이어 가능 요소에 다음 레이어가 주어질 때 유용합니다.
  QCPLayerable :: selectEvent (예 : \ ref mouseReleaseEvent). \ selectionDetails는 일반적으로 다음을 포함합니다.
  계층화 가능 부분의 어떤 부분에 대한 정보가 다중 부분 레이어 가능 (예 :
  QCPAxis :: SelectablePart). layerable이 plottable 인 경우 \ selectionDetails에 \ ref가 포함됩니다.
  \ a pos에 가장 가까운 단일 데이터 요소가있는 QCPDataSelection 인스턴스입니다.
  
  \ layerableAt, layoutElementAt, axisRectAt를 참조하십시오.
*/
QList<QCPLayerable*> QCustomPlot::layerableListAt(const QPointF &pos, bool onlySelectable, QList<QVariant> *selectionDetails) const
{
  QList<QCPLayerable*> result;
  for (int layerIndex=mLayers.size()-1; layerIndex>=0; --layerIndex)
  {
    const QList<QCPLayerable*> layerables = mLayers.at(layerIndex)->children();
    for (int i=layerables.size()-1; i>=0; --i)
    {
      if (!layerables.at(i)->realVisibility())
        continue;
      QVariant details;
      double dist = layerables.at(i)->selectTest(pos, onlySelectable, selectionDetails ? &details : 0);
      if (dist >= 0 && dist < selectionTolerance())
      {
        result.append(layerables.at(i));
        if (selectionDetails)
          selectionDetails->append(details);
      }
    }
  }
  return result;
}

/*!
  Saves the plot to a rastered image file \a fileName in the image format \a format. The plot is
  sized to \a width and \a height in pixels and scaled with \a scale. (width 100 and scale 2.0 lead
  to a full resolution file with width 200.) If the \a format supports compression, \a quality may
  be between 0 and 100 to control it.

  Returns true on success. If this function fails, most likely the given \a format isn't supported
  by the system, see Qt docs about QImageWriter::supportedImageFormats().

  The \a resolution will be written to the image file header (if the file format supports this) and
  has no direct consequence for the quality or the pixel size. However, if opening the image with a
  tool which respects the metadata, it will be able to scale the image to match either a given size
  in real units of length (inch, centimeters, etc.), or the target display DPI. You can specify in
  which units \a resolution is given, by setting \a resolutionUnit. The \a resolution is converted
  to the format's expected resolution unit internally.

  \see saveBmp, saveJpg, savePng, savePdf
*/
/*!
  플롯을 이미지 형식 \ a 형식의 마지막 이미지 파일 \ fileName에 저장합니다. 줄거리는
  \ a 너비와 \ a 픽셀 단위의 높이 및 \ a 배율로 조정됩니다. (폭 100 및 눈금 2.0 리드
  너비가 200 인 전체 해상도 파일로 변환합니다.) \ a 형식이 압축을 지원하면 \ 품질이
  0과 100 사이의 값으로 제어하십시오.

  성공하면 true를 반환합니다. 이 함수가 실패하면 주어진 \ a 형식이 지원되지 않을 가능성이 높습니다.
  QImageWriter :: supportedImageFormats ()에 대한 Qt 문서를 참조하십시오.

  \ 해상도가 이미지 파일 헤더에 기록됩니다 (파일 형식이 이것을 지원하는 경우).
  품질 또는 픽셀 크기에 직접적인 영향을 미치지 않습니다. 그러나 이미지를
  메타 데이터를 존중하는 툴을 사용하면 지정된 크기와 일치하도록 이미지의 크기를 조정할 수 있습니다.
  실제 단위 길이 (인치, 센티미터 등) 또는 대상 디스플레이 DPI. 에서 지정할 수 있습니다.
  \ a resolutionUnit을 설정하여 해상도가 주어진 단위를 지정합니다. 해상도가 변환됩니다.
  형식의 예상 해상도 단위 내부적으로.

  \ saveBmp, saveJpg, savePng, savePdf를 참조하십시오.
*/
bool QCustomPlot::saveRastered(const QString &fileName, int width, int height, double scale, const char *format, int quality, int resolution, QCP::ResolutionUnit resolutionUnit)
{
  QImage buffer = toPixmap(width, height, scale).toImage();
  
  int dotsPerMeter = 0;
  switch (resolutionUnit)
  {
    case QCP::ruDotsPerMeter: dotsPerMeter = resolution; break;
    case QCP::ruDotsPerCentimeter: dotsPerMeter = resolution*100; break;
    case QCP::ruDotsPerInch: dotsPerMeter = resolution/0.0254; break;
  }
  buffer.setDotsPerMeterX(dotsPerMeter); 
// this is saved together with some image formats, e.g. PNG, and is relevant when opening image in other tools
// PNG와 같은 일부 이미지 형식과 함께 저장되며 다른 도구에서 이미지를 열 때 적합합니다.
  buffer.setDotsPerMeterY(dotsPerMeter); 
// this is saved together with some image formats, e.g. PNG, and is relevant when opening image in other tools
// PNG와 같은 일부 이미지 형식과 함께 저장되며 다른 도구에서 이미지를 열 때 적합합니다.
  if (!buffer.isNull())
    return buffer.save(fileName, format, quality);
  else
    return false;
}

/*!
  Renders the plot to a pixmap and returns it.
  
  The plot is sized to \a width and \a height in pixels and scaled with \a scale. (width 100 and
  scale 2.0 lead to a full resolution pixmap with width 200.)
  
  \see toPainter, saveRastered, saveBmp, savePng, saveJpg, savePdf
*/
/*!
  플롯을 픽스맵으로 렌더링하고 반환합니다.
  
  플롯은 \ a 너비 및 \ 높이 (픽셀 단위)로 크기가 조정되고 \ a 배율로 배율 조정됩니다. (폭 100 및
  scale 2.0은 너비가 200 인 전체 해상도 pixmap으로 이어진다.)
  
  \ toPainter, saveRastered, saveBmp, savePng, saveJpg, savePdf를 참조하십시오.
*/
QPixmap QCustomPlot::toPixmap(int width, int height, double scale)
{
  // this method is somewhat similar to toPainter. Change something here, and a change in toPainter might be necessary, too.
 //이 메소드는 toPainter와 다소 비슷하다. 여기에서 무언가를 변경하면 toPainter의 변경이 필요할 수도 있습니다.
  int newWidth, newHeight;
  if (width == 0 || height == 0)
  {
    newWidth = this->width();
    newHeight = this->height();
  } else
  {
    newWidth = width;
    newHeight = height;
  }
  int scaledWidth = qRound(scale*newWidth);
  int scaledHeight = qRound(scale*newHeight);

  QPixmap result(scaledWidth, scaledHeight);
  result.fill(mBackgroundBrush.style() == Qt::SolidPattern ? mBackgroundBrush.color() : Qt::transparent);
 // if using non-solid pattern, make transparent now and draw brush pattern later
 // 솔리드가 아닌 패턴을 사용하는 경우 지금 투명하게 만들고 나중에 브러쉬 패턴을 그립니다.
  QCPPainter painter;
  painter.begin(&result);
  if (painter.isActive())
  {
    QRect oldViewport = viewport();
    setViewport(QRect(0, 0, newWidth, newHeight));
    painter.setMode(QCPPainter::pmNoCaching);
    if (!qFuzzyCompare(scale, 1.0))
    {
      if (scale > 1.0) // for scale < 1 we always want cosmetic pens where possible, because else lines might disappear for very small scales
 // scale <1 인 경우 가능한 한 cosmetic pen을 원한다. 왜냐하면 else line은 아주 작은 눈금으로 사라질 수 있기 때문이다.
        painter.setMode(QCPPainter::pmNonCosmetic);
      painter.scale(scale, scale);
    }
    if (mBackgroundBrush.style() != Qt::SolidPattern && mBackgroundBrush.style() != Qt::NoBrush) 
// solid fills were done a few lines above with QPixmap::fill
// QPixmap :: fill을 사용하여 솔리드 채우기를 몇 줄 위에 수행했습니다.
      painter.fillRect(mViewport, mBackgroundBrush);
    draw(&painter);
    setViewport(oldViewport);
    painter.end();
  } else // might happen if pixmap has width or height zero
         // pixmap의 너비 또는 높이가 0 일 때 발생할 수 있습니다.
  {
    qDebug() << Q_FUNC_INFO << "Couldn't activate painter on pixmap";
    return QPixmap();
  }
  return result;
}

/*!
  Renders the plot using the passed \a painter.
  
  The plot is sized to \a width and \a height in pixels. If the \a painter's scale is not 1.0, the resulting plot will
  appear scaled accordingly.
  
  \note If you are restricted to using a QPainter (instead of QCPPainter), create a temporary QPicture and open a QCPPainter
  on it. Then call \ref toPainter with this QCPPainter. After ending the paint operation on the picture, draw it with
  the QPainter. This will reproduce the painter actions the QCPPainter took, with a QPainter.
  
  \see toPixmap
*/
/*!
  전달 된 \ painter를 사용하여 플롯을 렌더링합니다.
  
  플롯은 \ a 폭과 \ height 픽셀 단위로 크기가 조정됩니다. \ A painter의 스케일이 1.0이 아닌 경우, 그 결과 플롯은
  그에 따라 크기가 조정됩니다.
  
  \ note QCPainter 대신 QPainter를 사용하도록 제한되어있는 경우 임시 QPicture를 만들고 QCPPainter를 엽니 다.
  그 위에. 그런 다음이 QCPPainter를 사용하여 \ ref toPainter를 호출하십시오. 그림에서 페인트 작업을 마친 후
  QPainter. 이것은 QPainter와 함께 QCPPainter가 찍은 화가 액션을 재현 할 것입니다.
  
  \ toPixmap 참조
*/
void QCustomPlot::toPainter(QCPPainter *painter, int width, int height)
{
  // this method is somewhat similar to toPixmap. Change something here, and a change in toPixmap might be necessary, too.
 //이 메소드는 toPixmap과 다소 비슷하다. 여기에서 무언가를 변경하면 toPixmap의 변경이 필요할 수도 있습니다.
  int newWidth, newHeight;
  if (width == 0 || height == 0)
  {
    newWidth = this->width();
    newHeight = this->height();
  } else
  {
    newWidth = width;
    newHeight = height;
  }

  if (painter->isActive())
  {
    QRect oldViewport = viewport();
    setViewport(QRect(0, 0, newWidth, newHeight));
    painter->setMode(QCPPainter::pmNoCaching);
    if (mBackgroundBrush.style() != Qt::NoBrush) // unlike in toPixmap, we can't do QPixmap::fill for Qt::SolidPattern brush style, so we also draw solid fills with fillRect here
// toPixmap과는 달리 Qt :: SolidPattern 브러시 스타일의 QPixmap :: fill을 수행 할 수 없으므로 여기 fillRect로 단색 채우기도 그립니다
      painter->fillRect(mViewport, mBackgroundBrush);
    draw(painter);
    setViewport(oldViewport);
  } else
    qDebug() << Q_FUNC_INFO << "Passed painter is not active";
}
/* end of 'src/core.cpp' */

//amalgamation: add plottable1d.cpp

/* including file 'src/colorgradient.cpp', size 24646                        */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / core.cpp'의 끝 */

// 합병 : plottable1d.cpp 추가

/* 파일 'src / colorgradient.cpp', 크기 24646 포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPColorGradient
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPColorGradient
  \brief Defines a color gradient for use with e.g. \ref QCPColorMap
  
  This class describes a color gradient which can be used to encode data with color. For example,
  QCPColorMap and QCPColorScale have \ref QCPColorMap::setGradient "setGradient" methods which
  take an instance of this class. Colors are set with \ref setColorStopAt(double position, const QColor &color)
  with a \a position from 0 to 1. In between these defined color positions, the
  color will be interpolated linearly either in RGB or HSV space, see \ref setColorInterpolation.

  Alternatively, load one of the preset color gradients shown in the image below, with \ref
  loadPreset, or by directly specifying the preset in the constructor.
  
  Apart from red, green and blue components, the gradient also interpolates the alpha values of the
  configured color stops. This allows to display some portions of the data range as transparent in
  the plot.
  
  \image html QCPColorGradient.png
  
  The \ref QCPColorGradient(GradientPreset preset) constructor allows directly converting a \ref
  GradientPreset to a QCPColorGradient. This means that you can directly pass \ref GradientPreset
  to all the \a setGradient methods, e.g.:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpcolorgradient-setgradient
  
  The total number of levels used in the gradient can be set with \ref setLevelCount. Whether the
  color gradient shall be applied periodically (wrapping around) to data values that lie outside
  the data range specified on the plottable instance can be controlled with \ref setPeriodic.
*/
/*! \ class QCPColorGradient
  \ brief 예를 들어 \ ref QCPColorMap에 사용할 색상 그라디언트를 정의합니다.
  
  이 클래스는 색상으로 데이터를 인코딩하는 데 사용할 수있는 색상 그라디언트를 설명합니다. 예를 들어,
  QCPColorMap 및 QCPColorScale에는 \ ref QCPColorMap :: setGradient "setGradient"메소드가 있습니다.
  이 클래스의 인스턴스를 가져옵니다. 색상은 \ ref setColorStopAt (double position, const QColor & color)로 설정됩니다.
  \ a 위치는 0에서 1 사이입니다. 이러한 정의 된 색상 위치 사이에서
  색상은 RGB 또는 HSV 공간에서 선형으로 보간됩니다. \ ref setColorInterpolation을 참조하십시오.

  또는 아래 이미지에 표시된 사전 설정된 색상 그라디언트 중 하나를 \ ref로로드하십시오.
  loadPreset을 사용하거나 생성자에서 사전 설정을 직접 지정합니다.
  
  빨강, 녹색 및 파랑 구성 요소를 제외하고 그라디언트는
  구성된 색상이 멈 춥니 다. 이렇게하면 데이터 범위의 일부를 투명하게 표시 할 수 있습니다.
  줄거리.
  
  \ image html QCPColorGradient.png
  
  \ ref QCPColorGradient (GradientPreset 프리셋) 생성자를 사용하면 \ ref를 직접 변환 할 수 있습니다.
  GradientPreset를 QCPColorGradient에 설정합니다. 즉, \ ref GradientPreset을 직접 전달할 수 있습니다.
  모든 \ setGradient 메소드에, 예를 들어 :
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpcolorgradient-setgradient
  
  그라데이션에 사용 된 총 레벨 수는 \ ref setLevelCount로 설정할 수 있습니다. 여부
  색상 그라디언트는 외부에있는 데이터 값에 주기적으로 (랩 어라운드) 적용되어야한다.
  plottable 인스턴스에 지정된 데이터 범위는 \ ref setPeriodic을 사용하여 제어 할 수 있습니다.
*/

/*!
  Constructs a new, empty QCPColorGradient with no predefined color stops. You can add own color
  stops with \ref setColorStopAt.

  The color level count is initialized to 350.
*/
/*!
  미리 정의 된 색 중단이없는 비어있는 새 QCPColorGradient를 생성합니다. 나만의 색을 추가 할 수 있습니다.
  \ ref setColorStopAt로 중지합니다.

  색상 수는 350으로 초기화됩니다.
*/
QCPColorGradient::QCPColorGradient() :
  mLevelCount(350),
  mColorInterpolation(ciRGB),
  mPeriodic(false),
  mColorBufferInvalidated(true)
{
  mColorBuffer.fill(qRgb(0, 0, 0), mLevelCount);
}

/*!
  Constructs a new QCPColorGradient initialized with the colors and color interpolation according
  to \a preset.

  The color level count is initialized to 350.
*/
/*!
  색과 보간에 따라 초기화 된 새로운 QCPColorGradient를 구축합니다.
  ~ 사전 설정.

  색상 수는 350으로 초기화됩니다.
*/
QCPColorGradient::QCPColorGradient(GradientPreset preset) :
  mLevelCount(350),
  mColorInterpolation(ciRGB),
  mPeriodic(false),
  mColorBufferInvalidated(true)
{
  mColorBuffer.fill(qRgb(0, 0, 0), mLevelCount);
  loadPreset(preset);
}

/* undocumented operator */
/* 문서화되지 않은 연산자 */
bool QCPColorGradient::operator==(const QCPColorGradient &other) const
{
  return ((other.mLevelCount == this->mLevelCount) &&
          (other.mColorInterpolation == this->mColorInterpolation) &&
          (other.mPeriodic == this->mPeriodic) &&
          (other.mColorStops == this->mColorStops));
}

/*!
  Sets the number of discretization levels of the color gradient to \a n. The default is 350 which
  is typically enough to create a smooth appearance. The minimum number of levels is 2.

  \image html QCPColorGradient-levelcount.png
*/
/*!
  색상 그라디언트의 이산화 수준 수를 \ a n으로 설정합니다. 기본값은 350입니다.
  일반적으로 부드러운 모양을 만들기에 충분합니다. 최소 레벨 수는 2입니다.

  \ image html QCPColorGradient-levelcount.png
*/
void QCPColorGradient::setLevelCount(int n)
{
  if (n < 2)
  {
    qDebug() << Q_FUNC_INFO << "n must be greater or equal 2 but was" << n;
    n = 2;
  }
  if (n != mLevelCount)
  {
    mLevelCount = n;
    mColorBufferInvalidated = true;
  }
}

/*!
  Sets at which positions from 0 to 1 which color shall occur. The positions are the keys, the
  colors are the values of the passed QMap \a colorStops. In between these color stops, the color
  is interpolated according to \ref setColorInterpolation.
  
  A more convenient way to create a custom gradient may be to clear all color stops with \ref
  clearColorStops (or creating a new, empty QCPColorGradient) and then adding them one by one with
  \ref setColorStopAt.
  
  \see clearColorStops
*/
/*!
  0에서 1까지의 위치를 ​​설정합니다. 위치는 키,
  colors는 전달 된 QMap \ a colorStops의 값입니다. 이 컬러 스톱 사이에는 컬러
  \ ref setColorInterpolation에 따라 보간됩니다.
  
  커스텀 그라디언트를 만드는 더 편리한 방법은 \ ref로 모든 색상 멈춤을 지우는 것입니다
  clearColorStops (또는 비어있는 새 QCPColorGradient 만들기)를 사용하여 하나씩 추가
  \ ref setColorStopAt.
  
  \ clearColorStops를 참조하십시오.
*/
void QCPColorGradient::setColorStops(const QMap<double, QColor> &colorStops)
{
  mColorStops = colorStops;
  mColorBufferInvalidated = true;
}

/*!
  Sets the \a color the gradient will have at the specified \a position (from 0 to 1). In between
  these color stops, the color is interpolated according to \ref setColorInterpolation.
  
  \see setColorStops, clearColorStops
*/
/*!
  지정된 \ a 위치 (0에서 1까지)에서 그라디언트가 가질 색을 \ 설정합니다. 사이
  이 색상은 멈추고 색상은 \ ref setColorInterpolation에 따라 보간됩니다.
  
  \ setColorStops, clearColorStops를 참조하십시오.
*/
void QCPColorGradient::setColorStopAt(double position, const QColor &color)
{
  mColorStops.insert(position, color);
  mColorBufferInvalidated = true;
}

/*!
  Sets whether the colors in between the configured color stops (see \ref setColorStopAt) shall be
  interpolated linearly in RGB or in HSV color space.
  
  For example, a sweep in RGB space from red to green will have a muddy brown intermediate color,
  whereas in HSV space the intermediate color is yellow.
*/
/*!
  구성된 색상 정지 사이의 색상을 설정할지 여부를 설정합니다 (\ ref setColorStopAt 참조).
  RGB 또는 HSV 색상 공간에서 선형으로 보간됩니다.
  
  예를 들어, RGB 공간에서 빨강에서 녹색으로 스윕하는 것은 진흙 투성이의 갈색 중간 색을 가지며,
  HSV 공간에서는 중간 색상이 노란색입니다.
*/
void QCPColorGradient::setColorInterpolation(QCPColorGradient::ColorInterpolation interpolation)
{
  if (interpolation != mColorInterpolation)
  {
    mColorInterpolation = interpolation;
    mColorBufferInvalidated = true;
  }
}

/*!
  Sets whether data points that are outside the configured data range (e.g. \ref
  QCPColorMap::setDataRange) are colored by periodically repeating the color gradient or whether
  they all have the same color, corresponding to the respective gradient boundary color.
  
  \image html QCPColorGradient-periodic.png
  
  As shown in the image above, gradients that have the same start and end color are especially
  suitable for a periodic gradient mapping, since they produce smooth color transitions throughout
  the color map. A preset that has this property is \ref gpHues.
  
  In practice, using periodic color gradients makes sense when the data corresponds to a periodic
  dimension, such as an angle or a phase. If this is not the case, the color encoding might become
  ambiguous, because multiple different data values are shown as the same color.
*/
/*!
  구성된 데이터 범위를 벗어나는 데이터 점 (예 : \ ref)을 설정합니다.
  QCPColorMap :: setDataRange)는 색상 그라디언트를 주기적으로 반복하거나
  그들은 모두 각각의 그라디언트 경계 색에 해당하는 동일한 색을 갖습니다.
  
  \ image html QCPColorGradient-periodic.png
  
  위 이미지에서 볼 수 있듯이 시작 및 끝 색상이 동일한 그라데이션은 특히
  전체적으로 부드러운 색상 변환을 생성하기 때문에주기적인 그래디언트 매핑에 적합합니다.
  칼라 맵 이 속성이있는 사전 설정은 \ ref gpHues입니다.
  
  실제로 주기적 색상 그라디언트를 사용하면 데이터가 주기적
  각도 또는 위상과 같은 치수. 그렇지 않은 경우 색상 인코딩이
  왜냐하면 여러 개의 서로 다른 데이터 값이 같은 색으로 표시되기 때문입니다.
*/
void QCPColorGradient::setPeriodic(bool enabled)
{
  mPeriodic = enabled;
}

/*! \overload
  
  This method is used to quickly convert a \a data array to colors. The colors will be output in
  the array \a scanLine. Both \a data and \a scanLine must have the length \a n when passed to this
  function. The data range that shall be used for mapping the data value to the gradient is passed
  in \a range. \a logarithmic indicates whether the data values shall be mapped to colors
  logarithmically.

  if \a data actually contains 2D-data linearized via <tt>[row*columnCount + column]</tt>, you can
  set \a dataIndexFactor to <tt>columnCount</tt> to convert a column instead of a row of the data
  array, in \a scanLine. \a scanLine will remain a regular (1D) array. This works because \a data
  is addressed <tt>data[i*dataIndexFactor]</tt>.
  
  Use the overloaded method to additionally provide alpha map data.

  The QRgb values that are placed in \a scanLine have their r, g and b components premultiplied
  with alpha (see QImage::Format_ARGB32_Premultiplied).
*/
/*! \초과 적재
  
  이 메서드는 데이터 배열을 색상으로 빠르게 변환하는 데 사용됩니다. 색상이에서 출력됩니다
  배열 \ a scanLine. \ data와 \ scanLine은 모두 전달 될 때 \ an 길이를 가져야합니다.
  기능. 그라데이션에 데이터 값을 매핑하는 데 사용되는 데이터 범위가 전달됩니다.
  \ in 범위. \ a 로그 값은 데이터 값이 색상에 매핑되어야하는지 여부를 나타냅니다.
  대수적으로.

  \ data에 실제로 <tt> [row * columnCount + column] </ tt>을 통해 선형화 된 2D 데이터가 포함되어 있다면
  데이터 행 대신 열을 변환하려면 \ dataIndexFactor를 <tt> columnCount </ tt>로 설정하십시오.
  배열, \ scanLine. \ scanLine은 일반 (1D) 배열로 유지됩니다. \ a 데이터로 인해 작동합니다.
  <tt> data [i * dataIndexFactor] </ tt>로 처리됩니다.
  
  오버로드 된 메서드를 사용하여 알파 맵 데이터를 추가로 제공하십시오.

  \ scanLine에있는 QRgb 값에는 r, g 및 b 구성 요소가 미리 곱 해져 있습니다.
  알파 (QImage :: Format_ARGB32_Premultiplied 참조)를 사용합니다.
*/
void QCPColorGradient::colorize(const double *data, const QCPRange &range, QRgb *scanLine, int n, int dataIndexFactor, bool logarithmic)
{
  // If you change something here, make sure to also adapt color() and the other colorize() overload
  // 여기에서 무언가를 변경하면 color ()와 colorize () 오버로드도 적용해야합니다.
  if (!data)
  {
    qDebug() << Q_FUNC_INFO << "null pointer given as data";
    return;
  }
  if (!scanLine)
  {
    qDebug() << Q_FUNC_INFO << "null pointer given as scanLine";
    return;
  }
  if (mColorBufferInvalidated)
    updateColorBuffer();
  
  if (!logarithmic)
  {
    const double posToIndexFactor = (mLevelCount-1)/range.size();
    if (mPeriodic)
    {
      for (int i=0; i<n; ++i)
      {
        int index = (int)((data[dataIndexFactor*i]-range.lower)*posToIndexFactor) % mLevelCount;
        if (index < 0)
          index += mLevelCount;
        scanLine[i] = mColorBuffer.at(index);
      }
    } else
    {
      for (int i=0; i<n; ++i)
      {
        int index = (data[dataIndexFactor*i]-range.lower)*posToIndexFactor;
        if (index < 0)
          index = 0;
        else if (index >= mLevelCount)
          index = mLevelCount-1;
        scanLine[i] = mColorBuffer.at(index);
      }
    }
  } else // logarithmic == true
  {
    if (mPeriodic)
    {
      for (int i=0; i<n; ++i)
      {
        int index = (int)(qLn(data[dataIndexFactor*i]/range.lower)/qLn(range.upper/range.lower)*(mLevelCount-1)) % mLevelCount;
        if (index < 0)
          index += mLevelCount;
        scanLine[i] = mColorBuffer.at(index);
      }
    } else
    {
      for (int i=0; i<n; ++i)
      {
        int index = qLn(data[dataIndexFactor*i]/range.lower)/qLn(range.upper/range.lower)*(mLevelCount-1);
        if (index < 0)
          index = 0;
        else if (index >= mLevelCount)
          index = mLevelCount-1;
        scanLine[i] = mColorBuffer.at(index);
      }
    }
  }
}

/*! \overload

  Additionally to the other overload of \ref colorize, this method takes the array \a alpha, which
  has the same size and structure as \a data and encodes the alpha information per data point.

  The QRgb values that are placed in \a scanLine have their r, g and b components premultiplied
  with alpha (see QImage::Format_ARGB32_Premultiplied).
*/
/*! \초과 적재

  또한 \ ref colorize의 다른 오버로드에이 메서드는 \ alpha 알파 배열을 사용합니다.
  는 데이터와 동일한 크기 및 구조를 가지며 데이터 요소 당 알파 정보를 인코딩합니다.

  \ scanLine에있는 QRgb 값에는 r, g 및 b 구성 요소가 미리 곱 해져 있습니다.
  알파 (QImage :: Format_ARGB32_Premultiplied 참조)를 사용합니다.
*/
void QCPColorGradient::colorize(const double *data, const unsigned char *alpha, const QCPRange &range, QRgb *scanLine, int n, int dataIndexFactor, bool logarithmic)
{
  // If you change something here, make sure to also adapt color() and the other colorize() overload
  // 여기에서 무언가를 변경하면 color ()와 colorize () 오버로드도 적용해야합니다.
  if (!data)
  {
    qDebug() << Q_FUNC_INFO << "null pointer given as data";
    return;
  }
  if (!alpha)
  {
    qDebug() << Q_FUNC_INFO << "null pointer given as alpha";
    return;
  }
  if (!scanLine)
  {
    qDebug() << Q_FUNC_INFO << "null pointer given as scanLine";
    return;
  }
  if (mColorBufferInvalidated)
    updateColorBuffer();
  
  if (!logarithmic)
  {
    const double posToIndexFactor = (mLevelCount-1)/range.size();
    if (mPeriodic)
    {
      for (int i=0; i<n; ++i)
      {
        int index = (int)((data[dataIndexFactor*i]-range.lower)*posToIndexFactor) % mLevelCount;
        if (index < 0)
          index += mLevelCount;
        if (alpha[dataIndexFactor*i] == 255)
        {
          scanLine[i] = mColorBuffer.at(index);
        } else
        {
          const QRgb rgb = mColorBuffer.at(index);
          const float alphaF = alpha[dataIndexFactor*i]/255.0f;
          scanLine[i] = qRgba(qRed(rgb)*alphaF, qGreen(rgb)*alphaF, qBlue(rgb)*alphaF, qAlpha(rgb)*alphaF);
        }
      }
    } else
    {
      for (int i=0; i<n; ++i)
      {
        int index = (data[dataIndexFactor*i]-range.lower)*posToIndexFactor;
        if (index < 0)
          index = 0;
        else if (index >= mLevelCount)
          index = mLevelCount-1;
        if (alpha[dataIndexFactor*i] == 255)
        {
          scanLine[i] = mColorBuffer.at(index);
        } else
        {
          const QRgb rgb = mColorBuffer.at(index);
          const float alphaF = alpha[dataIndexFactor*i]/255.0f;
          scanLine[i] = qRgba(qRed(rgb)*alphaF, qGreen(rgb)*alphaF, qBlue(rgb)*alphaF, qAlpha(rgb)*alphaF);
        }
      }
    }
  } else // logarithmic == true
  {
    if (mPeriodic)
    {
      for (int i=0; i<n; ++i)
      {
        int index = (int)(qLn(data[dataIndexFactor*i]/range.lower)/qLn(range.upper/range.lower)*(mLevelCount-1)) % mLevelCount;
        if (index < 0)
          index += mLevelCount;
        if (alpha[dataIndexFactor*i] == 255)
        {
          scanLine[i] = mColorBuffer.at(index);
        } else
        {
          const QRgb rgb = mColorBuffer.at(index);
          const float alphaF = alpha[dataIndexFactor*i]/255.0f;
          scanLine[i] = qRgba(qRed(rgb)*alphaF, qGreen(rgb)*alphaF, qBlue(rgb)*alphaF, qAlpha(rgb)*alphaF);
        }
      }
    } else
    {
      for (int i=0; i<n; ++i)
      {
        int index = qLn(data[dataIndexFactor*i]/range.lower)/qLn(range.upper/range.lower)*(mLevelCount-1);
        if (index < 0)
          index = 0;
        else if (index >= mLevelCount)
          index = mLevelCount-1;
        if (alpha[dataIndexFactor*i] == 255)
        {
          scanLine[i] = mColorBuffer.at(index);
        } else
        {
          const QRgb rgb = mColorBuffer.at(index);
          const float alphaF = alpha[dataIndexFactor*i]/255.0f;
          scanLine[i] = qRgba(qRed(rgb)*alphaF, qGreen(rgb)*alphaF, qBlue(rgb)*alphaF, qAlpha(rgb)*alphaF);
        }
      }
    }
  }
}

/*! \internal

  This method is used to colorize a single data value given in \a position, to colors. The data
  range that shall be used for mapping the data value to the gradient is passed in \a range. \a
  logarithmic indicates whether the data value shall be mapped to a color logarithmically.

  If an entire array of data values shall be converted, rather use \ref colorize, for better
  performance.

  The returned QRgb has its r, g and b components premultiplied with alpha (see
  QImage::Format_ARGB32_Premultiplied).
*/
/*! \내부의

  이 메서드는 \ a 위치에 주어진 단일 데이터 값을 색상으로 채색하는 데 사용됩니다. 자료
  데이터 값을 그라디언트에 매핑하는 데 사용되는 범위는 \ a 범위로 전달됩니다. \에이
  로그 값은 데이터 값이 대수적으로 색상에 매핑되어야하는지 여부를 나타냅니다.

  데이터 값의 전체 배열을 변환해야한다면 \ ref colorize를 사용하십시오.
  공연.

  반환 된 QRgb에는 알파가 미리 곱셈 된 r, g 및 b 구성 요소가 있습니다 (
  QImage :: Format_ARGB32_Premultiplied).
*/
QRgb QCPColorGradient::color(double position, const QCPRange &range, bool logarithmic)
{
  // If you change something here, make sure to also adapt ::colorize()
  // 여기에서 무엇인가를 바꾼다면, adapt :: colorize ()
  if (mColorBufferInvalidated)
    updateColorBuffer();
  int index = 0;
  if (!logarithmic)
    index = (position-range.lower)*(mLevelCount-1)/range.size();
  else
    index = qLn(position/range.lower)/qLn(range.upper/range.lower)*(mLevelCount-1);
  if (mPeriodic)
  {
    index = index % mLevelCount;
    if (index < 0)
      index += mLevelCount;
  } else
  {
    if (index < 0)
      index = 0;
    else if (index >= mLevelCount)
      index = mLevelCount-1;
  }
  return mColorBuffer.at(index);
}

/*!
  Clears the current color stops and loads the specified \a preset. A preset consists of predefined
  color stops and the corresponding color interpolation method.
  
  The available presets are:
  \image html QCPColorGradient.png
*/
/*!
  현재 색상을 지우고 지정된 \ a 사전 설정을로드합니다. 사전 설정은 미리 정의 된
  색상 정지 및 해당 색상 보간 방법.
  
  사용 가능한 사전 설정은 다음과 같습니다.
  \ image html QCPColorGradient.png
*/
void QCPColorGradient::loadPreset(GradientPreset preset)
{
  clearColorStops();
  switch (preset)
  {
    case gpGrayscale:
      setColorInterpolation(ciRGB);
      setColorStopAt(0, Qt::black);
      setColorStopAt(1, Qt::white);
      break;
    case gpHot:
      setColorInterpolation(ciRGB);
      setColorStopAt(0, QColor(50, 0, 0));
      setColorStopAt(0.2, QColor(180, 10, 0));
      setColorStopAt(0.4, QColor(245, 50, 0));
      setColorStopAt(0.6, QColor(255, 150, 10));
      setColorStopAt(0.8, QColor(255, 255, 50));
      setColorStopAt(1, QColor(255, 255, 255));
      break;
    case gpCold:
      setColorInterpolation(ciRGB);
      setColorStopAt(0, QColor(0, 0, 50));
      setColorStopAt(0.2, QColor(0, 10, 180));
      setColorStopAt(0.4, QColor(0, 50, 245));
      setColorStopAt(0.6, QColor(10, 150, 255));
      setColorStopAt(0.8, QColor(50, 255, 255));
      setColorStopAt(1, QColor(255, 255, 255));
      break;
    case gpNight:
      setColorInterpolation(ciHSV);
      setColorStopAt(0, QColor(10, 20, 30));
      setColorStopAt(1, QColor(250, 255, 250));
      break;
    case gpCandy:
      setColorInterpolation(ciHSV);
      setColorStopAt(0, QColor(0, 0, 255));
      setColorStopAt(1, QColor(255, 250, 250));
      break;
    case gpGeography:
      setColorInterpolation(ciRGB);
      setColorStopAt(0, QColor(70, 170, 210));
      setColorStopAt(0.20, QColor(90, 160, 180));
      setColorStopAt(0.25, QColor(45, 130, 175));
      setColorStopAt(0.30, QColor(100, 140, 125));
      setColorStopAt(0.5, QColor(100, 140, 100));
      setColorStopAt(0.6, QColor(130, 145, 120));
      setColorStopAt(0.7, QColor(140, 130, 120));
      setColorStopAt(0.9, QColor(180, 190, 190));
      setColorStopAt(1, QColor(210, 210, 230));
      break;
    case gpIon:
      setColorInterpolation(ciHSV);
      setColorStopAt(0, QColor(50, 10, 10));
      setColorStopAt(0.45, QColor(0, 0, 255));
      setColorStopAt(0.8, QColor(0, 255, 255));
      setColorStopAt(1, QColor(0, 255, 0));
      break;
    case gpThermal:
      setColorInterpolation(ciRGB);
      setColorStopAt(0, QColor(0, 0, 50));
      setColorStopAt(0.15, QColor(20, 0, 120));
      setColorStopAt(0.33, QColor(200, 30, 140));
      setColorStopAt(0.6, QColor(255, 100, 0));
      setColorStopAt(0.85, QColor(255, 255, 40));
      setColorStopAt(1, QColor(255, 255, 255));
      break;
    case gpPolar:
      setColorInterpolation(ciRGB);
      setColorStopAt(0, QColor(50, 255, 255));
      setColorStopAt(0.18, QColor(10, 70, 255));
      setColorStopAt(0.28, QColor(10, 10, 190));
      setColorStopAt(0.5, QColor(0, 0, 0));
      setColorStopAt(0.72, QColor(190, 10, 10));
      setColorStopAt(0.82, QColor(255, 70, 10));
      setColorStopAt(1, QColor(255, 255, 50));
      break;
    case gpSpectrum:
      setColorInterpolation(ciHSV);
      setColorStopAt(0, QColor(50, 0, 50));
      setColorStopAt(0.15, QColor(0, 0, 255));
      setColorStopAt(0.35, QColor(0, 255, 255));
      setColorStopAt(0.6, QColor(255, 255, 0));
      setColorStopAt(0.75, QColor(255, 30, 0));
      setColorStopAt(1, QColor(50, 0, 0));
      break;
    case gpJet:
      setColorInterpolation(ciRGB);
      setColorStopAt(0, QColor(0, 0, 100));
      setColorStopAt(0.15, QColor(0, 50, 255));
      setColorStopAt(0.35, QColor(0, 255, 255));
      setColorStopAt(0.65, QColor(255, 255, 0));
      setColorStopAt(0.85, QColor(255, 30, 0));
      setColorStopAt(1, QColor(100, 0, 0));
      break;
    case gpHues:
      setColorInterpolation(ciHSV);
      setColorStopAt(0, QColor(255, 0, 0));
      setColorStopAt(1.0/3.0, QColor(0, 0, 255));
      setColorStopAt(2.0/3.0, QColor(0, 255, 0));
      setColorStopAt(1, QColor(255, 0, 0));
      break;
  }
}

/*!
  Clears all color stops.
  
  \see setColorStops, setColorStopAt
*/
/*!
  모든 색상 정지를 지 웁니다.
  
  \ setColorStops, setColorStopAt를 참조하십시오.
*/
void QCPColorGradient::clearColorStops()
{
  mColorStops.clear();
  mColorBufferInvalidated = true;
}

/*!
  Returns an inverted gradient. The inverted gradient has all properties as this \ref
  QCPColorGradient, but the order of the color stops is inverted.
  
  \see setColorStops, setColorStopAt
*/
/*!
  거꾸로 된 그라데이션을 반환합니다. 거꾸로 된 그라데이션은 \ ref와 같은 모든 속성을가집니다.
  QCPColorGradient. 그러나 색상 정지 순서가 뒤 바뀌 었습니다.
  
  \ setColorStops, setColorStopAt를 참조하십시오.
*/

QCPColorGradient QCPColorGradient::inverted() const
{
  QCPColorGradient result(*this);
  result.clearColorStops();
  for (QMap<double, QColor>::const_iterator it=mColorStops.constBegin(); it!=mColorStops.constEnd(); ++it)
    result.setColorStopAt(1.0-it.key(), it.value());
  return result;
}

/*! \internal
  
  Returns true if the color gradient uses transparency, i.e. if any of the configured color stops
  has an alpha value below 255.
*/
/*! \내부의
  
  색상 그라디언트가 투명도를 사용하면 true를 반환합니다. 즉, 구성된 색상 중 하나가 중지되면 true를 반환합니다.
  255 미만의 알파 값을가집니다.
*/
bool QCPColorGradient::stopsUseAlpha() const
{
  for (QMap<double, QColor>::const_iterator it=mColorStops.constBegin(); it!=mColorStops.constEnd(); ++it)
  {
    if (it.value().alpha() < 255)
      return true;
  }
  return false;
}

/*! \internal
  
  Updates the internal color buffer which will be used by \ref colorize and \ref color, to quickly
  convert positions to colors. This is where the interpolation between color stops is calculated.
*/
/*! \내부의
  
  \ ref colorize와 \ ref color가 사용할 내부 컬러 버퍼를 빠르게 업데이트합니다.
  위치를 색상으로 변환하십시오. 여기서 색상 정지 사이의 보간이 계산됩니다.
*/
void QCPColorGradient::updateColorBuffer()
{
  if (mColorBuffer.size() != mLevelCount)
    mColorBuffer.resize(mLevelCount);
  if (mColorStops.size() > 1)
  {
    double indexToPosFactor = 1.0/(double)(mLevelCount-1);
    const bool useAlpha = stopsUseAlpha();
    for (int i=0; i<mLevelCount; ++i)
    {
      double position = i*indexToPosFactor;
      QMap<double, QColor>::const_iterator it = mColorStops.lowerBound(position);
      if (it == mColorStops.constEnd()) // position is on or after last stop, use color of last stop
                                        // 위치가 마지막 정거장에 있거나 그 직후에, 마지막 정류장의 색을 사용한다.
      {
        mColorBuffer[i] = (it-1).value().rgba();
      } else if (it == mColorStops.constBegin())
// position is on or before first stop, use color of first stop
// 위치가 첫 번째 정지 지점에 있거나 그 이전에 있고, 첫 번째 정지 지점의 색상을 사용합니다.
      {
        mColorBuffer[i] = it.value().rgba();
      } else 
// position is in between stops (or on an intermediate stop), interpolate color
// 위치가 정지 점 사이 (또는 중간 정지 점)에 있고, 색상을 보간합니다.
      {
        QMap<double, QColor>::const_iterator high = it;
        QMap<double, QColor>::const_iterator low = it-1;
        double t = (position-low.key())/(high.key()-low.key()); // interpolation factor 0..1 // 보간 인자 0..1
        switch (mColorInterpolation)
        {
          case ciRGB:
          {
            if (useAlpha)
            {
              const int alpha = (1-t)*low.value().alpha() + t*high.value().alpha();
              const float alphaPremultiplier = alpha/255.0f; // since we use QImage::Format_ARGB32_Premultiplied
                                                             // QImage :: Format_ARGB32_Premultiplied를 사용하기 때문에
              mColorBuffer[i] = qRgba(((1-t)*low.value().red() + t*high.value().red())*alphaPremultiplier,
                                      ((1-t)*low.value().green() + t*high.value().green())*alphaPremultiplier,
                                      ((1-t)*low.value().blue() + t*high.value().blue())*alphaPremultiplier,
                                      alpha);
            } else
            {
              mColorBuffer[i] = qRgb(((1-t)*low.value().red() + t*high.value().red()),
                                     ((1-t)*low.value().green() + t*high.value().green()),
                                     ((1-t)*low.value().blue() + t*high.value().blue()));
            }
            break;
          }
          case ciHSV:
          {
            QColor lowHsv = low.value().toHsv();
            QColor highHsv = high.value().toHsv();
            double hue = 0;
            double hueDiff = highHsv.hueF()-lowHsv.hueF();
            if (hueDiff > 0.5)
              hue = lowHsv.hueF() - t*(1.0-hueDiff);
            else if (hueDiff < -0.5)
              hue = lowHsv.hueF() + t*(1.0+hueDiff);
            else
              hue = lowHsv.hueF() + t*hueDiff;
            if (hue < 0) hue += 1.0;
            else if (hue >= 1.0) hue -= 1.0;
            if (useAlpha)
            {
              const QRgb rgb = QColor::fromHsvF(hue,
                                                (1-t)*lowHsv.saturationF() + t*highHsv.saturationF(),
                                                (1-t)*lowHsv.valueF() + t*highHsv.valueF()).rgb();
              const float alpha = (1-t)*lowHsv.alphaF() + t*highHsv.alphaF();
              mColorBuffer[i] = qRgba(qRed(rgb)*alpha, qGreen(rgb)*alpha, qBlue(rgb)*alpha, 255*alpha);
            }
            else
            {
              mColorBuffer[i] = QColor::fromHsvF(hue,
                                                 (1-t)*lowHsv.saturationF() + t*highHsv.saturationF(),
                                                 (1-t)*lowHsv.valueF() + t*highHsv.valueF()).rgb();
            }
            break;
          }
        }
      }
    }
  } else if (mColorStops.size() == 1)
  {
    const QRgb rgb = mColorStops.constBegin().value().rgb();
    const float alpha = mColorStops.constBegin().value().alphaF();
    mColorBuffer.fill(qRgba(qRed(rgb)*alpha, qGreen(rgb)*alpha, qBlue(rgb)*alpha, 255*alpha));
  } else // mColorStops is empty, fill color buffer with black
         // mColorStops가 비어 있고, 검정색 버퍼를 채 웁니다.
  {
    mColorBuffer.fill(qRgb(0, 0, 0));
  }
  mColorBufferInvalidated = false;
}
/* end of 'src/colorgradient.cpp' */


/* including file 'src/selectiondecorator-bracket.cpp', size 12313           */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

/* 'src / colorgradient.cpp'의 끝 */


/* 파일 'src / selectiondecorator-bracket.cpp', 크기 12313 포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPSelectionDecoratorBracket
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPSelectionDecoratorBracket
  \brief A selection decorator which draws brackets around each selected data segment
  
  Additionally to the regular highlighting of selected segments via color, fill and scatter style,
  this \ref QCPSelectionDecorator subclass draws markers at the begin and end of each selected data
  segment of the plottable.
  
  The shape of the markers can be controlled with \ref setBracketStyle, \ref setBracketWidth and
  \ref setBracketHeight. The color/fill can be controlled with \ref setBracketPen and \ref
  setBracketBrush.
  
  To introduce custom bracket styles, it is only necessary to sublcass \ref
  QCPSelectionDecoratorBracket and reimplement \ref drawBracket. The rest will be managed by the
  base class.
*/
/*! \ class QCPSelectionDecoratorBracket
  \ brief 선택한 각 데이터 세그먼트 주위에 대괄호를 그려주는 선택 데코레이터입니다.
  
  또한 색상, 채우기 및 분산 스타일을 통해 선택한 세그먼트를 정기적으로 강조 표시하는 경우,
  this \ ref QCPSelectionDecorator 서브 클래스는 각 선택된 데이터의 시작과 끝 부분에 마커를 그립니다
  plottable의 세그먼트.
  
  마커의 모양은 \ ref setBracketStyle, \ ref setBracketWidth 및 \ ref setBracketStyle을 사용하여 제어 할 수 있습니다.
  \ ref setBracketHeight. 색상 / 채우기는 \ ref setBracketPen 및 \ ref로 제어 할 수 있습니다.
  setBracketBrush.
  
  커스텀 브래킷 스타일을 도입하려면 \ ref를 서브 클래 싱 (sublassassing)하면됩니다
  QCPSelectionDecoratorBracket 및 \ ref drawBracket을 다시 구현하십시오. 나머지는
  기본 클래스.
*/

/*!
  Creates a new QCPSelectionDecoratorBracket instance with default values.
*/
/*!
  기본값을 사용하여 새 QCPSelectionDecoratorBracket 인스턴스를 만듭니다.
*/
QCPSelectionDecoratorBracket::QCPSelectionDecoratorBracket() :
  mBracketPen(QPen(Qt::black)),
  mBracketBrush(Qt::NoBrush),
  mBracketWidth(5),
  mBracketHeight(50),
  mBracketStyle(bsSquareBracket),
  mTangentToData(false),
  mTangentAverage(2)
{
  
}

QCPSelectionDecoratorBracket::~QCPSelectionDecoratorBracket()
{
}

/*!
  Sets the pen that will be used to draw the brackets at the beginning and end of each selected
  data segment.
*/
/*!
  각 선택의 시작과 끝에서 괄호를 그릴 때 사용할 펜을 설정합니다.
  데이터 세그먼트.
*/
void QCPSelectionDecoratorBracket::setBracketPen(const QPen &pen)
{
  mBracketPen = pen;
}

/*!
  Sets the brush that will be used to draw the brackets at the beginning and end of each selected
  data segment.
*/
/*!
  선택한 각 시작과 끝에서 괄호를 그리는 데 사용할 브러쉬를 설정합니다.
  데이터 세그먼트.
*/
void QCPSelectionDecoratorBracket::setBracketBrush(const QBrush &brush)
{
  mBracketBrush = brush;
}

/*!
  Sets the width of the drawn bracket. The width dimension is always parallel to the key axis of
  the data, or the tangent direction of the current data slope, if \ref setTangentToData is
  enabled.
*/
/*!
  그려진 대괄호의 너비를 설정합니다. 너비 치수는 항상 키 축에 평행합니다.
  데이터 또는 현재 데이터 기울기의 접선 방향. \ ref setTangentToData가
  사용하도록 설정되었습니다.
*/
void QCPSelectionDecoratorBracket::setBracketWidth(int width)
{
  mBracketWidth = width;
}

/*!
  Sets the height of the drawn bracket. The height dimension is always perpendicular to the key axis
  of the data, or the tangent direction of the current data slope, if \ref setTangentToData is
  enabled.
*/
/*!
  그려진 대괄호의 높이를 설정합니다. 높이 치수는 항상 키 축에 수직입니다.
  데이터의 기울기 또는 현재 데이터 기울기의 접선 방향. \ ref setTangentToData가
  사용하도록 설정되었습니다.
*/
void QCPSelectionDecoratorBracket::setBracketHeight(int height)
{
  mBracketHeight = height;
}

/*!
  Sets the shape that the bracket/marker will have.
  
  \see setBracketWidth, setBracketHeight
*/
/*!
  괄호 / 마커에 포함될 모양을 설정합니다.
  
  \ setBracketWidth, setBracketHeight를 참조하십시오.
*/
void QCPSelectionDecoratorBracket::setBracketStyle(QCPSelectionDecoratorBracket::BracketStyle style)
{
  mBracketStyle = style;
}

/*!
  Sets whether the brackets will be rotated such that they align with the slope of the data at the
  position that they appear in.
  
  For noisy data, it might be more visually appealing to average the slope over multiple data
  points. This can be configured via \ref setTangentAverage.
*/
/*!
  대괄호가 회전하여 데이터의 기울기와 정렬되도록 대괄호를 회전할지 여부를 설정합니다.
  그들이 나타나는 위치.
  
  시끄러운 데이터의 경우 여러 데이터에 대한 기울기를 평균화하는 것이 시각적으로 더 매력적일 수 있습니다
  전철기. 이것은 \ ref setTangentAverage를 통해 구성 할 수 있습니다.
*/
void QCPSelectionDecoratorBracket::setTangentToData(bool enabled)
{
  mTangentToData = enabled;
}

/*!
  Controls over how many data points the slope shall be averaged, when brackets shall be aligned
  with the data (if \ref setTangentToData is true).
  
  From the position of the bracket, \a pointCount points towards the selected data range will be
  taken into account. The smallest value of \a pointCount is 1, which is effectively equivalent to
  disabling \ref setTangentToData.
*/
/*!
  괄호가 정렬 될 때 기울기를 평균화 할 데이터 포인트의 수를 제어합니다.
  데이터가있는 경우 (\ ref setTangentToData가 true 인 경우).
  
  대괄호의 위치에서 pointCount가 선택한 데이터 범위를 향합니다.
  고려. \ pointCount의 최소값은 1입니다.
  \ ref setTangentToData를 사용 중지합니다.
*/
void QCPSelectionDecoratorBracket::setTangentAverage(int pointCount)
{
  mTangentAverage = pointCount;
  if (mTangentAverage < 1)
    mTangentAverage = 1;
}

/*!
  Draws the bracket shape with \a painter. The parameter \a direction is either -1 or 1 and
  indicates whether the bracket shall point to the left or the right (i.e. is a closing or opening
  bracket, respectively).
  
  The passed \a painter already contains all transformations that are necessary to position and
  rotate the bracket appropriately. Painting operations can be performed as if drawing upright
  brackets on flat data with horizontal key axis, with (0, 0) being the center of the bracket.
  
  If you wish to sublcass \ref QCPSelectionDecoratorBracket in order to provide custom bracket
  shapes (see \ref QCPSelectionDecoratorBracket::bsUserStyle), this is the method you should
  reimplement.
*/
/*!
  \ painter로 브라켓 모양을 그립니다. 매개 변수 \ a는 -1 또는 1이고
  브래킷이 왼쪽 또는 오른쪽을 가리킬 지 여부를 나타냅니다 (즉, 닫음 또는 열림).
  브래킷, 각각).
  
  전달 된 화가에는 이미 위치를 지정하는 데 필요한 모든 변환이 포함되어 있습니다.
  브래킷을 적절하게 돌리십시오. 페인트 작업은 마치 수직으로 그리는 것처럼 수행 할 수 있습니다.
  대괄호의 중심은 (0, 0) 인 수평 키 축을 가진 플랫 데이터의 대괄호입니다.
  
  커스텀 브라켓을 제공하기 위해 \ ref QCPSelectionDecoratorBracket을 서브 클래 싱하려는 경우
  셰이프 (\ ref QCPSelectionDecoratorBracket :: bsUserStyle 참조)가 있어야합니다.
  재 구현.
*/
void QCPSelectionDecoratorBracket::drawBracket(QCPPainter *painter, int direction) const
{
  switch (mBracketStyle)
  {
    case bsSquareBracket:
    {
      painter->drawLine(QLineF(mBracketWidth*direction, -mBracketHeight*0.5, 0, -mBracketHeight*0.5));
      painter->drawLine(QLineF(mBracketWidth*direction, mBracketHeight*0.5, 0, mBracketHeight*0.5));
      painter->drawLine(QLineF(0, -mBracketHeight*0.5, 0, mBracketHeight*0.5));
      break;
    }
    case bsHalfEllipse:
    {
      painter->drawArc(-mBracketWidth*0.5, -mBracketHeight*0.5, mBracketWidth, mBracketHeight, -90*16, -180*16*direction);
      break;
    }
    case bsEllipse:
    {
      painter->drawEllipse(-mBracketWidth*0.5, -mBracketHeight*0.5, mBracketWidth, mBracketHeight);
      break;
    }
    case bsPlus:
    {
      painter->drawLine(QLineF(0, -mBracketHeight*0.5, 0, mBracketHeight*0.5));
      painter->drawLine(QLineF(-mBracketWidth*0.5, 0, mBracketWidth*0.5, 0));
      break;
    }
    default:
    {
      qDebug() << Q_FUNC_INFO << "unknown/custom bracket style can't be handeld by default implementation:" << static_cast<int>(mBracketStyle);
      break;
    }
  }
}

/*!
  Draws the bracket decoration on the data points at the begin and end of each selected data
  segment given in \a seletion.
  
  It uses the method \ref drawBracket to actually draw the shapes.
  
  \seebaseclassmethod
*/
/*!
  선택한 각 데이터의 시작과 끝 부분에있는 데이터 요소에 대괄호 장식을 그립니다.
  세그먼트는 \ s 선택으로 주어진다.
  
  그것은 \ ref drawBracket 메서드를 사용하여 실제로 도형을 그립니다.
  
  \ seebaseclassmethod
*/
void QCPSelectionDecoratorBracket::drawDecoration(QCPPainter *painter, QCPDataSelection selection)
{
  if (!mPlottable || selection.isEmpty()) return;
  
  if (QCPPlottableInterface1D *interface1d = mPlottable->interface1D())
  {
    foreach (const QCPDataRange &dataRange, selection.dataRanges())
    {
      // determine position and (if tangent mode is enabled) angle of brackets:
      // 위치를 결정하고 접선 모드가 활성화 된 경우 대괄호 각도 :
      int openBracketDir = (mPlottable->keyAxis() && !mPlottable->keyAxis()->rangeReversed()) ? 1 : -1;
      int closeBracketDir = -openBracketDir;
      QPointF openBracketPos = getPixelCoordinates(interface1d, dataRange.begin());
      QPointF closeBracketPos = getPixelCoordinates(interface1d, dataRange.end()-1);
      double openBracketAngle = 0;
      double closeBracketAngle = 0;
      if (mTangentToData)
      {
        openBracketAngle = getTangentAngle(interface1d, dataRange.begin(), openBracketDir);
        closeBracketAngle = getTangentAngle(interface1d, dataRange.end()-1, closeBracketDir);
      }
      // draw opening bracket:
      // 여는 괄호를 그립니다.
      QTransform oldTransform = painter->transform();
      painter->setPen(mBracketPen);
      painter->setBrush(mBracketBrush);
      painter->translate(openBracketPos);
      painter->rotate(openBracketAngle/M_PI*180.0);
      drawBracket(painter, openBracketDir);
      painter->setTransform(oldTransform);
      // draw closing bracket:
      // 닫는 괄호를 그립니다.
      painter->setPen(mBracketPen);
      painter->setBrush(mBracketBrush);
      painter->translate(closeBracketPos);
      painter->rotate(closeBracketAngle/M_PI*180.0);
      drawBracket(painter, closeBracketDir);
      painter->setTransform(oldTransform);
    }
  }
}

/*! \internal
  
  If \ref setTangentToData is enabled, brackets need to be rotated according to the data slope.
  This method returns the angle in radians by which a bracket at the given \a dataIndex must be
  rotated.
  
  The parameter \a direction must be set to either -1 or 1, representing whether it is an opening
  or closing bracket. Since for slope calculation multiple data points are required, this defines
  the direction in which the algorithm walks, starting at \a dataIndex, to average those data
  points. (see \ref setTangentToData and \ref setTangentAverage)
  
  \a interface1d is the interface to the plottable's data which is used to query data coordinates.
*/
/*! \내부의
  
  \ ref setTangentToData를 사용하면 데이터 기울기에 따라 대괄호를 회전해야합니다.
  이 메서드는 지정된 \ dataIndex의 괄호를 라디안 단위로 반환합니다.
  회전.
  
  \ a 방향 매개 변수는 -1인지 1로 설정되어야합니다.
  또는 닫는 브래킷. 경사 계산을 위해서는 여러 데이터 포인트가 필요하므로
  \ dataIndex를 시작으로 알고리즘이 걷는 방향으로 데이터를 평균화합니다.
  전철기. (\ ref setTangentToData 및 \ ref setTangentAverage 참조)
  
  \ interface1d는 데이터 좌표를 쿼리하는 데 사용되는 플롯 테이블 데이터에 대한 인터페이스입니다.
*/
double QCPSelectionDecoratorBracket::getTangentAngle(const QCPPlottableInterface1D *interface1d, int dataIndex, int direction) const
{
  if (!interface1d || dataIndex < 0 || dataIndex >= interface1d->dataCount())
    return 0;
  direction = direction < 0 ? -1 : 1; // enforce direction is either -1 or 1
                                      // 방향을 적용하면 -1 또는 1입니다.
  // how many steps we can actually go from index in the given direction without exceeding data bounds:
  // 데이터 범위를 초과하지 않고 주어진 방향으로 인덱스에서 실제로 갈 수있는 단계 수 :
  int averageCount;
  if (direction < 0)
    averageCount = qMin(mTangentAverage, dataIndex);
  else
    averageCount = qMin(mTangentAverage, interface1d->dataCount()-1-dataIndex);
  qDebug() << averageCount;
  // calculate point average of averageCount points:
  // averageCount 점의 점 평균을 계산합니다.
  QVector<QPointF> points(averageCount);
  QPointF pointsAverage;
  int currentIndex = dataIndex;
  for (int i=0; i<averageCount; ++i)
  {
    points[i] = getPixelCoordinates(interface1d, currentIndex);
    pointsAverage += points[i];
    currentIndex += direction;
  }
  pointsAverage /= (double)averageCount;
  
  // calculate slope of linear regression through points:
  // 점을 통해 선형 회귀의 기울기를 계산합니다.
  double numSum = 0;
  double denomSum = 0;
  for (int i=0; i<averageCount; ++i)
  {
    const double dx = points.at(i).x()-pointsAverage.x();
    const double dy = points.at(i).y()-pointsAverage.y();
    numSum += dx*dy;
    denomSum += dx*dx;
  }
  if (!qFuzzyIsNull(denomSum) && !qFuzzyIsNull(numSum))
  {
    return qAtan2(numSum, denomSum);
  } else // undetermined angle, probably mTangentAverage == 1, so using only one data point
         // 미정의 각도, 아마도 mTangentAverage == 1, 하나의 데이터 포인트 만 사용하기
    return 0;
}

/*! \internal
  
  Returns the pixel coordinates of the data point at \a dataIndex, using \a interface1d to access
  the data points.
*/
/*! \내부의
  
  액세스하려면 \ a interface1d를 사용하여 dataIndex에있는 데이터 요소의 픽셀 좌표를 반환합니다.
  데이터 포인트.
*/
QPointF QCPSelectionDecoratorBracket::getPixelCoordinates(const QCPPlottableInterface1D *interface1d, int dataIndex) const
{
  QCPAxis *keyAxis = mPlottable->keyAxis();
  QCPAxis *valueAxis = mPlottable->valueAxis();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QPointF(0, 0); }
  
  if (keyAxis->orientation() == Qt::Horizontal)
    return QPointF(keyAxis->coordToPixel(interface1d->dataMainKey(dataIndex)), valueAxis->coordToPixel(interface1d->dataMainValue(dataIndex)));
  else
    return QPointF(valueAxis->coordToPixel(interface1d->dataMainValue(dataIndex)), keyAxis->coordToPixel(interface1d->dataMainKey(dataIndex)));
}
/* end of 'src/selectiondecorator-bracket.cpp' */


/* including file 'src/layoutelements/layoutelement-axisrect.cpp', size 47584 */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200  */
/* 'src / selectiondecorator-bracket.cpp'의 끝 */


/* 'src / layoutelements / layoutelement-axisrect.cpp'파일을 포함하여 크기 47584 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPAxisRect
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPAxisRect
  \brief Holds multiple axes and arranges them in a rectangular shape.
  
  This class represents an axis rect, a rectangular area that is bounded on all sides with an
  arbitrary number of axes.
  
  Initially QCustomPlot has one axis rect, accessible via QCustomPlot::axisRect(). However, the
  layout system allows to have multiple axis rects, e.g. arranged in a grid layout
  (QCustomPlot::plotLayout).
  
  By default, QCPAxisRect comes with four axes, at bottom, top, left and right. They can be
  accessed via \ref axis by providing the respective axis type (\ref QCPAxis::AxisType) and index.
  If you need all axes in the axis rect, use \ref axes. The top and right axes are set to be
  invisible initially (QCPAxis::setVisible). To add more axes to a side, use \ref addAxis or \ref
  addAxes. To remove an axis, use \ref removeAxis.
  
  The axis rect layerable itself only draws a background pixmap or color, if specified (\ref
  setBackground). It is placed on the "background" layer initially (see \ref QCPLayer for an
  explanation of the QCustomPlot layer system). The axes that are held by the axis rect can be
  placed on other layers, independently of the axis rect.
  
  Every axis rect has a child layout of type \ref QCPLayoutInset. It is accessible via \ref
  insetLayout and can be used to have other layout elements (or even other layouts with multiple
  elements) hovering inside the axis rect.
  
  If an axis rect is clicked and dragged, it processes this by moving certain axis ranges. The
  behaviour can be controlled with \ref setRangeDrag and \ref setRangeDragAxes. If the mouse wheel
  is scrolled while the cursor is on the axis rect, certain axes are scaled. This is controllable
  via \ref setRangeZoom, \ref setRangeZoomAxes and \ref setRangeZoomFactor. These interactions are
  only enabled if \ref QCustomPlot::setInteractions contains \ref QCP::iRangeDrag and \ref
  QCP::iRangeZoom.
  
  \image html AxisRectSpacingOverview.png
  <center>Overview of the spacings and paddings that define the geometry of an axis. The dashed
  line on the far left indicates the viewport/widget border.</center>
*/
/*! \ class QCPAxisRect
  \ brief 여러 축을 잡고 직사각형 모양으로 정렬합니다.
  
  이 클래스는, 축 Rect를 나타내, 모든 구석에
  임의의 수의 축.
  
  처음에는 QCustomPlot에 QCustomPlot :: axisRect ()를 통해 액세스 할 수있는 하나의 축 rect가 있습니다. 그러나, 그
  레이아웃 시스템은 여러 개의 축 직사각형을 가질 수 있습니다 (예 : 그리드 레이아웃으로 정렬).
  (QCustomPlot :: plotLayout).
  
  기본적으로 QCPAxisRect에는 아래, 위, 왼쪽 및 오른쪽의 네 축이 있습니다. 그들은 할 수있다
  각 축 유형 (\ ref QCPAxis :: AxisType) 및 색인을 제공하여 \ ref 축을 통해 액세스합니다.
  축 rect에서 모든 축이 필요하면 \ ref 축을 사용하십시오. 위쪽 및 오른쪽 축은 다음과 같이 설정됩니다.
  처음에는 보이지 않습니다 (QCPAxis :: setVisible). 한 축에 축을 더 추가하려면 \ ref addAxis 또는 \ ref를 사용합니다.
  addAxes. 축을 제거하려면 \ ref removeAxis를 사용하십시오.
  
  레이어 rectable 축 자체는 지정된 경우 배경 pixmap 또는 색상 만 그립니다 (\ ref
  setBackground). 처음에는 "배경"레이어에 배치됩니다 (\ ref QCPLayer에서
  QCustomPlot 레이어 시스템에 대한 설명). 축 rect에 의해 유지되는 축은
  다른 레이어에 놓고 축 rect와 별도로 배치합니다.
  
  모든 축 rect에는 \ ref QCPLayoutInset 유형의 하위 레이아웃이 있습니다. \ ref를 통해 액세스 할 수 있습니다.
  insetLayout을 사용하여 다른 레이아웃 요소 (또는 다중
  요소)가 축 rect 내부로 가져갑니다.
  
  축 rect를 클릭하고 끌면 특정 축 범위를 이동하여 축 rect를 처리합니다. 그만큼
  동작은 \ ref setRangeDrag 및 \ ref setRangeDragAxes를 사용하여 제어 할 수 있습니다. 마우스 휠
  커서가 축 rect에있는 동안 스크롤되며 특정 축의 크기가 조정됩니다. 이것은 제어 가능하다.
  \ ref setRangeZoom, \ ref setRangeZoomAxes 및 \ ref setRangeZoomFactor를 통해. 이러한 상호 작용은
  \ ref QCustomPlot :: setInteractions에 \ ref QCP :: iRangeDrag 및 \ ref가 포함 된 경우에만 활성화됩니다.
  QCP :: iRangeZoom.
  
  \ image html AxisRectSpacingOverview.png
  <center> 축의 형상을 정의하는 간격 및 패딩 개요입니다. 파선
  맨 왼쪽의 선은 뷰포트 / 위젯 경계를 나타냅니다. </ center>
*/

/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */

/*! \fn QCPLayoutInset *QCPAxisRect::insetLayout() const
  
  Returns the inset layout of this axis rect. It can be used to place other layout elements (or
  even layouts with multiple other elements) inside/on top of an axis rect.
  
  \see QCPLayoutInset
*/
/*! \ fn QCPLayoutInset * QCPAxisRect :: insetLayout () const
  
  이 축 rect의 인et 트 배치를 돌려줍니다. 다른 레이아웃 요소를 배치하는 데 사용할 수 있습니다 (또는
  다른 여러 요소가있는 레이아웃조차도) 축 rect의 안쪽 / 위에 있습니다.
  
  \ QCPLayoutInset 참조
*/

/*! \fn int QCPAxisRect::left() const
  
  Returns the pixel position of the left border of this axis rect. Margins are not taken into
  account here, so the returned value is with respect to the inner \ref rect.
*/
/*! \ fn int QCPAxisRect :: left () const
  
  이 축 rect의 왼쪽의 경계의 픽셀의 위치를 ​​돌려줍니다. 여백은 받아 들여지지 않는다.
  여기에 계정이 있으므로 반환 값은 내부 \ ref rect를 기준으로합니다.
*/
/*! \fn int QCPAxisRect::right() const
  
  Returns the pixel position of the right border of this axis rect. Margins are not taken into
  account here, so the returned value is with respect to the inner \ref rect.
*/
/*! \ fn int QCPAxisRect :: right () const
  
  이 축 rect의 오른쪽 보더의 픽셀 위치를 돌려줍니다. 여백은 받아 들여지지 않는다.
  여기에 계정이 있으므로 반환 값은 내부 \ ref rect를 기준으로합니다.
*/

/*! \fn int QCPAxisRect::top() const
  
  Returns the pixel position of the top border of this axis rect. Margins are not taken into
  account here, so the returned value is with respect to the inner \ref rect.
*/
/*! \ fn int QCPAxisRect :: top () const
  
  이 축 rect의 상단 경계의 픽셀 위치를 돌려줍니다. 여백은 받아 들여지지 않는다.
  여기에 계정이 있으므로 반환 값은 내부 \ ref rect를 기준으로합니다.
*/
/*! \fn int QCPAxisRect::bottom() const
  
  Returns the pixel position of the bottom border of this axis rect. Margins are not taken into
  account here, so the returned value is with respect to the inner \ref rect.
*/
/*! \ fn int QCPAxisRect :: bottom () const
  
  이 축 rect의 하단 보더의 픽셀 위치를 돌려줍니다. 여백은 받아 들여지지 않는다.
  여기에 계정이 있으므로 반환 값은 내부 \ ref rect를 기준으로합니다.
*/
/*! \fn int QCPAxisRect::width() const
  
  Returns the pixel width of this axis rect. Margins are not taken into account here, so the
  returned value is with respect to the inner \ref rect.
*/
/*! \ fn int QCPAxisRect :: width () const
  
  이 축 rect의 픽셀 폭을 돌려줍니다. 여백은 여기에 고려되지 않으므로
  반환 값은 내부 \ ref rect를 기준으로합니다.
*/

/*! \fn int QCPAxisRect::height() const
  
  Returns the pixel height of this axis rect. Margins are not taken into account here, so the
  returned value is with respect to the inner \ref rect.
*/
/*! \ fn int QCPAxisRect :: height () const
  
  이 축 rect의 픽셀의 높이를 돌려줍니다. 여백은 여기에 고려되지 않으므로
  반환 값은 내부 \ ref rect를 기준으로합니다.
*/

/*! \fn QSize QCPAxisRect::size() const
  
  Returns the pixel size of this axis rect. Margins are not taken into account here, so the
  returned value is with respect to the inner \ref rect.
*/
/*! \ fn QSize QCPAxisRect :: size () const
  
  이 축 rect의 픽셀 사이즈를 돌려줍니다. 여백은 여기에 고려되지 않으므로
  반환 값은 내부 \ ref rect를 기준으로합니다.
*/

/*! \fn QPoint QCPAxisRect::topLeft() const
  
  Returns the top left corner of this axis rect in pixels. Margins are not taken into account here,
  so the returned value is with respect to the inner \ref rect.
*/
/*! \ fn QPoint QCPAxisRect :: topLeft () const
  
  이 축 Rect의 좌상 구석을 픽셀 단위로 돌려줍니다. 여백은 여기에 고려되지 않습니다.
  그래서 반환 된 값은 inner \ ref rect를 기준으로합니다.
*/

/*! \fn QPoint QCPAxisRect::topRight() const
  
  Returns the top right corner of this axis rect in pixels. Margins are not taken into account
  here, so the returned value is with respect to the inner \ref rect.
*/
/*! \ fn QPoint QCPAxisRect :: topRight () const
  
  이 축의 좌상 구석을 픽셀 단위로 돌려줍니다. 여백은 고려되지 않습니다.
  여기에서, 반환 값은 inner \ ref rect를 기준으로합니다.
*/

/*! \fn QPoint QCPAxisRect::bottomLeft() const
  
  Returns the bottom left corner of this axis rect in pixels. Margins are not taken into account
  here, so the returned value is with respect to the inner \ref rect.
*/
/*! \ fn QPoint QCPAxisRect :: bottomLeft () const
  
  이 축의 좌상단 구석을 픽셀 단위로 돌려줍니다. 여백은 고려되지 않습니다.
  여기에서, 반환 값은 inner \ ref rect를 기준으로합니다.
*/

/*! \fn QPoint QCPAxisRect::bottomRight() const
  
  Returns the bottom right corner of this axis rect in pixels. Margins are not taken into account
  here, so the returned value is with respect to the inner \ref rect.
*/
/*! \ fn QPoint QCPAxisRect :: bottomRight () const
  
  이 축의 좌상 구석을 픽셀 단위로 돌려줍니다. 여백은 고려되지 않습니다.
  여기에서, 반환 값은 inner \ ref rect를 기준으로합니다.
*/

/*! \fn QPoint QCPAxisRect::center() const
  
  Returns the center of this axis rect in pixels. Margins are not taken into account here, so the
  returned value is with respect to the inner \ref rect.
*/
/*! \ fn QPoint QCPAxisRect :: center () const
  
  이 축의 중심을 픽셀 단위로 돌려줍니다. 여백은 여기에 고려되지 않으므로
  반환 값은 내부 \ ref rect를 기준으로합니다.
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */

/*!
  Creates a QCPAxisRect instance and sets default values. An axis is added for each of the four
  sides, the top and right axes are set invisible initially.
*/
/*!
  QCPAxisRect 인스턴스를 만들고 기본값을 설정합니다. 네 개의 축마다 축이 추가됩니다.
  측면의 경우 위쪽 및 오른쪽 축이 처음에는 보이지 않게 설정됩니다.
*/
QCPAxisRect::QCPAxisRect(QCustomPlot *parentPlot, bool setupDefaultAxes) :
  QCPLayoutElement(parentPlot),
  mBackgroundBrush(Qt::NoBrush),
  mBackgroundScaled(true),
  mBackgroundScaledMode(Qt::KeepAspectRatioByExpanding),
  mInsetLayout(new QCPLayoutInset),
  mRangeDrag(Qt::Horizontal|Qt::Vertical),
  mRangeZoom(Qt::Horizontal|Qt::Vertical),
  mRangeZoomFactorHorz(0.85),
  mRangeZoomFactorVert(0.85),
  mDragging(false)
{
  mInsetLayout->initializeParentPlot(mParentPlot);
  mInsetLayout->setParentLayerable(this);
  mInsetLayout->setParent(this);
  
  setMinimumSize(50, 50);
  setMinimumMargins(QMargins(15, 15, 15, 15));
  mAxes.insert(QCPAxis::atLeft, QList<QCPAxis*>());
  mAxes.insert(QCPAxis::atRight, QList<QCPAxis*>());
  mAxes.insert(QCPAxis::atTop, QList<QCPAxis*>());
  mAxes.insert(QCPAxis::atBottom, QList<QCPAxis*>());
  
  if (setupDefaultAxes)
  {
    QCPAxis *xAxis = addAxis(QCPAxis::atBottom);
    QCPAxis *yAxis = addAxis(QCPAxis::atLeft);
    QCPAxis *xAxis2 = addAxis(QCPAxis::atTop);
    QCPAxis *yAxis2 = addAxis(QCPAxis::atRight);
    setRangeDragAxes(xAxis, yAxis);
    setRangeZoomAxes(xAxis, yAxis);
    xAxis2->setVisible(false);
    yAxis2->setVisible(false);
    xAxis->grid()->setVisible(true);
    yAxis->grid()->setVisible(true);
    xAxis2->grid()->setVisible(false);
    yAxis2->grid()->setVisible(false);
    xAxis2->grid()->setZeroLinePen(Qt::NoPen);
    yAxis2->grid()->setZeroLinePen(Qt::NoPen);
    xAxis2->grid()->setVisible(false);
    yAxis2->grid()->setVisible(false);
  }
}

QCPAxisRect::~QCPAxisRect()
{
  delete mInsetLayout;
  mInsetLayout = 0;
  
  QList<QCPAxis*> axesList = axes();
  for (int i=0; i<axesList.size(); ++i)
    removeAxis(axesList.at(i));
}

/*!
  Returns the number of axes on the axis rect side specified with \a type.
  
  \see axis
*/
/*!
  \ a 유형으로 지정된 축 rect 측 축 수를 반환합니다.
  
  \ 축보기
*/
int QCPAxisRect::axisCount(QCPAxis::AxisType type) const
{
  return mAxes.value(type).size();
}

/*!
  Returns the axis with the given \a index on the axis rect side specified with \a type.
  
  \see axisCount, axes
*/
/*!
  \ a 형으로 지정된 축 rect 측의 지정된 \ a 인덱스를 가지는 축을 리턴합니다.
  
  \ 참조 axisCount, 축
*/
QCPAxis *QCPAxisRect::axis(QCPAxis::AxisType type, int index) const
{
  QList<QCPAxis*> ax(mAxes.value(type));
  if (index >= 0 && index < ax.size())
  {
    return ax.at(index);
  } else
  {
    qDebug() << Q_FUNC_INFO << "Axis index out of bounds:" << index;
    return 0;
  }
}

/*!
  Returns all axes on the axis rect sides specified with \a types.
  
  \a types may be a single \ref QCPAxis::AxisType or an <tt>or</tt>-combination, to get the axes of
  multiple sides.
  
  \see axis
*/
/*!
  \ a 유형으로 지정된 축 rect 측면의 모든 축을 반환합니다.
  
  \ a 유형은 축을 얻기 위해 단일 \ ref QCPAxis :: AxisType 또는 <tt> 또는 </ tt> - 결합 일 수 있습니다.
  여러 측면.
  
  \ 축보기
*/
QList<QCPAxis*> QCPAxisRect::axes(QCPAxis::AxisTypes types) const
{
  QList<QCPAxis*> result;
  if (types.testFlag(QCPAxis::atLeft))
    result << mAxes.value(QCPAxis::atLeft);
  if (types.testFlag(QCPAxis::atRight))
    result << mAxes.value(QCPAxis::atRight);
  if (types.testFlag(QCPAxis::atTop))
    result << mAxes.value(QCPAxis::atTop);
  if (types.testFlag(QCPAxis::atBottom))
    result << mAxes.value(QCPAxis::atBottom);
  return result;
}

/*! \overload
  
  Returns all axes of this axis rect.
*/
/*! \초과 적재
  
  이 축 rect의 모든 축을 돌려줍니다.
*/
QList<QCPAxis*> QCPAxisRect::axes() const
{
  QList<QCPAxis*> result;
  QHashIterator<QCPAxis::AxisType, QList<QCPAxis*> > it(mAxes);
  while (it.hasNext())
  {
    it.next();
    result << it.value();
  }
  return result;
}

/*!
  Adds a new axis to the axis rect side specified with \a type, and returns it. If \a axis is 0, a
  new QCPAxis instance is created internally. QCustomPlot owns the returned axis, so if you want to
  remove an axis, use \ref removeAxis instead of deleting it manually.

  You may inject QCPAxis instances (or subclasses of QCPAxis) by setting \a axis to an axis that was
  previously created outside QCustomPlot. It is important to note that QCustomPlot takes ownership
  of the axis, so you may not delete it afterwards. Further, the \a axis must have been created
  with this axis rect as parent and with the same axis type as specified in \a type. If this is not
  the case, a debug output is generated, the axis is not added, and the method returns 0.

  This method can not be used to move \a axis between axis rects. The same \a axis instance must
  not be added multiple times to the same or different axis rects.

  If an axis rect side already contains one or more axes, the lower and upper endings of the new
  axis (\ref QCPAxis::setLowerEnding, \ref QCPAxis::setUpperEnding) are set to \ref
  QCPLineEnding::esHalfBar.

  \see addAxes, setupFullAxesBox
*/
/*!
  \ a 유형으로 지정된 축 rect 측에 새 축을 추가하고이를 반환합니다. \ a 축이 0 인 경우 a
  새로운 QCPAxis 인스턴스가 내부적으로 생성됩니다. QCustomPlot은 반환 된 축을 소유하므로 원하는 경우
  축을 제거하고 \ ref removeAxis를 수동으로 삭제하는 대신 사용하십시오.

  축을 축에 축을 설정하여 QCPAxis 인스턴스 (또는 QCPAxis의 하위 클래스)를 주입 할 수 있습니다.
  이전에 QCustomPlot 외부에서 생성되었습니다. QCustomPlot은 소유권을 갖습니다.
  이후 축을 삭제할 수는 없습니다. 또한 \ a 축을 만들어야합니다.
  이 축 rect를 부모로 사용하고 \ a 유형에 지정된 축 유형과 동일하게 만듭니다. 그렇지 않은 경우
  경우, 디버그 출력이 생성되고 축이 추가되지 않으며 메서드는 0을 반환합니다.

  이 메서드는 축 rect 사이에서 축을 이동하는 데 사용할 수 없습니다. 동일한 \ a 축 인스턴스가 있어야합니다.
  동일한 또는 다른 축 rect에 여러 번 추가 할 수 없습니다.

  축 rect면에 이미 하나 이상의 축이 포함되어 있으면 새 축의 하단과 상단이 종료됩니다.
  축 (\ ref QCPAxis :: setLowerEnding, \ ref QCPAxis :: setUpperEnding)은 \ ref로 설정됩니다.
  QCPLineEnding :: esHalfBar.

  \ addAxes, setupFullAxesBox를 보라.
*/
QCPAxis *QCPAxisRect::addAxis(QCPAxis::AxisType type, QCPAxis *axis)
{
  QCPAxis *newAxis = axis;
  if (!newAxis)
  {
    newAxis = new QCPAxis(this, type);
  } else // user provided existing axis instance, do some sanity checks
         // 사용자가 기존 축 인스턴스를 제공하고, 온 전성 검사를 수행합니다.
  {
    if (newAxis->axisType() != type)
    {
      qDebug() << Q_FUNC_INFO << "passed axis has different axis type than specified in type parameter";
      return 0;
    }
    if (newAxis->axisRect() != this)
    {
      qDebug() << Q_FUNC_INFO << "passed axis doesn't have this axis rect as parent axis rect";
      return 0;
    }
    if (axes().contains(newAxis))
    {
      qDebug() << Q_FUNC_INFO << "passed axis is already owned by this axis rect";
      return 0;
    }
  }
  if (mAxes[type].size() > 0) // multiple axes on one side, add half-bar axis ending to additional axes with offset
                              // 여러 축이 있으면 오프셋이있는 추가 축으로 끝나는 반 막대 축 추가
  {
    bool invert = (type == QCPAxis::atRight) || (type == QCPAxis::atBottom);
    newAxis->setLowerEnding(QCPLineEnding(QCPLineEnding::esHalfBar, 6, 10, !invert));
    newAxis->setUpperEnding(QCPLineEnding(QCPLineEnding::esHalfBar, 6, 10, invert));
  }
  mAxes[type].append(newAxis);
  
  // reset convenience axis pointers on parent QCustomPlot if they are unset:
  // 부모 QCustomPlot에 편의 축 포인터를 재설정합니다 (설정되지 않은 경우).
  if (mParentPlot && mParentPlot->axisRectCount() > 0 && mParentPlot->axisRect(0) == this)
  {
    switch (type)
    {
      case QCPAxis::atBottom: { if (!mParentPlot->xAxis) mParentPlot->xAxis = newAxis; break; }
      case QCPAxis::atLeft: { if (!mParentPlot->yAxis) mParentPlot->yAxis = newAxis; break; }
      case QCPAxis::atTop: { if (!mParentPlot->xAxis2) mParentPlot->xAxis2 = newAxis; break; }
      case QCPAxis::atRight: { if (!mParentPlot->yAxis2) mParentPlot->yAxis2 = newAxis; break; }
    }
  }
  
  return newAxis;
}

/*!
  Adds a new axis with \ref addAxis to each axis rect side specified in \a types. This may be an
  <tt>or</tt>-combination of QCPAxis::AxisType, so axes can be added to multiple sides at once.
  
  Returns a list of the added axes.
  
  \see addAxis, setupFullAxesBox
*/
/*!
  \ ref 유형으로 지정된 각 축 rect 측에 \ ref addAxis가있는 새 축을 추가합니다. 이것은
  <tt> 또는 </ tt> - QCPAxis :: AxisType의 결합으로 축을 여러면에 동시에 추가 할 수 있습니다.
  
  추가 된 축의리스트를 돌려줍니다.
  
  \ addAxis, setupFullAxesBox를 참조하십시오.
*/
QList<QCPAxis*> QCPAxisRect::addAxes(QCPAxis::AxisTypes types)
{
  QList<QCPAxis*> result;
  if (types.testFlag(QCPAxis::atLeft))
    result << addAxis(QCPAxis::atLeft);
  if (types.testFlag(QCPAxis::atRight))
    result << addAxis(QCPAxis::atRight);
  if (types.testFlag(QCPAxis::atTop))
    result << addAxis(QCPAxis::atTop);
  if (types.testFlag(QCPAxis::atBottom))
    result << addAxis(QCPAxis::atBottom);
  return result;
}

/*!
  Removes the specified \a axis from the axis rect and deletes it.
  
  Returns true on success, i.e. if \a axis was a valid axis in this axis rect.
  
  \see addAxis
*/
/*!
  축 rect에서 지정된 \ a 축을 제거하고 삭제합니다.
  
  성공하면 true를 반환합니다. 즉, 축이이 축 rect에서 유효한 축인 경우입니다.
  
  \ see addAxis
*/
bool QCPAxisRect::removeAxis(QCPAxis *axis)
{
  // don't access axis->axisType() to provide safety when axis is an invalid pointer, rather go through all axis containers:
 // 축이 유효하지 않은 포인터 일 때 안전을 제공하려면 axis-> axisType ()에 액세스하지 말고 모든 축 컨테이너를 통과하십시오.
  QHashIterator<QCPAxis::AxisType, QList<QCPAxis*> > it(mAxes);
  while (it.hasNext())
  {
    it.next();
    if (it.value().contains(axis))
    {
      if (it.value().first() == axis && it.value().size() > 1) // if removing first axis, transfer axis offset to the new first axis (which at this point is the second axis, if it exists)
 //첫 번째 축을 제거하면 축 오프셋을 새로운 첫 번째 축 (이 시점에서 두 번째 축)으로 옮깁니다. 축이있는 경우)
        it.value()[1]->setOffset(axis->offset());
      mAxes[it.key()].removeOne(axis);
      if (qobject_cast<QCustomPlot*>(parentPlot())) // make sure this isn't called from QObject dtor when QCustomPlot is already destructed (happens when the axis rect is not in any layout and thus QObject-child of QCustomPlot)
// QCustomPlot이 이미 소멸 될 때 QObject dtor에서 호출되지 않도록하십시오 (축 rect가 레이아웃에 없으므로 QCustomPlot의 QObject-
        parentPlot()->axisRemoved(axis);
      delete axis;
      return true;
    }
  }
  qDebug() << Q_FUNC_INFO << "Axis isn't in axis rect:" << reinterpret_cast<quintptr>(axis);
  return false;
}

/*!
  Zooms in (or out) to the passed rectangular region \a pixelRect, given in pixel coordinates.

  All axes of this axis rect will have their range zoomed accordingly. If you only wish to zoom
  specific axes, use the overloaded version of this method.
  
  \see QCustomPlot::setSelectionRectMode
*/
/*!
  전달 된 사각형 영역 \ pixelRect를 픽셀 좌표로 확대 (또는 축소)합니다.

  이 축 rect의 모든 축에는 그에 따라 확대 된 범위가 있습니다. 확대 / 축소하려는 경우에만
  특정 축의 경우,이 메소드의 오버로드 된 버전을 사용하십시오.
  
  \ QCustomPlot :: setSelectionRectMode를 참조하십시오.
*/
void QCPAxisRect::zoom(const QRectF &pixelRect)
{
  zoom(pixelRect, axes());
}

/*! \overload
  
  Zooms in (or out) to the passed rectangular region \a pixelRect, given in pixel coordinates.
  
  Only the axes passed in \a affectedAxes will have their ranges zoomed accordingly.
  
  \see QCustomPlot::setSelectionRectMode
*/
/*! \초과 적재
  
  전달 된 사각형 영역 \ pixelRect를 픽셀 좌표로 확대 (또는 축소)합니다.
  
  \ a affectedAxes에 전달 된 축에만 범위가 확대됩니다.
  
  \ QCustomPlot :: setSelectionRectMode를 참조하십시오.
*/
void QCPAxisRect::zoom(const QRectF &pixelRect, const QList<QCPAxis*> &affectedAxes)
{
  foreach (QCPAxis *axis, affectedAxes)
  {
    if (!axis)
    {
      qDebug() << Q_FUNC_INFO << "a passed axis was zero";
      continue;
    }
    QCPRange pixelRange;
    if (axis->orientation() == Qt::Horizontal)
      pixelRange = QCPRange(pixelRect.left(), pixelRect.right());
    else
      pixelRange = QCPRange(pixelRect.top(), pixelRect.bottom());
    axis->setRange(axis->pixelToCoord(pixelRange.lower), axis->pixelToCoord(pixelRange.upper));
  }
}

/*!
  Convenience function to create an axis on each side that doesn't have any axes yet and set their
  visibility to true. Further, the top/right axes are assigned the following properties of the
  bottom/left axes:

  \li range (\ref QCPAxis::setRange)
  \li range reversed (\ref QCPAxis::setRangeReversed)
  \li scale type (\ref QCPAxis::setScaleType)
  \li tick visibility (\ref QCPAxis::setTicks)
  \li number format (\ref QCPAxis::setNumberFormat)
  \li number precision (\ref QCPAxis::setNumberPrecision)
  \li tick count of ticker (\ref QCPAxisTicker::setTickCount)
  \li tick origin of ticker (\ref QCPAxisTicker::setTickOrigin)

  Tick label visibility (\ref QCPAxis::setTickLabels) of the right and top axes are set to false.

  If \a connectRanges is true, the \ref QCPAxis::rangeChanged "rangeChanged" signals of the bottom
  and left axes are connected to the \ref QCPAxis::setRange slots of the top and right axes.
*/
/*!
  각 축에 아직 축이없고 각 축을 설정하지 않은 축을 만드는 편리함 기능
  사실에 대한 가시성. 또한 상단 / 우측 축에는
  아래 / 왼쪽 축 :

  \ li 범위 (\ ref QCPAxis :: setRange)
  \ li 범위가 반대로 됨 (\ ref QCPAxis :: setRangeReversed)
  \ li 눈금 유형 (\ ref QCPAxis :: setScaleType)
  \ li 틱 가시성 (\ ref QCPAxis :: setTicks)
  \ li 숫자 형식 (\ ref QCPAxis :: setNumberFormat)
  \ li 번호 정밀도 (\ ref QCPAxis :: setNumberPrecision)
  \ li ticker의 틱 수 (\ ref QCPAxisTicker :: setTickCount)
  \ li ticker의 원점 (\ ref QCPAxisTicker :: setTickOrigin)

  오른쪽 및 상단 축의 눈금 표시 여부 (\ ref QCPAxis :: setTickLabels)는 false로 설정됩니다.

  \ connectRanges가 참이면 \ ref QCPAxis :: rangeChanged "rangeChanged"신호가 맨 아래에 표시됩니다
  왼쪽 축은 상단 축과 우측 축의 \ ref QCPAxis :: setRange 슬롯에 연결됩니다.
*/
void QCPAxisRect::setupFullAxesBox(bool connectRanges)
{
  QCPAxis *xAxis, *yAxis, *xAxis2, *yAxis2;
  if (axisCount(QCPAxis::atBottom) == 0)
    xAxis = addAxis(QCPAxis::atBottom);
  else
    xAxis = axis(QCPAxis::atBottom);
  
  if (axisCount(QCPAxis::atLeft) == 0)
    yAxis = addAxis(QCPAxis::atLeft);
  else
    yAxis = axis(QCPAxis::atLeft);
  
  if (axisCount(QCPAxis::atTop) == 0)
    xAxis2 = addAxis(QCPAxis::atTop);
  else
    xAxis2 = axis(QCPAxis::atTop);
  
  if (axisCount(QCPAxis::atRight) == 0)
    yAxis2 = addAxis(QCPAxis::atRight);
  else
    yAxis2 = axis(QCPAxis::atRight);
  
  xAxis->setVisible(true);
  yAxis->setVisible(true);
  xAxis2->setVisible(true);
  yAxis2->setVisible(true);
  xAxis2->setTickLabels(false);
  yAxis2->setTickLabels(false);
  
  xAxis2->setRange(xAxis->range());
  xAxis2->setRangeReversed(xAxis->rangeReversed());
  xAxis2->setScaleType(xAxis->scaleType());
  xAxis2->setTicks(xAxis->ticks());
  xAxis2->setNumberFormat(xAxis->numberFormat());
  xAxis2->setNumberPrecision(xAxis->numberPrecision());
  xAxis2->ticker()->setTickCount(xAxis->ticker()->tickCount());
  xAxis2->ticker()->setTickOrigin(xAxis->ticker()->tickOrigin());
  
  yAxis2->setRange(yAxis->range());
  yAxis2->setRangeReversed(yAxis->rangeReversed());
  yAxis2->setScaleType(yAxis->scaleType());
  yAxis2->setTicks(yAxis->ticks());
  yAxis2->setNumberFormat(yAxis->numberFormat());
  yAxis2->setNumberPrecision(yAxis->numberPrecision());
  yAxis2->ticker()->setTickCount(yAxis->ticker()->tickCount());
  yAxis2->ticker()->setTickOrigin(yAxis->ticker()->tickOrigin());
  
  if (connectRanges)
  {
    connect(xAxis, SIGNAL(rangeChanged(QCPRange)), xAxis2, SLOT(setRange(QCPRange)));
    connect(yAxis, SIGNAL(rangeChanged(QCPRange)), yAxis2, SLOT(setRange(QCPRange)));
  }
}

/*!
  Returns a list of all the plottables that are associated with this axis rect.
  
  A plottable is considered associated with an axis rect if its key or value axis (or both) is in
  this axis rect.
  
  \see graphs, items
*/
/*!
  이 축 rect와 연관된 모든 plottable 목록을 반환합니다.
  
  플롯 테이블은 키 또는 값 축 (또는 둘 다)이있는 경우 축 rect와 관련되어있는 것으로 간주됩니다.
  이 축 rect.
  
  \ 그래프, 항목보기
*/
QList<QCPAbstractPlottable*> QCPAxisRect::plottables() const
{
  // Note: don't append all QCPAxis::plottables() into a list, because we might get duplicate entries
  // 참고 : 모든 QCPAxis :: plottables ()를 목록에 추가하지 마십시오. 중복 된 항목이있을 수 있습니다.
  QList<QCPAbstractPlottable*> result;
  for (int i=0; i<mParentPlot->mPlottables.size(); ++i)
  {
    if (mParentPlot->mPlottables.at(i)->keyAxis()->axisRect() == this || mParentPlot->mPlottables.at(i)->valueAxis()->axisRect() == this)
      result.append(mParentPlot->mPlottables.at(i));
  }
  return result;
}

/*!
  Returns a list of all the graphs that are associated with this axis rect.
  
  A graph is considered associated with an axis rect if its key or value axis (or both) is in
  this axis rect.
  
  \see plottables, items
*/
/*!
  이 축 rect와 관련 지을 수 있고있는 모든 그래프의리스트를 돌려줍니다.
  
  그래프가 키 또는 값 축 (또는 양쪽 모두)에있는 경우, 축 rect와 관련 지을 수 있었던 것으로 간주됩니다
  이 축 rect.
  
  \ plottables, items보기
*/
QList<QCPGraph*> QCPAxisRect::graphs() const
{
  // Note: don't append all QCPAxis::graphs() into a list, because we might get duplicate entries
  // 참고 : 중복 된 항목이있을 수 있으므로 모든 QCPAxis :: graphs ()를 목록에 추가하지 마십시오.
  QList<QCPGraph*> result;
  for (int i=0; i<mParentPlot->mGraphs.size(); ++i)
  {
    if (mParentPlot->mGraphs.at(i)->keyAxis()->axisRect() == this || mParentPlot->mGraphs.at(i)->valueAxis()->axisRect() == this)
      result.append(mParentPlot->mGraphs.at(i));
  }
  return result;
}

/*!
  Returns a list of all the items that are associated with this axis rect.
  
  An item is considered associated with an axis rect if any of its positions has key or value axis
  set to an axis that is in this axis rect, or if any of its positions has \ref
  QCPItemPosition::setAxisRect set to the axis rect, or if the clip axis rect (\ref
  QCPAbstractItem::setClipAxisRect) is set to this axis rect.
  
  \see plottables, graphs
*/
/*!
  이 축 rect와 관련 지을 수 있었던 모든 항목의리스트를 돌려줍니다.
  
  항목 중 하나에 키 또는 값 축이있는 경우 항목이 축 rect와 연결되어 있다고 간주됩니다.
  이 축 rect에있는 축으로 설정하거나 해당 위치 중 하나에 \ ref가있는 경우
  축 rect로 설정된 QCPItemPosition :: setAxisRect 또는 클립 축 rect (\ ref
  QCPAbstractItem :: setClipAxisRect)가이 축 rect로 설정됩니다.
  
  \ plotables, 그래프보기
*/
QList<QCPAbstractItem *> QCPAxisRect::items() const
{
  // Note: don't just append all QCPAxis::items() into a list, because we might get duplicate entries
  //       and miss those items that have this axis rect as clipAxisRect.
  // 참고 : 모든 QCPAxis :: items ()를 목록에 추가하지 마십시오. 중복 항목이있을 수 있습니다.
  //이 축 rect가 clipAxisRect 인 항목을 놓치십시오.
  QList<QCPAbstractItem*> result;
  for (int itemId=0; itemId<mParentPlot->mItems.size(); ++itemId)
  {
    if (mParentPlot->mItems.at(itemId)->clipAxisRect() == this)
    {
      result.append(mParentPlot->mItems.at(itemId));
      continue;
    }
    QList<QCPItemPosition*> positions = mParentPlot->mItems.at(itemId)->positions();
    for (int posId=0; posId<positions.size(); ++posId)
    {
      if (positions.at(posId)->axisRect() == this ||
          positions.at(posId)->keyAxis()->axisRect() == this ||
          positions.at(posId)->valueAxis()->axisRect() == this)
      {
        result.append(mParentPlot->mItems.at(itemId));
        break;
      }
    }
  }
  return result;
}

/*!
  This method is called automatically upon replot and doesn't need to be called by users of
  QCPAxisRect.
  
  Calls the base class implementation to update the margins (see \ref QCPLayoutElement::update),
  and finally passes the \ref rect to the inset layout (\ref insetLayout) and calls its
  QCPInsetLayout::update function.
  
  \seebaseclassmethod
*/
/*!
  이 메소드는 replot시 자동으로 호출되므로 사용자가 호출하지 않아도됩니다.
  QCPAxisRect.
  
  기본 클래스 구현을 호출하여 여백을 업데이트합니다 (\ ref QCPLayoutElement :: update 참조).
  마지막으로 \ ref rect를 삽입 된 레이아웃 (\ ref insetLayout)으로 전달하고
  QCPInsetLayout :: 업데이트 함수.
  
  \ seebaseclassmethod
*/
void QCPAxisRect::update(UpdatePhase phase)
{
  QCPLayoutElement::update(phase);
  
  switch (phase)
  {
    case upPreparation:
    {
      QList<QCPAxis*> allAxes = axes();
      for (int i=0; i<allAxes.size(); ++i)
        allAxes.at(i)->setupTickVectors();
      break;
    }
    case upLayout:
    {
      mInsetLayout->setOuterRect(rect());
      break;
    }
    default: break;
  }
  
  // pass update call on to inset layout (doesn't happen automatically, because QCPAxisRect doesn't derive from QCPLayout):
// 인셋 레이아웃에 업데이트 호출을 전달합니다 (QCPAxisRect가 QCPLayout에서 파생되지 않기 때문에 자동으로 발생하지 않음).
  mInsetLayout->update(phase);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QList<QCPLayoutElement*> QCPAxisRect::elements(bool recursive) const
{
  QList<QCPLayoutElement*> result;
  if (mInsetLayout)
  {
    result << mInsetLayout;
    if (recursive)
      result << mInsetLayout->elements(recursive);
  }
  return result;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPAxisRect::applyDefaultAntialiasingHint(QCPPainter *painter) const
{
  painter->setAntialiasing(false);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPAxisRect::draw(QCPPainter *painter)
{
  drawBackground(painter);
}

/*!
  Sets \a pm as the axis background pixmap. The axis background pixmap will be drawn inside the
  axis rect. Since axis rects place themselves on the "background" layer by default, the axis rect
  backgrounds are usually drawn below everything else.

  For cases where the provided pixmap doesn't have the same size as the axis rect, scaling can be
  enabled with \ref setBackgroundScaled and the scaling mode (i.e. whether and how the aspect ratio
  is preserved) can be set with \ref setBackgroundScaledMode. To set all these options in one call,
  consider using the overloaded version of this function.

  Below the pixmap, the axis rect may be optionally filled with a brush, if specified with \ref
  setBackground(const QBrush &brush).
  
  \see setBackgroundScaled, setBackgroundScaledMode, setBackground(const QBrush &brush)
*/
/*!
  \ a pm을 축 배경 pixmap으로 설정합니다. 축 배경 pixmap은
  축 rect. 축 rect는 기본적으로 "background"레이어에 배치되기 때문에 rect 축은
  배경은 일반적으로 다른 모든 것의 아래에 그려집니다.

  제공된 pixmap이 축 rect와 크기가 같지 않은 경우 크기 조정이 가능합니다.
  \ ref setBackgroundScaled 및 배율 모드 (즉, 가로 세로 비
  보존됩니다)는 \ ref setBackgroundScaledMode로 설정할 수 있습니다. 이러한 모든 옵션을 하나의 호출로 설정하려면,
  이 함수의 오버로드 된 버전 사용을 고려하십시오.

  픽스맵 아래에서 rect 축은 \ ref로 지정되면 선택적으로 브러쉬로 채워질 수 있습니다.
  setBackground (const QBrush & 브러시).
  
  \ setBackgroundScaled 참조, setBackgroundScaledMode, setBackground (const QBrush & brush)
*/
void QCPAxisRect::setBackground(const QPixmap &pm)
{
  mBackgroundPixmap = pm;
  mScaledBackgroundPixmap = QPixmap();
}

/*! \overload
  
  Sets \a brush as the background brush. The axis rect background will be filled with this brush.
  Since axis rects place themselves on the "background" layer by default, the axis rect backgrounds
  are usually drawn below everything else.

  The brush will be drawn before (under) any background pixmap, which may be specified with \ref
  setBackground(const QPixmap &pm).

  To disable drawing of a background brush, set \a brush to Qt::NoBrush.
  
  \see setBackground(const QPixmap &pm)
*/

/*! \초과 적재
  
  브러시를 배경 브러시로 설정합니다. 축 직사각형 배경이이 브러시로 채워집니다.
  축 rect는 기본적으로 "background"레이어에 배치되기 때문에 축 rect 배경
  일반적으로 다른 모든 것의 아래에 그려집니다.

  브러시는 배경 픽스맵 앞에 (그 아래에) 그려지며, 이는 \ ref로 지정 될 수 있습니다
  setBackground (const QPixmap & pm).

  배경 브러쉬 그리기를 사용하지 않으려면 \ brush를 Qt :: NoBrush로 설정하십시오.
  
  \ 참조 setBackground (const QPixmap & pm)
*/
void QCPAxisRect::setBackground(const QBrush &brush)
{
  mBackgroundBrush = brush;
}

/*! \overload
  
  Allows setting the background pixmap of the axis rect, whether it shall be scaled and how it
  shall be scaled in one call.

  \see setBackground(const QPixmap &pm), setBackgroundScaled, setBackgroundScaledMode
*/

/*! \초과 적재
  
  축 rect의 배경 pixmap 설정 여부, 축척 여부, 축척 등을 설정할 수 있습니다.
  하나의 호출로 확장되어야한다.

  \ setBackground (const QPixmap & pm), setBackgroundScaled, setBackgroundScaledMode를 참조하십시오.
*/
void QCPAxisRect::setBackground(const QPixmap &pm, bool scaled, Qt::AspectRatioMode mode)
{
  mBackgroundPixmap = pm;
  mScaledBackgroundPixmap = QPixmap();
  mBackgroundScaled = scaled;
  mBackgroundScaledMode = mode;
}

/*!
  Sets whether the axis background pixmap shall be scaled to fit the axis rect or not. If \a scaled
  is set to true, you may control whether and how the aspect ratio of the original pixmap is
  preserved with \ref setBackgroundScaledMode.
  
  Note that the scaled version of the original pixmap is buffered, so there is no performance
  penalty on replots. (Except when the axis rect dimensions are changed continuously.)
  
  \see setBackground, setBackgroundScaledMode
*/
/*!
  축 배경 pixmap이 축 rect에 맞게 축척 될지 여부를 설정합니다. 조정 된 경우 \
  이 true로 설정되면 원본 pixmap의 종횡비가
  \ ref setBackgroundScaledMode로 보존됩니다.
  
  원본 pixmap의 크기가 조정 된 버전은 버퍼링되므로 성능이 없습니다.
  replots에 페널티. (축 rect 치수가 연속적으로 변경된 경우 제외)
  
  \ setBackground, setBackgroundScaledMode를 참조하십시오.
*/
void QCPAxisRect::setBackgroundScaled(bool scaled)
{
  mBackgroundScaled = scaled;
}

/*!
  If scaling of the axis background pixmap is enabled (\ref setBackgroundScaled), use this function to
  define whether and how the aspect ratio of the original pixmap passed to \ref setBackground is preserved.
  \see setBackground, setBackgroundScaled
*/
/*!
  축 배경 pixmap의 배율이 활성화 된 경우 (\ ref setBackgroundScaled)이 함수를 사용하여
  \ ref setBackground로 전달 된 원본 픽스맵의 종횡비가 유지되는지 여부와 그 정의를 정의합니다.
  \ setBackground, setBackgroundScaled를 참조하십시오.
*/
void QCPAxisRect::setBackgroundScaledMode(Qt::AspectRatioMode mode)
{
  mBackgroundScaledMode = mode;
}

/*!
  Returns the range drag axis of the \a orientation provided. If multiple axes were set, returns
  the first one (use \ref rangeDragAxes to retrieve a list with all set axes).

  \see setRangeDragAxes
*/
/*!
  제공된 \ a 방향의 범위 드래그 축을 반환합니다. 여러 축이 설정된 경우
  첫 번째 것 (\ ref rangeDragAxes를 사용하여 모든 설정된 축을 가진 목록을 검색).

  \ setRangeDragAxes를 참조하십시오.
*/
QCPAxis *QCPAxisRect::rangeDragAxis(Qt::Orientation orientation)
{
  if (orientation == Qt::Horizontal)
    return mRangeDragHorzAxis.isEmpty() ? 0 : mRangeDragHorzAxis.first().data();
  else
    return mRangeDragVertAxis.isEmpty() ? 0 : mRangeDragVertAxis.first().data();
}

/*!
  Returns the range zoom axis of the \a orientation provided. If multiple axes were set, returns
  the first one (use \ref rangeZoomAxes to retrieve a list with all set axes).

  \see setRangeZoomAxes
*/
/*!
  제공된 \ a 방향의 범위 줌 축을 반환합니다. 여러 축이 설정된 경우
  첫 번째 것 (\ ref rangeZoomAxes를 사용하여 모든 설정된 축을 가진 목록을 검색).

  \ see setRangeZoomAxes
*/
QCPAxis *QCPAxisRect::rangeZoomAxis(Qt::Orientation orientation)
{
  if (orientation == Qt::Horizontal)
    return mRangeZoomHorzAxis.isEmpty() ? 0 : mRangeZoomHorzAxis.first().data();
  else
    return mRangeZoomVertAxis.isEmpty() ? 0 : mRangeZoomVertAxis.first().data();
}

/*!
  Returns all range drag axes of the \a orientation provided.

  \see rangeZoomAxis, setRangeZoomAxes
*/
/*!
  제공된 \ a 방향의 모든 범위 드래그 축을 반환합니다.

  \ rangeZoomAxis, setRangeZoomAxes를 참조하십시오.
*/
QList<QCPAxis*> QCPAxisRect::rangeDragAxes(Qt::Orientation orientation)
{
  QList<QCPAxis*> result;
  if (orientation == Qt::Horizontal)
  {
    for (int i=0; i<mRangeDragHorzAxis.size(); ++i)
    {
      if (!mRangeDragHorzAxis.at(i).isNull())
        result.append(mRangeDragHorzAxis.at(i).data());
    }
  } else
  {
    for (int i=0; i<mRangeDragVertAxis.size(); ++i)
    {
      if (!mRangeDragVertAxis.at(i).isNull())
        result.append(mRangeDragVertAxis.at(i).data());
    }
  }
  return result;
}

/*!
  Returns all range zoom axes of the \a orientation provided.

  \see rangeDragAxis, setRangeDragAxes
*/
/*!
  제공된 \ a 방향의 모든 범위 줌 축을 반환합니다.

  \ see rangeDragAxis, setRangeDragAxes
*/
QList<QCPAxis*> QCPAxisRect::rangeZoomAxes(Qt::Orientation orientation)
{
  QList<QCPAxis*> result;
  if (orientation == Qt::Horizontal)
  {
    for (int i=0; i<mRangeZoomHorzAxis.size(); ++i)
    {
      if (!mRangeZoomHorzAxis.at(i).isNull())
        result.append(mRangeZoomHorzAxis.at(i).data());
    }
  } else
  {
    for (int i=0; i<mRangeZoomVertAxis.size(); ++i)
    {
      if (!mRangeZoomVertAxis.at(i).isNull())
        result.append(mRangeZoomVertAxis.at(i).data());
    }
  }
  return result;
}

/*!
  Returns the range zoom factor of the \a orientation provided.
  
  \see setRangeZoomFactor
*/
/*!
  제공된 \ a 방향의 범위 줌 인수를 반환합니다.
  
  \ see setRangeZoomFactor
*/
double QCPAxisRect::rangeZoomFactor(Qt::Orientation orientation)
{
  return (orientation == Qt::Horizontal ? mRangeZoomFactorHorz : mRangeZoomFactorVert);
}

/*!
  Sets which axis orientation may be range dragged by the user with mouse interaction.
  What orientation corresponds to which specific axis can be set with
  \ref setRangeDragAxes(QCPAxis *horizontal, QCPAxis *vertical). By
  default, the horizontal axis is the bottom axis (xAxis) and the vertical axis
  is the left axis (yAxis).
  
  To disable range dragging entirely, pass 0 as \a orientations or remove \ref QCP::iRangeDrag from \ref
  QCustomPlot::setInteractions. To enable range dragging for both directions, pass <tt>Qt::Horizontal |
  Qt::Vertical</tt> as \a orientations.
  
  In addition to setting \a orientations to a non-zero value, make sure \ref QCustomPlot::setInteractions
  contains \ref QCP::iRangeDrag to enable the range dragging interaction.
  
  \see setRangeZoom, setRangeDragAxes, QCustomPlot::setNoAntialiasingOnDrag
*/
/*!
  마우스 조작으로 사용자가 범위를 드래그 할 수있는 축 방향을 설정합니다.
  어떤 방향이 어떤 특정 축을 사용하여 설정 될 수 있는가
  \ ref setRangeDragAxes (QCPAxis * 가로, QCPAxis * 세로). 으로
  기본값, 가로 축은 아래 축 (xAxis)이고 세로 축
  왼쪽 축 (yAxis)입니다.
  
  범위 드래그를 완전히 비활성화하려면 \ a 방향으로 0을 전달하거나 \ ref에서 \ ref QCP :: iRangeDrag를 제거합니다.
  QCustomPlot :: setInteractions. 양방향으로 범위 드래그를 사용하려면 <tt> Qt :: Horizontal |
  Qt :: Vertical </ tt>을 방향으로 사용합니다.
  
  오리엔테이션을 0이 아닌 값으로 설정하는 것 외에도 \ ref QCustomPlot :: setInteractions
  범위 드래그 상호 작용을 사용하려면 \ ref QCP :: iRangeDrag를 포함합니다.
  
  \ setRangeZoom, setRangeDragAxes, QCustomPlot :: setNoAntialiasingOnDrag를 참조하십시오.
*/
void QCPAxisRect::setRangeDrag(Qt::Orientations orientations)
{
  mRangeDrag = orientations;
}

/*!
  Sets which axis orientation may be zoomed by the user with the mouse wheel. What orientation
  corresponds to which specific axis can be set with \ref setRangeZoomAxes(QCPAxis *horizontal,
  QCPAxis *vertical). By default, the horizontal axis is the bottom axis (xAxis) and the vertical
  axis is the left axis (yAxis).

  To disable range zooming entirely, pass 0 as \a orientations or remove \ref QCP::iRangeZoom from \ref
  QCustomPlot::setInteractions. To enable range zooming for both directions, pass <tt>Qt::Horizontal |
  Qt::Vertical</tt> as \a orientations.
  
  In addition to setting \a orientations to a non-zero value, make sure \ref QCustomPlot::setInteractions
  contains \ref QCP::iRangeZoom to enable the range zooming interaction.
  
  \see setRangeZoomFactor, setRangeZoomAxes, setRangeDrag
*/
/*!
  마우스 휠로 사용자가 확대 / 축소 할 수있는 축 방향을 설정합니다. 어떤 오리엔테이션
  어느 특정 축을 \ ref setRangeZoomAxes (QCPAxis * horizontal,
  QCPAxis * 세로). 기본적으로 가로 축은 아래 축 (xAxis)이고 세로 축
  축은 왼쪽 축 (yAxis)입니다.

  범위 확대를 완전히 비활성화하려면 0을 \ a 방향으로 전달하거나 \ ref QCP :: iRangeZoom을 \ ref에서 제거하십시오
  QCustomPlot :: setInteractions. 양방향으로 범위 확대를 사용하려면 <tt> Qt :: Horizontal |
  Qt :: Vertical </ tt>을 방향으로 사용합니다.
  
  오리엔테이션을 0이 아닌 값으로 설정하는 것 외에도 \ ref QCustomPlot :: setInteractions
  범위 확대 / 축소 상호 작용을 사용하려면 \ ref QCP :: iRangeZoom을 포함합니다.
  
  \ setRangeZoomFactor, setRangeZoomAxes, setRangeDrag를 참조하십시오.
*/
void QCPAxisRect::setRangeZoom(Qt::Orientations orientations)
{
  mRangeZoom = orientations;
}

/*! \overload
  
  Sets the axes whose range will be dragged when \ref setRangeDrag enables mouse range dragging on
  the QCustomPlot widget. Pass 0 if no axis shall be dragged in the respective orientation.

  Use the overload taking a list of axes, if multiple axes (more than one per orientation) shall
  react to dragging interactions.

  \see setRangeZoomAxes
*/
/*! \초과 적재
  
  \ ref setRangeDrag가 마우스 범위 드래그를 가능하게 할 때 범위가 드래그 될 축을 설정합니다.
  QCustomPlot 위젯. 각 방향으로 축을 드래그하지 않으면 0을 전달합니다.

  축의 목록을 취하여 과부하를 사용하십시오. 여러 축 (방향 당 둘 이상)이
  상호 작용을 드래그하여 반응합니다.

  \ see setRangeZoomAxes
*/
void QCPAxisRect::setRangeDragAxes(QCPAxis *horizontal, QCPAxis *vertical)
{
  QList<QCPAxis*> horz, vert;
  if (horizontal)
    horz.append(horizontal);
  if (vertical)
    vert.append(vertical);
  setRangeDragAxes(horz, vert);
}

/*! \overload

  This method allows to set up multiple axes to react to horizontal and vertical dragging. The drag
  orientation that the respective axis will react to is deduced from its orientation (\ref
  QCPAxis::orientation).

  In the unusual case that you wish to e.g. drag a vertically oriented axis with a horizontal drag
  motion, use the overload taking two separate lists for horizontal and vertical dragging.
*/
/*! \초과 적재

  이 방법을 사용하면 수평 및 수직 끌기에 반응하는 여러 축을 설정할 수 있습니다. 드래그
  각각의 축이 반응 할 방위는 방위 (\ ref
  QCPAxis :: orientation).

  비정상적인 경우에 예를 들어 수직 끌기 축을 수평 끌기로 끌기를 원한다면
  모션에서 수평 및 수직 드래그를 위해 두 개의 개별 목록을 사용하여 과부하를 사용하십시오.
*/

void QCPAxisRect::setRangeDragAxes(QList<QCPAxis*> axes)
{
  QList<QCPAxis*> horz, vert;
  foreach (QCPAxis *ax, axes)
  {
    if (ax->orientation() == Qt::Horizontal)
      horz.append(ax);
    else
      vert.append(ax);
  }
  setRangeDragAxes(horz, vert);
}

/*! \overload

  This method allows to set multiple axes up to react to horizontal and vertical dragging, and
  define specifically which axis reacts to which drag orientation (irrespective of the axis
  orientation).
*/
/*! \초과 적재

  이 방법을 사용하면 수평 및 수직 끌기에 반응하도록 여러 축을 위로 설정할 수 있습니다.
  어떤 축이 어떤 끌기 방향에 반응 하는지를 구체적으로 정의합니다 (축에 관계없이).
  정위).
*/
void QCPAxisRect::setRangeDragAxes(QList<QCPAxis*> horizontal, QList<QCPAxis*> vertical)
{
  mRangeDragHorzAxis.clear();
  foreach (QCPAxis *ax, horizontal)
  {
    QPointer<QCPAxis> axPointer(ax);
    if (!axPointer.isNull())
      mRangeDragHorzAxis.append(axPointer);
    else
      qDebug() << Q_FUNC_INFO << "invalid axis passed in horizontal list:" << reinterpret_cast<quintptr>(ax);
  }
  mRangeDragVertAxis.clear();
  foreach (QCPAxis *ax, vertical)
  {
    QPointer<QCPAxis> axPointer(ax);
    if (!axPointer.isNull())
      mRangeDragVertAxis.append(axPointer);
    else
      qDebug() << Q_FUNC_INFO << "invalid axis passed in vertical list:" << reinterpret_cast<quintptr>(ax);
  }
}

/*!
  Sets the axes whose range will be zoomed when \ref setRangeZoom enables mouse wheel zooming on
  the QCustomPlot widget. Pass 0 if no axis shall be zoomed in the respective orientation.

  The two axes can be zoomed with different strengths, when different factors are passed to \ref
  setRangeZoomFactor(double horizontalFactor, double verticalFactor).

  Use the overload taking a list of axes, if multiple axes (more than one per orientation) shall
  react to zooming interactions.

  \see setRangeDragAxes
*/
/*!
  \ ref setRangeZoom이 마우스 휠 확대를 켤 때 범위가 확대되는 축을 설정합니다.
  QCustomPlot 위젯. 각 방향으로 축이 확대되지 않으면 0을 전달합니다.

  서로 다른 요소가 \ ref에 전달되면 두 축을 다른 강도로 확대 할 수 있습니다.
  setRangeZoomFactor (double horizontalFactor, double verticalFactor).

  축의 목록을 취하여 과부하를 사용하십시오. 여러 축 (방향 당 둘 이상)이
  확대 / 축소 상호 작용에 반응합니다.

  \ setRangeDragAxes를 참조하십시오.
*/
void QCPAxisRect::setRangeZoomAxes(QCPAxis *horizontal, QCPAxis *vertical)
{
  QList<QCPAxis*> horz, vert;
  if (horizontal)
    horz.append(horizontal);
  if (vertical)
    vert.append(vertical);
  setRangeZoomAxes(horz, vert);
}

/*! \overload

  This method allows to set up multiple axes to react to horizontal and vertical range zooming. The
  zoom orientation that the respective axis will react to is deduced from its orientation (\ref
  QCPAxis::orientation).

  In the unusual case that you wish to e.g. zoom a vertically oriented axis with a horizontal zoom
  interaction, use the overload taking two separate lists for horizontal and vertical zooming.
*/
/*! \초과 적재

  이 방법을 사용하면 수평 및 수직 범위 확대 / 축소에 반응하는 여러 축을 설정할 수 있습니다. 그만큼
  각 축이 반응 할 확대 / 축소 배향은 배향 (\ ref
  QCPAxis :: orientation).

  비정상적인 경우에 예를 들어 세로 줌 축을 수평 줌으로 줌하려는 경우
  상호 작용에서 수평 및 수직 확대를 위해 두 개의 개별 목록을 사용하여 과부하를 사용합니다.
*/
void QCPAxisRect::setRangeZoomAxes(QList<QCPAxis*> axes)
{
  QList<QCPAxis*> horz, vert;
  foreach (QCPAxis *ax, axes)
  {
    if (ax->orientation() == Qt::Horizontal)
      horz.append(ax);
    else
      vert.append(ax);
  }
  setRangeZoomAxes(horz, vert);
}

/*! \overload

  This method allows to set multiple axes up to react to horizontal and vertical zooming, and
  define specifically which axis reacts to which zoom orientation (irrespective of the axis
  orientation).
*/
/*! \초과 적재

  이 방법을 사용하면 수평 및 수직 확대 / 축소에 반응하도록 여러 축을 위로 설정할 수 있습니다.
  특정 축이 어떤 줌 방향에 반응 하는지를 구체적으로 정의합니다 (축과 관계 없음).
  정위).
*/
void QCPAxisRect::setRangeZoomAxes(QList<QCPAxis*> horizontal, QList<QCPAxis*> vertical)
{
  mRangeZoomHorzAxis.clear();
  foreach (QCPAxis *ax, horizontal)
  {
    QPointer<QCPAxis> axPointer(ax);
    if (!axPointer.isNull())
      mRangeZoomHorzAxis.append(axPointer);
    else
      qDebug() << Q_FUNC_INFO << "invalid axis passed in horizontal list:" << reinterpret_cast<quintptr>(ax);
  }
  mRangeZoomVertAxis.clear();
  foreach (QCPAxis *ax, vertical)
  {
    QPointer<QCPAxis> axPointer(ax);
    if (!axPointer.isNull())
      mRangeZoomVertAxis.append(axPointer);
    else
      qDebug() << Q_FUNC_INFO << "invalid axis passed in vertical list:" << reinterpret_cast<quintptr>(ax);
  }
}

/*!
  Sets how strong one rotation step of the mouse wheel zooms, when range zoom was activated with
  \ref setRangeZoom. The two parameters \a horizontalFactor and \a verticalFactor provide a way to
  let the horizontal axis zoom at different rates than the vertical axis. Which axis is horizontal
  and which is vertical, can be set with \ref setRangeZoomAxes.

  When the zoom factor is greater than one, scrolling the mouse wheel backwards (towards the user)
  will zoom in (make the currently visible range smaller). For zoom factors smaller than one, the
  same scrolling direction will zoom out.
*/
/*!
  범위 확대가 활성화되었을 때 마우스 휠의 한 회전 단계가 얼마나 강한지를 설정합니다.
  \ ref setRangeZoom. horizontalFactor와 \ verticalFactor의 두 매개 변수는
  가로 축이 세로 축과 다른 속도로 확대되도록하십시오. 어느 축이 수평인가
  수직이며, \ ref setRangeZoomAxes로 설정할 수 있습니다.

  확대 / 축소 비율이 1보다 큰 경우 마우스 휠을 뒤로 (사용자쪽으로)
  (현재 보이는 범위를 더 작게) 확대 할 것입니다. 줌 배율이 1보다 작 으면
  동일한 스크롤 방향이 축소됩니다.
*/
void QCPAxisRect::setRangeZoomFactor(double horizontalFactor, double verticalFactor)
{
  mRangeZoomFactorHorz = horizontalFactor;
  mRangeZoomFactorVert = verticalFactor;
}

/*! \overload
  
  Sets both the horizontal and vertical zoom \a factor.
*/
/*! \초과 적재
  
  수평 및 수직 확대 / 축소 비율을 설정합니다.
*/
void QCPAxisRect::setRangeZoomFactor(double factor)
{
  mRangeZoomFactorHorz = factor;
  mRangeZoomFactorVert = factor;
}

/*! \internal
  
  Draws the background of this axis rect. It may consist of a background fill (a QBrush) and a
  pixmap.
  
  If a brush was given via \ref setBackground(const QBrush &brush), this function first draws an
  according filling inside the axis rect with the provided \a painter.
  
  Then, if a pixmap was provided via \ref setBackground, this function buffers the scaled version
  depending on \ref setBackgroundScaled and \ref setBackgroundScaledMode and then draws it inside
  the axis rect with the provided \a painter. The scaled version is buffered in
  mScaledBackgroundPixmap to prevent expensive rescaling at every redraw. It is only updated, when
  the axis rect has changed in a way that requires a rescale of the background pixmap (this is
  dependent on the \ref setBackgroundScaledMode), or when a differend axis background pixmap was
  set.
  
  \see setBackground, setBackgroundScaled, setBackgroundScaledMode
*/
/*! \내부의
  
  이 축 rect의 백그라운드를 묘화합니다. 배경 채우기 (QBrush)와
  pixmap.
  
  \ ref setBackground (const QBrush & brush)를 통해 브러시가 제공되면이 함수는 먼저
  제공되는 \ painter로 축 rect 내부를 채운다.
  
  그런 다음 pixmap이 \ ref setBackground를 통해 제공된 경우이 함수는 크기가 조정 된 버전을 버퍼링합니다
  \ ref setBackgroundScaled 및 \ ref setBackgroundScaledMode에 따라 달라지며 내부에 그려집니다.
  제공된 축으로 축 rect. 크기가 조정 된 버전은에서 버퍼링됩니다.
  mScaledBackgroundPixmap은 모든 다시 그리기시 값 비싼 재조정을 방지합니다. 업데이트 될 때만
  축 rect는 백그라운드 pixmap의 크기 조정이 필요한 방식으로 변경되었습니다 (이것은
  \ ref setBackgroundScaledMode에 의존), 또는 differennd 축 배경 pixmap이
  세트.
  
  \ setBackground, setBackgroundScaled, setBackgroundScaledMode를 참조하십시오.
*/
void QCPAxisRect::drawBackground(QCPPainter *painter)
{
  // draw background fill:
  // 배경 채우기 그리기 :
  if (mBackgroundBrush != Qt::NoBrush)
    painter->fillRect(mRect, mBackgroundBrush);
  
  // draw background pixmap (on top of fill, if brush specified):
  // 배경 pixmap 그리기 (브러쉬가 지정된 경우 채우기 상단에 있음) :
  if (!mBackgroundPixmap.isNull())
  {
    if (mBackgroundScaled)
    {
      // check whether mScaledBackground needs to be updated:
      // mScaledBackground를 업데이트해야하는지 여부를 확인합니다.
      QSize scaledSize(mBackgroundPixmap.size());
      scaledSize.scale(mRect.size(), mBackgroundScaledMode);
      if (mScaledBackgroundPixmap.size() != scaledSize)
        mScaledBackgroundPixmap = mBackgroundPixmap.scaled(mRect.size(), mBackgroundScaledMode, Qt::SmoothTransformation);
      painter->drawPixmap(mRect.topLeft()+QPoint(0, -1), mScaledBackgroundPixmap, QRect(0, 0, mRect.width(), mRect.height()) & mScaledBackgroundPixmap.rect());
    } else
    {
      painter->drawPixmap(mRect.topLeft()+QPoint(0, -1), mBackgroundPixmap, QRect(0, 0, mRect.width(), mRect.height()));
    }
  }
}

/*! \internal
  
  This function makes sure multiple axes on the side specified with \a type don't collide, but are
  distributed according to their respective space requirement (QCPAxis::calculateMargin).
  
  It does this by setting an appropriate offset (\ref QCPAxis::setOffset) on all axes except the
  one with index zero.
  
  This function is called by \ref calculateAutoMargin.
*/
/*! \내부의
  
  이 함수는 \ a 유형으로 지정된 측면의 여러 축이 충돌하지 않지만
  각각의 공간 요구 사항 (QCPAxis :: calculateMargin)에 따라 분산됩니다.
  
  이것은 적절한 오프셋 (\ ref QCPAxis :: setOffset)을 설정합니다.
  하나는 인덱스 0입니다.
  
  이 함수는 \ ref calculateAutoMargin에 의해 호출됩니다.
*/
void QCPAxisRect::updateAxesOffset(QCPAxis::AxisType type)
{
  const QList<QCPAxis*> axesList = mAxes.value(type);
  if (axesList.isEmpty())
    return;
  
  bool isFirstVisible = !axesList.first()->visible(); // if the first axis is visible, the second axis (which is where the loop starts) isn't the first visible axis, so initialize with false
// 첫 번째 축이 표시되면 두 번째 축 (루프가 시작되는 위치)이 첫 번째 표시된 축이 아니므로 false로 초기화하십시오.
  for (int i=1; i<axesList.size(); ++i)
  {
    int offset = axesList.at(i-1)->offset() + axesList.at(i-1)->calculateMargin();
    if (axesList.at(i)->visible()) // only add inner tick length to offset if this axis is visible and it's not the first visible one (might happen if true first axis is invisible)
//이 축을 볼 수 있고 처음 보이는 축이 아닌 경우에만 내부 틱 길이를 오프셋에 추가합니다 (첫 번째 축이 보이지 않는 경우 발생할 수 있음)
    {
      if (!isFirstVisible)
        offset += axesList.at(i)->tickLengthIn();
      isFirstVisible = false;
    }
    axesList.at(i)->setOffset(offset);
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
int QCPAxisRect::calculateAutoMargin(QCP::MarginSide side)
{
  if (!mAutoMargins.testFlag(side))
    qDebug() << Q_FUNC_INFO << "Called with side that isn't specified as auto margin";
  
  updateAxesOffset(QCPAxis::marginSideToAxisType(side));
  
  // note: only need to look at the last (outer most) axis to determine the total margin, due to updateAxisOffset call
  // 참고 : updateAxisOffset 호출로 인해 총 마진을 결정하기 위해 가장 마지막 (가장 바깥 쪽) 축만 살펴 봐야합니다.
  const QList<QCPAxis*> axesList = mAxes.value(QCPAxis::marginSideToAxisType(side));
  if (axesList.size() > 0)
    return axesList.last()->offset() + axesList.last()->calculateMargin();
  else
    return 0;
}

/*! \internal
  
  Reacts to a change in layout to potentially set the convenience axis pointers \ref
  QCustomPlot::xAxis, \ref QCustomPlot::yAxis, etc. of the parent QCustomPlot to the respective
  axes of this axis rect. This is only done if the respective convenience pointer is currently zero
  and if there is no QCPAxisRect at position (0, 0) of the plot layout.
  
  This automation makes it simpler to replace the main axis rect with a newly created one, without
  the need to manually reset the convenience pointers.
*/
/*! \내부의
  
  잠재적으로 편리한 축 포인터를 설정하기 위해 레이아웃 변경에 반응합니다. \ ref
  QCustomPlot :: xAxis, 부모 QCustomPlot의 \ ref QCustomPlot :: yAxis 등을
  이 축 rect의 축. 각 편의 포인터가 현재 0 인 경우에만 수행됩니다
  플롯 레이아웃의 위치 (0, 0)에 QCPAxisRect가없는 경우.
  
  이 자동화로 메인 축 rect를 새롭게 생성 된 것으로 교체하는 것이 더 간단 해졌습니다.
  편의 포인터를 수동으로 재설정해야합니다.
*/
void QCPAxisRect::layoutChanged()
{
  if (mParentPlot && mParentPlot->axisRectCount() > 0 && mParentPlot->axisRect(0) == this)
  {
    if (axisCount(QCPAxis::atBottom) > 0 && !mParentPlot->xAxis)
      mParentPlot->xAxis = axis(QCPAxis::atBottom);
    if (axisCount(QCPAxis::atLeft) > 0 && !mParentPlot->yAxis)
      mParentPlot->yAxis = axis(QCPAxis::atLeft);
    if (axisCount(QCPAxis::atTop) > 0 && !mParentPlot->xAxis2)
      mParentPlot->xAxis2 = axis(QCPAxis::atTop);
    if (axisCount(QCPAxis::atRight) > 0 && !mParentPlot->yAxis2)
      mParentPlot->yAxis2 = axis(QCPAxis::atRight);
  }
}

/*! \internal
  
  Event handler for when a mouse button is pressed on the axis rect. If the left mouse button is
  pressed, the range dragging interaction is initialized (the actual range manipulation happens in
  the \ref mouseMoveEvent).

  The mDragging flag is set to true and some anchor points are set that are needed to determine the
  distance the mouse was dragged in the mouse move/release events later.
  
  \see mouseMoveEvent, mouseReleaseEvent
*/
/*! \내부의
  
  축 rect에서 마우스 버튼을 눌렀을 때의 이벤트 핸들러입니다. 마우스 왼쪽 버튼이
  누르면 범위 드래그 상호 작용이 초기화됩니다 (실제 범위 조작은
  \ ref mouseMoveEvent).

  mDragging 플래그가 true로 설정되어 있고, 일부 앵커 포인트가 설정되어 있습니다.
  나중에 마우스 이동 / 릴리스 이벤트에서 마우스를 드래그 한 거리.
  
  \ see mouseMoveEvent, mouseReleaseEvent
*/
void QCPAxisRect::mousePressEvent(QMouseEvent *event, const QVariant &details)
{
  Q_UNUSED(details)
  if (event->buttons() & Qt::LeftButton)
  {
    mDragging = true;
    // initialize antialiasing backup in case we start dragging:
    // 드래그를 시작할 경우를 대비해 앤티 엘리 어싱 백업을 초기화합니다.
    if (mParentPlot->noAntialiasingOnDrag())
    {
      mAADragBackup = mParentPlot->antialiasedElements();
      mNotAADragBackup = mParentPlot->notAntialiasedElements();
    }
    // Mouse range dragging interaction:
    // 마우스 범위 드래그 상호 작용 :
    if (mParentPlot->interactions().testFlag(QCP::iRangeDrag))
    {
      mDragStartHorzRange.clear();
      for (int i=0; i<mRangeDragHorzAxis.size(); ++i)
        mDragStartHorzRange.append(mRangeDragHorzAxis.at(i).isNull() ? QCPRange() : mRangeDragHorzAxis.at(i)->range());
      mDragStartVertRange.clear();
      for (int i=0; i<mRangeDragVertAxis.size(); ++i)
        mDragStartVertRange.append(mRangeDragVertAxis.at(i).isNull() ? QCPRange() : mRangeDragVertAxis.at(i)->range());
    }
  }
}

/*! \internal
  
  Event handler for when the mouse is moved on the axis rect. If range dragging was activated in a
  preceding \ref mousePressEvent, the range is moved accordingly.
  
  \see mousePressEvent, mouseReleaseEvent
*/
/*! \내부의
  
  마우스를 축 rect에서 이동할 때의 이벤트 핸들러입니다. 범위 드래그가
  앞에 \ ref mousePressEvent를 지정하면 범위가 그에 따라 이동합니다.
  
  \ see mousePressEvent, mouseReleaseEvent
*/
void QCPAxisRect::mouseMoveEvent(QMouseEvent *event, const QPointF &startPos)
{
  Q_UNUSED(startPos)
  // Mouse range dragging interaction:
  // 마우스 범위 드래그 상호 작용 :
  if (mDragging && mParentPlot->interactions().testFlag(QCP::iRangeDrag))
  {
    
    if (mRangeDrag.testFlag(Qt::Horizontal))
    {
      for (int i=0; i<mRangeDragHorzAxis.size(); ++i)
      {
        QCPAxis *ax = mRangeDragHorzAxis.at(i).data();
        if (!ax)
          continue;
        if (i >= mDragStartHorzRange.size())
          break;
        if (ax->mScaleType == QCPAxis::stLinear)
        {
          double diff = ax->pixelToCoord(startPos.x()) - ax->pixelToCoord(event->pos().x());
          ax->setRange(mDragStartHorzRange.at(i).lower+diff, mDragStartHorzRange.at(i).upper+diff);
        } else if (ax->mScaleType == QCPAxis::stLogarithmic)
        {
          double diff = ax->pixelToCoord(startPos.x()) / ax->pixelToCoord(event->pos().x());
          ax->setRange(mDragStartHorzRange.at(i).lower*diff, mDragStartHorzRange.at(i).upper*diff);
        }
      }
    }
    
    if (mRangeDrag.testFlag(Qt::Vertical))
    {
      for (int i=0; i<mRangeDragVertAxis.size(); ++i)
      {
        QCPAxis *ax = mRangeDragVertAxis.at(i).data();
        if (!ax)
          continue;
        if (i >= mDragStartVertRange.size())
          break;
        if (ax->mScaleType == QCPAxis::stLinear)
        {
          double diff = ax->pixelToCoord(startPos.y()) - ax->pixelToCoord(event->pos().y());
          ax->setRange(mDragStartVertRange.at(i).lower+diff, mDragStartVertRange.at(i).upper+diff);
        } else if (ax->mScaleType == QCPAxis::stLogarithmic)
        {
          double diff = ax->pixelToCoord(startPos.y()) / ax->pixelToCoord(event->pos().y());
          ax->setRange(mDragStartVertRange.at(i).lower*diff, mDragStartVertRange.at(i).upper*diff);
        }
      }
    }
    
    if (mRangeDrag != 0) // if either vertical or horizontal drag was enabled, do a replot
                         // 수직 또는 수평 드래그가 활성화 된 경우 replot을 수행합니다.
    {
      if (mParentPlot->noAntialiasingOnDrag())
        mParentPlot->setNotAntialiasedElements(QCP::aeAll);
      mParentPlot->replot(QCustomPlot::rpQueuedReplot);
    }
    
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPAxisRect::mouseReleaseEvent(QMouseEvent *event, const QPointF &startPos)
{
  Q_UNUSED(event)
  Q_UNUSED(startPos)
  mDragging = false;
  if (mParentPlot->noAntialiasingOnDrag())
  {
    mParentPlot->setAntialiasedElements(mAADragBackup);
    mParentPlot->setNotAntialiasedElements(mNotAADragBackup);
  }
}

/*! \internal
  
  Event handler for mouse wheel events. If rangeZoom is Qt::Horizontal, Qt::Vertical or both, the
  ranges of the axes defined as rangeZoomHorzAxis and rangeZoomVertAxis are scaled. The center of
  the scaling operation is the current cursor position inside the axis rect. The scaling factor is
  dependent on the mouse wheel delta (which direction the wheel was rotated) to provide a natural
  zooming feel. The Strength of the zoom can be controlled via \ref setRangeZoomFactor.
  
  Note, that event->delta() is usually +/-120 for single rotation steps. However, if the mouse
  wheel is turned rapidly, many steps may bunch up to one event, so the event->delta() may then be
  multiples of 120. This is taken into account here, by calculating \a wheelSteps and using it as
  exponent of the range zoom factor. This takes care of the wheel direction automatically, by
  inverting the factor, when the wheel step is negative (f^-1 = 1/f).
*/
/*! \내부의
  
  마우스 휠 이벤트의 이벤트 핸들러입니다. rangeZoom이 Qt :: Horizontal, Qt :: Vertical 또는 둘 모두라면,
  rangeZoomHorzAxis 및 rangeZoomVertAxis로 정의 된 축의 범위가 조정됩니다. 센터
  축척 연산은 축 rect 내부의 현재 커서 위치입니다. 스케일링 팩터는 다음과 같습니다.
  마우스 휠 델타 (휠이 회전 된 방향)에 따라 자연스러운
  확대 / 축소 느낌. 줌의 강도는 \ ref setRangeZoomFactor를 통해 제어 할 수 있습니다.
  
  이벤트 -> 델타 ()는 보통 1 회전 단계에서 +/- 120입니다. 그러나 마우스
  휠이 빠르게 돌리면 많은 단계가 하나의 이벤트를 묶을 수 있으므로 이벤트 -> 델타 ()는
  120의 배수.이 값은 \ wheelSteps를 계산하여 다음과 같이 계산하여 계산됩니다.
  범위 확대 / 축소 지수의 지수. 이것은 자동으로 휠 방향을 처리합니다.
  휠 스텝이 음수이면 (f ^ -1 = 1 / f) 요인 반전.
*/
void QCPAxisRect::wheelEvent(QWheelEvent *event)
{
  // Mouse range zooming interaction:
  // 마우스 범위 확대 / 축소 상호 작용 :
  if (mParentPlot->interactions().testFlag(QCP::iRangeZoom))
  {
    if (mRangeZoom != 0)
    {
      double factor;
      double wheelSteps = event->delta()/120.0; // a single step delta is +/-120 usually
      if (mRangeZoom.testFlag(Qt::Horizontal))  // 한 단계 델타는 보통 +/- 120입니다.
      {
        factor = qPow(mRangeZoomFactorHorz, wheelSteps);
        for (int i=0; i<mRangeZoomHorzAxis.size(); ++i)
        {
          if (!mRangeZoomHorzAxis.at(i).isNull())
            mRangeZoomHorzAxis.at(i)->scaleRange(factor, mRangeZoomHorzAxis.at(i)->pixelToCoord(event->pos().x()));
        }
      }
      if (mRangeZoom.testFlag(Qt::Vertical))
      {
        factor = qPow(mRangeZoomFactorVert, wheelSteps);
        for (int i=0; i<mRangeZoomVertAxis.size(); ++i)
        {
          if (!mRangeZoomVertAxis.at(i).isNull())
            mRangeZoomVertAxis.at(i)->scaleRange(factor, mRangeZoomVertAxis.at(i)->pixelToCoord(event->pos().y()));
        }
      }
      mParentPlot->replot();
    }
  }
}
/* end of 'src/layoutelements/layoutelement-axisrect.cpp' */


/* including file 'src/layoutelements/layoutelement-legend.cpp', size 31097  */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / layoutelements / layoutelement-axisrect.cpp'의 끝 */


/* 'src / layoutelements / layoutelement-legend.cpp'파일을 포함한 크기 31097 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPAbstractLegendItem
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPAbstractLegendItem
  \brief The abstract base class for all entries in a QCPLegend.
  
  It defines a very basic interface for entries in a QCPLegend. For representing plottables in the
  legend, the subclass \ref QCPPlottableLegendItem is more suitable.
  
  Only derive directly from this class when you need absolute freedom (e.g. a custom legend entry
  that's not even associated with a plottable).

  You must implement the following pure virtual functions:
  \li \ref draw (from QCPLayerable)
  
  You inherit the following members you may use:
  <table>
    <tr>
      <td>QCPLegend *\b mParentLegend</td>
      <td>A pointer to the parent QCPLegend.</td>
    </tr><tr>
      <td>QFont \b mFont</td>
      <td>The generic font of the item. You should use this font for all or at least the most prominent text of the item.</td>
    </tr>
  </table>
*/
/*! \ class QCPAbstractLegendItem
  \ brief QCPLegend의 모든 항목에 대한 추상 기본 클래스입니다.
  
  QCPLegend의 항목에 대해 매우 기본적인 인터페이스를 정의합니다. 에서 플롯 테이블을 나타 내기 위해
  범례, 하위 클래스 \ ref QCPPlottableLegendItem이 더 적합합니다.
  
  절대 자유가 필요한 경우에만이 클래스에서 직접 파생됩니다 (예 : 맞춤 범례 항목
  그것은 심지어 plottable과 관련이 없습니다).

  다음의 순수 가상 함수를 구현해야합니다.
  \ li \ ref draw (QCPLayerable에서)
  
  다음 회원을 상속받을 수 있습니다.
  <table>
    <tr>
      <td> QCPLegend * \ b mParentLegend </ td>
      <td> 상위 QCPLegend에 대한 포인터입니다. </ td>
    </ tr> <tr>
      <td> QFont \ b mFont </ td>
      <td> 항목의 일반 글꼴. 이 글꼴은 항목의 전부 또는 적어도 가장 눈에 잘 띄는 텍스트에 사용해야합니다. </ td>
    </ tr>
  </ table>
*/

/* start of documentation of signals */
/* 신호 문서화 */

/*! \fn void QCPAbstractLegendItem::selectionChanged(bool selected)
  
  This signal is emitted when the selection state of this legend item has changed, either by user
  interaction or by a direct call to \ref setSelected.
*/
/*! \ fn void QCPAbstractLegendItem :: selectionChanged (bool 선택됨)
  
  이 신호는이 범례 항목의 선택 상태가 사용자에 의해 변경되거나
  상호 작용 또는 \ ref setSelected에 대한 직접 호출에 의해 수행됩니다.
*/

/* end of documentation of signals */
/* 신호의 문서화 끝 */

/*!
  Constructs a QCPAbstractLegendItem and associates it with the QCPLegend \a parent. This does not
  cause the item to be added to \a parent, so \ref QCPLegend::addItem must be called separately.
*/
/*!
  QCPAbstractLegendItem을 생성하고 QCPLegend \ a 부모와 연결합니다. 이것은
  항목을 \ 부모에 추가하게하여 \ ref QCPLegend :: addItem을 별도로 호출해야합니다.
*/
QCPAbstractLegendItem::QCPAbstractLegendItem(QCPLegend *parent) :
  QCPLayoutElement(parent->parentPlot()),
  mParentLegend(parent),
  mFont(parent->font()),
  mTextColor(parent->textColor()),
  mSelectedFont(parent->selectedFont()),
  mSelectedTextColor(parent->selectedTextColor()),
  mSelectable(true),
  mSelected(false)
{
  setLayer(QLatin1String("legend"));
  setMargins(QMargins(0, 0, 0, 0));
}

/*!
  Sets the default font of this specific legend item to \a font.
  
  \see setTextColor, QCPLegend::setFont
*/
/*!
  이 범례 항목의 기본 글꼴을 \ a font로 설정합니다.
  
  \ setTextColor, QCPLegend :: setFont를 참조하십시오.
*/
void QCPAbstractLegendItem::setFont(const QFont &font)
{
  mFont = font;
}

/*!
  Sets the default text color of this specific legend item to \a color.
  
  \see setFont, QCPLegend::setTextColor
*/
/*!
  이 범례 항목을 선택하면 \ a 글꼴이 일반 텍스트 대신 일반 텍스트를 그리는 데 사용됩니다
  \ ref setFont를 사용하여 글꼴을 설정합니다.
  
  \ setFont, QCPLegend :: setSelectedFont를 참조하십시오.
*/
void QCPAbstractLegendItem::setTextColor(const QColor &color)
{
  mTextColor = color;
}

/*!
  When this legend item is selected, \a font is used to draw generic text, instead of the normal
  font set with \ref setFont.
  
  \see setFont, QCPLegend::setSelectedFont
*/
/*!
  이 범례 항목을 선택하면 일반 텍스트 대신 일반 텍스트를 그리는 데 \ a 색을 사용합니다.
  \ ref setTextColor로 설정된 색상.
  
  \ setTextColor, QCPLegend :: setSelectedTextColor를 참조하십시오.
*/
void QCPAbstractLegendItem::setSelectedFont(const QFont &font)
{
  mSelectedFont = font;
}

/*!
  When this legend item is selected, \a color is used to draw generic text, instead of the normal
  color set with \ref setTextColor.
  
  \see setTextColor, QCPLegend::setSelectedTextColor
*/
/*!
  이 특정 범례 항목을 선택할 수 있는지 여부를 설정합니다.
  
  \ setSelectedParts, QCustomPlot :: setInteractions를 참조하십시오.
*/
void QCPAbstractLegendItem::setSelectedTextColor(const QColor &color)
{
  mSelectedTextColor = color;
}

/*!
  Sets whether this specific legend item is selectable.
  
  \see setSelectedParts, QCustomPlot::setInteractions
*/
/*!
  이 특정 범례 항목을 선택할 수 있는지 여부를 설정합니다.
  
  \ setSelectedParts, QCustomPlot :: setInteractions를 참조하십시오.
*/
void QCPAbstractLegendItem::setSelectable(bool selectable)
{
  if (mSelectable != selectable)
  {
    mSelectable = selectable;
    emit selectableChanged(mSelectable);
  }
}

/*!
  Sets whether this specific legend item is selected.
  
  It is possible to set the selection state of this item by calling this function directly, even if
  setSelectable is set to false.
  
  \see setSelectableParts, QCustomPlot::setInteractions
*/
/*!
  이 특정 범례 항목의 선택 여부를 설정합니다.
  
  이 함수를 직접 호출하여이 항목의 선택 상태를 설정할 수도 있습니다.
  setSelectable는 false로 설정됩니다.
  
  \ setSelectableParts, QCustomPlot :: setInteractions를 참조하십시오.
*/
void QCPAbstractLegendItem::setSelected(bool selected)
{
  if (mSelected != selected)
  {
    mSelected = selected;
    emit selectionChanged(mSelected);
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPAbstractLegendItem::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  Q_UNUSED(details)
  if (!mParentPlot) return -1;
  if (onlySelectable && (!mSelectable || !mParentLegend->selectableParts().testFlag(QCPLegend::spItems)))
    return -1;
  
  if (mRect.contains(pos.toPoint()))
    return mParentPlot->selectionTolerance()*0.99;
  else
    return -1;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPAbstractLegendItem::applyDefaultAntialiasingHint(QCPPainter *painter) const
{
  applyAntialiasingHint(painter, mAntialiased, QCP::aeLegendItems);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QRect QCPAbstractLegendItem::clipRect() const
{
  return mOuterRect;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPAbstractLegendItem::selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)
{
  Q_UNUSED(event)
  Q_UNUSED(details)
  if (mSelectable && mParentLegend->selectableParts().testFlag(QCPLegend::spItems))
  {
    bool selBefore = mSelected;
    setSelected(additive ? !mSelected : true);
    if (selectionStateChanged)
      *selectionStateChanged = mSelected != selBefore;
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPAbstractLegendItem::deselectEvent(bool *selectionStateChanged)
{
  if (mSelectable && mParentLegend->selectableParts().testFlag(QCPLegend::spItems))
  {
    bool selBefore = mSelected;
    setSelected(false);
    if (selectionStateChanged)
      *selectionStateChanged = mSelected != selBefore;
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPPlottableLegendItem
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPPlottableLegendItem
  \brief A legend item representing a plottable with an icon and the plottable name.
  
  This is the standard legend item for plottables. It displays an icon of the plottable next to the
  plottable name. The icon is drawn by the respective plottable itself (\ref
  QCPAbstractPlottable::drawLegendIcon), and tries to give an intuitive symbol for the plottable.
  For example, the QCPGraph draws a centered horizontal line and/or a single scatter point in the
  middle.
  
  Legend items of this type are always associated with one plottable (retrievable via the
  plottable() function and settable with the constructor). You may change the font of the plottable
  name with \ref setFont. Icon padding and border pen is taken from the parent QCPLegend, see \ref
  QCPLegend::setIconBorderPen and \ref QCPLegend::setIconTextPadding.

  The function \ref QCPAbstractPlottable::addToLegend/\ref QCPAbstractPlottable::removeFromLegend
  creates/removes legend items of this type.
  
  Since QCPLegend is based on QCPLayoutGrid, a legend item itself is just a subclass of
  QCPLayoutElement. While it could be added to a legend (or any other layout) via the normal layout
  interface, QCPLegend has specialized functions for handling legend items conveniently, see the
  documentation of \ref QCPLegend.
*/
/*! \ class QCPPlottableLegendItem
  \ brief 아이콘과 plottable 이름이있는 플롯을 나타내는 범례 항목입니다.
  
  이것은 plottables의 표준 범례 항목입니다. 옆에있는 플롯 테이블 아이콘을 표시합니다.
  plottable 이름. 아이콘은 각각의 플롯 테이블 자체에 의해 그려집니다 (\ ref
  QCPAbstractPlottable :: drawLegendIcon), plottable에 대한 직관적 인 기호를 표시합니다.
  예를 들어, QCPGraph는 중심에 수평선 및 / 또는 단일 분산 점을
  중간.
  
  이 유형의 범례 항목은 항상 하나의 플롯 테이블과 연결됩니다 (
  plottable () 함수를 사용하고 생성자로 설정할 수 있습니다. 플롯 테이블의 글꼴을 변경할 수 있습니다.
  \ ref setFont를 사용하여 이름을 지정하십시오. 아이콘 패딩과 테두리 펜은 부모 QCPLegend에서 가져온 것으로 \ ref를 참조하십시오.
  QCPLegend :: setIconBorderPen 및 \ ref QCPLegend :: setIconTextPadding입니다.

  함수 \ ref QCPAbstractPlottable :: addToLegend / \ ref QCPAbstractPlottable :: removeFromLegend
  이 유형의 범례 항목을 만들거나 제거합니다.
  
  QCPLegend는 QCPLayoutGrid를 기반으로하므로 범례 항목 자체는
  QCPLayoutElement. 범례 레이아웃을 통해 범례 (또는 다른 레이아웃)에 추가 될 수 있지만
  인터페이스를 통해 QCPLegend에는 범례 항목을 편리하게 처리하는 특수 기능이 있습니다.
  \ ref QCPLegend의 문서.
*/

/*!
  Creates a new legend item associated with \a plottable.
  
  Once it's created, it can be added to the legend via \ref QCPLegend::addItem.
  
  A more convenient way of adding/removing a plottable to/from the legend is via the functions \ref
  QCPAbstractPlottable::addToLegend and \ref QCPAbstractPlottable::removeFromLegend.
*/
/*!
  플롯 테이블과 연결된 새 범례 항목을 만듭니다.
  
  일단 생성되면 \ ref QCPLegend :: addItem을 통해 범례에 추가 될 수 있습니다.
  
  범례에 /에서 플롯 테이블을 추가 / 제거하는보다 편리한 방법은 함수 \ ref를 사용하는 것입니다
  QCPAbstractPlottable :: addToLegend 및 \ ref QCPAbstractPlottable :: removeFromLegend입니다.
*/
QCPPlottableLegendItem::QCPPlottableLegendItem(QCPLegend *parent, QCPAbstractPlottable *plottable) :
  QCPAbstractLegendItem(parent),
  mPlottable(plottable)
{
  setAntialiased(false);
}

/*! \internal
  
  Returns the pen that shall be used to draw the icon border, taking into account the selection
  state of this item.
*/
/*! \내부의
  
  선택을 고려해 아이콘의 경계를 묘화하는데 사용하는 펜을 리턴합니다.
  이 항목의 상태.
*/
QPen QCPPlottableLegendItem::getIconBorderPen() const
{
  return mSelected ? mParentLegend->selectedIconBorderPen() : mParentLegend->iconBorderPen();
}

/*! \internal
  
  Returns the text color that shall be used to draw text, taking into account the selection state
  of this item.
*/
/*! \내부의
  
  선택 상태를 고려해 텍스트의 묘화에 사용하는 텍스트의 색을 돌려줍니다.
  이 항목의.
*/
QColor QCPPlottableLegendItem::getTextColor() const
{
  return mSelected ? mSelectedTextColor : mTextColor;
}

/*! \internal
  
  Returns the font that shall be used to draw text, taking into account the selection state of this
  item.
*/
/*! \내부의
  
  이 선택 상태를 고려해 텍스트의 묘화에 사용하는 폰트를 돌려줍니다.
  목.
*/
QFont QCPPlottableLegendItem::getFont() const
{
  return mSelected ? mSelectedFont : mFont;
}

/*! \internal
  
  Draws the item with \a painter. The size and position of the drawn legend item is defined by the
  parent layout (typically a \ref QCPLegend) and the \ref minimumOuterSizeHint and \ref
  maximumOuterSizeHint of this legend item.
*/
/*! \내부의
  
  \ painter를 사용하여 항목을 그립니다. 그린 된 범례 항목의 크기와 위치는
  상위 레이아웃 (일반적으로 \ ref QCPLegend) 및 \ ref minimumOuterSizeHint 및 \ ref
  이 범례 항목의 maximumOuterSizeHint
*/
void QCPPlottableLegendItem::draw(QCPPainter *painter)
{
  if (!mPlottable) return;
  painter->setFont(getFont());
  painter->setPen(QPen(getTextColor()));
  QSizeF iconSize = mParentLegend->iconSize();
  QRectF textRect = painter->fontMetrics().boundingRect(0, 0, 0, iconSize.height(), Qt::TextDontClip, mPlottable->name());
  QRectF iconRect(mRect.topLeft(), iconSize);
  int textHeight = qMax(textRect.height(), iconSize.height()); 
 // if text has smaller height than icon, center text vertically in icon height, else align tops
 // 텍스트의 높이가 아이콘보다 작은 경우 텍스트를 아이콘 높이에 세로로 가운데 정렬하고, 그렇지 않으면 상단을 정렬합니다.
  painter->drawText(mRect.x()+iconSize.width()+mParentLegend->iconTextPadding(), mRect.y(), textRect.width(), textHeight, Qt::TextDontClip, mPlottable->name());
  // draw icon:
  // 아이콘 그리기 :
  painter->save();
  painter->setClipRect(iconRect, Qt::IntersectClip);
  mPlottable->drawLegendIcon(painter, iconRect);
  painter->restore();
  // draw icon border:
  // 아이콘 테두리를 그립니다.
  if (getIconBorderPen().style() != Qt::NoPen)
  {
    painter->setPen(getIconBorderPen());
    painter->setBrush(Qt::NoBrush);
    int halfPen = qCeil(painter->pen().widthF()*0.5)+1;
    painter->setClipRect(mOuterRect.adjusted(-halfPen, -halfPen, halfPen, halfPen));
// extend default clip rect so thicker pens (especially during selection) are not clipped
// 두꺼운 펜 (특히 선택 중에)이 클리핑되지 않도록 기본 클립 rect를 확장합니다.
    painter->drawRect(iconRect);
  }
}

/*! \internal
  
  Calculates and returns the size of this item. This includes the icon, the text and the padding in
  between.
  
  \seebaseclassmethod
*/
/*! \내부의
  
  이 항목의 크기를 계산하여 반환합니다. 여기에는 아이콘, 텍스트 및 패딩이 포함됩니다.
  중에서.
  
  \ seebaseclassmethod
*/
QSize QCPPlottableLegendItem::minimumOuterSizeHint() const
{
  if (!mPlottable) return QSize();
  QSize result(0, 0);
  QRect textRect;
  QFontMetrics fontMetrics(getFont());
  QSize iconSize = mParentLegend->iconSize();
  textRect = fontMetrics.boundingRect(0, 0, 0, iconSize.height(), Qt::TextDontClip, mPlottable->name());
  result.setWidth(iconSize.width() + mParentLegend->iconTextPadding() + textRect.width());
  result.setHeight(qMax(textRect.height(), iconSize.height()));
  result.rwidth() += mMargins.left()+mMargins.right();
  result.rheight() += mMargins.top()+mMargins.bottom();
  return result;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPLegend
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPLegend
  \brief Manages a legend inside a QCustomPlot.

  A legend is a small box somewhere in the plot which lists plottables with their name and icon.

  A legend is populated with legend items by calling \ref QCPAbstractPlottable::addToLegend on the
  plottable, for which a legend item shall be created. In the case of the main legend (\ref
  QCustomPlot::legend), simply adding plottables to the plot while \ref
  QCustomPlot::setAutoAddPlottableToLegend is set to true (the default) creates corresponding
  legend items. The legend item associated with a certain plottable can be removed with \ref
  QCPAbstractPlottable::removeFromLegend. However, QCPLegend also offers an interface to add and
  manipulate legend items directly: \ref item, \ref itemWithPlottable, \ref itemCount, \ref
  addItem, \ref removeItem, etc.

  Since \ref QCPLegend derives from \ref QCPLayoutGrid, it can be placed in any position a \ref
  QCPLayoutElement may be positioned. The legend items are themselves \ref QCPLayoutElement
  "QCPLayoutElements" which are placed in the grid layout of the legend. \ref QCPLegend only adds
  an interface specialized for handling child elements of type \ref QCPAbstractLegendItem, as
  mentioned above. In principle, any other layout elements may also be added to a legend via the
  normal \ref QCPLayoutGrid interface. See the special page about \link thelayoutsystem The Layout
  System\endlink for examples on how to add other elements to the legend and move it outside the axis
  rect.

  Use the methods \ref setFillOrder and \ref setWrap inherited from \ref QCPLayoutGrid to control
  in which order (column first or row first) the legend is filled up when calling \ref addItem, and
  at which column or row wrapping occurs.

  By default, every QCustomPlot has one legend (\ref QCustomPlot::legend) which is placed in the
  inset layout of the main axis rect (\ref QCPAxisRect::insetLayout). To move the legend to another
  position inside the axis rect, use the methods of the \ref QCPLayoutInset. To move the legend
  outside of the axis rect, place it anywhere else with the \ref QCPLayout/\ref QCPLayoutElement
  interface.
*/
/*! \ class QCPLegend
  \ brief QCustomPlot 내에서 범례를 관리합니다.

  범례는 이름과 아이콘이있는 플롯 테이블을 나열하는 플롯의 어딘가에있는 작은 상자입니다.

  범례에는 \ ref QCPAbstractPlottable :: addToLegend를 호출하여 범례 항목이 채워집니다.
  plottable : 범용 항목이 생성됩니다. 주요 전설의 경우 (\ ref
  QCustomPlot :: legend), 플롯을 플롯에 추가하는 동안 \ ref
  QCustomPlot :: setAutoAddPlottableToLegend를 true로 설정하면 (기본값) 해당하는
  전설 항목. 특정 플롯 테이블과 연결된 범례 항목은 \ ref로 제거 할 수 있습니다.
  QCPAbstractPlottable :: removeFromLegend. 그러나 QCPLegend는 또한
  범례 항목을 직접 조작 : \ ref 항목, \ ref itemWithPlottable, \ ref itemCount, \ ref
  addItem, \ ref removeItem 등

  \ ref QCPLegend는 \ ref QCPLayoutGrid에서 파생되므로 \ ref의 어느 위치 에나 배치 할 수 있습니다.
  QCPLayoutElement를 배치 할 수 있습니다. 범례 항목 자체는 \ ref QCPLayoutElement입니다.
  범례의 그리드 레이아웃에 배치되는 "QCPLayoutElements". \ ref QCPLegend 만 추가합니다.
  \ ref QCPAbstractLegendItem 형식의 자식 요소를 처리하기위한 특수 인터페이스
  위에 언급했듯이. 원칙적으로, 다른 레이아웃 요소는 또한 다음을 통해 범례에 추가 될 수 있습니다.
  일반 \ ref QCPLayoutGrid 인터페이스. \ layout thelayoutsystem에 대한 특별 페이지를 참조하십시오.
  범례에 다른 요소를 추가하고이를 축 외부로 이동하는 방법에 대한 예제는 System \ endlink를 참조하십시오.
  rect.

  \ ref QCPLayoutGrid에서 상속받은 \ ref setFillOrder 및 \ ref setWrap 메서드를 사용하여 제어합니다.
  어떤 순서 (첫 번째 열 또는 첫 번째 열)에서 \ ref addItem을 호출하면 범례가 채워지고,
  열 또는 행의 줄 Y ^이 _ 생합니다.

  기본적으로 모든 QCustomPlot에는 하나의 범례 (\ ref QCustomPlot :: legend)가 있습니다.이 범례는
  주 축 rect (\ ref QCPAxisRect :: insetLayout)의 인세 트 레이아웃. 범례를 다른 것으로 이동하려면
  축 rect 내부의 위치에서 \ ref QCPLayoutInset의 메소드를 사용하십시오. 범례 이동
  축 rect 바깥쪽에 \ ref QCPLayout / \ ref QCPLayoutElement가있는 다른 곳에 배치하십시오.
  인터페이스.
*/


/* start of documentation of signals */
/* 신호 문서화 */

/*! \fn void QCPLegend::selectionChanged(QCPLegend::SelectableParts selection);

  This signal is emitted when the selection state of this legend has changed.
  
  \see setSelectedParts, setSelectableParts
*/
/*! \ fn void QCPLegend :: selectionChanged (QCPLegend :: SelectableParts 선택);

  이 범례의 선택 상태가 변경되면이 신호가 방출됩니다.
  
  \ setSelectedParts, setSelectableParts를 참조하십시오.
*/

/* end of documentation of signals */
/* 신호의 문서화 끝 */ 


/*!
  Constructs a new QCPLegend instance with default values.
  
  Note that by default, QCustomPlot already contains a legend ready to be used as \ref
  QCustomPlot::legend
*/
/*!
  디폴트 치를 가지는 새로운 QCPLegend의 인스턴스를 구축합니다.
  
  기본적으로 QCustomPlot에는 이미 \ ref로 사용할 준비가 된 범례가 포함되어 있습니다.
  QCustomPlot :: 범례
*/
QCPLegend::QCPLegend()
{
  setFillOrder(QCPLayoutGrid::foRowsFirst);
  setWrap(0);
  
  setRowSpacing(3);
  setColumnSpacing(8);
  setMargins(QMargins(7, 5, 7, 4));
  setAntialiased(false);
  setIconSize(32, 18);
  
  setIconTextPadding(7);
  
  setSelectableParts(spLegendBox | spItems);
  setSelectedParts(spNone);
  
  setBorderPen(QPen(Qt::black, 0));
  setSelectedBorderPen(QPen(Qt::blue, 2));
  setIconBorderPen(Qt::NoPen);
  setSelectedIconBorderPen(QPen(Qt::blue, 2));
  setBrush(Qt::white);
  setSelectedBrush(Qt::white);
  setTextColor(Qt::black);
  setSelectedTextColor(Qt::blue);
}

QCPLegend::~QCPLegend()
{
  clearItems();
  if (qobject_cast<QCustomPlot*>(mParentPlot)) // make sure this isn't called from QObject dtor when QCustomPlot is already destructed (happens when the legend is not in any layout and thus QObject-child of QCustomPlot)
// QCustomPlot이 이미 파괴되었을 때 QObject dtor에서 호출되지 않도록하십시오 (범례가 레이아웃에 없으므로 QCustomPlot의 QObject- 자식)
    mParentPlot->legendRemoved(this);
}

/* no doc for getter, see setSelectedParts */
/* getter에 대한 doc은, setSelectedParts를 참조 */
QCPLegend::SelectableParts QCPLegend::selectedParts() const
{
  // check whether any legend elements selected, if yes, add spItems to return value
  // 선택된 범례 요소가 있는지 확인합니다. 그렇다면 spItem을 반환하여 값을 반환합니다.
  bool hasSelectedItems = false;
  for (int i=0; i<itemCount(); ++i)
  {
    if (item(i) && item(i)->selected())
    {
      hasSelectedItems = true;
      break;
    }
  }
  if (hasSelectedItems)
    return mSelectedParts | spItems;
  else
    return mSelectedParts & ~spItems;
}

/*!
  Sets the pen, the border of the entire legend is drawn with.
*/
/*!
  펜을 설정하면 전체 범례 테두리가 그려집니다.
*/
void QCPLegend::setBorderPen(const QPen &pen)
{
  mBorderPen = pen;
}

/*!
  Sets the brush of the legend background.
*/
/*!
  범례 배경의 브러시를 설정합니다.
*/
void QCPLegend::setBrush(const QBrush &brush)
{
  mBrush = brush;
}

/*!
  Sets the default font of legend text. Legend items that draw text (e.g. the name of a graph) will
  use this font by default. However, a different font can be specified on a per-item-basis by
  accessing the specific legend item.
  
  This function will also set \a font on all already existing legend items.
  
  \see QCPAbstractLegendItem::setFont
*/
/*!
  범례 텍스트의 기본 글꼴을 설정합니다. 텍스트를 그리는 범례 항목 (예 : 그래프 이름)은
  기본적으로이 글꼴을 사용하십시오. 그러나 다른 글꼴은 항목별로 항목별로 지정할 수 있습니다.
  특정 범례 항목에 액세스합니다.
  
  이 함수는 이미 존재하는 모든 범례 항목에 \ a 글꼴도 설정합니다.
  
  \ 참조하십시오 QCPAbstractLegendItem :: setFont
*/
void QCPLegend::setFont(const QFont &font)
{
  mFont = font;
  for (int i=0; i<itemCount(); ++i)
  {
    if (item(i))
      item(i)->setFont(mFont);
  }
}

/*!
  Sets the default color of legend text. Legend items that draw text (e.g. the name of a graph)
  will use this color by default. However, a different colors can be specified on a per-item-basis
  by accessing the specific legend item.
  
  This function will also set \a color on all already existing legend items.
  
  \see QCPAbstractLegendItem::setTextColor
*/
/*!
  범례 텍스트의 기본 색상을 설정합니다. 텍스트를 그리는 범례 항목 (예 : 그래프 이름)
  기본적으로이 색상을 사용합니다. 그러나 항목별로 항목별로 다른 색상을 지정할 수 있습니다.
  특정 범례 항목에 액세스하여
  
  이 함수는 또한 기존의 모든 범례 항목에 \ 색상을 설정합니다.
  
  \ see QCPAbstractLegendItem :: setTextColor
*/
void QCPLegend::setTextColor(const QColor &color)
{
  mTextColor = color;
  for (int i=0; i<itemCount(); ++i)
  {
    if (item(i))
      item(i)->setTextColor(color);
  }
}

/*!
  Sets the size of legend icons. Legend items that draw an icon (e.g. a visual
  representation of the graph) will use this size by default.
*/
/*!
  범례 아이콘의 크기를 설정합니다. 아이콘을 그리는 범례 항목 (예 : 시각적
  그래프 표현)은 기본적으로이 크기를 사용합니다.
*/
void QCPLegend::setIconSize(const QSize &size)
{
  mIconSize = size;
}

/*! \overload
*/
/*! \초과 적재
*/
void QCPLegend::setIconSize(int width, int height)
{
  mIconSize.setWidth(width);
  mIconSize.setHeight(height);
}

/*!
  Sets the horizontal space in pixels between the legend icon and the text next to it.
  Legend items that draw an icon (e.g. a visual representation of the graph) and text (e.g. the
  name of the graph) will use this space by default.
*/
/*!
  범례 아이콘과 옆에있는 텍스트 사이의 가로 간격을 픽셀 단위로 설정합니다.
  아이콘을 그리는 범례 항목 (예 : 그래프의 시각적 표현) 및 텍스트 (예 :
  그래프의 이름)은 기본적으로이 공간을 사용합니다.
*/
void QCPLegend::setIconTextPadding(int padding)
{
  mIconTextPadding = padding;
}

/*!
  Sets the pen used to draw a border around each legend icon. Legend items that draw an
  icon (e.g. a visual representation of the graph) will use this pen by default.
  
  If no border is wanted, set this to \a Qt::NoPen.
*/
/*!
  각 범례 아이콘 주위에 경계선을 그리는 데 사용되는 펜을 설정합니다. 그려주는 전설 항목
  아이콘 (예 : 그래프의 시각적 표현)은 기본적으로이 펜을 사용합니다.
  
  테두리가 필요 없다면 이것을 \ a Qt :: NoPen으로 설정하십시오.
*/
void QCPLegend::setIconBorderPen(const QPen &pen)
{
  mIconBorderPen = pen;
}

/*!
  Sets whether the user can (de-)select the parts in \a selectable by clicking on the QCustomPlot surface.
  (When \ref QCustomPlot::setInteractions contains \ref QCP::iSelectLegend.)
  
  However, even when \a selectable is set to a value not allowing the selection of a specific part,
  it is still possible to set the selection of this part manually, by calling \ref setSelectedParts
  directly.
  
  \see SelectablePart, setSelectedParts
*/
/*!
  사용자가 QCustomPlot 표면을 클릭하여 선택 가능한 부품을 선택할 수 있는지 여부를 설정합니다.
  (\ ref QCustomPlot :: setInteractions에 \ ref QCP :: iSelectLegend가 포함되어있는 경우).
  
  그러나 \ a 선택 항목이 특정 부분의 선택을 허용하지 않는 값으로 설정된 경우에도,
  \ ref setSelectedParts를 호출하여 수동으로이 부분의 선택을 설정할 수도 있습니다.
  직접.
  
  \ SelectablePart, setSelectedParts를 참조하십시오.
*/
void QCPLegend::setSelectableParts(const SelectableParts &selectable)
{
  if (mSelectableParts != selectable)
  {
    mSelectableParts = selectable;
    emit selectableChanged(mSelectableParts);
  }
}

/*!
  Sets the selected state of the respective legend parts described by \ref SelectablePart. When a part
  is selected, it uses a different pen/font and brush. If some legend items are selected and \a selected
  doesn't contain \ref spItems, those items become deselected.
  
  The entire selection mechanism is handled automatically when \ref QCustomPlot::setInteractions
  contains iSelectLegend. You only need to call this function when you wish to change the selection
  state manually.
  
  This function can change the selection state of a part even when \ref setSelectableParts was set to a
  value that actually excludes the part.
  
  emits the \ref selectionChanged signal when \a selected is different from the previous selection state.
  
  Note that it doesn't make sense to set the selected state \ref spItems here when it wasn't set
  before, because there's no way to specify which exact items to newly select. Do this by calling
  \ref QCPAbstractLegendItem::setSelected directly on the legend item you wish to select.
  
  \see SelectablePart, setSelectableParts, selectTest, setSelectedBorderPen, setSelectedIconBorderPen, setSelectedBrush,
  setSelectedFont
*/
/*!
  \ ref SelectablePart가 설명하는 각 범례 부분의 선택된 상태를 설정합니다. 부품
  이 옵션을 선택하면 다른 펜 / 글꼴 및 브러시가 사용됩니다. 일부 범례 항목이 선택되고 \ a가 선택되면
  \ ref spItems을 포함하지 않으면 해당 항목은 선택 취소됩니다.
  
  \ ref QCustomPlot :: setInteractions가 실행되면 전체 선택 메커니즘이 자동으로 처리됩니다.
  iSelectLegend를 포함합니다. 선택을 변경할 때만이 함수를 호출하면됩니다.
  수동으로 상태.
  
  이 함수는 \ ref setSelectableParts가 a로 설정된 경우에도 파트의 선택 상태를 변경할 수 있습니다.
  실제로 부품을 제외하는 값.
  
  선택이 이전 선택 상태와 다른 경우 \ ref selectionChanged 신호를 내 보냅니다.
  
  여기서는 선택된 상태 \ ref spItems가 설정되지 않았을 때 여기에 설정하는 것은 의미가 없습니다.
  이전에는 새 항목을 선택할 정확한 방법을 지정할 방법이 없으므로 전화 걸기
  \ ref QCPAbstractLegendItem :: setSelected를 선택하려는 범례 항목에 직접 지정합니다.
  
  \ SelectablePart, setSelectableParts, selectTest, setSelectedBorderPen, setSelectedIconBorderPen, setSelectedBrush,
  setSelectedFont
*/
void QCPLegend::setSelectedParts(const SelectableParts &selected)
{
  SelectableParts newSelected = selected;
  mSelectedParts = this->selectedParts(); // update mSelectedParts in case item selection changed
                                          // 항목 선택이 변경된 경우 mSelectedParts를 업데이트합니다.


  if (mSelectedParts != newSelected)
  {
    if (!mSelectedParts.testFlag(spItems) && newSelected.testFlag(spItems)) 
// attempt to set spItems flag (can't do that)
// spItems 플래그를 설정하려고합니다 (그렇게 할 수 없습니다)
    {
      qDebug() << Q_FUNC_INFO << "spItems flag can not be set, it can only be unset with this function";
      newSelected &= ~spItems;
    }
    if (mSelectedParts.testFlag(spItems) && !newSelected.testFlag(spItems)) 
// spItems flag was unset, so clear item selection
// spItems 플래그가 설정되지 않았으므로 항목 선택을 지 웁니다.
    {
      for (int i=0; i<itemCount(); ++i)
      {
        if (item(i))
          item(i)->setSelected(false);
      }
    }
    mSelectedParts = newSelected;
    emit selectionChanged(mSelectedParts);
  }
}

/*!
  When the legend box is selected, this pen is used to draw the border instead of the normal pen
  set via \ref setBorderPen.

  \see setSelectedParts, setSelectableParts, setSelectedBrush
*/
/*!
  범례 상자를 선택하면이 펜을 사용하여 일반 펜 대신 테두리를 그립니다.
  \ ref setBorderPen을 통해 설정하십시오.

  \ setSelectedParts, setSelectableParts, setSelectedBrush를 참조하십시오.
*/
void QCPLegend::setSelectedBorderPen(const QPen &pen)
{
  mSelectedBorderPen = pen;
}

/*!
  Sets the pen legend items will use to draw their icon borders, when they are selected.

  \see setSelectedParts, setSelectableParts, setSelectedFont
*/
/*!
  펜 범례 항목이 선택되면 아이콘 테두리를 그릴 때 사용할 펜 범례 항목을 설정합니다.

  \ setSelectedParts, setSelectableParts, setSelectedFont를 참조하십시오.
*/
void QCPLegend::setSelectedIconBorderPen(const QPen &pen)
{
  mSelectedIconBorderPen = pen;
}

/*!
  When the legend box is selected, this brush is used to draw the legend background instead of the normal brush
  set via \ref setBrush.

  \see setSelectedParts, setSelectableParts, setSelectedBorderPen
*/
/*!
  범례 상자를 선택하면이 브러시를 사용하여 일반 브러시 대신 범례 배경을 그립니다.
  \ ref setBrush를 통해 설정하십시오.

  \ setSelectedParts, setSelectableParts, setSelectedBorderPen을 참조하십시오.
*/
void QCPLegend::setSelectedBrush(const QBrush &brush)
{
  mSelectedBrush = brush;
}

/*!
  Sets the default font that is used by legend items when they are selected.
  
  This function will also set \a font on all already existing legend items.

  \see setFont, QCPAbstractLegendItem::setSelectedFont
*/
/*!
  범례 항목을 선택할 때 사용되는 기본 글꼴을 설정합니다.
  
  이 함수는 이미 존재하는 모든 범례 항목에 \ a 글꼴도 설정합니다.

  \ setFont, QCPAbstractLegendItem :: setSelectedFont를 참조하십시오.
*/
void QCPLegend::setSelectedFont(const QFont &font)
{
  mSelectedFont = font;
  for (int i=0; i<itemCount(); ++i)
  {
    if (item(i))
      item(i)->setSelectedFont(font);
  }
}

/*!
  Sets the default text color that is used by legend items when they are selected.
  
  This function will also set \a color on all already existing legend items.

  \see setTextColor, QCPAbstractLegendItem::setSelectedTextColor
*/
/*!
  범례 항목을 선택할 때 사용되는 기본 텍스트 색을 설정합니다.
  
  이 함수는 또한 기존의 모든 범례 항목에 \ 색상을 설정합니다.

  \ setTextColor, QCPAbstractLegendItem :: setSelectedTextColor를 참조하십시오.
*/
void QCPLegend::setSelectedTextColor(const QColor &color)
{
  mSelectedTextColor = color;
  for (int i=0; i<itemCount(); ++i)
  {
    if (item(i))
      item(i)->setSelectedTextColor(color);
  }
}

/*!
  Returns the item with index \a i.

  Note that the linear index depends on the current fill order (\ref setFillOrder).

  \see itemCount, addItem, itemWithPlottable
*/
/*!
  인덱스가 \ a i 인 항목을 반환합니다.

  선형 인덱스는 현재 채우기 순서 (\ ref setFillOrder)에 따라 달라집니다.

  \ itemCount, addItem, itemWithPlottable을 참조하십시오.
*/

QCPAbstractLegendItem *QCPLegend::item(int index) const
{
  return qobject_cast<QCPAbstractLegendItem*>(elementAt(index));
}

/*!
  Returns the QCPPlottableLegendItem which is associated with \a plottable (e.g. a \ref QCPGraph*).
  If such an item isn't in the legend, returns 0.
  
  \see hasItemWithPlottable
*/
/*!
  \ a plottable (예 : \ ref QCPGraph *)과 연관된 QCPPlottableLegendItem을 리턴합니다.
  이러한 항목이 범례에없는 경우 0을 반환합니다.
  
  \ hasItemWithPlottable을 참조하십시오.
*/
QCPPlottableLegendItem *QCPLegend::itemWithPlottable(const QCPAbstractPlottable *plottable) const
{
  for (int i=0; i<itemCount(); ++i)
  {
    if (QCPPlottableLegendItem *pli = qobject_cast<QCPPlottableLegendItem*>(item(i)))
    {
      if (pli->plottable() == plottable)
        return pli;
    }
  }
  return 0;
}

/*!
  Returns the number of items currently in the legend.

  Note that if empty cells are in the legend (e.g. by calling methods of the \ref QCPLayoutGrid
  base class which allows creating empty cells), they are included in the returned count.

  \see item
*/
/*!
  현재 범례에있는 항목 수를 반환합니다.

  빈 셀이 범례에있는 경우 (예 : \ ref QCPLayoutGrid 메서드 호출)
  빈 셀을 만들 수있는 기본 클래스), 반환 된 개수에 포함됩니다.

  \ 항목보기
*/
int QCPLegend::itemCount() const
{
  return elementCount();
}

/*!
  Returns whether the legend contains \a item.
  
  \see hasItemWithPlottable
*/
/*!
  범례에 \ a 항목이 있는지 여부를 반환합니다.
  
  \ hasItemWithPlottable을 참조하십시오.
*/
bool QCPLegend::hasItem(QCPAbstractLegendItem *item) const
{
  for (int i=0; i<itemCount(); ++i)
  {
    if (item == this->item(i))
        return true;
  }
  return false;
}

/*!
  Returns whether the legend contains a QCPPlottableLegendItem which is associated with \a plottable (e.g. a \ref QCPGraph*).
  If such an item isn't in the legend, returns false.
  
  \see itemWithPlottable
*/
/*!
  범례에 \ plottable (예 : \ ref QCPGraph *)과 연결된 QCPPlotableLegendItem이 있는지 여부를 반환합니다.
  그러한 항목이 범례에없는 경우 거짓을 반환합니다.
  
  \ itemWithPlottable 참조
*/
bool QCPLegend::hasItemWithPlottable(const QCPAbstractPlottable *plottable) const
{
  return itemWithPlottable(plottable);
}

/*!
  Adds \a item to the legend, if it's not present already. The element is arranged according to the
  current fill order (\ref setFillOrder) and wrapping (\ref setWrap).

  Returns true on sucess, i.e. if the item wasn't in the list already and has been successfuly added.

  The legend takes ownership of the item.

  \see removeItem, item, hasItem
*/
/*!
  이미 존재하지 않는 항목을 범례에 추가합니다. 요소는
  현재 채우기 순서 (\ ref setFillOrder) 및 줄 바꿈 (\ ref setWrap).

  성공시, 즉 항목이 이미 목록에없고 성공적으로 추가 된 경우 true를 반환합니다.

  범례는 항목의 소유권을가집니다.

  \ removeItem, item, hasItem을 보라.
*/
bool QCPLegend::addItem(QCPAbstractLegendItem *item)
{
  return addElement(item);
}

/*! \overload

  Removes the item with the specified \a index from the legend and deletes it.

  After successful removal, the legend is reordered according to the current fill order (\ref
  setFillOrder) and wrapping (\ref setWrap), so no empty cell remains where the removed \a item
  was. If you don't want this, rather use the raw element interface of \ref QCPLayoutGrid.

  Returns true, if successful. Unlike \ref QCPLayoutGrid::removeAt, this method only removes
  elements derived from \ref QCPAbstractLegendItem.

  \see itemCount, clearItems
*/
/*! \초과 적재

  지정된 \ a 인덱스를 가진 항목을 범례에서 제거하고 삭제합니다.

  제거가 성공적으로 끝나면 범례는 현재 채우기 순서에 따라 재정렬됩니다 (\ ref
  setFillOrder) 및 줄 바꿈 (\ ref setWrap)을 사용하면 제거 된 항목이있는 곳의 빈 셀이 남아 있지 않습니다.
  였다. 이것을 원하지 않으면 \ ref QCPLayoutGrid의 원시 요소 인터페이스를 사용하십시오.

  성공하면 true를 리턴합니다. \ ref QCPLayoutGrid :: removeAt와 달리이 메서드는
  \ ref QCPAbstractLegendItem에서 파생 된 요소

  \ itemCount, clearItems를 참조하십시오.
*/
bool QCPLegend::removeItem(int index)
{
  if (QCPAbstractLegendItem *ali = item(index))
  {
    bool success = remove(ali);
    if (success)
      setFillOrder(fillOrder(), true); // gets rid of empty cell by reordering
                                       // 재정렬하여 빈 셀을 제거합니다.
    return success;
  } else
    return false;
}

/*! \overload

  Removes \a item from the legend and deletes it.

  After successful removal, the legend is reordered according to the current fill order (\ref
  setFillOrder) and wrapping (\ref setWrap), so no empty cell remains where the removed \a item
  was. If you don't want this, rather use the raw element interface of \ref QCPLayoutGrid.

  Returns true, if successful.

  \see clearItems
*/
/*! \초과 적재

  범례에서 항목을 제거하고 삭제합니다.

  제거가 성공적으로 끝나면 범례는 현재 채우기 순서에 따라 재정렬됩니다 (\ ref
  setFillOrder) 및 줄 바꿈 (\ ref setWrap)을 사용하면 제거 된 항목이있는 곳의 빈 셀이 남아 있지 않습니다.
  였다. 이것을 원하지 않으면 \ ref QCPLayoutGrid의 원시 요소 인터페이스를 사용하십시오.

  성공하면 true를 리턴합니다.

  \ see clearItems
*/
bool QCPLegend::removeItem(QCPAbstractLegendItem *item)
{
  bool success = remove(item);
  if (success)
    setFillOrder(fillOrder(), true); // gets rid of empty cell by reordering
                                     // 재정렬하여 빈 셀을 제거합니다.
  return success;
}

/*!
  Removes all items from the legend.
*/
/*!
  범례에서 모든 항목을 제거합니다.
*/
void QCPLegend::clearItems()
{
  for (int i=itemCount()-1; i>=0; --i)
    removeItem(i);
}

/*!
  Returns the legend items that are currently selected. If no items are selected,
  the list is empty.
  
  \see QCPAbstractLegendItem::setSelected, setSelectable
*/
/*!
  현재 선택되어있는 범례 항목을 반환합니다. 항목이 선택되지 않은 경우,
  목록은 비어 있습니다.
  
  \ 참조 QCPAbstractLegendItem :: setSelected, setSelectable
*/
QList<QCPAbstractLegendItem *> QCPLegend::selectedItems() const
{
  QList<QCPAbstractLegendItem*> result;
  for (int i=0; i<itemCount(); ++i)
  {
    if (QCPAbstractLegendItem *ali = item(i))
    {
      if (ali->selected())
        result.append(ali);
    }
  }
  return result;
}

/*! \internal

  A convenience function to easily set the QPainter::Antialiased hint on the provided \a painter
  before drawing main legend elements.

  This is the antialiasing state the painter passed to the \ref draw method is in by default.
  
  This function takes into account the local setting of the antialiasing flag as well as the
  overrides set with \ref QCustomPlot::setAntialiasedElements and \ref
  QCustomPlot::setNotAntialiasedElements.
  
  \seebaseclassmethod
  
  \see setAntialiased
*/
/*! \내부의

  제공된 Painter에서 QPainter :: Antialiased 힌트를 쉽게 설정할 수있는 편리한 함수입니다.
  주 범례 요소를 그리기 전에

  화가가 \ ref draw 메서드에 전달한 앤티 엘리 어싱 상태입니다.
  
  이 함수는 앤티 엘리 어싱 플래그의 로컬 설정은 물론
  \ ref QCustomPlot :: setAntialiasedElements 및 \ ref를 사용하여 설정 한 재정의
  QCustomPlot :: setNotAntialiasedElements.
  
  \ seebaseclassmethod
  
  \ setAntialiased 참조
*/
void QCPLegend::applyDefaultAntialiasingHint(QCPPainter *painter) const
{
  applyAntialiasingHint(painter, mAntialiased, QCP::aeLegend);
}

/*! \internal
  
  Returns the pen used to paint the border of the legend, taking into account the selection state
  of the legend box.
*/
/*! \내부의
  
  선택 상태를 고려해 범례의 경계를 페인트하는데 사용하는 펜을 돌려줍니다.
  범례 상자의
*/
QPen QCPLegend::getBorderPen() const
{
  return mSelectedParts.testFlag(spLegendBox) ? mSelectedBorderPen : mBorderPen;
}

/*! \internal
  
  Returns the brush used to paint the background of the legend, taking into account the selection
  state of the legend box.
*/
/*! \내부의
  
  선택 항목을 고려하여 범례 배경을 페인트하는 데 사용되는 브러시를 반환합니다.
  범례 상자의 상태.
*/
QBrush QCPLegend::getBrush() const
{
  return mSelectedParts.testFlag(spLegendBox) ? mSelectedBrush : mBrush;
}

/*! \internal
  
  Draws the legend box with the provided \a painter. The individual legend items are layerables
  themselves, thus are drawn independently.
*/
/*! \내부의
  
  제공된 \ painter로 범례 상자를 그립니다. 개별 범례 항목은 레이어 가능 항목입니다.
  따라서, 독립적으로 그려진다.
*/
void QCPLegend::draw(QCPPainter *painter)
{
  // draw background rect:
  // 배경 rect를 그립니다.
  painter->setBrush(getBrush());
  painter->setPen(getBorderPen());
  painter->drawRect(mOuterRect);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPLegend::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  if (!mParentPlot) return -1;
  if (onlySelectable && !mSelectableParts.testFlag(spLegendBox))
    return -1;
  
  if (mOuterRect.contains(pos.toPoint()))
  {
    if (details) details->setValue(spLegendBox);
    return mParentPlot->selectionTolerance()*0.99;
  }
  return -1;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPLegend::selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)
{
  Q_UNUSED(event)
  mSelectedParts = selectedParts(); // in case item selection has changed
                                    // 항목 선택이 변경된 경우
  if (details.value<SelectablePart>() == spLegendBox && mSelectableParts.testFlag(spLegendBox))
  {
    SelectableParts selBefore = mSelectedParts;
    setSelectedParts(additive ? mSelectedParts^spLegendBox : mSelectedParts|spLegendBox);
 // no need to unset spItems in !additive case, because they will be deselected by QCustomPlot (they're normal QCPLayerables with own deselectEvent)
 // QCustomPlot에 의해 선택 해제 될 것이므로! additive case에 spItem을 설정 해제 할 필요가 없습니다 (그들은 자신의 deselectEvent가있는 정상적인 QCPLayer입니다)
    if (selectionStateChanged)
      *selectionStateChanged = mSelectedParts != selBefore;
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPLegend::deselectEvent(bool *selectionStateChanged)
{
  mSelectedParts = selectedParts(); // in case item selection has changed
                                    // 항목 선택이 변경된 경우
  if (mSelectableParts.testFlag(spLegendBox))
  {
    SelectableParts selBefore = mSelectedParts;
    setSelectedParts(selectedParts() & ~spLegendBox);
    if (selectionStateChanged)
      *selectionStateChanged = mSelectedParts != selBefore;
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCP::Interaction QCPLegend::selectionCategory() const
{
  return QCP::iSelectLegend;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCP::Interaction QCPAbstractLegendItem::selectionCategory() const
{
  return QCP::iSelectLegend;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPLegend::parentPlotInitialized(QCustomPlot *parentPlot)
{
  if (parentPlot && !parentPlot->legend)
    parentPlot->legend = this;
}
/* end of 'src/layoutelements/layoutelement-legend.cpp' */


/* including file 'src/layoutelements/layoutelement-textelement.cpp', size 12761 */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200     */
/* 'src / layoutelements / layoutelement-legend.cpp'의 끝 */


/* 파일 'src / layoutelements / layoutelement-textelement.cpp', 크기 12761 포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPTextElement
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPTextElement
  \brief A layout element displaying a text

  The text may be specified with \ref setText, the formatting can be controlled with \ref setFont,
  \ref setTextColor, and \ref setTextFlags.

  A text element can be added as follows:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcptextelement-creation
*/

/*! \ class QCPTextElement
  \ brief 텍스트를 표시하는 레이아웃 요소

  텍스트는 \ ref setText로 지정할 수 있습니다. 서식은 \ ref setFont로 제어 할 수 있습니다.
  \ ref setTextColor 및 \ ref setTextFlags.

  텍스트 요소는 다음과 같이 추가 할 수 있습니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcptextelement-creation
*/

/* start documentation of signals */
/* 신호의 문서화를 시작한다. */

/*! \fn void QCPTextElement::selectionChanged(bool selected)
  
  This signal is emitted when the selection state has changed to \a selected, either by user
  interaction or by a direct call to \ref setSelected.
  
  \see setSelected, setSelectable
*/
/*! \ fn void QCPTextElement :: selectionChanged (bool 선택됨)
  
  이 신호는 선택 상태가 \ a로 변경되거나 사용자가 선택한 경우에 발생합니다.
  상호 작용 또는 \ ref setSelected에 대한 직접 호출에 의해 수행됩니다.
  
  \ setSelected를 참조하십시오, setSelectable
*/

/*! \fn void QCPTextElement::clicked(QMouseEvent *event)

  This signal is emitted when the text element is clicked.

  \see doubleClicked, selectTest
*/
/*! \ fn void QCPTextElement :: clicked (QMouseEvent * 이벤트)

  이 신호는 텍스트 요소를 클릭하면 방출됩니다.

  \ doubleClicked, select 테스트를 참조하십시오.
*/

/*! \fn void QCPTextElement::doubleClicked(QMouseEvent *event)

  This signal is emitted when the text element is double clicked.

  \see clicked, selectTest
*/
/*! \ fn 무효 QCPTextElement :: doubleClicked (QMouseEvent * 이벤트)

  이 신호는 텍스트 요소가 두 번 클릭 될 때 방출됩니다.

  \ clicked, selectTest보기
*/

/* end documentation of signals */
/* 신호의 끝 문서 */

/*! \overload
  
  Creates a new QCPTextElement instance and sets default values. The initial text is empty (\ref
  setText).
*/
/*! \초과 적재
  
  새 QCPTextElement 인스턴스를 만들고 기본값을 설정합니다. 초기 텍스트는 비어 있습니다 (\ ref
  setText).
*/
QCPTextElement::QCPTextElement(QCustomPlot *parentPlot) :
  QCPLayoutElement(parentPlot),
  mText(),
  mTextFlags(Qt::AlignCenter|Qt::TextWordWrap),
  mFont(QFont(QLatin1String("sans serif"), 12)), // will be taken from parentPlot if available, see below
                                                 // 사용 가능한 경우 parentPlot에서 가져옵니다 (아래 참조).
  mTextColor(Qt::black),
  mSelectedFont(QFont(QLatin1String("sans serif"), 12)), // will be taken from parentPlot if available, see below
                                                         // 사용 가능한 경우 parentPlot에서 가져옵니다 (아래 참조).
  mSelectedTextColor(Qt::blue),
  mSelectable(false),
  mSelected(false)
{
  if (parentPlot)
  {
    mFont = parentPlot->font();
    mSelectedFont = parentPlot->font();
  }
  setMargins(QMargins(2, 2, 2, 2));
}

/*! \overload
  
  Creates a new QCPTextElement instance and sets default values.

  The initial text is set to \a text.
*/
/*! \초과 적재
  
  새 QCPTextElement 인스턴스를 만들고 기본값을 설정합니다.

  초기 텍스트는 \ a 텍스트로 설정됩니다.
*/
QCPTextElement::QCPTextElement(QCustomPlot *parentPlot, const QString &text) :
  QCPLayoutElement(parentPlot),
  mText(text),
  mTextFlags(Qt::AlignCenter|Qt::TextWordWrap),
  mFont(QFont(QLatin1String("sans serif"), 12)), // will be taken from parentPlot if available, see below
                                                 // 사용 가능한 경우 parentPlot에서 가져옵니다 (아래 참조).
  mTextColor(Qt::black),
  mSelectedFont(QFont(QLatin1String("sans serif"), 12)), // will be taken from parentPlot if available, see below
                                                         // 사용 가능한 경우 parentPlot에서 가져옵니다 (아래 참조).
  mSelectedTextColor(Qt::blue),
  mSelectable(false),
  mSelected(false)
{
  if (parentPlot)
  {
    mFont = parentPlot->font();
    mSelectedFont = parentPlot->font();
  }
  setMargins(QMargins(2, 2, 2, 2));
}

/*! \overload
  
  Creates a new QCPTextElement instance and sets default values.

  The initial text is set to \a text with \a pointSize.
*/
/*! \초과 적재
  
  새 QCPTextElement 인스턴스를 만들고 기본값을 설정합니다.

  초기 텍스트는 \ a pointSize 인 텍스트로 설정됩니다.
*/
QCPTextElement::QCPTextElement(QCustomPlot *parentPlot, const QString &text, double pointSize) :
  QCPLayoutElement(parentPlot),
  mText(text),
  mTextFlags(Qt::AlignCenter|Qt::TextWordWrap),
  mFont(QFont(QLatin1String("sans serif"), pointSize)), // will be taken from parentPlot if available, see below
                                                        // 사용 가능한 경우 parentPlot에서 가져옵니다 (아래 참조).
  mTextColor(Qt::black),
  mSelectedFont(QFont(QLatin1String("sans serif"), pointSize)), 
// will be taken from parentPlot if available, see below
// 사용 가능한 경우 parentPlot에서 가져옵니다 (아래 참조).
  mSelectedTextColor(Qt::blue),
  mSelectable(false),
  mSelected(false)
{
  if (parentPlot)
  {
    mFont = parentPlot->font();
    mFont.setPointSizeF(pointSize);
    mSelectedFont = parentPlot->font();
    mSelectedFont.setPointSizeF(pointSize);
  }
  setMargins(QMargins(2, 2, 2, 2));
}

/*! \overload
  
  Creates a new QCPTextElement instance and sets default values.

  The initial text is set to \a text with \a pointSize and the specified \a fontFamily.
*/
/*! \초과 적재
  
  새 QCPTextElement 인스턴스를 만들고 기본값을 설정합니다.

  초기 텍스트는 \ a pointSize 및 지정된 \ a fontFamily가있는 \ a 텍스트로 설정됩니다.
*/
QCPTextElement::QCPTextElement(QCustomPlot *parentPlot, const QString &text, const QString &fontFamily, double pointSize) :
  QCPLayoutElement(parentPlot),
  mText(text),
  mTextFlags(Qt::AlignCenter|Qt::TextWordWrap),
  mFont(QFont(fontFamily, pointSize)),
  mTextColor(Qt::black),
  mSelectedFont(QFont(fontFamily, pointSize)),
  mSelectedTextColor(Qt::blue),
  mSelectable(false),
  mSelected(false)
{
  setMargins(QMargins(2, 2, 2, 2));
}

/*! \overload
  
  Creates a new QCPTextElement instance and sets default values.

  The initial text is set to \a text with the specified \a font.
*/
/*! \초과 적재
  
  새 QCPTextElement 인스턴스를 만들고 기본값을 설정합니다.

  초기 텍스트는 \ a 글꼴로 지정된 텍스트로 설정됩니다.
*/
QCPTextElement::QCPTextElement(QCustomPlot *parentPlot, const QString &text, const QFont &font) :
  QCPLayoutElement(parentPlot),
  mText(text),
  mTextFlags(Qt::AlignCenter|Qt::TextWordWrap),
  mFont(font),
  mTextColor(Qt::black),
  mSelectedFont(font),
  mSelectedTextColor(Qt::blue),
  mSelectable(false),
  mSelected(false)
{
  setMargins(QMargins(2, 2, 2, 2));
}

/*!
  Sets the text that will be displayed to \a text. Multiple lines can be created by insertion of "\n".
  
  \see setFont, setTextColor, setTextFlags
*/
/*!
  \ a 텍스트로 표시 할 텍스트를 설정합니다. "\ n"을 삽입하면 여러 줄을 만들 수 있습니다.
  
  \ setFont, setTextColor, setTextFlags를 참조하십시오.
*/
void QCPTextElement::setText(const QString &text)
{
  mText = text;
}

/*!
  Sets options for text alignment and wrapping behaviour. \a flags is a bitwise OR-combination of
  \c Qt::AlignmentFlag and \c Qt::TextFlag enums.
  
  Possible enums are:
  - Qt::AlignLeft
  - Qt::AlignRight
  - Qt::AlignHCenter
  - Qt::AlignJustify
  - Qt::AlignTop
  - Qt::AlignBottom
  - Qt::AlignVCenter
  - Qt::AlignCenter
  - Qt::TextDontClip
  - Qt::TextSingleLine
  - Qt::TextExpandTabs
  - Qt::TextShowMnemonic
  - Qt::TextWordWrap
  - Qt::TextIncludeTrailingSpaces
*/
/*!
  텍스트 정렬 및 줄 바꿈 동작에 대한 옵션을 설정합니다. \ a 플래그는 다음과 같은 비트 OR 조합입니다.
  \ c Qt :: AlignmentFlag 및 \ Q Qt :: TextFlag 열거 형.
  
  가능한 열거 형은 다음과 같습니다.
  - Qt :: AlignLeft
  - Qt :: AlignRight
  - Qt :: AlignHCenter
  - Qt :: AlignJustify
  - Qt :: 정렬
  - Qt :: AlignBottom
  - Qt :: AlignVCenter
  - Qt :: AlignCenter
  - Qt :: TextDontClip
  - Qt :: TextSingleLine
  - Qt :: TextExpandTabs
  - Qt :: TextShowMnemonic
  - Qt :: TextWordWrap
  - Qt :: TextIncludeTrailingSpaces
*/
void QCPTextElement::setTextFlags(int flags)
{
  mTextFlags = flags;
}

/*!
  Sets the \a font of the text.
  
  \see setTextColor, setSelectedFont
*/
/*!
  텍스트의 \ 폰트를 설정합니다.
  
  \ setTextColor, setSelectedFont를 참조하십시오.
*/
void QCPTextElement::setFont(const QFont &font)
{
  mFont = font;
}

/*!
  Sets the \a color of the text.
  
  \see setFont, setSelectedTextColor
*/
/*!
  텍스트의 색을 설정합니다.
  
  \ setFont, setSelectedTextColor를 참조하십시오.
*/
void QCPTextElement::setTextColor(const QColor &color)
{
  mTextColor = color;
}

/*!
  Sets the \a font of the text that will be used if the text element is selected (\ref setSelected).
  
  \see setFont
*/
/*!
  텍스트 요소가 선택되면 (\ ref setSelected) 사용될 텍스트의 글꼴을 설정합니다.
  
  \ see setFont
*/
void QCPTextElement::setSelectedFont(const QFont &font)
{
  mSelectedFont = font;
}

/*!
  Sets the \a color of the text that will be used if the text element is selected (\ref setSelected).
  
  \see setTextColor
*/
/*!
  텍스트 요소가 선택되면 (\ ref setSelected) 사용될 텍스트의 색을 설정합니다.
  
  \ setTextColor 참조
*/
void QCPTextElement::setSelectedTextColor(const QColor &color)
{
  mSelectedTextColor = color;
}

/*!
  Sets whether the user may select this text element.

  Note that even when \a selectable is set to <tt>false</tt>, the selection state may be changed
  programmatically via \ref setSelected.
*/
/*!
  유저가이 텍스트 요소를 선택할 수 있을지 어떨지를 설정합니다.

  \ a 선택 항목이 <tt> false </ tt>로 설정되어 있어도 선택 상태가 변경 될 수 있습니다
  \ ref setSelected를 통해 프로그래밍 방식으로.
*/
void QCPTextElement::setSelectable(bool selectable)
{
  if (mSelectable != selectable)
  {
    mSelectable = selectable;
    emit selectableChanged(mSelectable);
  }
}

/*!
  Sets the selection state of this text element to \a selected. If the selection has changed, \ref
  selectionChanged is emitted.
  
  Note that this function can change the selection state independently of the current \ref
  setSelectable state.
*/
/*!
  이 텍스트 요소의 선택 상태를 \ a로 설정합니다. 선택이 변경되면 \ ref
  selectionChanged가 발행됩니다.
  
  이 함수는 현재의 \ ref와는 별개로 선택 상태를 변경할 수 있습니다.
  setSelectable 상태.
*/
void QCPTextElement::setSelected(bool selected)
{
  if (mSelected != selected)
  {
    mSelected = selected;
    emit selectionChanged(mSelected);
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPTextElement::applyDefaultAntialiasingHint(QCPPainter *painter) const
{
  applyAntialiasingHint(painter, mAntialiased, QCP::aeOther);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPTextElement::draw(QCPPainter *painter)
{
  painter->setFont(mainFont());
  painter->setPen(QPen(mainTextColor()));
  painter->drawText(mRect, Qt::AlignCenter, mText, &mTextBoundingRect);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QSize QCPTextElement::minimumOuterSizeHint() const
{
  QFontMetrics metrics(mFont);
  QSize result(metrics.boundingRect(0, 0, 0, 0, Qt::AlignCenter, mText).size());
  result.rwidth() += mMargins.left()+mMargins.right();
  result.rheight() += mMargins.top()+mMargins.bottom();
  return result;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QSize QCPTextElement::maximumOuterSizeHint() const
{
  QFontMetrics metrics(mFont);
  QSize result(metrics.boundingRect(0, 0, 0, 0, Qt::AlignCenter, mText).size());
  result.setWidth(QWIDGETSIZE_MAX);
  result.rheight() += mMargins.top()+mMargins.bottom();
  return result;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPTextElement::selectEvent(QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)
{
  Q_UNUSED(event)
  Q_UNUSED(details)
  if (mSelectable)
  {
    bool selBefore = mSelected;
    setSelected(additive ? !mSelected : true);
    if (selectionStateChanged)
      *selectionStateChanged = mSelected != selBefore;
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPTextElement::deselectEvent(bool *selectionStateChanged)
{
  if (mSelectable)
  {
    bool selBefore = mSelected;
    setSelected(false);
    if (selectionStateChanged)
      *selectionStateChanged = mSelected != selBefore;
  }
}

/*!
  Returns 0.99*selectionTolerance (see \ref QCustomPlot::setSelectionTolerance) when \a pos is
  within the bounding box of the text element's text. Note that this bounding box is updated in the
  draw call.

  If \a pos is outside the text's bounding box or if \a onlySelectable is true and this text
  element is not selectable (\ref setSelectable), returns -1.

  \seebaseclassmethod
*/
/*!
  \ pos가있는 경우 0.99 * selectionTolerance (\ ref QCustomPlot :: setSelectionTolerance 참조)를 반환합니다.
  텍스트 요소의 텍스트 바운딩 박스 내에서. 이 바운딩 박스는
  전화 걸기.

  \ a pos가 텍스트의 경계 상자 밖에 있거나 \ a onlySelectable이 true이고이 텍스트가
  요소를 선택할 수 없으면 (\ ref setSelectable) -1을 반환합니다.

  \ seebaseclassmethod
*/
double QCPTextElement::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  Q_UNUSED(details)
  if (onlySelectable && !mSelectable)
    return -1;
  
  if (mTextBoundingRect.contains(pos.toPoint()))
    return mParentPlot->selectionTolerance()*0.99;
  else
    return -1;
}

/*!
  Accepts the mouse event in order to emit the according click signal in the \ref
  mouseReleaseEvent.

  \seebaseclassmethod
*/
/*!
  \ ref에있는 클릭 신호를 출력하기 위해 마우스 이벤트를받습니다.
  mouseReleaseEvent.

  \ seebaseclassmethod
*/
void QCPTextElement::mousePressEvent(QMouseEvent *event, const QVariant &details)
{
  Q_UNUSED(details)
  event->accept();
}

/*!
  Emits the \ref clicked signal if the cursor hasn't moved by more than a few pixels since the \ref
  mousePressEvent.

  \seebaseclassmethod
*/
/*!
  \ ref 이후 커서가 몇 픽셀 이상 움직이지 않으면 \ ref 클릭 신호를 내 보낸다.
  mousePressEvent입니다.

  \ seebaseclassmethod
*/
void QCPTextElement::mouseReleaseEvent(QMouseEvent *event, const QPointF &startPos)
{
  if ((QPointF(event->pos())-startPos).manhattanLength() <= 3)
    emit clicked(event);
}

/*!
  Emits the \ref doubleClicked signal.

  \seebaseclassmethod
*/
/*!
  \ ref doubleClicked 신호를 내 보냅니다.

  \ seebaseclassmethod
*/
void QCPTextElement::mouseDoubleClickEvent(QMouseEvent *event, const QVariant &details)
{
  Q_UNUSED(details)
  emit doubleClicked(event);
}

/*! \internal
  
  Returns the main font to be used. This is mSelectedFont if \ref setSelected is set to
  <tt>true</tt>, else mFont is returned.
*/
/*! \내부의
  
  사용할 주 글꼴을 반환합니다. \ ref setSelected를로 설정하면 이것은 mSelectedFont입니다.
  <tt> true </ tt>, 그렇지 않으면 mFont가 반환됩니다.
*/
QFont QCPTextElement::mainFont() const
{
  return mSelected ? mSelectedFont : mFont;
}

/*! \internal
  
  Returns the main color to be used. This is mSelectedTextColor if \ref setSelected is set to
  <tt>true</tt>, else mTextColor is returned.
*/
/*! \내부의
  
  사용할 주 색상을 반환합니다. \ ref setSelected를로 설정하면 이것은 mSelectedTextColor입니다.
  <tt> true </ tt>, 그렇지 않으면 mTextColor가 반환됩니다.
*/
QColor QCPTextElement::mainTextColor() const
{
  return mSelected ? mSelectedTextColor : mTextColor;
}
/* end of 'src/layoutelements/layoutelement-textelement.cpp' */


/* including file 'src/layoutelements/layoutelement-colorscale.cpp', size 25770 */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200    */
/* 'src / layoutelements / layoutelement-textelement.cpp'의 끝 */


/* 파일 'src / layoutelements / layoutelement-colorscale.cpp', 크기 25770 포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPColorScale
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPColorScale
  \brief A color scale for use with color coding data such as QCPColorMap
  
  This layout element can be placed on the plot to correlate a color gradient with data values. It
  is usually used in combination with one or multiple \ref QCPColorMap "QCPColorMaps".

  \image html QCPColorScale.png
  
  The color scale can be either horizontal or vertical, as shown in the image above. The
  orientation and the side where the numbers appear is controlled with \ref setType.
  
  Use \ref QCPColorMap::setColorScale to connect a color map with a color scale. Once they are
  connected, they share their gradient, data range and data scale type (\ref setGradient, \ref
  setDataRange, \ref setDataScaleType). Multiple color maps may be associated with a single color
  scale, to make them all synchronize these properties.
  
  To have finer control over the number display and axis behaviour, you can directly access the
  \ref axis. See the documentation of QCPAxis for details about configuring axes. For example, if
  you want to change the number of automatically generated ticks, call
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpcolorscale-tickcount
  
  Placing a color scale next to the main axis rect works like with any other layout element:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpcolorscale-creation
  In this case we have placed it to the right of the default axis rect, so it wasn't necessary to
  call \ref setType, since \ref QCPAxis::atRight is already the default. The text next to the color
  scale can be set with \ref setLabel.
  
  For optimum appearance (like in the image above), it may be desirable to line up the axis rect and
  the borders of the color scale. Use a \ref QCPMarginGroup to achieve this:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpcolorscale-margingroup
  
  Color scales are initialized with a non-zero minimum top and bottom margin (\ref
  setMinimumMargins), because vertical color scales are most common and the minimum top/bottom
  margin makes sure it keeps some distance to the top/bottom widget border. So if you change to a
  horizontal color scale by setting \ref setType to \ref QCPAxis::atBottom or \ref QCPAxis::atTop, you
  might want to also change the minimum margins accordingly, e.g. <tt>setMinimumMargins(QMargins(6, 0, 6, 0))</tt>.
*/
/*! \ class QCPColorScale
  \ brief QCPColorMap과 같은 색상 코딩 데이터와 함께 사용하기위한 색상 스케일입니다.
  
  이 레이아웃 요소는 색상 그라디언트를 데이터 값과 연관시키기 위해 플롯에 배치 할 수 있습니다. 그것
  일반적으로 하나 이상의 \ ref QCPColorMap "QCPColorMaps"와 결합하여 사용됩니다.

  \ image html QCPColorScale.png
  
  컬러 스케일은 위의 그림과 같이 가로 또는 세로 일 수 있습니다. 그만큼
  방향 및 숫자가 나타나는면은 \ ref setType으로 제어됩니다.
  
  \ ref QCPColorMap :: setColorScale을 사용하여 색상 표를 색상 표와 연결합니다. 그들이
  연결되면 그라디언트, 데이터 범위 및 데이터 크기 유형을 공유합니다 (\ ref setGradient, \ ref
  setDataRange, \ ref setDataScaleType). 여러 색상 맵은 단일 색상과 연관 될 수 있습니다.
  이러한 속성을 모두 동기화하도록 설정합니다.
  
  숫자 표시 및 축 동작을보다 세밀하게 제어하려면
  \ ref 축. 축 구성에 대한 자세한 내용은 QCPAxis의 설명서를 참조하십시오. 예를 들어, if
  자동 생성 된 틱의 수를 변경하려면
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpcolorscale-tickcount
  
  주축 rect 옆에 색상 스케일을 배치하면 다른 레이아웃 요소와 같이 작동합니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpcolorscale-creation
  이 경우 기본 축 rect의 오른쪽에 배치 했으므로 필요하지 않았습니다.
  \ ref QCPAxis :: atRight가 이미 기본값이기 때문에 \ ref setType을 호출하십시오. 색상 옆의 텍스트
  scale은 \ ref setLabel로 설정할 수 있습니다.
  
  위의 그림과 같이 최적의 외관을 위해 축 rect와
  색 눈금의 테두리. 이를 달성하려면 \ ref QCPMarginGroup을 사용하십시오.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpcolorscale-margingroup
  
  색 눈금은 0이 아닌 최소 위쪽 및 아래쪽 여백으로 초기화됩니다 (\ ref
  setMinimumMargins). 왜냐하면 수직 색상 비율이 가장 일반적이며 최소 상단 / 하단
  여백은 위쪽 / 아래쪽 위젯 테두리에 약간의 거리를 유지하도록합니다. 그래서 당신이
  \ ref setType을 \ ref QCPAxis :: atBottom 또는 \ ref QCPAxis :: atTop로 설정하여 수평 색상 스케일을 설정합니다.
  <tt> setMinimumMargins (QMargins (6, 0, 6, 0)) </ tt>와 같이 최소 여백을 적절히 변경하고 싶을 수도 있습니다.
*/

/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */

/*! \fn QCPAxis *QCPColorScale::axis() const
  
  Returns the internal \ref QCPAxis instance of this color scale. You can access it to alter the
  appearance and behaviour of the axis. \ref QCPColorScale duplicates some properties in its
  interface for convenience. Those are \ref setDataRange (\ref QCPAxis::setRange), \ref
  setDataScaleType (\ref QCPAxis::setScaleType), and the method \ref setLabel (\ref
  QCPAxis::setLabel). As they each are connected, it does not matter whether you use the method on
  the QCPColorScale or on its QCPAxis.
  
  If the type of the color scale is changed with \ref setType, the axis returned by this method
  will change, too, to either the left, right, bottom or top axis, depending on which type was set.
*/
/*! \ fn QCPAxis * QCPColorScale :: axis () const
  
  이 컬러 스케일의 내부 \ ref QCPAxis 인스턴스를 반환합니다. 이 도구에 액세스하여
  모양 및 축 동작. \ ref QCPColorScale은 일부 속성을 복제합니다.
  편의를 위해 인터페이스. 그것들은 \ ref setDataRange (\ ref QCPAxis :: setRange), \ ref
  setDataScaleType (\ ref QCPAxis :: setScaleType) 및 메서드 \ ref setLabel (\ ref
  QCPAxis :: setLabel). 그들 각각이 연결되어 있기 때문에, 당신이이 방법을 사용했는지 여부는 중요하지 않습니다.
  QCPColorScale 또는 해당 QCPAxis.
  
  \ ref setType를 사용하여 색상 스케일의 유형이 변경되면이 방법으로 반환 된 축
  설정 한 유형에 따라 왼쪽, 오른쪽, 아래 또는 위쪽 축 중 하나로 변경됩니다.
*/

/* end documentation of signals */
/* start documentation of signals */
/* 신호의 끝 문서 */
/* 신호의 문서화를 시작한다. */

/*! \fn void QCPColorScale::dataRangeChanged(const QCPRange &newRange);
  
  This signal is emitted when the data range changes.
  
  \see setDataRange
*/
/*! \ fn void QCPColorScale :: dataRangeChanged (const QCPRange & newRange);
  
  이 신호는 데이터 범위가 변경 될 때 방출됩니다.
  
  \ 참조 setDataRange
*/

/*! \fn void QCPColorScale::dataScaleTypeChanged(QCPAxis::ScaleType scaleType);
  
  This signal is emitted when the data scale type changes.
  
  \see setDataScaleType
*/
/*! \ fn void QCPColorScale :: dataScaleTypeChanged (QCPAxis :: ScaleType scaleType);
  
  이 신호는 데이터 스케일 유형이 변경 될 때 방출됩니다.
  
  \ setDataScaleType 참조
*/

/*! \fn void QCPColorScale::gradientChanged(const QCPColorGradient &newGradient);
  
  This signal is emitted when the gradient changes.
  
  \see setGradient
*/
/*! \ fn void QCPColorScale :: gradientChanged (const QCPColorGradient & newGradient);
  
  이 신호는 그래디언트가 변경 될 때 방출됩니다.
  
  \ setGradient를 참조하십시오.
*/

/* end documentation of signals */
/* 신호의 끝 문서 */

/*!
  Constructs a new QCPColorScale.
*/
/*!
  새로운 QCPColorScale를 구축합니다.
*/
QCPColorScale::QCPColorScale(QCustomPlot *parentPlot) :
  QCPLayoutElement(parentPlot),
  mType(QCPAxis::atTop),
// set to atTop such that setType(QCPAxis::atRight) below doesn't skip work because it thinks it's already atRight
// 아래의 setType (QCPAxis :: atRight)이 이미 atRight라고 생각하여 작업을 건너 뛰지 않도록 atTop으로 설정합니다.
  mDataScaleType(QCPAxis::stLinear),
  mBarWidth(20),
  mAxisRect(new QCPColorScaleAxisRectPrivate(this))
{
  setMinimumMargins(QMargins(0, 6, 0, 6));
// for default right color scale types, keep some room at bottom and top (important if no margin group is used)
 // 기본 오른쪽 색상 스케일 유형의 경우 하단 및 상단에 여유 공간을 남깁니다 (여백 그룹을 사용하지 않을 경우 중요)
  setType(QCPAxis::atRight);
  setDataRange(QCPRange(0, 6));
}

QCPColorScale::~QCPColorScale()
{
  delete mAxisRect;
}

/* undocumented getter */
/* 문서화되지 않은 getter */
QString QCPColorScale::label() const
{
  if (!mColorAxis)
  {
    qDebug() << Q_FUNC_INFO << "internal color axis undefined";
    return QString();
  }
  
  return mColorAxis.data()->label();
}

/* undocumented getter */
/* 문서화되지 않은 getter */
bool QCPColorScale::rangeDrag() const
{
  if (!mAxisRect)
  {
    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
    return false;
  }
  
  return mAxisRect.data()->rangeDrag().testFlag(QCPAxis::orientation(mType)) &&
      mAxisRect.data()->rangeDragAxis(QCPAxis::orientation(mType)) &&
      mAxisRect.data()->rangeDragAxis(QCPAxis::orientation(mType))->orientation() == QCPAxis::orientation(mType);
}

/* undocumented getter */
/* 문서화되지 않은 getter */
bool QCPColorScale::rangeZoom() const
{
  if (!mAxisRect)
  {
    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
    return false;
  }
  
  return mAxisRect.data()->rangeZoom().testFlag(QCPAxis::orientation(mType)) &&
      mAxisRect.data()->rangeZoomAxis(QCPAxis::orientation(mType)) &&
      mAxisRect.data()->rangeZoomAxis(QCPAxis::orientation(mType))->orientation() == QCPAxis::orientation(mType);
}

/*!
  Sets at which side of the color scale the axis is placed, and thus also its orientation.
  
  Note that after setting \a type to a different value, the axis returned by \ref axis() will
  be a different one. The new axis will adopt the following properties from the previous axis: The
  range, scale type, label and ticker (the latter will be shared and not copied).
*/
/*!
  축이 배치되는 색상 스케일의 측면을 설정하고 방향도 지정합니다.
  
  \ a 유형을 다른 값으로 설정하면 \ ref axis ()에 의해 반환 된 축이
  다른 사람이 되십시오. 새 축은 이전 축에서 다음 특성을 채택합니다.
  범위, 스케일 유형, 레이블 및 티커 (후자는 공유되고 복사되지 않습니다).
*/
void QCPColorScale::setType(QCPAxis::AxisType type)
{
  if (!mAxisRect)
  {
    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
    return;
  }
  if (mType != type)
  {
    mType = type;
    QCPRange rangeTransfer(0, 6);
    QString labelTransfer;
    QSharedPointer<QCPAxisTicker> tickerTransfer;
    // transfer/revert some settings on old axis if it exists:
    // 이전 축의 일부 설정을 이전 / 되돌리기 :
    bool doTransfer = (bool)mColorAxis;
    if (doTransfer)
    {
      rangeTransfer = mColorAxis.data()->range();
      labelTransfer = mColorAxis.data()->label();
      tickerTransfer = mColorAxis.data()->ticker();
      mColorAxis.data()->setLabel(QString());
      disconnect(mColorAxis.data(), SIGNAL(rangeChanged(QCPRange)), this, SLOT(setDataRange(QCPRange)));
      disconnect(mColorAxis.data(), SIGNAL(scaleTypeChanged(QCPAxis::ScaleType)), this, SLOT(setDataScaleType(QCPAxis::ScaleType)));
    }
    QList<QCPAxis::AxisType> allAxisTypes = QList<QCPAxis::AxisType>() << QCPAxis::atLeft << QCPAxis::atRight << QCPAxis::atBottom << QCPAxis::atTop;
    foreach (QCPAxis::AxisType atype, allAxisTypes)
    {
      mAxisRect.data()->axis(atype)->setTicks(atype == mType);
      mAxisRect.data()->axis(atype)->setTickLabels(atype== mType);
    }
    // set new mColorAxis pointer:
    // 새 mColorAxis 포인터를 설정합니다.
    mColorAxis = mAxisRect.data()->axis(mType);
    // transfer settings to new axis:
    // 새 축으로 설정을 전송합니다.
    if (doTransfer)
    {
      mColorAxis.data()->setRange(rangeTransfer); // range transfer necessary if axis changes from vertical to horizontal or vice versa (axes with same orientation are synchronized via signals)
// 축이 수직에서 수평으로 또는 그 반대로 바뀌면 필요한 범위 전송 (동일한 방향을 가진 축은 신호를 통해 동기화 됨)
      mColorAxis.data()->setLabel(labelTransfer);
      mColorAxis.data()->setTicker(tickerTransfer);
    }
    connect(mColorAxis.data(), SIGNAL(rangeChanged(QCPRange)), this, SLOT(setDataRange(QCPRange)));
    connect(mColorAxis.data(), SIGNAL(scaleTypeChanged(QCPAxis::ScaleType)), this, SLOT(setDataScaleType(QCPAxis::ScaleType)));
    mAxisRect.data()->setRangeDragAxes(QList<QCPAxis*>() << mColorAxis.data());
  }
}

/*!
  Sets the range spanned by the color gradient and that is shown by the axis in the color scale.
  
  It is equivalent to calling QCPColorMap::setDataRange on any of the connected color maps. It is
  also equivalent to directly accessing the \ref axis and setting its range with \ref
  QCPAxis::setRange.
  
  \see setDataScaleType, setGradient, rescaleDataRange
*/
/*!
  색 그라데이션에 걸친 범위를 설정하고 축에 의해 색 눈금으로 표시되는 범위를 설정합니다.
  
  연결된 색상 맵에서 QCPColorMap :: setDataRange를 호출하는 것과 같습니다. 그것은
  \ ref 축에 직접 액세스하고 \ ref로 범위를 설정하는 것과 같습니다.
  QCPAxis :: setRange.
  
  \ setDataScaleType, setGradient, rescaleDataRange를 참조하십시오.
*/
void QCPColorScale::setDataRange(const QCPRange &dataRange)
{
  if (mDataRange.lower != dataRange.lower || mDataRange.upper != dataRange.upper)
  {
    mDataRange = dataRange;
    if (mColorAxis)
      mColorAxis.data()->setRange(mDataRange);
    emit dataRangeChanged(mDataRange);
  }
}

/*!
  Sets the scale type of the color scale, i.e. whether values are linearly associated with colors
  or logarithmically.
  
  It is equivalent to calling QCPColorMap::setDataScaleType on any of the connected color maps. It is
  also equivalent to directly accessing the \ref axis and setting its scale type with \ref
  QCPAxis::setScaleType.
  
  \see setDataRange, setGradient
*/
/*!
  색상 스케일의 크기 유형을 설정합니다. 즉, 값이 색상과 선형으로 연관되는지 여부를 설정합니다.
  또는 대수적으로.
  
  연결된 색상 맵에서 QCPColorMap :: setDataScaleType을 호출하는 것과 같습니다. 그것은
  \ ref 축에 직접 액세스하고 \ ref로 축척 유형을 설정하는 것과 같습니다.
  QCPAxis :: setScaleType.
  
  \ setDataRange, setGradient를 참조하십시오.
*/
void QCPColorScale::setDataScaleType(QCPAxis::ScaleType scaleType)
{
  if (mDataScaleType != scaleType)
  {
    mDataScaleType = scaleType;
    if (mColorAxis)
      mColorAxis.data()->setScaleType(mDataScaleType);
    if (mDataScaleType == QCPAxis::stLogarithmic)
      setDataRange(mDataRange.sanitizedForLogScale());
    emit dataScaleTypeChanged(mDataScaleType);
  }
}

/*!
  Sets the color gradient that will be used to represent data values.
  
  It is equivalent to calling QCPColorMap::setGradient on any of the connected color maps.
  
  \see setDataRange, setDataScaleType
*/
/*!
  데이터 값을 나타내는 데 사용할 색상 그라디언트를 설정합니다.
  
  연결된 색상 맵에서 QCPColorMap :: setGradient를 호출하는 것과 같습니다.
  
  \ setDataRange, setDataScaleType을 참조하십시오.
*/
void QCPColorScale::setGradient(const QCPColorGradient &gradient)
{
  if (mGradient != gradient)
  {
    mGradient = gradient;
    if (mAxisRect)
      mAxisRect.data()->mGradientImageInvalidated = true;
    emit gradientChanged(mGradient);
  }
}

/*!
  Sets the axis label of the color scale. This is equivalent to calling \ref QCPAxis::setLabel on
  the internal \ref axis.
*/
/*!
  칼라 스케일의 축 label를 설정합니다. 이것은 \ ref QCPAxis :: setLabel on을 호출하는 것과 같습니다.
  내부 \ ref 축.
*/
void QCPColorScale::setLabel(const QString &str)
{
  if (!mColorAxis)
  {
    qDebug() << Q_FUNC_INFO << "internal color axis undefined";
    return;
  }
  
  mColorAxis.data()->setLabel(str);
}

/*!
  Sets the width (or height, for horizontal color scales) the bar where the gradient is displayed
  will have.
*/
/*!
  그라디언트가 표시되는 막대의 가로 또는 세로 색상 막대를 설정합니다.
  가질거야.
*/
void QCPColorScale::setBarWidth(int width)
{
  mBarWidth = width;
}

/*!
  Sets whether the user can drag the data range (\ref setDataRange).
  
  Note that \ref QCP::iRangeDrag must be in the QCustomPlot's interactions (\ref
  QCustomPlot::setInteractions) to allow range dragging.
*/
/*!
  사용자가 데이터 범위 (\ ref setDataRange)를 끌 수 있는지 여부를 설정합니다.
  
  \ ref QCP :: iRangeDrag는 QCustomPlot의 상호 작용에 있어야합니다 (\ ref
  QCustomPlot :: setInteractions)를 사용하여 범위를 드래그 할 수 있습니다.
*/
void QCPColorScale::setRangeDrag(bool enabled)
{
  if (!mAxisRect)
  {
    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
    return;
  }
  
  if (enabled)
    mAxisRect.data()->setRangeDrag(QCPAxis::orientation(mType));
  else
    mAxisRect.data()->setRangeDrag(0);
}

/*!
  Sets whether the user can zoom the data range (\ref setDataRange) by scrolling the mouse wheel.
  
  Note that \ref QCP::iRangeZoom must be in the QCustomPlot's interactions (\ref
  QCustomPlot::setInteractions) to allow range dragging.
*/
/*!
  마우스 휠을 스크롤하여 데이터 범위 (\ ref setDataRange)를 확대 할 수 있는지 여부를 설정합니다.
  
  \ ref QCP :: iRangeZoom은 QCustomPlot의 상호 작용에 있어야합니다 (\ ref
  QCustomPlot :: setInteractions)를 사용하여 범위를 드래그 할 수 있습니다.
*/
void QCPColorScale::setRangeZoom(bool enabled)
{
  if (!mAxisRect)
  {
    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
    return;
  }
  
  if (enabled)
    mAxisRect.data()->setRangeZoom(QCPAxis::orientation(mType));
  else
    mAxisRect.data()->setRangeZoom(0);
}

/*!
  Returns a list of all the color maps associated with this color scale.
*/
/*!
  이 칼라 스케일에 관련 지을 수 있던 모든 칼라 맵의리스트를 돌려줍니다.
*/
QList<QCPColorMap*> QCPColorScale::colorMaps() const
{
  QList<QCPColorMap*> result;
  for (int i=0; i<mParentPlot->plottableCount(); ++i)
  {
    if (QCPColorMap *cm = qobject_cast<QCPColorMap*>(mParentPlot->plottable(i)))
      if (cm->colorScale() == this)
        result.append(cm);
  }
  return result;
}

/*!
  Changes the data range such that all color maps associated with this color scale are fully mapped
  to the gradient in the data dimension.
  
  \see setDataRange
*/
/*!
  이 색상 스케일과 연관된 모든 색상 맵이 완전히 매핑되도록 데이터 범위를 변경합니다.
  데이터 차원의 그래디언트로 이동합니다.
  
  \ 참조 setDataRange
*/
void QCPColorScale::rescaleDataRange(bool onlyVisibleMaps)
{
  QList<QCPColorMap*> maps = colorMaps();
  QCPRange newRange;
  bool haveRange = false;
  QCP::SignDomain sign = QCP::sdBoth;
  if (mDataScaleType == QCPAxis::stLogarithmic)
    sign = (mDataRange.upper < 0 ? QCP::sdNegative : QCP::sdPositive);
  for (int i=0; i<maps.size(); ++i)
  {
    if (!maps.at(i)->realVisibility() && onlyVisibleMaps)
      continue;
    QCPRange mapRange;
    if (maps.at(i)->colorScale() == this)
    {
      bool currentFoundRange = true;
      mapRange = maps.at(i)->data()->dataBounds();
      if (sign == QCP::sdPositive)
      {
        if (mapRange.lower <= 0 && mapRange.upper > 0)
          mapRange.lower = mapRange.upper*1e-3;
        else if (mapRange.lower <= 0 && mapRange.upper <= 0)
          currentFoundRange = false;
      } else if (sign == QCP::sdNegative)
      {
        if (mapRange.upper >= 0 && mapRange.lower < 0)
          mapRange.upper = mapRange.lower*1e-3;
        else if (mapRange.upper >= 0 && mapRange.lower >= 0)
          currentFoundRange = false;
      }
      if (currentFoundRange)
      {
        if (!haveRange)
          newRange = mapRange;
        else
          newRange.expand(mapRange);
        haveRange = true;
      }
    }
  }
  if (haveRange)
  {
    if (!QCPRange::validRange(newRange)) // likely due to range being zero (plottable has only constant data in this dimension), shift current range to at least center the data
// 범위가 0 일 가능성이 높습니다 (plottable은이 차원에서 상수 데이터 만 포함 함), 현재 범위를 데이터를 최소한 중앙으로 이동합니다
    {
      double center = (newRange.lower+newRange.upper)*0.5; 
// upper and lower should be equal anyway, but just to make sure, incase validRange returned false for other reason
// upper와 lower는 반드시 동일해야하지만, 확실하게하려면 incase validRange가 다른 이유로 false를 반환합니다.
      if (mDataScaleType == QCPAxis::stLinear)
      {
        newRange.lower = center-mDataRange.size()/2.0;
        newRange.upper = center+mDataRange.size()/2.0;
      } else // mScaleType == stLogarithmic
      {
        newRange.lower = center/qSqrt(mDataRange.upper/mDataRange.lower);
        newRange.upper = center*qSqrt(mDataRange.upper/mDataRange.lower);
      }
    }
    setDataRange(newRange);
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPColorScale::update(UpdatePhase phase)
{
  QCPLayoutElement::update(phase);
  if (!mAxisRect)
  {
    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
    return;
  }
  
  mAxisRect.data()->update(phase);
  
  switch (phase)
  {
    case upMargins:
    {
      if (mType == QCPAxis::atBottom || mType == QCPAxis::atTop)
      {
        setMaximumSize(QWIDGETSIZE_MAX, mBarWidth+mAxisRect.data()->margins().top()+mAxisRect.data()->margins().bottom());
        setMinimumSize(0,               mBarWidth+mAxisRect.data()->margins().top()+mAxisRect.data()->margins().bottom());
      } else
      {
        setMaximumSize(mBarWidth+mAxisRect.data()->margins().left()+mAxisRect.data()->margins().right(), QWIDGETSIZE_MAX);
        setMinimumSize(mBarWidth+mAxisRect.data()->margins().left()+mAxisRect.data()->margins().right(), 0);
      }
      break;
    }
    case upLayout:
    {
      mAxisRect.data()->setOuterRect(rect());
      break;
    }
    default: break;
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPColorScale::applyDefaultAntialiasingHint(QCPPainter *painter) const
{
  painter->setAntialiasing(false);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPColorScale::mousePressEvent(QMouseEvent *event, const QVariant &details)
{
  if (!mAxisRect)
  {
    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
    return;
  }
  mAxisRect.data()->mousePressEvent(event, details);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPColorScale::mouseMoveEvent(QMouseEvent *event, const QPointF &startPos)
{
  if (!mAxisRect)
  {
    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
    return;
  }
  mAxisRect.data()->mouseMoveEvent(event, startPos);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPColorScale::mouseReleaseEvent(QMouseEvent *event, const QPointF &startPos)
{
  if (!mAxisRect)
  {
    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
    return;
  }
  mAxisRect.data()->mouseReleaseEvent(event, startPos);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPColorScale::wheelEvent(QWheelEvent *event)
{
  if (!mAxisRect)
  {
    qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";
    return;
  }
  mAxisRect.data()->wheelEvent(event);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPColorScaleAxisRectPrivate
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPColorScaleAxisRectPrivate

  \internal
  \brief An axis rect subclass for use in a QCPColorScale
  
  This is a private class and not part of the public QCustomPlot interface.
  
  It provides the axis rect functionality for the QCPColorScale class.
*/
/*! \ class QCPColorScaleAxisRectPrivate

  \내부의
  \ brief QCPColorScale에서 사용할 축 rect 하위 클래스입니다.
  
  이것은 개인 클래스이며 공용 QCustomPlot 인터페이스의 일부가 아닙니다.
  
  QCPColorScale 클래스에 대한 축 rect 기능을 제공합니다.
*/


/*!
  Creates a new instance, as a child of \a parentColorScale.
*/
/*!
  새로운 인스턴스를 \ parentColorScale의 아이로서 작성합니다.
*/
QCPColorScaleAxisRectPrivate::QCPColorScaleAxisRectPrivate(QCPColorScale *parentColorScale) :
  QCPAxisRect(parentColorScale->parentPlot(), true),
  mParentColorScale(parentColorScale),
  mGradientImageInvalidated(true)
{
  setParentLayerable(parentColorScale);
  setMinimumMargins(QMargins(0, 0, 0, 0));
  QList<QCPAxis::AxisType> allAxisTypes = QList<QCPAxis::AxisType>() << QCPAxis::atBottom << QCPAxis::atTop << QCPAxis::atLeft << QCPAxis::atRight;
  foreach (QCPAxis::AxisType type, allAxisTypes)
  {
    axis(type)->setVisible(true);
    axis(type)->grid()->setVisible(false);
    axis(type)->setPadding(0);
    connect(axis(type), SIGNAL(selectionChanged(QCPAxis::SelectableParts)), this, SLOT(axisSelectionChanged(QCPAxis::SelectableParts)));
    connect(axis(type), SIGNAL(selectableChanged(QCPAxis::SelectableParts)), this, SLOT(axisSelectableChanged(QCPAxis::SelectableParts)));
  }

  connect(axis(QCPAxis::atLeft), SIGNAL(rangeChanged(QCPRange)), axis(QCPAxis::atRight), SLOT(setRange(QCPRange)));
  connect(axis(QCPAxis::atRight), SIGNAL(rangeChanged(QCPRange)), axis(QCPAxis::atLeft), SLOT(setRange(QCPRange)));
  connect(axis(QCPAxis::atBottom), SIGNAL(rangeChanged(QCPRange)), axis(QCPAxis::atTop), SLOT(setRange(QCPRange)));
  connect(axis(QCPAxis::atTop), SIGNAL(rangeChanged(QCPRange)), axis(QCPAxis::atBottom), SLOT(setRange(QCPRange)));
  connect(axis(QCPAxis::atLeft), SIGNAL(scaleTypeChanged(QCPAxis::ScaleType)), axis(QCPAxis::atRight), SLOT(setScaleType(QCPAxis::ScaleType)));
  connect(axis(QCPAxis::atRight), SIGNAL(scaleTypeChanged(QCPAxis::ScaleType)), axis(QCPAxis::atLeft), SLOT(setScaleType(QCPAxis::ScaleType)));
  connect(axis(QCPAxis::atBottom), SIGNAL(scaleTypeChanged(QCPAxis::ScaleType)), axis(QCPAxis::atTop), SLOT(setScaleType(QCPAxis::ScaleType)));
  connect(axis(QCPAxis::atTop), SIGNAL(scaleTypeChanged(QCPAxis::ScaleType)), axis(QCPAxis::atBottom), SLOT(setScaleType(QCPAxis::ScaleType)));
  
  // make layer transfers of color scale transfer to axis rect and axes
  // the axes must be set after axis rect, such that they appear above color gradient drawn by axis rect:
  // 축과 축에 색 스케일 전송의 레이어 전송을 만든다.
  // 축은 축 rect에 의해 설정되어야합니다. 축에 의해 그려지는 색 그라디언트 위에 나타납니다. rect :
  connect(parentColorScale, SIGNAL(layerChanged(QCPLayer*)), this, SLOT(setLayer(QCPLayer*)));
  foreach (QCPAxis::AxisType type, allAxisTypes)
    connect(parentColorScale, SIGNAL(layerChanged(QCPLayer*)), axis(type), SLOT(setLayer(QCPLayer*)));
}

/*! \internal
  
  Updates the color gradient image if necessary, by calling \ref updateGradientImage, then draws
  it. Then the axes are drawn by calling the \ref QCPAxisRect::draw base class implementation.
  
  \seebaseclassmethod
*/
/*! \내부의
  
  필요한 경우 \ ref updateGradientImage를 호출하여 색상 그라디언트 이미지를 업데이트 한 다음 그립니다
  그것. 그런 다음 \ ref QCPAxisRect :: draw 기본 클래스 구현을 호출하여 축을 그립니다.
  
  \ seebaseclassmethod
*/
void QCPColorScaleAxisRectPrivate::draw(QCPPainter *painter)
{
  if (mGradientImageInvalidated)
    updateGradientImage();
  
  bool mirrorHorz = false;
  bool mirrorVert = false;
  if (mParentColorScale->mColorAxis)
  {
    mirrorHorz = mParentColorScale->mColorAxis.data()->rangeReversed() && (mParentColorScale->type() == QCPAxis::atBottom || mParentColorScale->type() == QCPAxis::atTop);
    mirrorVert = mParentColorScale->mColorAxis.data()->rangeReversed() && (mParentColorScale->type() == QCPAxis::atLeft || mParentColorScale->type() == QCPAxis::atRight);
  }
  
  painter->drawImage(rect().adjusted(0, -1, 0, -1), mGradientImage.mirrored(mirrorHorz, mirrorVert));
  QCPAxisRect::draw(painter);
}

/*! \internal

  Uses the current gradient of the parent \ref QCPColorScale (specified in the constructor) to
  generate a gradient image. This gradient image will be used in the \ref draw method.
*/
/*! \내부의

  부모 \ ref QCPColorScale (생성자에 지정됨)의 현재 그래디언트를 사용하여
  그라디언트 이미지를 생성합니다. 이 그래디언트 이미지는 \ ref draw 메서드에서 사용됩니다.
*/
void QCPColorScaleAxisRectPrivate::updateGradientImage()
{
  if (rect().isEmpty())
    return;
  
  const QImage::Format format = QImage::Format_ARGB32_Premultiplied;
  int n = mParentColorScale->mGradient.levelCount();
  int w, h;
  QVector<double> data(n);
  for (int i=0; i<n; ++i)
    data[i] = i;
  if (mParentColorScale->mType == QCPAxis::atBottom || mParentColorScale->mType == QCPAxis::atTop)
  {
    w = n;
    h = rect().height();
    mGradientImage = QImage(w, h, format);
    QVector<QRgb*> pixels;
    for (int y=0; y<h; ++y)
      pixels.append(reinterpret_cast<QRgb*>(mGradientImage.scanLine(y)));
    mParentColorScale->mGradient.colorize(data.constData(), QCPRange(0, n-1), pixels.first(), n);
    for (int y=1; y<h; ++y)
      memcpy(pixels.at(y), pixels.first(), n*sizeof(QRgb));
  } else
  {
    w = rect().width();
    h = n;
    mGradientImage = QImage(w, h, format);
    for (int y=0; y<h; ++y)
    {
      QRgb *pixels = reinterpret_cast<QRgb*>(mGradientImage.scanLine(y));
      const QRgb lineColor = mParentColorScale->mGradient.color(data[h-1-y], QCPRange(0, n-1));
      for (int x=0; x<w; ++x)
        pixels[x] = lineColor;
    }
  }
  mGradientImageInvalidated = false;
}

/*! \internal

  This slot is connected to the selectionChanged signals of the four axes in the constructor. It
  synchronizes the selection state of the axes.
*/
/*! \내부의

  이 슬롯은 생성자의 네 축의 selectionChanged 신호에 연결됩니다. 그것
  축의 선택 상태를 동기화합니다.
*/
void QCPColorScaleAxisRectPrivate::axisSelectionChanged(QCPAxis::SelectableParts selectedParts)
{
  // axis bases of four axes shall always (de-)selected synchronously:
  // 4 축의 축 기본은 항상 동 기적으로 선택됩니다 (de-).
  QList<QCPAxis::AxisType> allAxisTypes = QList<QCPAxis::AxisType>() << QCPAxis::atBottom << QCPAxis::atTop << QCPAxis::atLeft << QCPAxis::atRight;
  foreach (QCPAxis::AxisType type, allAxisTypes)
  {
    if (QCPAxis *senderAxis = qobject_cast<QCPAxis*>(sender()))
      if (senderAxis->axisType() == type)
        continue;
    
    if (axis(type)->selectableParts().testFlag(QCPAxis::spAxis))
    {
      if (selectedParts.testFlag(QCPAxis::spAxis))
        axis(type)->setSelectedParts(axis(type)->selectedParts() | QCPAxis::spAxis);
      else
        axis(type)->setSelectedParts(axis(type)->selectedParts() & ~QCPAxis::spAxis);
    }
  }
}

/*! \internal

  This slot is connected to the selectableChanged signals of the four axes in the constructor. It
  synchronizes the selectability of the axes.
*/
/*! \내부의

  이 슬롯은 생성자의 4 개 축의 선택 가능한 변경 신호에 연결됩니다. 그것
  축의 선택 가능성을 동기화합니다.
*/
void QCPColorScaleAxisRectPrivate::axisSelectableChanged(QCPAxis::SelectableParts selectableParts)
{
  // synchronize axis base selectability:
  // 축베이스 선택성 동기화 :
  QList<QCPAxis::AxisType> allAxisTypes = QList<QCPAxis::AxisType>() << QCPAxis::atBottom << QCPAxis::atTop << QCPAxis::atLeft << QCPAxis::atRight;
  foreach (QCPAxis::AxisType type, allAxisTypes)
  {
    if (QCPAxis *senderAxis = qobject_cast<QCPAxis*>(sender()))
      if (senderAxis->axisType() == type)
        continue;
    
    if (axis(type)->selectableParts().testFlag(QCPAxis::spAxis))
    {
      if (selectableParts.testFlag(QCPAxis::spAxis))
        axis(type)->setSelectableParts(axis(type)->selectableParts() | QCPAxis::spAxis);
      else
        axis(type)->setSelectableParts(axis(type)->selectableParts() & ~QCPAxis::spAxis);
    }
  }
}
/* end of 'src/layoutelements/layoutelement-colorscale.cpp' */


/* including file 'src/plottables/plottable-graph.cpp', size 73960           */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / layoutelements / layoutelement-colorscale.cpp'의 끝 */


/* 파일 'src / plottables / plottable-graph.cpp'포함, 크기 73960 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPGraphData
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPGraphData
  \brief Holds the data of one single data point for QCPGraph.
  
  The stored data is:
  \li \a key: coordinate on the key axis of this data point (this is the \a mainKey and the \a sortKey)
  \li \a value: coordinate on the value axis of this data point (this is the \a mainValue)
  
  The container for storing multiple data points is \ref QCPGraphDataContainer. It is a typedef for
  \ref QCPDataContainer with \ref QCPGraphData as the DataType template parameter. See the
  documentation there for an explanation regarding the data type's generic methods.
  
  \see QCPGraphDataContainer
*/
/*! \ class QCPGraphData
  \ brief QCPGraph에 대한 단일 데이터 포인트의 데이터를 보유합니다.
  
  저장된 데이터는 다음과 같습니다.
  \ li \ a key :이 데이터 포인트의 키 축의 좌표입니다 (이것은 mainKey와 \ a sortKey입니다)
  \ li \ a value :이 데이터 포인트의 값 축에 대한 좌표 (이것은 \ a mainValue 임)
  
  여러 데이터 요소를 저장하는 컨테이너는 \ ref QCPGraphDataContainer입니다. 그것은에 대한 typedef입니다.
  \ ref QCPDataContainer는 \ ref QCPGraphData를 DataType 템플릿 매개 변수로 사용합니다. 자세한 내용은
  데이터 유형의 제네릭 메소드에 대한 설명은 문서를 참조하십시오.
  
  \ QCPGraphDataContainer 참조
*/

/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */

/*! \fn double QCPGraphData::sortKey() const
  
  Returns the \a key member of this data point.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn double QCPGraphData :: sortKey () const
  
  이 데이터 포인트의 키 멤버를 돌려줍니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn static QCPGraphData QCPGraphData::fromSortKey(double sortKey)
  
  Returns a data point with the specified \a sortKey. All other members are set to zero.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn 정적 QCPGraphData QCPGraphData :: fromSortKey (double sortKey)
  
  지정된 \ a sortKey를 가지는 데이터 포인트를 돌려줍니다. 다른 모든 멤버는 0으로 설정됩니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn static static bool QCPGraphData::sortKeyIsMainKey()
  
  Since the member \a key is both the data point key coordinate and the data ordering parameter,
  this method returns true.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn 정적 정적 bool QCPGraphData :: sortKeyIsMainKey ()
  
  member \ a 키는 데이터 포인트 키 좌표와 데이터 정렬 매개 변수이기 때문에,
  이 메소드는 true를 리턴합니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn double QCPGraphData::mainKey() const
  
  Returns the \a key member of this data point.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn double QCPGraphData :: mainKey () const
  
  이 데이터 포인트의 키 멤버를 돌려줍니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn double QCPGraphData::mainValue() const
  
  Returns the \a value member of this data point.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn double QCPGraphData :: mainValue () const
  
  이 데이터 포인트의 \ a 값 멤버를 반환합니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn QCPRange QCPGraphData::valueRange() const
  
  Returns a QCPRange with both lower and upper boundary set to \a value of this data point.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn QCPRange QCPGraphData :: valueRange () const
  
  이 데이터 포인트의 값에 상한과 하한을 모두 설정 한 QCPRange를 반환합니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */

/*!
  Constructs a data point with key and value set to zero.
*/
/*!
  키와 값을 제로로 설정해 데이터 포인트를 구축합니다.
*/
QCPGraphData::QCPGraphData() :
  key(0),
  value(0)
{
}

/*!
  Constructs a data point with the specified \a key and \a value.
*/
/*!
  지정된 \ a 키와 \ a 치를 가지는 데이터 포인트를 구축합니다.
*/
QCPGraphData::QCPGraphData(double key, double value) :
  key(key),
  value(value)
{
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPGraph
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPGraph
  \brief A plottable representing a graph in a plot.

  \image html QCPGraph.png
  
  Usually you create new graphs by calling QCustomPlot::addGraph. The resulting instance can be
  accessed via QCustomPlot::graph.

  To plot data, assign it with the \ref setData or \ref addData functions. Alternatively, you can
  also access and modify the data via the \ref data method, which returns a pointer to the internal
  \ref QCPGraphDataContainer.
  
  Graphs are used to display single-valued data. Single-valued means that there should only be one
  data point per unique key coordinate. In other words, the graph can't have \a loops. If you do
  want to plot non-single-valued curves, rather use the QCPCurve plottable.
  
  Gaps in the graph line can be created by adding data points with NaN as value
  (<tt>qQNaN()</tt> or <tt>std::numeric_limits<double>::quiet_NaN()</tt>) in between the two data points that shall be
  separated.
  
  \section qcpgraph-appearance Changing the appearance
  
  The appearance of the graph is mainly determined by the line style, scatter style, brush and pen
  of the graph (\ref setLineStyle, \ref setScatterStyle, \ref setBrush, \ref setPen).
  
  \subsection filling Filling under or between graphs
  
  QCPGraph knows two types of fills: Normal graph fills towards the zero-value-line parallel to
  the key axis of the graph, and fills between two graphs, called channel fills. To enable a fill,
  just set a brush with \ref setBrush which is neither Qt::NoBrush nor fully transparent.
  
  By default, a normal fill towards the zero-value-line will be drawn. To set up a channel fill
  between this graph and another one, call \ref setChannelFillGraph with the other graph as
  parameter.

  \see QCustomPlot::addGraph, QCustomPlot::graph
*/
/*! \ class QCPGraph
  \ brief 플롯에서 그래프를 나타내는 플롯 테이블.

  \ image html QCPGraph.png
  
  일반적으로 QCustomPlot :: addGraph를 호출하여 새 그래프를 만듭니다. 결과 인스턴스는
  QCustomPlot :: graph를 통해 액세스 할 수 있습니다.

  데이터를 플롯하려면 \ ref setData 또는 \ ref addData 함수로 지정하십시오. 또는
  \ ref 데이터 메서드를 통해 데이터에 액세스하고 수정합니다.이 메서드는 내부에 대한 포인터를 반환합니다.
  \ ref QCPGraphDataContainer.
  
  그래프는 단일 값 데이터를 표시하는 데 사용됩니다. 단일 값은 하나만 있어야 함을 의미합니다.
  고유 키 좌표 당 데이터 포인트. 즉, 그래프에는 \ a 루프가있을 수 없습니다. 네가 그렇게한다면
  단일 값이 아닌 곡선을 플롯하려면 QCP 커브 플롯을 사용하십시오.
  
  그래프 선의 틈은 NaN을 값으로하여 데이터 요소를 추가하여 만들 수 있습니다.
  두 데이터 포인트 사이에 (<tt> qQNaN () </ tt> 또는 <tt> std :: numeric_limits <double> :: quiet_NaN () </ tt>)
  분리.
  
  \ section qcpgraph-appearance 외관 변경하기
  
  그래프의 모양은 주로 선 스타일, 분산 형 스타일, 브러시 및 펜에 의해 결정됩니다
  그래프의 (\ ref setLineStyle, \ ref setScatterStyle, \ ref setBrush, \ ref setPen).
  
  \ subsection 채우기 그래프 아래 또는 사이에 채우기
  
  QCPGraph는 두 가지 유형의 채우기를 알고 있습니다. 일반 그래프는 평행선에 0 값선을 채 웁니다.
  그래프의 핵심 축이며 채널 채우기라는 두 그래프 사이를 채 웁니다. 채우기를 사용하려면,
  Qt :: NoBrush가 아니거나 완전히 투명하지 않은 \ ref setBrush를 사용하여 브러시를 설정하면됩니다.
  
  기본적으로 0 값 라인에 대한 정상 채우기가 그려집니다. 채널 채우기를 설정하려면
  이 그래프와 다른 그래프 사이에서 \ ref setChannelFillGraph를 다른 그래프와 같이 호출하십시오.
  매개 변수.

  \ QCustomPlot :: addGraph, QCustomPlot :: graph를 참조하십시오.
*/

/* start of documentation of inline functions */
/* 인라인 함수의 문서화 시작 */

/*! \fn QSharedPointer<QCPGraphDataContainer> QCPGraph::data() const
  
  Returns a shared pointer to the internal data storage of type \ref QCPGraphDataContainer. You may
  use it to directly manipulate the data, which may be more convenient and faster than using the
  regular \ref setData or \ref addData methods.
*/
/*! \ fn QSharedPointer <QCPGraphDataContainer> QCPGraph :: data () const
  
  \ ref QCPGraphDataContainer 유형의 내부 데이터 저장소에 대한 공유 포인터를 반환합니다. 당신은 할 수있다
  그것을 사용하여 데이터를 직접 조작하십시오. 이는 데이터를 사용하는 것보다 더 편리하고 빠릅니다.
  정규 \ ref setData 또는 \ ref addData 메소드.
*/

/* end of documentation of inline functions */
/* 인라인 함수의 문서 끝 */

/*!
  Constructs a graph which uses \a keyAxis as its key axis ("x") and \a valueAxis as its value
  axis ("y"). \a keyAxis and \a valueAxis must reside in the same QCustomPlot instance and not have
  the same orientation. If either of these restrictions is violated, a corresponding message is
  printed to the debug output (qDebug), the construction is not aborted, though.
  
  The created QCPGraph is automatically registered with the QCustomPlot instance inferred from \a
  keyAxis. This QCustomPlot instance takes ownership of the QCPGraph, so do not delete it manually
  but use QCustomPlot::removePlottable() instead.
  
  To directly create a graph inside a plot, you can also use the simpler QCustomPlot::addGraph function.
*/
/*!
  \ keyAxis를 열쇠 축 ( "x")으로서 사용해, 값으로서 \ valueAxis를 값으로서 사용하는 그래프를 작성합니다.
  축 ( "y"). \ a keyAxis 및 \ a valueAxis는 동일한 QCustomPlot 인스턴스에 있어야하며
  같은 방향. 이러한 제한 사항 중 하나라도 위반하면 해당 메시지가 다음과 같습니다.
  디버그 출력 (qDebug)에 인쇄되면, 구성은 중단되지 않습니다.
  
  생성 된 QCPGraph는 \ a에서 유추 한 QCustomPlot 인스턴스에 자동으로 등록됩니다.
  keyAxis. 이 QCustomPlot 인스턴스는 QCPGraph의 소유권을 가지므로 수동으로 삭제하지 마십시오.
  QCustomPlot :: removePlottable ()을 대신 사용하십시오.
  
  플롯 내에서 직접 그래프를 만들려면 더 간단한 QCustomPlot :: addGraph 함수를 사용할 수도 있습니다.
*/
QCPGraph::QCPGraph(QCPAxis *keyAxis, QCPAxis *valueAxis) :
  QCPAbstractPlottable1D<QCPGraphData>(keyAxis, valueAxis)
{
  // special handling for QCPGraphs to maintain the simple graph interface:
  // 간단한 그래프 인터페이스를 유지하기위한 QCPGraphs를위한 특별한 처리 :
  mParentPlot->registerGraph(this);

  setPen(QPen(Qt::blue, 0));
  setBrush(Qt::NoBrush);
  
  setLineStyle(lsLine);
  setScatterSkip(0);
  setChannelFillGraph(0);
  setAdaptiveSampling(true);
}

QCPGraph::~QCPGraph()
{
}

/*! \overload
  
  Replaces the current data container with the provided \a data container.
  
  Since a QSharedPointer is used, multiple QCPGraphs may share the same data container safely.
  Modifying the data in the container will then affect all graphs that share the container. Sharing
  can be achieved by simply exchanging the data containers wrapped in shared pointers:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpgraph-datasharing-1
  
  If you do not wish to share containers, but create a copy from an existing container, rather use
  the \ref QCPDataContainer<DataType>::set method on the graph's data container directly:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpgraph-datasharing-2
  
  \see addData
*/
/*! \초과 적재
  
  현재 데이터 컨테이너를 제공된 \ 데이터 컨테이너로 바꿉니다.
  
  QSharedPointer가 사용되기 때문에 여러 QCPGraph가 동일한 데이터 컨테이너를 안전하게 공유 할 수 있습니다.
  컨테이너의 데이터를 수정하면 컨테이너를 공유하는 모든 그래프에 영향을 미칩니다. 나누는
  공유 포인터에 랩핑 된 데이터 컨테이너를 단순히 교환하여 얻을 수 있습니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpgraph-datasharing-1
  
  컨테이너를 공유하지 않고 기존 컨테이너에서 사본을 만들려면
  그래프의 데이터 컨테이너에서 \ ref QCPDataContainer <DataType> :: set 메서드를 직접 호출합니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpgraph-datasharing-2
  
  \ addData를 참조하십시오.
*/
void QCPGraph::setData(QSharedPointer<QCPGraphDataContainer> data)
{
  mDataContainer = data;
}

/*! \overload
  
  Replaces the current data with the provided points in \a keys and \a values. The provided
  vectors should have equal length. Else, the number of added points will be the size of the
  smallest vector.
  
  If you can guarantee that the passed data points are sorted by \a keys in ascending order, you
  can set \a alreadySorted to true, to improve performance by saving a sorting run.
  
  \see addData
*/
/*! \초과 적재
  
  현재 데이터를 \ a 키와 \ a 값의 제공된 점으로 바꿉니다. 제공된
  벡터의 길이는 동일해야합니다. 그렇지 않으면 추가 된 포인트의 수는
  가장 작은 벡터.
  
  전달 된 데이터 요소가 \ a 키에 따라 오름차순으로 정렬되도록 보장 할 수 있으면
  정렬 실행을 저장하여 성능을 향상 시키려면 \ a alreadySorted를 true로 설정할 수 있습니다.
  
  \ addData를 참조하십시오.
*/
void QCPGraph::setData(const QVector<double> &keys, const QVector<double> &values, bool alreadySorted)
{
  mDataContainer->clear();
  addData(keys, values, alreadySorted);
}

/*!
  Sets how the single data points are connected in the plot. For scatter-only plots, set \a ls to
  \ref lsNone and \ref setScatterStyle to the desired scatter style.
  
  \see setScatterStyle
*/
/*!
  플롯에서 단일 데이터 점의 연결 방법을 설정합니다. 산점 전용 플롯의 경우 \ a ls를로 설정합니다.
  \ ref lsNone 및 \ ref setScatterStyle을 원하는 분산 스타일로 설정하십시오.
  
  \ setScatterStyle 참조
*/
void QCPGraph::setLineStyle(LineStyle ls)
{
  mLineStyle = ls;
}

/*!
  Sets the visual appearance of single data points in the plot. If set to \ref QCPScatterStyle::ssNone, no scatter points
  are drawn (e.g. for line-only-plots with appropriate line style).
  
  \see QCPScatterStyle, setLineStyle
*/
/*!
  플롯에서 단일 데이터 요소의 시각적 모양을 설정합니다. \ ref QCPScatterStyle :: ssNone으로 설정하면 분산 점이 없습니다.
  (예 : 적절한 선 스타일의 선 전용 플롯의 경우).
  
  \ QCPScatterStyle, setLineStyle 참조
*/
void QCPGraph::setScatterStyle(const QCPScatterStyle &style)
{
  mScatterStyle = style;
}

/*!
  If scatters are displayed (scatter style not \ref QCPScatterStyle::ssNone), \a skip number of
  scatter points are skipped/not drawn after every drawn scatter point.

  This can be used to make the data appear sparser while for example still having a smooth line,
  and to improve performance for very high density plots.

  If \a skip is set to 0 (default), all scatter points are drawn.

  \see setScatterStyle
*/
/*!
  산포가 표시되면 (산산이 스타일은 \ ref QCPScatterStyle :: ssNone이 아님) \ skip number of
  그려진 모든 스 캐터 지점 이후에 스 캐터 지점은 건너 뛰거나 그려지지 않습니다.

  이것은 예를 들어 여전히 부드러운 선을 가지고있는 동안 데이터를 더 드문 드문하게 보이게하는 데 사용될 수 있습니다.
  매우 높은 밀도 플롯의 성능을 향상시킬 수 있습니다.

  \ a skip이 0 (기본값)으로 설정되면 모든 분산 점이 그려집니다.

  \ setScatterStyle 참조
*/
void QCPGraph::setScatterSkip(int skip)
{
  mScatterSkip = qMax(0, skip);
}

/*!
  Sets the target graph for filling the area between this graph and \a targetGraph with the current
  brush (\ref setBrush).
  
  When \a targetGraph is set to 0, a normal graph fill to the zero-value-line will be shown. To
  disable any filling, set the brush to Qt::NoBrush.

  \see setBrush
*/
/*!
  이 그래프와 \ targetGraph의 사이의 영역을 현재의 것으로 채우도록 (듯이) 타겟 그래프를 설정합니다.
  브러쉬 (\ ref setBrush).
  
  \ targetGraph가 0으로 설정되면, 0 값 라인에 대한 정상적인 그래프 채우기가 표시됩니다. 에
  채우기를 해제하고 브러쉬를 Qt :: NoBrush로 설정하십시오.

  \ setBrush를 참조하십시오.
*/
void QCPGraph::setChannelFillGraph(QCPGraph *targetGraph)
{
  // prevent setting channel target to this graph itself:
  //이 그래프 자체에 채널 타겟을 설정하는 것을 막는다 :
  if (targetGraph == this)
  {
    qDebug() << Q_FUNC_INFO << "targetGraph is this graph itself";
    mChannelFillGraph = 0;
    return;
  }
  // prevent setting channel target to a graph not in the plot:
  // 채널 타겟을 플롯에없는 그래프로 설정하지 못하게합니다 :
  if (targetGraph && targetGraph->mParentPlot != mParentPlot)
  {
    qDebug() << Q_FUNC_INFO << "targetGraph not in same plot";
    mChannelFillGraph = 0;
    return;
  }
  
  mChannelFillGraph = targetGraph;
}

/*!
  Sets whether adaptive sampling shall be used when plotting this graph. QCustomPlot's adaptive
  sampling technique can drastically improve the replot performance for graphs with a larger number
  of points (e.g. above 10,000), without notably changing the appearance of the graph.
  
  By default, adaptive sampling is enabled. Even if enabled, QCustomPlot decides whether adaptive
  sampling shall actually be used on a per-graph basis. So leaving adaptive sampling enabled has no
  disadvantage in almost all cases.
  
  \image html adaptive-sampling-line.png "A line plot of 500,000 points without and with adaptive sampling"
  
  As can be seen, line plots experience no visual degradation from adaptive sampling. Outliers are
  reproduced reliably, as well as the overall shape of the data set. The replot time reduces
  dramatically though. This allows QCustomPlot to display large amounts of data in realtime.
  
  \image html adaptive-sampling-scatter.png "A scatter plot of 100,000 points without and with adaptive sampling"
  
  Care must be taken when using high-density scatter plots in combination with adaptive sampling.
  The adaptive sampling algorithm treats scatter plots more carefully than line plots which still
  gives a significant reduction of replot times, but not quite as much as for line plots. This is
  because scatter plots inherently need more data points to be preserved in order to still resemble
  the original, non-adaptive-sampling plot. As shown above, the results still aren't quite
  identical, as banding occurs for the outer data points. This is in fact intentional, such that
  the boundaries of the data cloud stay visible to the viewer. How strong the banding appears,
  depends on the point density, i.e. the number of points in the plot.
  
  For some situations with scatter plots it might thus be desirable to manually turn adaptive
  sampling off. For example, when saving the plot to disk. This can be achieved by setting \a
  enabled to false before issuing a command like \ref QCustomPlot::savePng, and setting \a enabled
  back to true afterwards.
*/
/*!
  이 그래프를 그릴 때 적응 형 샘플링을 사용할지 여부를 설정합니다. QCustomPlot의 적응 형
  샘플링 기술을 사용하면 더 큰 수의 그래프에 대한 복제 성능을 대폭 향상시킬 수 있습니다
  그래프의 모양을 눈에 띄게 변화시키지 않으면 서 점의 수 (예 : 10,000 개 이상).
  
  기본적으로 적응 형 샘플링이 활성화됩니다. 활성화 된 경우에도 QCustomPlot은 적응 형
  샘플링은 실제로 그래프 단위로 사용되어야한다. 따라서 적응 형 샘플링을 사용하도록 설정하면
  거의 모든 경우에서 단점.
  
  \ image html adaptive-sampling-line.png "적응 샘플링을 사용하지 않고 50 만 포인트의 라인 플롯"
  
  알 수 있듯이, 라인 플롯은 적응 형 샘플링으로 인한 시각적 저하를 경험하지 않습니다. 이상 치는
  데이터 세트의 전반적인 모양뿐만 아니라 신뢰성있게 재현됩니다. replot 시간이 줄어 듭니다.
  극적으로. 이를 통해 QCustomPlot은 대량의 데이터를 실시간으로 표시 할 수 있습니다.
  
  \ image html adaptive-sampling-scatter.png "적응 샘플링없이 100,000 포인트의 산점도"
  
  적응 형 샘플링과 함께 고밀도 산점도를 사용하는 경우주의를 기울여야합니다.
  적응 형 샘플링 알고리즘은 스 캐터 플롯을 여전히 라인 플롯보다 취급합니다
  replot time의 상당한 감소를 가져다 주지만 라인 플롯의 경우 만큼은 아닙니다. 이것은
  스 캐터 플롯은 본질적으로 여전히 유사하게 유지하기 위해 더 많은 데이터 요소를 필요로하기 때문에
  원래의 비 적응 샘플링 플롯. 위와 같이 결과는 여전히
  동일하게, 바깥 쪽 데이터 점에 밴딩이 발생합니다. 사실 이것은 의도적 인 것이므로
  데이터 클라우드의 경계가 뷰어에 계속 표시됩니다. 밴딩이 얼마나 강한 지,
  점 밀도, 즉 플롯의 점 수에 따라 달라집니다.
  
  분산 형 플롯을 사용하는 상황에서 수동으로 적응 형
  샘플 오프. 예를 들어, 플롯을 디스크에 저장할 때. \ a를 설정하면됩니다.
  \ ref QCustomPlot :: savePng와 같은 명령을 실행하기 전에 false로 설정하고 \ a를 설정
  나중에 다시 true로.
*/
void QCPGraph::setAdaptiveSampling(bool enabled)
{
  mAdaptiveSampling = enabled;
}

/*! \overload
  
  Adds the provided points in \a keys and \a values to the current data. The provided vectors
  should have equal length. Else, the number of added points will be the size of the smallest
  vector.
  
  If you can guarantee that the passed data points are sorted by \a keys in ascending order, you
  can set \a alreadySorted to true, to improve performance by saving a sorting run.
  
  Alternatively, you can also access and modify the data directly via the \ref data method, which
  returns a pointer to the internal data container.
*/
/*! \초과 적재
  
  \ a 키와 \ a 값에 제공된 점을 현재 데이터에 추가합니다. 제공된 벡터
  길이가 같아야합니다. 그렇지 않으면 추가 된 포인트의 수는 가장 작은 것의 크기가됩니다.
  벡터.
  
  전달 된 데이터 요소가 \ a 키에 따라 오름차순으로 정렬되도록 보장 할 수 있으면
  정렬 실행을 저장하여 성능을 향상 시키려면 \ a alreadySorted를 true로 설정할 수 있습니다.
  
  또는 \ ref 데이터 메서드를 통해 직접 데이터에 액세스하고 수정할 수도 있습니다.
  내부 데이터 컨테이너에 대한 포인터를 반환합니다.
*/
void QCPGraph::addData(const QVector<double> &keys, const QVector<double> &values, bool alreadySorted)
{
  if (keys.size() != values.size())
    qDebug() << Q_FUNC_INFO << "keys and values have different sizes:" << keys.size() << values.size();
  const int n = qMin(keys.size(), values.size());
  QVector<QCPGraphData> tempData(n);
  QVector<QCPGraphData>::iterator it = tempData.begin();
  const QVector<QCPGraphData>::iterator itEnd = tempData.end();
  int i = 0;
  while (it != itEnd)
  {
    it->key = keys[i];
    it->value = values[i];
    ++it;
    ++i;
  }
  mDataContainer->add(tempData, alreadySorted); 
// don't modify tempData beyond this to prevent copy on write
// 복사시 쓰기를 방지하기 위해 tempData를이 값 이상으로 수정하지 마십시오.
}

/*! \overload
  
  Adds the provided data point as \a key and \a value to the current data.
  
  Alternatively, you can also access and modify the data directly via the \ref data method, which
  returns a pointer to the internal data container.
*/
/*! \초과 적재
  
  제공된 데이터 요소를 \ 키와 \ 값을 현재 데이터에 추가합니다.
  
  또는 \ ref 데이터 메서드를 통해 직접 데이터에 액세스하고 수정할 수도 있습니다.
  내부 데이터 컨테이너에 대한 포인터를 반환합니다.
*/
void QCPGraph::addData(double key, double value)
{
  mDataContainer->add(QCPGraphData(key, value));
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPGraph::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())
    return -1;
  if (!mKeyAxis || !mValueAxis)
    return -1;
  
  if (mKeyAxis.data()->axisRect()->rect().contains(pos.toPoint()))
  {
    QCPGraphDataContainer::const_iterator closestDataPoint = mDataContainer->constEnd();
    double result = pointDistance(pos, closestDataPoint);
    if (details)
    {
      int pointIndex = closestDataPoint-mDataContainer->constBegin();
      details->setValue(QCPDataSelection(QCPDataRange(pointIndex, pointIndex+1)));
    }
    return result;
  } else
    return -1;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPRange QCPGraph::getKeyRange(bool &foundRange, QCP::SignDomain inSignDomain) const
{
  return mDataContainer->keyRange(foundRange, inSignDomain);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPRange QCPGraph::getValueRange(bool &foundRange, QCP::SignDomain inSignDomain, const QCPRange &inKeyRange) const
{
  return mDataContainer->valueRange(foundRange, inSignDomain, inKeyRange);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPGraph::draw(QCPPainter *painter)
{
  if (!mKeyAxis || !mValueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
  if (mKeyAxis.data()->range().size() <= 0 || mDataContainer->isEmpty()) return;
  if (mLineStyle == lsNone && mScatterStyle.isNone()) return;
  
  QVector<QPointF> lines, scatters; 
// line and (if necessary) scatter pixel coordinates will be stored here while iterating over segments
// 선과 (필요한 경우) 산란 픽셀 좌표는 세그먼트를 반복하는 동안 여기에 저장됩니다.
  
  // loop over and draw segments of unselected/selected data:
  // 선택되지 않은 / 선택한 데이터의 세그먼트를 반복 및 그립니다.
  QList<QCPDataRange> selectedSegments, unselectedSegments, allSegments;
  getDataSegments(selectedSegments, unselectedSegments);
  allSegments << unselectedSegments << selectedSegments;
  for (int i=0; i<allSegments.size(); ++i)
  {
    bool isSelectedSegment = i >= unselectedSegments.size();
    // get line pixel points appropriate to line style:
    // 선 스타일에 적합한 선 픽셀 점을 얻습니다.
    QCPDataRange lineDataRange = isSelectedSegment ? allSegments.at(i) : allSegments.at(i).adjusted(-1, 1); // unselected segments extend lines to bordering selected data point (safe to exceed total data bounds in first/last segment, getLines takes care)
// 선택되지 않은 선분이 선을 선택된 데이터 점을 경계로 확장합니다 (첫 번째 / 마지막 선분에서 전체 데이터 경계를 초과하지 않도록 안전하며 getLines가주의를 기울입니다)
    getLines(&lines, lineDataRange);
    
    // check data validity if flag set:
    // 플래그가 설정된 경우 데이터 유효성을 검사합니다.
#ifdef QCUSTOMPLOT_CHECK_DATA
    QCPGraphDataContainer::const_iterator it;
    for (it = mDataContainer->constBegin(); it != mDataContainer->constEnd(); ++it)
    {
      if (QCP::isInvalidData(it->key, it->value))
        qDebug() << Q_FUNC_INFO << "Data point at" << it->key << "invalid." << "Plottable name:" << name();
    }
#endif
    
    // draw fill of graph:
    // 그래프 채우기 :
    if (isSelectedSegment && mSelectionDecorator)
      mSelectionDecorator->applyBrush(painter);
    else
      painter->setBrush(mBrush);
    painter->setPen(Qt::NoPen);
    drawFill(painter, &lines);
    
    // draw line:
    // 선 그리기 :
    if (mLineStyle != lsNone)
    {
      if (isSelectedSegment && mSelectionDecorator)
        mSelectionDecorator->applyPen(painter);
      else
        painter->setPen(mPen);
      painter->setBrush(Qt::NoBrush);
      if (mLineStyle == lsImpulse)
        drawImpulsePlot(painter, lines);
      else
        drawLinePlot(painter, lines); // also step plots can be drawn as a line plot
                                      // 또한 스텝 플롯을 선 플롯으로 그릴 수 있습니다.
    }
    
    // draw scatters:
    // 흩어지는 부분을 그립니다.
    QCPScatterStyle finalScatterStyle = mScatterStyle;
    if (isSelectedSegment && mSelectionDecorator)
      finalScatterStyle = mSelectionDecorator->getFinalScatterStyle(mScatterStyle);
    if (!finalScatterStyle.isNone())
    {
      getScatters(&scatters, allSegments.at(i));
      drawScatterPlot(painter, scatters, finalScatterStyle);
    }
  }
  
  // draw other selection decoration that isn't just line/scatter pens and brushes:
  // 선 / 산란 펜 및 브러쉬가 아닌 다른 선택 장식을 그립니다.
  if (mSelectionDecorator)
    mSelectionDecorator->drawDecoration(painter, selection());
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPGraph::drawLegendIcon(QCPPainter *painter, const QRectF &rect) const
{
  // draw fill:
  // 채우기 :
  if (mBrush.style() != Qt::NoBrush)
  {
    applyFillAntialiasingHint(painter);
    painter->fillRect(QRectF(rect.left(), rect.top()+rect.height()/2.0, rect.width(), rect.height()/3.0), mBrush);
  }
  // draw line vertically centered:
  // 수직으로 선을 그립니다.
  if (mLineStyle != lsNone)
  {
    applyDefaultAntialiasingHint(painter);
    painter->setPen(mPen);
    painter->drawLine(QLineF(rect.left(), rect.top()+rect.height()/2.0, rect.right()+5, rect.top()+rect.height()/2.0)); // +5 on x2 else last segment is missing from dashed/dotted pens
          // x5에 +5 다른 끝 점이 점선 / 점선 펜에서 누락되었습니다.
  }
  // draw scatter symbol:
  // 스 캐터 기호를 그립니다.
  if (!mScatterStyle.isNone())
  {
    applyScattersAntialiasingHint(painter);
    // scale scatter pixmap if it's too large to fit in legend icon rect:
    // 범람 pixmap이 너무 커서 범례 아이콘에 맞출 수없는 경우 rect rect :
    if (mScatterStyle.shape() == QCPScatterStyle::ssPixmap && (mScatterStyle.pixmap().size().width() > rect.width() || mScatterStyle.pixmap().size().height() > rect.height()))
    {
      QCPScatterStyle scaledStyle(mScatterStyle);
      scaledStyle.setPixmap(scaledStyle.pixmap().scaled(rect.size().toSize(), Qt::KeepAspectRatio, Qt::SmoothTransformation));
      scaledStyle.applyTo(painter, mPen);
      scaledStyle.drawShape(painter, QRectF(rect).center());
    } else
    {
      mScatterStyle.applyTo(painter, mPen);
      mScatterStyle.drawShape(painter, QRectF(rect).center());
    }
  }
}

/*! \internal

  This method retrieves an optimized set of data points via \ref getOptimizedLineData, an branches
  out to the line style specific functions such as \ref dataToLines, \ref dataToStepLeftLines, etc.
  according to the line style of the graph.

  \a lines will be filled with points in pixel coordinates, that can be drawn with the according
  draw functions like \ref drawLinePlot and \ref drawImpulsePlot. The points returned in \a lines
  aren't necessarily the original data points. For example, step line styles require additional
  points to form the steps when drawn. If the line style of the graph is \ref lsNone, the \a
  lines vector will be empty.

  \a dataRange specifies the beginning and ending data indices that will be taken into account for
  conversion. In this function, the specified range may exceed the total data bounds without harm:
  a correspondingly trimmed data range will be used. This takes the burden off the user of this
  function to check for valid indices in \a dataRange, e.g. when extending ranges coming from \ref
  getDataSegments.

  \see getScatters
*/
/*! \내부의

  이 메소드는 \ ref getOptimizedLineData, 분기를 통해 최적화 된 데이터 요소 세트를 검색합니다.
  \ ref dataToLines, \ ref dataToStepLeftLines 등과 같은 라인 스타일의 특정 함수에 출력합니다.
  그래프의 선 스타일에 따라

  \ a 라인은 픽셀 좌표로 점으로 채워지며,
  \ ref drawLinePlot 및 \ ref drawImpulsePlot과 같은 함수를 그립니다. \ a 라인에서 반환 된 포인트
  반드시 원본 데이터 포인트 일 필요는 없습니다. 예를 들어, 스텝 선 스타일은 추가 필요합니다.
  그려 질 때 단계를 형성하는 점. 그래프의 선 스타일이 \ ref lsNone이면 \ a
  lines 벡터는 비어 있습니다.

  \ dataRange는 시작과 끝 데이터 인덱스를 지정합니다.
  변환. 이 함수에서 지정된 범위는 피해없이 총 데이터 범위를 초과 할 수 있습니다.
  해당 트리밍 된 데이터 범위가 사용됩니다. 이것은 사용자의 부담을 덜어줍니다.
  \ dataRange에서 유효한 인덱스를 검사하는 함수. 예를 들어 \ ref에서 오는 범위를 확장 할 때
  getDataSegments.

  \ see getScatters
*/
void QCPGraph::getLines(QVector<QPointF> *lines, const QCPDataRange &dataRange) const
{
  if (!lines) return;
  QCPGraphDataContainer::const_iterator begin, end;
  getVisibleDataBounds(begin, end, dataRange);
  if (begin == end)
  {
    lines->clear();
    return;
  }
  
  QVector<QCPGraphData> lineData;
  if (mLineStyle != lsNone)
    getOptimizedLineData(&lineData, begin, end);
  
  if (mKeyAxis->rangeReversed() != (mKeyAxis->orientation() == Qt::Vertical)) 
// make sure key pixels are sorted ascending in lineData (significantly simplifies following processing)
// 키 픽셀이 lineData에서 오름차순으로 정렬되어 있는지 확인하십시오 (처리 과정이 크게 단순화됩니다)
    std::reverse(lineData.begin(), lineData.end());

  switch (mLineStyle)
  {
    case lsNone: lines->clear(); break;
    case lsLine: *lines = dataToLines(lineData); break;
    case lsStepLeft: *lines = dataToStepLeftLines(lineData); break;
    case lsStepRight: *lines = dataToStepRightLines(lineData); break;
    case lsStepCenter: *lines = dataToStepCenterLines(lineData); break;
    case lsImpulse: *lines = dataToImpulseLines(lineData); break;
  }
}

/*! \internal

  This method retrieves an optimized set of data points via \ref getOptimizedScatterData and then
  converts them to pixel coordinates. The resulting points are returned in \a scatters, and can be
  passed to \ref drawScatterPlot.

  \a dataRange specifies the beginning and ending data indices that will be taken into account for
  conversion. In this function, the specified range may exceed the total data bounds without harm:
  a correspondingly trimmed data range will be used. This takes the burden off the user of this
  function to check for valid indices in \a dataRange, e.g. when extending ranges coming from \ref
  getDataSegments.
*/
/*! \내부의

  이 메소드는 \ ref getOptimizedScatterData를 통해 최적화 된 데이터 포인트 세트를 검색 한 다음
  픽셀 좌표로 변환합니다. 결과 포인트는 \ a 분산으로 반환되며
  \ ref drawScatterPlot에 전달됩니다.

  \ dataRange는 시작과 끝 데이터 인덱스를 지정합니다.
  변환. 이 함수에서 지정된 범위는 피해없이 총 데이터 범위를 초과 할 수 있습니다.
  해당 트리밍 된 데이터 범위가 사용됩니다. 이것은 사용자의 부담을 덜어줍니다.
  \ dataRange에서 유효한 인덱스를 검사하는 함수. 예를 들어 \ ref에서 오는 범위를 확장 할 때
  getDataSegments.
*/
void QCPGraph::getScatters(QVector<QPointF> *scatters, const QCPDataRange &dataRange) const
{
  if (!scatters) return;
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; scatters->clear(); return; }
  
  QCPGraphDataContainer::const_iterator begin, end;
  getVisibleDataBounds(begin, end, dataRange);
  if (begin == end)
  {
    scatters->clear();
    return;
  }
  
  QVector<QCPGraphData> data;
  getOptimizedScatterData(&data, begin, end);
  
  if (mKeyAxis->rangeReversed() != (mKeyAxis->orientation() == Qt::Vertical))
 // make sure key pixels are sorted ascending in data (significantly simplifies following processing)
 // 키 픽셀이 데이터에서 오름차순으로 정렬되는지 확인합니다 (처리 과정이 크게 단순화됩니다)
    std :: reverse (data.begin (), data.end ());
    std::reverse(data.begin(), data.end());
  
  scatters->resize(data.size());
  if (keyAxis->orientation() == Qt::Vertical)
  {
    for (int i=0; i<data.size(); ++i)
    {
      if (!qIsNaN(data.at(i).value))
      {
        (*scatters)[i].setX(valueAxis->coordToPixel(data.at(i).value));
        (*scatters)[i].setY(keyAxis->coordToPixel(data.at(i).key));
      }
    }
  } else
  {
    for (int i=0; i<data.size(); ++i)
    {
      if (!qIsNaN(data.at(i).value))
      {
        (*scatters)[i].setX(keyAxis->coordToPixel(data.at(i).key));
        (*scatters)[i].setY(valueAxis->coordToPixel(data.at(i).value));
      }
    }
  }
}

/*! \internal

  Takes raw data points in plot coordinates as \a data, and returns a vector containing pixel
  coordinate points which are suitable for drawing the line style \ref lsLine.
  
  The source of \a data is usually \ref getOptimizedLineData, and this method is called in \a
  getLines if the line style is set accordingly.

  \see dataToStepLeftLines, dataToStepRightLines, dataToStepCenterLines, dataToImpulseLines, getLines, drawLinePlot
*/
/*! \내부의

  플롯 좌표의 원시 데이터 점을 \ 데이터로 가져와 픽셀이 들어있는 벡터를 반환합니다.
  선 스타일 \ ref lsLine을 그리는 데 적합한 좌표 점.
  
  데이터의 소스는 일반적으로 \ ref getOptimizedLineData이며,이 메소드는 \ a에서 호출됩니다.
  그에 따라 선 스타일이 설정된 경우 getLines

  \ dataToStepLeftLines, dataToStepRightLines, dataToStepCenterLines, dataToImpulseLines, getLines, drawLinePlot를 참조하십시오.
*/
QVector<QPointF> QCPGraph::dataToLines(const QVector<QCPGraphData> &data) const
{
  QVector<QPointF> result;
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return result; }

  result.resize(data.size());
  
  // transform data points to pixels:
  // 데이터 포인트를 픽셀로 변환 :
  if (keyAxis->orientation() == Qt::Vertical)
  {
    for (int i=0; i<data.size(); ++i)
    {
      result[i].setX(valueAxis->coordToPixel(data.at(i).value));
      result[i].setY(keyAxis->coordToPixel(data.at(i).key));
    }
  } else // key axis is horizontal // 키 축은 수평입니다.
  {
    for (int i=0; i<data.size(); ++i)
    {
      result[i].setX(keyAxis->coordToPixel(data.at(i).key));
      result[i].setY(valueAxis->coordToPixel(data.at(i).value));
    }
  }
  return result;
}

/*! \internal

  Takes raw data points in plot coordinates as \a data, and returns a vector containing pixel
  coordinate points which are suitable for drawing the line style \ref lsStepLeft.
  
  The source of \a data is usually \ref getOptimizedLineData, and this method is called in \a
  getLines if the line style is set accordingly.

  \see dataToLines, dataToStepRightLines, dataToStepCenterLines, dataToImpulseLines, getLines, drawLinePlot
*/
/*! \내부의

  플롯 좌표의 원시 데이터 점을 \ 데이터로 가져와 픽셀이 들어있는 벡터를 반환합니다.
  선 스타일 \ ref lsStepLeft를 그리는 데 적합한 좌표 점.
  
  데이터의 소스는 일반적으로 \ ref getOptimizedLineData이며,이 메소드는 \ a에서 호출됩니다.
  그에 따라 선 스타일이 설정된 경우 getLines

  \ dataToLines, dataToStepRightLines, dataToStepCenterLines, dataToImpulseLines, getLines, drawLinePlot를 참조하십시오.
*/
QVector<QPointF> QCPGraph::dataToStepLeftLines(const QVector<QCPGraphData> &data) const
{
  QVector<QPointF> result;
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return result; }
  
  result.resize(data.size()*2);
  
  // calculate steps from data and transform to pixel coordinates:
  // 데이터에서 단계를 계산하고 픽셀 좌표로 변환 :
  if (keyAxis->orientation() == Qt::Vertical)
  {
    double lastValue = valueAxis->coordToPixel(data.first().value);
    for (int i=0; i<data.size(); ++i)
    {
      const double key = keyAxis->coordToPixel(data.at(i).key);
      result[i*2+0].setX(lastValue);
      result[i*2+0].setY(key);
      lastValue = valueAxis->coordToPixel(data.at(i).value);
      result[i*2+1].setX(lastValue);
      result[i*2+1].setY(key);
    }
  } else // key axis is horizontal // 키 축은 수평입니다.
  {
    double lastValue = valueAxis->coordToPixel(data.first().value);
    for (int i=0; i<data.size(); ++i)
    {
      const double key = keyAxis->coordToPixel(data.at(i).key);
      result[i*2+0].setX(key);
      result[i*2+0].setY(lastValue);
      lastValue = valueAxis->coordToPixel(data.at(i).value);
      result[i*2+1].setX(key);
      result[i*2+1].setY(lastValue);
    }
  }
  return result;
}

/*! \internal

  Takes raw data points in plot coordinates as \a data, and returns a vector containing pixel
  coordinate points which are suitable for drawing the line style \ref lsStepRight.
  
  The source of \a data is usually \ref getOptimizedLineData, and this method is called in \a
  getLines if the line style is set accordingly.

  \see dataToLines, dataToStepLeftLines, dataToStepCenterLines, dataToImpulseLines, getLines, drawLinePlot
*/
/*! \내부의

  플롯 좌표의 원시 데이터 점을 \ 데이터로 가져와 픽셀이 들어있는 벡터를 반환합니다.
  선 스타일 \ ref lsStepRight를 그리는 데 적합한 좌표 점.
  
  데이터의 소스는 일반적으로 \ ref getOptimizedLineData이며,이 메소드는 \ a에서 호출됩니다.
  그에 따라 선 스타일이 설정된 경우 getLines

  \ dataToLines, dataToStepLeftLines, dataToStepCenterLines, dataToImpulseLines, getLines, drawLinePlot를 참조하십시오.
*/
QVector<QPointF> QCPGraph::dataToStepRightLines(const QVector<QCPGraphData> &data) const
{
  QVector<QPointF> result;
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return result; }
  
  result.resize(data.size()*2);
  
  // calculate steps from data and transform to pixel coordinates:
  // 데이터에서 단계를 계산하고 픽셀 좌표로 변환 :
  if (keyAxis->orientation() == Qt::Vertical)
  {
    double lastKey = keyAxis->coordToPixel(data.first().key);
    for (int i=0; i<data.size(); ++i)
    {
      const double value = valueAxis->coordToPixel(data.at(i).value);
      result[i*2+0].setX(value);
      result[i*2+0].setY(lastKey);
      lastKey = keyAxis->coordToPixel(data.at(i).key);
      result[i*2+1].setX(value);
      result[i*2+1].setY(lastKey);
    }
  } else // key axis is horizontal // 키 축은 수평입니다.
  {
    double lastKey = keyAxis->coordToPixel(data.first().key);
    for (int i=0; i<data.size(); ++i)
    {
      const double value = valueAxis->coordToPixel(data.at(i).value);
      result[i*2+0].setX(lastKey);
      result[i*2+0].setY(value);
      lastKey = keyAxis->coordToPixel(data.at(i).key);
      result[i*2+1].setX(lastKey);
      result[i*2+1].setY(value);
    }
  }
  return result;
}

/*! \internal

  Takes raw data points in plot coordinates as \a data, and returns a vector containing pixel
  coordinate points which are suitable for drawing the line style \ref lsStepCenter.
  
  The source of \a data is usually \ref getOptimizedLineData, and this method is called in \a
  getLines if the line style is set accordingly.

  \see dataToLines, dataToStepLeftLines, dataToStepRightLines, dataToImpulseLines, getLines, drawLinePlot
*/
/*! \내부의

  플롯 좌표의 원시 데이터 점을 \ 데이터로 가져와 픽셀이 들어있는 벡터를 반환합니다.
  선 스타일 그리기에 적합한 좌표 점 \ ref lsStepCenter.
  
  데이터의 소스는 일반적으로 \ ref getOptimizedLineData이며,이 메소드는 \ a에서 호출됩니다.
  그에 따라 선 스타일이 설정된 경우 getLines

  \ dataToLines, dataToStepLeftLines, dataToStepRightLines, dataToImpulseLines, getLines, drawLinePlot를 참조하십시오.
*/
QVector<QPointF> QCPGraph::dataToStepCenterLines(const QVector<QCPGraphData> &data) const
{
  QVector<QPointF> result;
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return result; }
  
  result.resize(data.size()*2);
  
  // calculate steps from data and transform to pixel coordinates:
  // 데이터에서 단계를 계산하고 픽셀 좌표로 변환 :
  if (keyAxis->orientation() == Qt::Vertical)
  {
    double lastKey = keyAxis->coordToPixel(data.first().key);
    double lastValue = valueAxis->coordToPixel(data.first().value);
    result[0].setX(lastValue);
    result[0].setY(lastKey);
    for (int i=1; i<data.size(); ++i)
    {
      const double key = (keyAxis->coordToPixel(data.at(i).key)+lastKey)*0.5;
      result[i*2-1].setX(lastValue);
      result[i*2-1].setY(key);
      lastValue = valueAxis->coordToPixel(data.at(i).value);
      lastKey = keyAxis->coordToPixel(data.at(i).key);
      result[i*2+0].setX(lastValue);
      result[i*2+0].setY(key);
    }
    result[data.size()*2-1].setX(lastValue);
    result[data.size()*2-1].setY(lastKey);
  } else // key axis is horizontal // 키 축은 수평입니다.
  {
    double lastKey = keyAxis->coordToPixel(data.first().key);
    double lastValue = valueAxis->coordToPixel(data.first().value);
    result[0].setX(lastKey);
    result[0].setY(lastValue);
    for (int i=1; i<data.size(); ++i)
    {
      const double key = (keyAxis->coordToPixel(data.at(i).key)+lastKey)*0.5;
      result[i*2-1].setX(key);
      result[i*2-1].setY(lastValue);
      lastValue = valueAxis->coordToPixel(data.at(i).value);
      lastKey = keyAxis->coordToPixel(data.at(i).key);
      result[i*2+0].setX(key);
      result[i*2+0].setY(lastValue);
    }
    result[data.size()*2-1].setX(lastKey);
    result[data.size()*2-1].setY(lastValue);
  }
  return result;
}

/*! \internal

  Takes raw data points in plot coordinates as \a data, and returns a vector containing pixel
  coordinate points which are suitable for drawing the line style \ref lsImpulse.
  
  The source of \a data is usually \ref getOptimizedLineData, and this method is called in \a
  getLines if the line style is set accordingly.

  \see dataToLines, dataToStepLeftLines, dataToStepRightLines, dataToStepCenterLines, getLines, drawImpulsePlot
*/
/*! \내부의

  플롯 좌표의 원시 데이터 점을 \ 데이터로 가져와 픽셀이 들어있는 벡터를 반환합니다.
  선 스타일 \ ref lsImpulse를 그리는 데 적합한 좌표 점.
  
  데이터의 소스는 일반적으로 \ ref getOptimizedLineData이며,이 메소드는 \ a에서 호출됩니다.
  그에 따라 선 스타일이 설정된 경우 getLines

  \ dataToLines, dataToStepLeftLines, dataToStepRightLines, dataToStepCenterLines, getLines, drawImpulsePlot를 참조하십시오.
*/
QVector<QPointF> QCPGraph::dataToImpulseLines(const QVector<QCPGraphData> &data) const
{
  QVector<QPointF> result;
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return result; }
  
  result.resize(data.size()*2);
  
  // transform data points to pixels:
  // 데이터 포인트를 픽셀로 변환 :
  if (keyAxis->orientation() == Qt::Vertical)
  {
    for (int i=0; i<data.size(); ++i)
    {
      const double key = keyAxis->coordToPixel(data.at(i).key);
      result[i*2+0].setX(valueAxis->coordToPixel(0));
      result[i*2+0].setY(key);
      result[i*2+1].setX(valueAxis->coordToPixel(data.at(i).value));
      result[i*2+1].setY(key);
    } 
  } else // key axis is horizontal // 키 축은 수평입니다.
  {
    for (int i=0; i<data.size(); ++i)
    {
      const double key = keyAxis->coordToPixel(data.at(i).key);
      result[i*2+0].setX(key);
      result[i*2+0].setY(valueAxis->coordToPixel(0));
      result[i*2+1].setX(key);
      result[i*2+1].setY(valueAxis->coordToPixel(data.at(i).value));
    }
  }
  return result;
}

/*! \internal
  
  Draws the fill of the graph using the specified \a painter, with the currently set brush.
  
  Depending on whether a normal fill or a channel fill (\ref setChannelFillGraph) is needed, \ref
  getFillPolygon or \ref getChannelFillPolygon are used to find the according fill polygons.
  
  In order to handle NaN Data points correctly (the fill needs to be split into disjoint areas),
  this method first determines a list of non-NaN segments with \ref getNonNanSegments, on which to
  operate. In the channel fill case, \ref getOverlappingSegments is used to consolidate the non-NaN
  segments of the two involved graphs, before passing the overlapping pairs to \ref
  getChannelFillPolygon.
  
  Pass the points of this graph's line as \a lines, in pixel coordinates.

  \see drawLinePlot, drawImpulsePlot, drawScatterPlot
*/
/*! \내부의
  
  지정된 \ a 페인터와 현재 설정된 브러시를 사용하여 그래프의 채우기를 그립니다.
  
  일반 채우기 또는 채널 채우기 (\ ref setChannelFillGraph)가 필요한지 여부에 따라 \ ref
  getFillPolygon 또는 \ ref getChannelFillPolygon은 채우기 폴리곤을 찾기 위해 사용됩니다.
  
  NaN 데이터 포인트를 올바르게 처리하려면 채우기를 연결되지 않은 영역으로 분할해야합니다.
  이 메소드는 먼저 \ ref getNonNanSegments가있는 NaN이 아닌 세그먼트의 목록을 결정합니다.
  작동합니다. 채널 채우기의 경우 \ ref getOverlappingSegments는 비 NaN을 통합하는 데 사용됩니다
  중첩 된 쌍을 \ ref에 전달하기 전에 관련된 두 그래프의 세그먼트
  getChannelFillPolygon.
  
  이 그래프 선의 점을 픽셀 좌표로 \ a 선으로 전달합니다.

  \ drawLinePlot, drawImpulsePlot, drawScatterPlot을 참조하십시오.
*/
void QCPGraph::drawFill(QCPPainter *painter, QVector<QPointF> *lines) const
{
  if (mLineStyle == lsImpulse) return; // fill doesn't make sense for impulse plot
                                       // 충동은 충동 계획에 이해가 가지 않습니다.
  if (painter->brush().style() == Qt::NoBrush || painter->brush().color().alpha() == 0) return;
  
  applyFillAntialiasingHint(painter);
  QVector<QCPDataRange> segments = getNonNanSegments(lines, keyAxis()->orientation());
  if (!mChannelFillGraph)
  {
    // draw base fill under graph, fill goes all the way to the zero-value-line:
    // 그래프 아래에 기본 칠을 그립니다. fill은 0 값 행까지 계속됩니다.
    for (int i=0; i<segments.size(); ++i)
      painter->drawPolygon(getFillPolygon(lines, segments.at(i)));
  } else
  {
    // draw fill between this graph and mChannelFillGraph:
    //이 그래프와 mChannelFillGraph 사이에 채우기를 그립니다.
    QVector<QPointF> otherLines;
    mChannelFillGraph->getLines(&otherLines, QCPDataRange(0, mChannelFillGraph->dataCount()));
    if (!otherLines.isEmpty())
    {
      QVector<QCPDataRange> otherSegments = getNonNanSegments(&otherLines, mChannelFillGraph->keyAxis()->orientation());
      QVector<QPair<QCPDataRange, QCPDataRange> > segmentPairs = getOverlappingSegments(segments, lines, otherSegments, &otherLines);
      for (int i=0; i<segmentPairs.size(); ++i)
        painter->drawPolygon(getChannelFillPolygon(lines, segmentPairs.at(i).first, &otherLines, segmentPairs.at(i).second));
    }
  }
}

/*! \internal

  Draws scatter symbols at every point passed in \a scatters, given in pixel coordinates. The
  scatters will be drawn with \a painter and have the appearance as specified in \a style.

  \see drawLinePlot, drawImpulsePlot
*/
/*! \내부의

  픽셀 좌표로 주어진, 분산 된 모든 점에 분산 형 기호를 그립니다. 그만큼
  뿌려 놓는 사람은 \ 화가와 함께 그려지며 \ 스타일로 지정된 모양을가집니다.

  \ drawLinePlot, drawImpulsePlot 참조
*/
void QCPGraph::drawScatterPlot(QCPPainter *painter, const QVector<QPointF> &scatters, const QCPScatterStyle &style) const
{
  applyScattersAntialiasingHint(painter);
  style.applyTo(painter, mPen);
  for (int i=0; i<scatters.size(); ++i)
    style.drawShape(painter, scatters.at(i).x(), scatters.at(i).y());
}

/*!  \internal
  
  Draws lines between the points in \a lines, given in pixel coordinates.
  
  \see drawScatterPlot, drawImpulsePlot, QCPAbstractPlottable1D::drawPolyline
*/
/*! \내부의
  
  픽셀 좌표로 주어진 점 사이의 선을 \ a 행에 그립니다.
  
  \ drawScatterPlot, drawImpulsePlot, QCPAbstractPlottable1D :: drawPolyline을 참조하십시오.
*/
void QCPGraph::drawLinePlot(QCPPainter *painter, const QVector<QPointF> &lines) const
{
  if (painter->pen().style() != Qt::NoPen && painter->pen().color().alpha() != 0)
  {
    applyDefaultAntialiasingHint(painter);
    drawPolyline(painter, lines);
  }
}

/*! \internal

  Draws impulses from the provided data, i.e. it connects all line pairs in \a lines, given in
  pixel coordinates. The \a lines necessary for impulses are generated by \ref dataToImpulseLines
  from the regular graph data points.

  \see drawLinePlot, drawScatterPlot
*/
/*! \내부의

  제공된 데이터로부터 충동을 뽑습니다. 즉, \ a 행의 모든 ​​행 쌍을 연결합니다.
  픽셀 좌표. 펄스에 필요한 \ a 라인은 \ ref dataToImpulseLines에 의해 생성됩니다.
  일반 그래프 데이터 포인트에서.

  \ drawLinePlot, drawScatterPlot 참조
*/
void QCPGraph::drawImpulsePlot(QCPPainter *painter, const QVector<QPointF> &lines) const
{
  if (painter->pen().style() != Qt::NoPen && painter->pen().color().alpha() != 0)
  {
    applyDefaultAntialiasingHint(painter);
    QPen oldPen = painter->pen();
    QPen newPen = painter->pen();
    newPen.setCapStyle(Qt::FlatCap); // so impulse line doesn't reach beyond zero-line
                                     // 그래서 임펄스 라인은 제로 라인을 넘어선 다.
    painter->setPen(newPen);
    painter->drawLines(lines);
    painter->setPen(oldPen);
  }
}

/*! \internal

  Returns via \a lineData the data points that need to be visualized for this graph when plotting
  graph lines, taking into consideration the currently visible axis ranges and, if \ref
  setAdaptiveSampling is enabled, local point densities. The considered data can be restricted
  further by \a begin and \a end, e.g. to only plot a certain segment of the data (see \ref
  getDataSegments).

  This method is used by \ref getLines to retrieve the basic working set of data.

  \see getOptimizedScatterData
*/
/*! \내부의

  플로팅 할 때이 그래프에 대해 시각화해야하는 데이터 요소를 \ lineData를 통해 반환합니다.
  그래프 라인, 현재 보이는 축 범위를 고려하고, \ ref
  setAdaptiveSampling가 유효 해, 로컬 포인트 밀도. 고려되는 데이터는 제한 될 수 있습니다.
  추가로 \ a begin과 \ end에 의해, 예를 들어 데이터의 특정 세그먼트 만 플롯 할 수 있습니다 (\ ref 참조).
  getDataSegments)를 호출합니다.

  이 메소드는 \ ref getLines에서 기본 작업 세트를 검색하는 데 사용됩니다.

  \ see getOptimizedScatterData
*/
void QCPGraph::getOptimizedLineData(QVector<QCPGraphData> *lineData, const QCPGraphDataContainer::const_iterator &begin, const QCPGraphDataContainer::const_iterator &end) const
{
  if (!lineData) return;
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
  if (begin == end) return;
  
  int dataCount = end-begin;
  int maxCount = std::numeric_limits<int>::max();
  if (mAdaptiveSampling)
  {
    double keyPixelSpan = qAbs(keyAxis->coordToPixel(begin->key)-keyAxis->coordToPixel((end-1)->key));
    if (2*keyPixelSpan+2 < (double)std::numeric_limits<int>::max())
      maxCount = 2*keyPixelSpan+2;
  }
  
  if (mAdaptiveSampling && dataCount >= maxCount) 
// use adaptive sampling only if there are at least two points per pixel on average
// 픽셀 당 최소 두 점이 평균 인 경우에만 적응 샘플링 사용
  {
    QCPGraphDataContainer::const_iterator it = begin;
    double minValue = it->value;
    double maxValue = it->value;
    QCPGraphDataContainer::const_iterator currentIntervalFirstPoint = it;
    int reversedFactor = keyAxis->pixelOrientation(); 
// is used to calculate keyEpsilon pixel into the correct direction
// 정확한 방향으로 keyEpsilon 픽셀을 계산하는 데 사용됩니다.
    int reversedRound = reversedFactor==-1 ? 1 : 0;
// is used to switch between floor (normal) and ceil (reversed) rounding of currentIntervalStartKey
// currentIntervalStartKey의 floor (normal)과 ceil (reversed) 반올림 사이를 전환하는 데 사용됩니다.
    double currentIntervalStartKey = keyAxis->pixelToCoord((int)(keyAxis->coordToPixel(begin->key)+reversedRound));
    double lastIntervalEndKey = currentIntervalStartKey;
    double keyEpsilon = qAbs(currentIntervalStartKey-keyAxis->pixelToCoord(keyAxis->coordToPixel(currentIntervalStartKey)+1.0*reversedFactor)); 
// interval of one pixel on screen when mapped to plot key coordinates
// 플롯 키 좌표에 매핑 될 때 화면상의 한 픽셀의 간격
    bool keyEpsilonVariable = keyAxis->scaleType() == QCPAxis::stLogarithmic; 
// indicates whether keyEpsilon needs to be updated after every interval (for log axes)
// 매 간격 후에 keyEpsilon을 업데이트해야하는지 여부를 나타냅니다 (로그 축에 대해).
    int intervalDataCount = 1;
    ++it; 
// advance iterator to second data point because adaptive sampling works in 1 point retrospect
// 적응 샘플링이 1 포인트 회상에서 작동하기 때문에 반복기를 두 번째 데이터 요소로 전진시킨다.
    while (it != end)
    {
      if (it->key < currentIntervalStartKey+keyEpsilon) 
// data point is still within same pixel, so skip it and expand value span of this cluster if necessary
// 데이터 포인트가 여전히 동일한 픽셀 내에 있으므로 생략하고이 클러스터의 값 범위를 확장합니다 (필요한 경우).
      {
        if (it->value < minValue)
          minValue = it->value;
        else if (it->value > maxValue)
          maxValue = it->value;
        ++intervalDataCount;
      } else // new pixel interval started // 새 픽셀 간격이 시작되었습니다.
      {
        if (intervalDataCount >= 2)
// last pixel had multiple data points, consolidate them to a cluster
// 마지막 픽셀에 여러 데이터 요소가있는 경우이를 클러스터에 통합
        {
          if (lastIntervalEndKey < currentIntervalStartKey-keyEpsilon) 
// last point is further away, so first point of this cluster must be at a real data point
// 마지막 포인트가 멀어 지므로이 클러스터의 첫 번째 포인트는 실제 데이터 포인트에 있어야합니다.
            lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.2, currentIntervalFirstPoint->value));
          lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.25, minValue));
          lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.75, maxValue));
          if (it->key > currentIntervalStartKey+keyEpsilon*2) // new pixel started further away from previous cluster, so make sure the last point of the cluster is at a real data point
 // 새 픽셀이 이전 클러스터에서 더 멀리 시작되었으므로 클러스터의 마지막 포인트가 실제 데이터 포인트에 있는지 확인하십시오
            lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.8, (it-1)->value));
        } else
          lineData->append(QCPGraphData(currentIntervalFirstPoint->key, currentIntervalFirstPoint->value));
        lastIntervalEndKey = (it-1)->key;
        minValue = it->value;
        maxValue = it->value;
        currentIntervalFirstPoint = it;
        currentIntervalStartKey = keyAxis->pixelToCoord((int)(keyAxis->coordToPixel(it->key)+reversedRound));
        if (keyEpsilonVariable)
          keyEpsilon = qAbs(currentIntervalStartKey-keyAxis->pixelToCoord(keyAxis->coordToPixel(currentIntervalStartKey)+1.0*reversedFactor));
        intervalDataCount = 1;
      }
      ++it;
    }
    // handle last interval:
    // 마지막 간격을 처리합니다.
    if (intervalDataCount >= 2) 
// last pixel had multiple data points, consolidate them to a cluster
// 마지막 픽셀에 여러 데이터 요소가있는 경우이를 클러스터에 통합
    {
      if (lastIntervalEndKey < currentIntervalStartKey-keyEpsilon) 
// last point wasn't a cluster, so first point of this cluster must be at a real data point
// 마지막 점이 클러스터가 아니므로이 클러스터의 첫 번째 점은 실제 데이터 점에 있어야합니다.
        lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.2, currentIntervalFirstPoint->value));
      lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.25, minValue));
      lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.75, maxValue));
    } else
      lineData->append(QCPGraphData(currentIntervalFirstPoint->key, currentIntervalFirstPoint->value));
    
  } else 
// don't use adaptive sampling algorithm, transfer points one-to-one from the data container into the output
// 적응 형 샘플링 알고리즘을 사용하지 않습니다. 데이터 컨테이너에서 출력으로 일대 일 전송 점을 사용합니다.
  {
    lineData->resize(dataCount);
    std::copy(begin, end, lineData->begin());
  }
}

/*! \internal

  Returns via \a scatterData the data points that need to be visualized for this graph when
  plotting scatter points, taking into consideration the currently visible axis ranges and, if \ref
  setAdaptiveSampling is enabled, local point densities. The considered data can be restricted
  further by \a begin and \a end, e.g. to only plot a certain segment of the data (see \ref
  getDataSegments).

  This method is used by \ref getScatters to retrieve the basic working set of data.

  \see getOptimizedLineData
*/
/*! \내부의

  scatterData를 통해이 그래프에 대해 시각화해야하는 데이터 포인트를 반환합니다.
  현재 보이는 축 범위를 고려하여 산점을 플롯하고, \ ref
  setAdaptiveSampling가 유효 해, 로컬 포인트 밀도. 고려되는 데이터는 제한 될 수 있습니다.
  추가로 \ a begin과 \ end에 의해, 예를 들어 데이터의 특정 세그먼트 만 플롯 할 수 있습니다 (\ ref 참조).
  getDataSegments)를 호출합니다.

  이 메소드는 \ ref getScatters가 기본 작업 세트를 검색하는 데 사용됩니다.

  \ see getOptimizedLineData
*/
void QCPGraph::getOptimizedScatterData(QVector<QCPGraphData> *scatterData, QCPGraphDataContainer::const_iterator begin, QCPGraphDataContainer::const_iterator end) const
{
  if (!scatterData) return;
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
  
  const int scatterModulo = mScatterSkip+1;
  const bool doScatterSkip = mScatterSkip > 0;
  int beginIndex = begin-mDataContainer->constBegin();
  int endIndex = end-mDataContainer->constBegin();
  while (doScatterSkip && begin != end && beginIndex % scatterModulo != 0) 
// advance begin iterator to first non-skipped scatter
// 건너 뛰기가없는 첫 번째 스 캐터로 이터레이터를 시작합니다.
  {
    ++beginIndex;
    ++begin;
  }
  if (begin == end) return;
  int dataCount = end-begin;
  int maxCount = std::numeric_limits<int>::max();
  if (mAdaptiveSampling)
  {
    int keyPixelSpan = qAbs(keyAxis->coordToPixel(begin->key)-keyAxis->coordToPixel((end-1)->key));
    maxCount = 2*keyPixelSpan+2;
  }
  
  if (mAdaptiveSampling && dataCount >= maxCount) 
// use adaptive sampling only if there are at least two points per pixel on average
// 픽셀 당 최소 두 점이 평균 인 경우에만 적응 샘플링 사용
  {
    double valueMaxRange = valueAxis->range().upper;
    double valueMinRange = valueAxis->range().lower;
    QCPGraphDataContainer::const_iterator it = begin;
    int itIndex = beginIndex;
    double minValue = it->value;
    double maxValue = it->value;
    QCPGraphDataContainer::const_iterator minValueIt = it;
    QCPGraphDataContainer::const_iterator maxValueIt = it;
    QCPGraphDataContainer::const_iterator currentIntervalStart = it;
    int reversedFactor = keyAxis->pixelOrientation();
// is used to calculate keyEpsilon pixel into the correct direction
// 정확한 방향으로 keyEpsilon 픽셀을 계산하는 데 사용됩니다.
    int reversedRound = reversedFactor==-1 ? 1 : 0; 
// is used to switch between floor (normal) and ceil (reversed) rounding of currentIntervalStartKey
//는 currentIntervalStartKey의 floor (normal)과 ceil (reversed) 반올림 사이를 전환하는 데 사용됩니다.
    double currentIntervalStartKey = keyAxis->pixelToCoord((int)(keyAxis->coordToPixel(begin->key)+reversedRound));
    double keyEpsilon = qAbs(currentIntervalStartKey-keyAxis->pixelToCoord(keyAxis->coordToPixel(currentIntervalStartKey)+1.0*reversedFactor)); 
// interval of one pixel on screen when mapped to plot key coordinates
// 플롯 키 좌표에 매핑 될 때 화면상의 한 픽셀의 간격
    bool keyEpsilonVariable = keyAxis->scaleType() == QCPAxis::stLogarithmic; 
// indicates whether keyEpsilon needs to be updated after every interval (for log axes)
// 매 간격 후에 keyEpsilon을 업데이트해야하는지 여부를 나타냅니다 (로그 축에 대해).
    int intervalDataCount = 1;
// advance iterator to second (non-skipped) data point because adaptive sampling works in 1 point retrospect:
// 적응 형 샘플링이 1 포인트 retrospect에서 작동하기 때문에 반복기를 두 번째 (건너 뛰지 않은) 데이터 포인트로 전진시킵니다.
    if (!doScatterSkip)
      ++it;
    else
    {
      itIndex += scatterModulo;
      if (itIndex < endIndex) // make sure we didn't jump over end // 끝까지 뛰어 넘지 않았는지 확인
        it += scatterModulo;
      else
      {
        it = end;
        itIndex = endIndex;
      }
    }
    // main loop over data points:
    // 데이터 포인트에 대한 메인 루프 :
    while (it != end)
    {
      if (it->key < currentIntervalStartKey+keyEpsilon) 
// data point is still within same pixel, so skip it and expand value span of this pixel if necessary
// 데이터 포인트가 여전히 동일한 픽셀 내에 있으므로 생략하고이 픽셀의 값 범위를 확장합니다 (필요한 경우).
      {
        if (it->value < minValue && it->value > valueMinRange && it->value < valueMaxRange)
        {
          minValue = it->value;
          minValueIt = it;
        } else if (it->value > maxValue && it->value > valueMinRange && it->value < valueMaxRange)
        {
          maxValue = it->value;
          maxValueIt = it;
        }
        ++intervalDataCount;
      } else // new pixel started   // 새 픽셀이 시작되었습니다.
      {
        if (intervalDataCount >= 2) // last pixel had multiple data points, consolidate them
                                    // 마지막 픽셀에 여러 데이터 요소가있는 경우이를 통합합니다.
        {
          // determine value pixel span and add as many points in interval to maintain certain vertical data density (this is specific to scatter plot):
// 값 픽셀 간격을 결정하고 일정한 수직 데이터 밀도를 유지하기 위해 간격에 많은 점을 추가합니다 (이는 산점도에 특정 적입니다).
          double valuePixelSpan = qAbs(valueAxis->coordToPixel(minValue)-valueAxis->coordToPixel(maxValue));
          int dataModulo = qMax(1, qRound(intervalDataCount/(valuePixelSpan/4.0))); 
// approximately every 4 value pixels one data point on average
// 평균적으로 하나의 데이터 포인트 당 약 4 개의 값 픽셀
          QCPGraphDataContainer::const_iterator intervalIt = currentIntervalStart;
          int c = 0;
          while (intervalIt != it)
          {
            if ((c % dataModulo == 0 || intervalIt == minValueIt || intervalIt == maxValueIt) && intervalIt->value > valueMinRange && intervalIt->value < valueMaxRange)
              scatterData->append(*intervalIt);
            ++c;
            if (!doScatterSkip)
              ++intervalIt;
            else
              intervalIt += scatterModulo; // since we know indices of "currentIntervalStart", "intervalIt" and "it" are multiples of scatterModulo, we can't accidentally jump over "it" here
// "currentIntervalStart", "intervalIt"및 "it"의 인덱스는 scatterModulo의 배수이므로 우연히 여기에서 "it"을 뛰어 넘을 수는 없습니다.
          }
        } else if (currentIntervalStart->value > valueMinRange && currentIntervalStart->value < valueMaxRange)
          scatterData->append(*currentIntervalStart);
        minValue = it->value;
        maxValue = it->value;
        currentIntervalStart = it;
        currentIntervalStartKey = keyAxis->pixelToCoord((int)(keyAxis->coordToPixel(it->key)+reversedRound));
        if (keyEpsilonVariable)
          keyEpsilon = qAbs(currentIntervalStartKey-keyAxis->pixelToCoord(keyAxis->coordToPixel(currentIntervalStartKey)+1.0*reversedFactor));
        intervalDataCount = 1;
      }
      // advance to next data point:
      // 다음 데이터 점으로 이동 :
      if (!doScatterSkip)
        ++it;
      else
      {
        itIndex += scatterModulo;
        if (itIndex < endIndex) // make sure we didn't jump over end  // 끝까지 뛰어 넘지 않았는지 확인
          it += scatterModulo;
        else
        {
          it = end;
          itIndex = endIndex;
        }
      }
    }
    // handle last interval:
    // 마지막 간격을 처리합니다.
    if (intervalDataCount >= 2) // last pixel had multiple data points, consolidate them
                                // 마지막 픽셀에 여러 데이터 요소가있는 경우이를 통합합니다.
    {
      // determine value pixel span and add as many points in interval to maintain certain vertical data density (this is specific to scatter plot):
 // 값 픽셀 간격을 결정하고 일정한 수직 데이터 밀도를 유지하기 위해 간격에 많은 점을 추가합니다 (이는 산점도에 특정 적입니다).
      double valuePixelSpan = qAbs(valueAxis->coordToPixel(minValue)-valueAxis->coordToPixel(maxValue));
      int dataModulo = qMax(1, qRound(intervalDataCount/(valuePixelSpan/4.0)));
// approximately every 4 value pixels one data point on average
// 평균적으로 하나의 데이터 포인트 당 약 4 개의 값 픽셀
      QCPGraphDataContainer::const_iterator intervalIt = currentIntervalStart;
      int intervalItIndex = intervalIt-mDataContainer->constBegin();
      int c = 0;
      while (intervalIt != it)
      {
        if ((c % dataModulo == 0 || intervalIt == minValueIt || intervalIt == maxValueIt) && intervalIt->value > valueMinRange && intervalIt->value < valueMaxRange)
          scatterData->append(*intervalIt);
        ++c;
        if (!doScatterSkip)
          ++intervalIt;
        else // here we can't guarantee that adding scatterModulo doesn't exceed "it" (because "it" is equal to "end" here, and "end" isn't scatterModulo-aligned), so check via index comparison:
 // 여기에서는 "it"이 "end"와 같고 "end"가 scatterModulo로 정렬되지 않았기 때문에 scatterModulo를 추가하는 것이 "it"을 초과하지 않는다고 보장 할 수 없으므로 인덱스 비교를 통해 확인하십시오.
        {
          intervalItIndex += scatterModulo;
          if (intervalItIndex < itIndex)
            intervalIt += scatterModulo;
          else
          {
            intervalIt = it;
            intervalItIndex = itIndex;
          }
        }
      }
    } else if (currentIntervalStart->value > valueMinRange && currentIntervalStart->value < valueMaxRange)
      scatterData->append(*currentIntervalStart);
    
  } else // don't use adaptive sampling algorithm, transfer points one-to-one from the data container into the output
         // 적응 형 샘플링 알고리즘을 사용하지 않습니다. 데이터 컨테이너에서 출력으로 일대 일 전송 점을 사용합니다.
  {
    QCPGraphDataContainer::const_iterator it = begin;
    int itIndex = beginIndex;
    scatterData->reserve(dataCount);
    while (it != end)
    {
      scatterData->append(*it);
      // advance to next data point:
      // 다음 데이터 점으로 이동 :
      if (!doScatterSkip)
        ++it;
      else
      {
        itIndex += scatterModulo;
        if (itIndex < endIndex)
          it += scatterModulo;
        else
        {
          it = end;
          itIndex = endIndex;
        }
      }
    }
  }
}

/*!
  This method outputs the currently visible data range via \a begin and \a end. The returned range
  will also never exceed \a rangeRestriction.

  This method takes into account that the drawing of data lines at the axis rect border always
  requires the points just outside the visible axis range. So \a begin and \a end may actually
  indicate a range that contains one additional data point to the left and right of the visible
  axis range.
*/
/*!
  이 메서드는 \ a begin과 \ a end를 통해 현재 보이는 데이터 범위를 출력합니다. 반환 된 범위
  \ rangeRestriction을 초과하지 않습니다.

  이 방법은 축 rect 경계에서 항상 데이터 선을 그리는 작업을 고려합니다.
  보이는 축 범위 밖에있는 점이 필요합니다. 그래서 \ begin과 \ end는 실제로
  보이는 것의 왼쪽과 오른쪽에 하나의 추가 데이터 포인트를 포함하는 범위를 나타냅니다.
  축 범위.
*/
void QCPGraph::getVisibleDataBounds(QCPGraphDataContainer::const_iterator &begin, QCPGraphDataContainer::const_iterator &end, const QCPDataRange &rangeRestriction) const
{
  if (rangeRestriction.isEmpty())
  {
    end = mDataContainer->constEnd();
    begin = end;
  } else
  {
    QCPAxis *keyAxis = mKeyAxis.data();
    QCPAxis *valueAxis = mValueAxis.data();
    if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
    // get visible data range:
    // 표시되는 데이터 범위 가져 오기 :
    begin = mDataContainer->findBegin(keyAxis->range().lower);
    end = mDataContainer->findEnd(keyAxis->range().upper);
    // limit lower/upperEnd to rangeRestriction:
    // lower / upperEnd를 rangeRestriction으로 제한합니다.
    mDataContainer->limitIteratorsToDataRange(begin, end, rangeRestriction); 
// this also ensures rangeRestriction outside data bounds doesn't break anything
// 이것은 또한 데이터 경계 밖의 rangeRestriction이 아무 것도 부수 지 않는다는 것을 보장합니다.
  }
}

/*!  \internal
  
  This method goes through the passed points in \a lineData and returns a list of the segments
  which don't contain NaN data points.
  
  \a keyOrientation defines whether the \a x or \a y member of the passed QPointF is used to check
  for NaN. If \a keyOrientation is \c Qt::Horizontal, the \a y member is checked, if it is \c
  Qt::Vertical, the \a x member is checked.
  
  \see getOverlappingSegments, drawFill
*/
/*! \내부의
  
  이 메소드는 lineData의 전달 된 점을 통과하여 세그먼트 목록을 반환합니다.
  NaN 데이터 포인트를 포함하지 않습니다.
  
  \ a keyOrientation은 전달 된 QPointF의 \ ax 또는 \ member가 검사에 사용되는지 여부를 정의합니다
  NaN. \ a keyOrientation이 \ c Qt :: Horizontal 인 경우, \ ​​ay 멤버가 \ c 인 경우 선택됩니다
  Qt :: Vertical, \ ax 멤버가 체크됩니다.
  
  \ getOverlappingSegments, drawFill을 참조하십시오.
*/
QVector<QCPDataRange> QCPGraph::getNonNanSegments(const QVector<QPointF> *lineData, Qt::Orientation keyOrientation) const
{
  QVector<QCPDataRange> result;
  const int n = lineData->size();
  
  QCPDataRange currentSegment(-1, -1);
  int i = 0;
  
  if (keyOrientation == Qt::Horizontal)
  {
    while (i < n)
    {
      while (i < n && qIsNaN(lineData->at(i).y()))
 // seek next non-NaN data point
// 다음 NaN 이외의 데이터 포인트 찾기
        ++i;
      if (i == n)
        break;
      currentSegment.setBegin(i++);
      while (i < n && !qIsNaN(lineData->at(i).y())) 
// seek next NaN data point or end of data
// 다음 NaN 데이터 포인트 또는 데이터의 끝을 찾습니다.
        ++i;
      currentSegment.setEnd(i++);
      result.append(currentSegment);
    }
  } else // keyOrientation == Qt::Vertical
  {
    while (i < n)
    {
      while (i < n && qIsNaN(lineData->at(i).x())) 
// seek next non-NaN data point
// 다음 NaN 이외의 데이터 포인트 찾기
        ++i;
      if (i == n)
        break;
      currentSegment.setBegin(i++);
      while (i < n && !qIsNaN(lineData->at(i).x())) 
// seek next NaN data point or end of data
// 다음 NaN 데이터 포인트 또는 데이터의 끝을 찾습니다.
        ++i;
      currentSegment.setEnd(i++);
      result.append(currentSegment);
    }
  }
  return result;
}

/*!  \internal
  
  This method takes two segment lists (e.g. created by \ref getNonNanSegments) \a thisSegments and
  \a otherSegments, and their associated point data \a thisData and \a otherData.

  It returns all pairs of segments (the first from \a thisSegments, the second from \a
  otherSegments), which overlap in plot coordinates.
  
  This method is useful in the case of a channel fill between two graphs, when only those non-NaN
  segments which actually overlap in their key coordinate shall be considered for drawing a channel
  fill polygon.
  
  It is assumed that the passed segments in \a thisSegments are ordered ascending by index, and
  that the segments don't overlap themselves. The same is assumed for the segments in \a
  otherSegments. This is fulfilled when the segments are obtained via \ref getNonNanSegments.
  
  \see getNonNanSegments, segmentsIntersect, drawFill, getChannelFillPolygon
*/
/*! \내부의
  
  이 메소드는 두 개의 세그먼트 목록을 취합니다 (예 : \ ref getNonNanSegments에 의해 생성 됨). thisSegments와
  \ otherSegments 및 관련 지 점 데이터 \ thisData 및 \ otherData가 있습니다.

  모든 세그먼트 쌍을 반환합니다 (thisSegments에서 첫 번째 세그먼트, \a에서 두 번째 세그먼트).
  otherSegments), 플롯 좌표에서 겹칩니다.
  
  이 메소드는 두 그래프 사이의 채널 채우기의 경우에 유용합니다. 비 NaN
  실제로 그 키 좌표에서 겹치는 세그먼트는 채널 그리기를 위해 고려되어야한다
  다각형 채우기.
  
  \ this thisSegments에 전달 된 세그먼트는 인덱스에 따라 오름차순으로 정렬되어 있다고 가정합니다.
  세그먼트가 서로 겹치지 않는다는 것입니다. \ a의 세그먼트에 대해서도 동일하게 가정합니다.
  otherSegments. \ ref getNonNanSegments를 통해 세그먼트를 가져올 때 수행됩니다.
  
  \ getNonNanSegments, segmentsIntersect, drawFill, getChannelFillPolygon을 참조하십시오.
*/
QVector<QPair<QCPDataRange, QCPDataRange> > QCPGraph::getOverlappingSegments(QVector<QCPDataRange> thisSegments, const QVector<QPointF> *thisData, QVector<QCPDataRange> otherSegments, const QVector<QPointF> *otherData) const
{
  QVector<QPair<QCPDataRange, QCPDataRange> > result;
  if (thisData->isEmpty() || otherData->isEmpty() || thisSegments.isEmpty() || otherSegments.isEmpty())
    return result;
  
  int thisIndex = 0;
  int otherIndex = 0;
  const bool verticalKey = mKeyAxis->orientation() == Qt::Vertical;
  while (thisIndex < thisSegments.size() && otherIndex < otherSegments.size())
  {
    if (thisSegments.at(thisIndex).size() < 2) 
// segments with fewer than two points won't have a fill anyhow
// 세 개 이상의 점이있는 세그먼트는 아무 것도 채워지지 않습니다.
    {
      ++thisIndex;
      continue;
    }
    if (otherSegments.at(otherIndex).size() < 2) 
// segments with fewer than two points won't have a fill anyhow
// 2 점 미만의 세그먼트에는 아무 것도 채워지지 않습니다.
    {
      ++otherIndex;
      continue;
    }
    double thisLower, thisUpper, otherLower, otherUpper;
    if (!verticalKey)
    {
      thisLower = thisData->at(thisSegments.at(thisIndex).begin()).x();
      thisUpper = thisData->at(thisSegments.at(thisIndex).end()-1).x();
      otherLower = otherData->at(otherSegments.at(otherIndex).begin()).x();
      otherUpper = otherData->at(otherSegments.at(otherIndex).end()-1).x();
    } else
    {
      thisLower = thisData->at(thisSegments.at(thisIndex).begin()).y();
      thisUpper = thisData->at(thisSegments.at(thisIndex).end()-1).y();
      otherLower = otherData->at(otherSegments.at(otherIndex).begin()).y();
      otherUpper = otherData->at(otherSegments.at(otherIndex).end()-1).y();
    }
    
    int bPrecedence;
    if (segmentsIntersect(thisLower, thisUpper, otherLower, otherUpper, bPrecedence))
      result.append(QPair<QCPDataRange, QCPDataRange>(thisSegments.at(thisIndex), otherSegments.at(otherIndex)));
    
    if (bPrecedence <= 0)
// otherSegment doesn't reach as far as thisSegment, so continue with next otherSegment, keeping current thisSegment
// otherSegment가 thisSegment까지 도달하지 못하면 다음 thisSegment를 유지하면서 next otherSegment로 계속 진행합니다.
      ++otherIndex;
    else 
// otherSegment reaches further than thisSegment, so continue with next thisSegment, keeping current otherSegment
// otherSegment가 thisSegment보다 커지면 nextSegment와 계속 진행하여 현재 otherSegment를 유지합니다.
      ++thisIndex;
  }
  
  return result;
}

/*!  \internal
  
  Returns whether the segments defined by the coordinates (aLower, aUpper) and (bLower, bUpper)
  have overlap.
  
  The output parameter \a bPrecedence indicates whether the \a b segment reaches farther than the
  \a a segment or not. If \a bPrecedence returns 1, segment \a b reaches the farthest to higher
  coordinates (i.e. bUpper > aUpper). If it returns -1, segment \a a reaches the farthest. Only if
  both segment's upper bounds are identical, 0 is returned as \a bPrecedence.
  
  It is assumed that the lower bounds always have smaller or equal values than the upper bounds.
  
  \see getOverlappingSegments
*/
/*! \내부의
  
  좌표 (aLower, aUpper)와 (bLower, bUpper)에 의해 정의 된 세그먼트 (segment)
  겹쳐있다.
  
  출력 매개 변수 \ a bPrecedence는 \ ab 세그먼트가
  \ a 세그먼트 또는 아닙니다. \ a bPrecedence가 1을 반환하면 \ ab가 가장 먼 지점에서 가장 높은 지점에 도달합니다.
  좌표 (즉, bUpper> aUpper). -1을 반환하면 세그먼트 \ aa가 가장 멀리 도달합니다. 경우에만
  두 세그먼트의 상한은 동일하고 0은 \ a bPrecedence로 반환됩니다.
  
  하한은 항상 상한보다 작거나 같은 값으로 가정합니다.
  
  \ see getOverlappingSegments
*/
bool QCPGraph::segmentsIntersect(double aLower, double aUpper, double bLower, double bUpper, int &bPrecedence) const
{
  bPrecedence = 0;
  if (aLower > bUpper)
  {
    bPrecedence = -1;
    return false;
  } else if (bLower > aUpper)
  {
    bPrecedence = 1;
    return false;
  } else
  {
    if (aUpper > bUpper)
      bPrecedence = -1;
    else if (aUpper < bUpper)
      bPrecedence = 1;
    
    return true;
  }
}

/*! \internal
  
  Returns the point which closes the fill polygon on the zero-value-line parallel to the key axis.
  The logarithmic axis scale case is a bit special, since the zero-value-line in pixel coordinates
  is in positive or negative infinity. So this case is handled separately by just closing the fill
  polygon on the axis which lies in the direction towards the zero value.

  \a matchingDataPoint will provide the key (in pixels) of the returned point. Depending on whether
  the key axis of this graph is horizontal or vertical, \a matchingDataPoint will provide the x or
  y value of the returned point, respectively.
*/
/*! \내부의
  
  키 축에 평행 한 0 개의 값의 행에서 채우기 다각형을 닫는 점을 반환합니다.
  로그 축 스케일 경우는 약간 특별합니다. 픽셀 좌표의 0 값 라인
  양수 또는 음수 무한대입니다. 따라서이 경우는 채우기를 닫음으로써 개별적으로 처리됩니다.
  0 값을 향하는 방향에있는 축상의 다각형.

  \ a matchingDataPoint는 반환 된 포인트의 키 (픽셀 단위)를 제공합니다. 여부에 따라
  이 그래프의 핵심 축은 수평 또는 수직이며, \ a matchingDataPoint는 x 또는
  반환 된 점의 y 값입니다.
*/
QPointF QCPGraph::getFillBasePoint(QPointF matchingDataPoint) const
{
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QPointF(); }
  
  QPointF result;
  if (valueAxis->scaleType() == QCPAxis::stLinear)
  {
    if (keyAxis->orientation() == Qt::Horizontal)
    {
      result.setX(matchingDataPoint.x());
      result.setY(valueAxis->coordToPixel(0));
    } else // keyAxis->orientation() == Qt::Vertical
    {
      result.setX(valueAxis->coordToPixel(0));
      result.setY(matchingDataPoint.y());
    }
  } else // valueAxis->mScaleType == QCPAxis::stLogarithmic
  {
    // In logarithmic scaling we can't just draw to value 0 so we just fill all the way
    // to the axis which is in the direction towards 0
    // 로그 스케일링에서 값 0을 그릴 수 없으므로 모든 것을 채울 수 있습니다.
    // 0 방향으로 향한 축에
    if (keyAxis->orientation() == Qt::Vertical)
    {
      if ((valueAxis->range().upper < 0 && !valueAxis->rangeReversed()) ||
          (valueAxis->range().upper > 0 && valueAxis->rangeReversed())) 
// if range is negative, zero is on opposite side of key axis
// 범위가 음수이면 0이 키 축의 반대쪽에 있습니다.
        result.setX(keyAxis->axisRect()->right());
      else
        result.setX(keyAxis->axisRect()->left());
      result.setY(matchingDataPoint.y());
    } else if (keyAxis->axisType() == QCPAxis::atTop || keyAxis->axisType() == QCPAxis::atBottom)
    {
      result.setX(matchingDataPoint.x());
      if ((valueAxis->range().upper < 0 && !valueAxis->rangeReversed()) ||
          (valueAxis->range().upper > 0 && valueAxis->rangeReversed())) 
// if range is negative, zero is on opposite side of key axis
// 범위가 음수이면 0이 키 축의 반대쪽에 있습니다.
        result.setY(keyAxis->axisRect()->top());
      else
        result.setY(keyAxis->axisRect()->bottom());
    }
  }
  return result;
}

/*! \internal
  
  Returns the polygon needed for drawing normal fills between this graph and the key axis.
  
  Pass the graph's data points (in pixel coordinates) as \a lineData, and specify the \a segment
  which shall be used for the fill. The collection of \a lineData points described by \a segment
  must not contain NaN data points (see \ref getNonNanSegments).
  
  The returned fill polygon will be closed at the key axis (the zero-value line) for linear value
  axes. For logarithmic value axes the polygon will reach just beyond the corresponding axis rect
  side (see \ref getFillBasePoint).

  For increased performance (due to implicit sharing), keep the returned QPolygonF const.
  
  \see drawFill, getNonNanSegments
*/
/*! \내부의
  
  이 그래프와 키 축간에 통상의 칠을 묘화하는데 필요한 폴리곤을 돌려줍니다.
  
  그래프의 데이터 포인트 (픽셀 좌표)를 \ lineData로 전달하고 \ a 세그먼트를 지정합니다.
  그것은 채우기를 위해 사용되어야한다. 세그먼트 (segment)로 기술되는 lineData의 콜렉션
  NaN 데이터 포인트를 포함 할 수 없습니다 (\ ref getNonNanSegments 참조).
  
  반환 된 채우기 다각형은 선형 값의 경우 키 축 (0 값 라인)에서 닫힙니다.
  축. 대수 값 축의 경우 다각형은 해당 축 rect 바로 위에 도달합니다.
  side (\ ref getFillBasePoint를 보라).

  성능을 향상 시키려면 (암시 적 공유로 인해) 리턴 된 QPolygonF const를 유지하십시오.
  
  \ see drawFill, getNonNanSegments
*/
const QPolygonF QCPGraph::getFillPolygon(const QVector<QPointF> *lineData, QCPDataRange segment) const
{
  if (segment.size() < 2)
    return QPolygonF();
  QPolygonF result(segment.size()+2);
  
  result[0] = getFillBasePoint(lineData->at(segment.begin()));
  std::copy(lineData->constBegin()+segment.begin(), lineData->constBegin()+segment.end(), result.begin()+1);
  result[result.size()-1] = getFillBasePoint(lineData->at(segment.end()-1));
  
  return result;
}

/*! \internal
  
  Returns the polygon needed for drawing (partial) channel fills between this graph and the graph
  specified by \ref setChannelFillGraph.
  
  The data points of this graph are passed as pixel coordinates via \a thisData, the data of the
  other graph as \a otherData. The returned polygon will be calculated for the specified data
  segments \a thisSegment and \a otherSegment, pertaining to the respective \a thisData and \a
  otherData, respectively.
  
  The passed \a thisSegment and \a otherSegment should correspond to the segment pairs returned by
  \ref getOverlappingSegments, to make sure only segments that actually have key coordinate overlap
  need to be processed here.
  
  For increased performance due to implicit sharing, keep the returned QPolygonF const.
  
  \see drawFill, getOverlappingSegments, getNonNanSegments
*/
/*! \내부의
  
  이 그래프와 그래프의 사이의 부분 채널 채우기에 필요한 다각형을 돌려줍니다.
  \ ref setChannelFillGraph에 의해 지정됩니다.
  
  이 그래프의 데이터 포인트는 \ this thisData를 통해 픽셀 좌표로 전달되고,
  다른 그래프는 \ otherData입니다. 반환 된 다각형은 지정된 데이터에 대해 계산됩니다.
  세그먼트 \ a thisSegment 및 \ a thisSegment 및 해당 \ a에 속한 otherSegment
  otherData를 참조하십시오.
  
  전달 된 thisSegment 및 \ otherSegment는에 의해 반환 된 세그먼트 쌍과 일치해야합니다.
  \ ref getOverlappingSegments, 실제로 키 좌표가 겹치는 세그먼트 만 확인하십시오.
  여기서 처리해야합니다.
  
  내재적 공유로 인한 성능 향상을 위해 반환 된 QPolygonF const를 유지하십시오.
  
  \ see drawFill, getOverlappingSegments, getNonNanSegments
*/
const QPolygonF QCPGraph::getChannelFillPolygon(const QVector<QPointF> *thisData, QCPDataRange thisSegment, const QVector<QPointF> *otherData, QCPDataRange otherSegment) const
{
  if (!mChannelFillGraph)
    return QPolygonF();
  
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QPolygonF(); }
  if (!mChannelFillGraph.data()->mKeyAxis) { qDebug() << Q_FUNC_INFO << "channel fill target key axis invalid"; return QPolygonF(); }
  
  if (mChannelFillGraph.data()->mKeyAxis.data()->orientation() != keyAxis->orientation())
    return QPolygonF(); // don't have same axis orientation, can't fill that (Note: if keyAxis fits, valueAxis will fit too, because it's always orthogonal to keyAxis)
// 같은 축 방향을 가지지 않고 채울 수 없습니다 (주 : keyAxis가 맞으면 valueAxis도 맞을 것입니다, 왜냐하면 항상 keyAxis와 직교하기 때문입니다)
  
  if (thisData->isEmpty()) return QPolygonF();
  QVector<QPointF> thisSegmentData(thisSegment.size());
  QVector<QPointF> otherSegmentData(otherSegment.size());
  std::copy(thisData->constBegin()+thisSegment.begin(), thisData->constBegin()+thisSegment.end(), thisSegmentData.begin());
  std::copy(otherData->constBegin()+otherSegment.begin(), otherData->constBegin()+otherSegment.end(), otherSegmentData.begin());
  // pointers to be able to swap them, depending which data range needs cropping:
  // 자르기가 필요한 데이터 범위에 따라 포인터를 바꿀 수있는 포인터 :
  QVector<QPointF> *staticData = &thisSegmentData;
  QVector<QPointF> *croppedData = &otherSegmentData;
  
  // crop both vectors to ranges in which the keys overlap (which coord is key, depends on axisType):
  // 두 벡터를 키가 겹치는 범위로 자릅니다 (key는 key 유형에 따라 다름).
  if (keyAxis->orientation() == Qt::Horizontal)
  {
    // x is key
    // crop lower bound:
    // x는 키입니다.
    // 자르기 하한 :
    if (staticData->first().x() < croppedData->first().x()) // other one must be cropped
                                                            // 다른 하나는 잘려야합니다
      qSwap(staticData, croppedData);
    const int lowBound = findIndexBelowX(croppedData, staticData->first().x());
    if (lowBound == -1) return QPolygonF(); // key ranges have no overlap
                                            // 키 범위에는 겹침이 없습니다.
    croppedData->remove(0, lowBound);
    // set lowest point of cropped data to fit exactly key position of first static data point via linear interpolation:
    // 직선 보간을 통해 첫 번째 정적 데이터 포인트의 정확한 키 위치에 맞게 자른 데이터의 최저 지점 설정 :
    if (croppedData->size() < 2) return QPolygonF(); // need at least two points for interpolation
                                                     // 보간을 위해 최소한 두 개의 점이 필요합니다.
    double slope;
    if (!qFuzzyCompare(croppedData->at(1).x(), croppedData->at(0).x()))
      slope = (croppedData->at(1).y()-croppedData->at(0).y())/(croppedData->at(1).x()-croppedData->at(0).x());
    else
      slope = 0;
    (*croppedData)[0].setY(croppedData->at(0).y()+slope*(staticData->first().x()-croppedData->at(0).x()));
    (*croppedData)[0].setX(staticData->first().x());
    
    // crop upper bound:
    // 상한 자르기 :
    if (staticData->last().x() > croppedData->last().x()) // other one must be cropped
                                                          // 다른 하나는 잘려야합니다.
      qSwap(staticData, croppedData);
    int highBound = findIndexAboveX(croppedData, staticData->last().x());
    if (highBound == -1) return QPolygonF(); // key ranges have no overlap
                                             // 키 범위에는 겹침이 없습니다.
    croppedData->remove(highBound+1, croppedData->size()-(highBound+1));
// set highest point of cropped data to fit exactly key position of last static data point via linear interpolation:
// 직선 보간법을 통해 최종 정적 데이터 포인트의 정확한 키 위치에 맞게 자른 데이터의 가장 높은 점 설정 :
    if (croppedData->size() < 2) return QPolygonF(); // need at least two points for interpolation
                                                     // 필요하다. 보간을 위해 최소한 두 개의 점이
    const int li = croppedData->size()-1; // last index // 마지막 색인
    if (!qFuzzyCompare(croppedData->at(li).x(), croppedData->at(li-1).x()))
      slope = (croppedData->at(li).y()-croppedData->at(li-1).y())/(croppedData->at(li).x()-croppedData->at(li-1).x());
    else
      slope = 0;
    (*croppedData)[li].setY(croppedData->at(li-1).y()+slope*(staticData->last().x()-croppedData->at(li-1).x()));
    (*croppedData)[li].setX(staticData->last().x());
  } else // mKeyAxis->orientation() == Qt::Vertical
  {
    // y is key
    // crop lower bound:
    // y는 키입니다.
    // 자르기 하한 :
    if (staticData->first().y() < croppedData->first().y()) // other one must be cropped
                                                            // 다른 하나는 잘려야합니다
      qSwap(staticData, croppedData);
    int lowBound = findIndexBelowY(croppedData, staticData->first().y());
    if (lowBound == -1) return QPolygonF(); // key ranges have no overlap
                                             // 키 범위에는 겹침이 없습니다.
    croppedData->remove(0, lowBound);
 // set lowest point of cropped data to fit exactly key position of first static data point via linear interpolation:
 // 직선 보간을 통해 첫 번째 정적 데이터 포인트의 정확한 키 위치에 맞게 자른 데이터의 최저 지점 설정 :
    if (croppedData->size() < 2) return QPolygonF(); // need at least two points for interpolation
                                                     // 보간을 위해 최소한 두 개의 점이 필요합니다.
    double slope;
    if (!qFuzzyCompare(croppedData->at(1).y(), croppedData->at(0).y())) // avoid division by zero in step plots
                                                                        // 단계 플롯에서 0으로 나누기를 피하십시오
      slope = (croppedData->at(1).x()-croppedData->at(0).x())/(croppedData->at(1).y()-croppedData->at(0).y());
    else
      slope = 0;
    (*croppedData)[0].setX(croppedData->at(0).x()+slope*(staticData->first().y()-croppedData->at(0).y()));
    (*croppedData)[0].setY(staticData->first().y());
    
    // crop upper bound:
    // 상한 자르기 :
    if (staticData->last().y() > croppedData->last().y()) // other one must be cropped
                                                          // 다른 하나는 잘려야합니다.
      qSwap(staticData, croppedData);
    int highBound = findIndexAboveY(croppedData, staticData->last().y());
    if (highBound == -1) return QPolygonF(); // key ranges have no overlap
                                             // 키 범위에는 겹침이 없습니다.
    croppedData->remove(highBound+1, croppedData->size()-(highBound+1));
// set highest point of cropped data to fit exactly key position of last static data point via linear interpolation:
// 직선 보간법을 통해 최종 정적 데이터 포인트의 정확한 키 위치에 맞게 자른 데이터의 가장 높은 점 설정 :
    if (croppedData->size() < 2) return QPolygonF(); // need at least two points for interpolation
                                                     // 보간을 위해 최소한 두 개의 점이 필요합니다.
    int li = croppedData->size()-1; // last index    // 마지막 색인
    if (!qFuzzyCompare(croppedData->at(li).y(), croppedData->at(li-1).y())) // avoid division by zero in step plots
                                                                            // step plot에서 0으로 나눗셈을 피하십시오.
      slope = (croppedData->at(li).x()-croppedData->at(li-1).x())/(croppedData->at(li).y()-croppedData->at(li-1).y());
    else
      slope = 0;
    (*croppedData)[li].setX(croppedData->at(li-1).x()+slope*(staticData->last().y()-croppedData->at(li-1).y()));
    (*croppedData)[li].setY(staticData->last().y());
  }
  
  // return joined:
  for (int i=otherSegmentData.size()-1; i>=0; --i) // insert reversed, otherwise the polygon will be twisted
                                                   // 반대 방향으로 삽입합니다. 그렇지 않으면 다각형이 비틀어집니다
    thisSegmentData << otherSegmentData.at(i);
  return QPolygonF(thisSegmentData);
}

/*! \internal
  
  Finds the smallest index of \a data, whose points x value is just above \a x. Assumes x values in
  \a data points are ordered ascending, as is ensured by \ref getLines/\ref getScatters if the key
  axis is horizontal.

  Used to calculate the channel fill polygon, see \ref getChannelFillPolygon.
*/
/*! \내부의
  
  \ a 데이터의 가장 작은 인덱스를 찾습니다.이 인덱스의 x 값은 \ a x 바로 위에 있습니다. x 값을 다음과 같이 가정합니다.
  \ ref에 의해 보증되는대로 데이터 포인트는 오름차순으로 정렬됩니다. getLines / ref getScatters
  축이 수평입니다.

  채널 채우기 폴리곤을 계산하는 데 사용됩니다. \ ref getChannelFillPolygon을 참조하십시오.
*/
int QCPGraph::findIndexAboveX(const QVector<QPointF> *data, double x) const
{
  for (int i=data->size()-1; i>=0; --i)
  {
    if (data->at(i).x() < x)
    {
      if (i<data->size()-1)
        return i+1;
      else
        return data->size()-1;
    }
  }
  return -1;
}

/*! \internal
  
  Finds the highest index of \a data, whose points x value is just below \a x. Assumes x values in
  \a data points are ordered ascending, as is ensured by \ref getLines/\ref getScatters if the key
  axis is horizontal.
  
  Used to calculate the channel fill polygon, see \ref getChannelFillPolygon.
*/
/*! \내부의
  
  포인트 x 값이 \ a x 바로 아래에있는 \ a 데이터의 가장 높은 인덱스를 찾습니다. x 값을 다음과 같이 가정합니다.
  \ ref에 의해 보증되는대로 데이터 포인트는 오름차순으로 정렬됩니다. getLines / ref getScatters
  축이 수평입니다.
  
  채널 채우기 폴리곤을 계산하는 데 사용됩니다. \ ref getChannelFillPolygon을 참조하십시오.
*/
int QCPGraph::findIndexBelowX(const QVector<QPointF> *data, double x) const
{
  for (int i=0; i<data->size(); ++i)
  {
    if (data->at(i).x() > x)
    {
      if (i>0)
        return i-1;
      else
        return 0;
    }
  }
  return -1;
}

/*! \internal
  
  Finds the smallest index of \a data, whose points y value is just above \a y. Assumes y values in
  \a data points are ordered ascending, as is ensured by \ref getLines/\ref getScatters if the key
  axis is vertical.
  
  Used to calculate the channel fill polygon, see \ref getChannelFillPolygon.
*/
/*! \내부의
  
  \ y 데이터의 가장 작은 인덱스를 찾습니다.이 인덱스의 y 값은 \ y입니다. y 값을 다음과 같이 가정합니다.
  \ ref에 의해 보증되는대로 데이터 포인트는 오름차순으로 정렬됩니다. getLines / ref getScatters
  축이 수직입니다.
  
  채널 채우기 폴리곤을 계산하는 데 사용됩니다. \ ref getChannelFillPolygon을 참조하십시오.
*/

int QCPGraph::findIndexAboveY(const QVector<QPointF> *data, double y) const
{
  for (int i=data->size()-1; i>=0; --i)
  {
    if (data->at(i).y() < y)
    {
      if (i<data->size()-1)
        return i+1;
      else
        return data->size()-1;
    }
  }
  return -1;
}

/*! \internal
  
  Calculates the minimum distance in pixels the graph's representation has from the given \a
  pixelPoint. This is used to determine whether the graph was clicked or not, e.g. in \ref
  selectTest. The closest data point to \a pixelPoint is returned in \a closestData. Note that if
  the graph has a line representation, the returned distance may be smaller than the distance to
  the \a closestData point, since the distance to the graph line is also taken into account.
  
  If either the graph has no data or if the line style is \ref lsNone and the scatter style's shape
  is \ref QCPScatterStyle::ssNone (i.e. there is no visual representation of the graph), returns -1.0.
*/
/*! \내부의
  
  주어진 \ a에서 그래프의 표현이 갖는 최소 거리를 픽셀 단위로 계산합니다.
  pixelPoint. 이것은 그래프가 클릭되었는지 여부를 결정하는 데 사용됩니다 (예 : \ ref에서).
  selectTest. \ pixelPoint에 가장 근접한 데이터 포인트는 \ nearestData에 반환됩니다. 만약
  그래프는 선 표현을 가지고, 반환 된 거리는 거리보다 작을 수 있습니다
  그래프 라인까지의 거리 또한 고려되기 때문에 \ a closestData 포인트.
  
  그래프에 데이터가 없거나 선 스타일이 \ ref lsNone이고 스 캐터 스타일의 모양 인 경우
  \ ref QCPScatterStyle :: ssNone (즉, 그래프의 시각적 표현이 없음) -1.0을 반환합니다.
*/
double QCPGraph::pointDistance(const QPointF &pixelPoint, QCPGraphDataContainer::const_iterator &closestData) const
{
  closestData = mDataContainer->constEnd();
  if (mDataContainer->isEmpty())
    return -1.0;
  if (mLineStyle == lsNone && mScatterStyle.isNone())
    return -1.0;
  
  // calculate minimum distances to graph data points and find closestData iterator:
  // 그래프 데이터 포인트에 대한 최소 거리를 계산하고 nearestData를 찾습니다. iterator :
  double minDistSqr = std::numeric_limits<double>::max();
  // determine which key range comes into question, taking selection tolerance around pos into account:
  // 어떤 키 범위가 문제가되는지 판단하고 pos 주위의 선택 공차를 고려합니다.
  double posKeyMin, posKeyMax, dummy;
  pixelsToCoords(pixelPoint-QPointF(mParentPlot->selectionTolerance(), mParentPlot->selectionTolerance()), posKeyMin, dummy);
  pixelsToCoords(pixelPoint+QPointF(mParentPlot->selectionTolerance(), mParentPlot->selectionTolerance()), posKeyMax, dummy);
  if (posKeyMin > posKeyMax)
    qSwap(posKeyMin, posKeyMax);
  // iterate over found data points and then choose the one with the shortest distance to pos:
  // 찾은 데이터 포인트를 반복 한 다음 pos와 가장 가까운 거리를 선택합니다.
  QCPGraphDataContainer::const_iterator begin = mDataContainer->findBegin(posKeyMin, true);
  QCPGraphDataContainer::const_iterator end = mDataContainer->findEnd(posKeyMax, true);
  for (QCPGraphDataContainer::const_iterator it=begin; it!=end; ++it)
  {
    const double currentDistSqr = QCPVector2D(coordsToPixels(it->key, it->value)-pixelPoint).lengthSquared();
    if (currentDistSqr < minDistSqr)
    {
      minDistSqr = currentDistSqr;
      closestData = it;
    }
  }
    
// calculate distance to graph line if there is one (if so, will probably be smaller than distance to closest data point):
 // 그래프 선과의 거리를 계산합니다 (그렇다면 가장 가까운 데이터 점까지의 거리보다 작을 것입니다).
  if (mLineStyle != lsNone)
  {
    // line displayed, calculate distance to line segments:
    // 표시되는 선, 선분까지의 거리 계산 :
    QVector<QPointF> lineData;
    getLines(&lineData, QCPDataRange(0, dataCount()));
    QCPVector2D p(pixelPoint);
    const int step = mLineStyle==lsImpulse ? 2 : 1;
// impulse plot differs from other line styles in that the lineData points are only pairwise connected
// 충동 플롯은 lineData 포인트가 쌍으로 만 연결된다는 점에서 다른 라인 스타일과 다릅니다.
    for (int i=0; i<lineData.size()-1; i+=step)
    {
      const double currentDistSqr = p.distanceSquaredToLine(lineData.at(i), lineData.at(i+1));
      if (currentDistSqr < minDistSqr)
        minDistSqr = currentDistSqr;
    }
  }
  
  return qSqrt(minDistSqr);
}

/*! \internal
  
  Finds the highest index of \a data, whose points y value is just below \a y. Assumes y values in
  \a data points are ordered ascending, as is ensured by \ref getLines/\ref getScatters if the key
  axis is vertical.

  Used to calculate the channel fill polygon, see \ref getChannelFillPolygon.
*/
/*! \내부의
  
  점 y 값이 \ y보다 작은 \ a 데이터의 가장 높은 인덱스를 찾습니다. y 값을 다음과 같이 가정합니다.
  \ ref에 의해 보증되는대로 데이터 포인트는 오름차순으로 정렬됩니다. getLines / ref getScatters
  축이 수직입니다.

  채널 채우기 폴리곤을 계산하는 데 사용됩니다. \ ref getChannelFillPolygon을 참조하십시오.
*/
int QCPGraph::findIndexBelowY(const QVector<QPointF> *data, double y) const
{
  for (int i=0; i<data->size(); ++i)
  {
    if (data->at(i).y() > y)
    {
      if (i>0)
        return i-1;
      else
        return 0;
    }
  }
  return -1;
}
/* end of 'src/plottables/plottable-graph.cpp' */


/* including file 'src/plottables/plottable-curve.cpp', size 63527           */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / plottables / plottable-graph.cpp'의 끝 */


/* 파일 'src / plottables / plottable-curve.cpp'포함, 크기 63527 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPCurveData
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPCurveData
  \brief Holds the data of one single data point for QCPCurve.
  
  The stored data is:
  \li \a t: the free ordering parameter of this curve point, like in the mathematical vector <em>(x(t), y(t))</em>. (This is the \a sortKey)
  \li \a key: coordinate on the key axis of this curve point (this is the \a mainKey)
  \li \a value: coordinate on the value axis of this curve point (this is the \a mainValue)
  
  The container for storing multiple data points is \ref QCPCurveDataContainer. It is a typedef for
  \ref QCPDataContainer with \ref QCPCurveData as the DataType template parameter. See the
  documentation there for an explanation regarding the data type's generic methods.
  
  \see QCPCurveDataContainer
*/
/*! \ class QCPCurveData
  \ brief QCPCurve에 대한 단일 데이터 포인트의 데이터를 보유합니다.
  
  저장된 데이터는 다음과 같습니다.
  \ li \ at : 수학적 벡터 <em> (x (t), y (t)) </ em>처럼이 곡선 점의 자유 순서 매개 변수. (이것은 \ sortKey입니다)
  \ li \ a key :이 커브 포인트의 키 축에 대한 좌표입니다 (이 값은 \ mainKey입니다)
  \ li \ a value :이 커브 포인트의 값 축에 대한 좌표입니다 (이 값은 \ a mainValue 임).
  
  여러 데이터 요소를 저장하는 컨테이너는 \ ref QCPCurveDataContainer입니다. 그것은에 대한 typedef입니다.
  \ ref QCPDataContainer는 \ ref QCPCurveData를 DataType 템플릿 매개 변수로 사용합니다. 자세한 내용은
  데이터 유형의 제네릭 메소드에 대한 설명은 문서를 참조하십시오.
  
  \ QCPCurveDataContainer 참조
*/

/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */

/*! \fn double QCPCurveData::sortKey() const
  
  Returns the \a t member of this data point.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn double QCPCurveData :: sortKey () const
  
  이 데이터 포인트의 멤버를 반환합니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/


/*! \fn static QCPCurveData QCPCurveData::fromSortKey(double sortKey)
  
  Returns a data point with the specified \a sortKey (assigned to the data point's \a t member).
  All other members are set to zero.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn 정적 QCPCurveData QCPCurveData :: fromSortKey (double sortKey)
  
  지정된 \ sortKey (데이터 포인트의 \에 멤버에 할당 됨)가있는 데이터 포인트를 반환합니다.
  다른 모든 멤버는 0으로 설정됩니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn static static bool QCPCurveData::sortKeyIsMainKey()
  
  Since the member \a key is the data point key coordinate and the member \a t is the data ordering
  parameter, this method returns false.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn 정적 정적 bool QCPCurveData :: sortKeyIsMainKey ()
  
  member \ a 키가 데이터 포인트 키 좌표이고 member \ at가 데이터 순서이므로
  이 메소드는 false를 반환합니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn double QCPCurveData::mainKey() const
  
  Returns the \a key member of this data point.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn double QCPCurveData :: mainKey () const
  
  이 데이터 포인트의 키 멤버를 돌려줍니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn double QCPCurveData::mainValue() const
  
  Returns the \a value member of this data point.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn double QCPCurveData :: mainValue () const
  
  이 데이터 포인트의 \ a 값 멤버를 반환합니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/


/*! \fn QCPRange QCPCurveData::valueRange() const
  
  Returns a QCPRange with both lower and upper boundary set to \a value of this data point.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn QCPRange QCPCurveData :: valueRange () const
  
  이 데이터 포인트의 값에 상한과 하한을 모두 설정 한 QCPRange를 반환합니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */

/*!
  Constructs a curve data point with t, key and value set to zero.
*/
/*!
  t, key 및 value가 0으로 설정된 곡선 데이터 요소를 구성합니다.
*/
QCPCurveData::QCPCurveData() :
  t(0),
  key(0),
  value(0)
{
}

/*!
  Constructs a curve data point with the specified \a t, \a key and \a value.
*/
/*!
  지정된 \ at, \ a key 및 \ a 값을 사용하여 곡선 데이터 요소를 만듭니다.
*/
QCPCurveData::QCPCurveData(double t, double key, double value) :
  t(t),
  key(key),
  value(value)
{
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPCurve
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPCurve
  \brief A plottable representing a parametric curve in a plot.
  
  \image html QCPCurve.png
  
  Unlike QCPGraph, plottables of this type may have multiple points with the same key coordinate,
  so their visual representation can have \a loops. This is realized by introducing a third
  coordinate \a t, which defines the order of the points described by the other two coordinates \a
  x and \a y.

  To plot data, assign it with the \ref setData or \ref addData functions. Alternatively, you can
  also access and modify the curve's data via the \ref data method, which returns a pointer to the
  internal \ref QCPCurveDataContainer.
  
  Gaps in the curve can be created by adding data points with NaN as key and value
  (<tt>qQNaN()</tt> or <tt>std::numeric_limits<double>::quiet_NaN()</tt>) in between the two data points that shall be
  separated.
  
  \section qcpcurve-appearance Changing the appearance
  
  The appearance of the curve is determined by the pen and the brush (\ref setPen, \ref setBrush).
  
  \section qcpcurve-usage Usage
  
  Like all data representing objects in QCustomPlot, the QCPCurve is a plottable
  (QCPAbstractPlottable). So the plottable-interface of QCustomPlot applies
  (QCustomPlot::plottable, QCustomPlot::removePlottable, etc.)
  
  Usually, you first create an instance:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpcurve-creation-1
  which registers it with the QCustomPlot instance of the passed axes. Note that this QCustomPlot instance takes
  ownership of the plottable, so do not delete it manually but use QCustomPlot::removePlottable() instead.
  The newly created plottable can be modified, e.g.:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpcurve-creation-2
*/
/*! \ class QCPCurve
  \ brief 플롯에서 파라 메트릭 곡선을 나타내는 플롯 테이블.
  
  \ image html QCPCurve.png
  
  QCPGraph와 달리이 유형의 플롯 테이블은 동일한 키 좌표를 가진 여러 점을 가질 수 있습니다.
  그래서 그들의 시각적 표현은 \ a 루프를 가질 수 있습니다. 이것은 세 번째
  좌표 \ at는 다른 두 좌표로 설명되는 점의 순서를 정의합니다. \ a
  x와 \ y.

  데이터를 플롯하려면 \ ref setData 또는 \ ref addData 함수로 지정하십시오. 또는
  또한 \ ref 데이터 메소드를 통해 커브의 데이터에 액세스하고 수정합니다.
  내부 \ ref QCPCurveDataContainer.
  
  커브의 간격은 키와 값으로 NaN을 사용하여 데이터 요소를 추가하여 만들 수 있습니다.
  두 데이터 포인트 사이에 (<tt> qQNaN () </ tt> 또는 <tt> std :: numeric_limits <double> :: quiet_NaN () </ tt>)
  분리.
  
  \ section qcpcurve-appearance 모양 변경
  
  커브의 모양은 펜과 브러시 (\ ref setPen, \ ref setBrush)에 의해 결정됩니다.
  
  \ section qcpcurve-usage 사용법
  
  QCustomPlot의 객체를 나타내는 모든 데이터와 마찬가지로 QCPCurve는 plottable입니다.
  (QCPAbstractPlottable). QCustomPlot의 plottable-interface가 적용됩니다.
  (QCustomPlot :: plottable, QCustomPlot :: removePlottable 등)
  
  일반적으로 먼저 인스턴스를 만듭니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpcurve-creation-1
  전달 된 축의 QCustomPlot 인스턴스에이를 등록합니다. 이 QCustomPlot 인스턴스는
  plottable의 소유권이므로 수동으로 삭제하지 말고 QCustomPlot :: removePlottable ()을 대신 사용하십시오.
  새로 생성 된 플롯 테이블은 다음과 같이 수정할 수 있습니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpcurve-creation-2
*/

/* start of documentation of inline functions */
/* 인라인 함수의 문서화 시작 */

/*! \fn QSharedPointer<QCPCurveDataContainer> QCPCurve::data() const
  
  Returns a shared pointer to the internal data storage of type \ref QCPCurveDataContainer. You may
  use it to directly manipulate the data, which may be more convenient and faster than using the
  regular \ref setData or \ref addData methods.
*/
/*! \ fn QSharedPointer <QCPCurveDataContainer> QCPCurve :: data () const
  
  \ ref QCPCurveDataContainer 유형의 내부 데이터 저장소에 대한 공유 포인터를 반환합니다. 당신은 할 수있다
  그것을 사용하여 데이터를 직접 조작하십시오. 이는 데이터를 사용하는 것보다 더 편리하고 빠릅니다.
  정규 \ ref setData 또는 \ ref addData 메소드.
*/

/* end of documentation of inline functions */
/* 인라인 함수의 문서 끝 */

/*!
  Constructs a curve which uses \a keyAxis as its key axis ("x") and \a valueAxis as its value
  axis ("y"). \a keyAxis and \a valueAxis must reside in the same QCustomPlot instance and not have
  the same orientation. If either of these restrictions is violated, a corresponding message is
  printed to the debug output (qDebug), the construction is not aborted, though.
  
  The created QCPCurve is automatically registered with the QCustomPlot instance inferred from \a
  keyAxis. This QCustomPlot instance takes ownership of the QCPCurve, so do not delete it manually
  but use QCustomPlot::removePlottable() instead.
*/
/*!
  키 축 ( "x")으로서 \ keyAxis를 사용해, 값으로서 \ valueAxis를 사용하는 곡선을 구축합니다.
  축 ( "y"). \ a keyAxis 및 \ a valueAxis는 동일한 QCustomPlot 인스턴스에 있어야하며
  같은 방향. 이러한 제한 사항 중 하나라도 위반하면 해당 메시지가 다음과 같습니다.
  디버그 출력 (qDebug)에 인쇄되면, 구성은 중단되지 않습니다.
  
  생성 된 QCPCurve는 \ a에서 유추 한 QCustomPlot 인스턴스에 자동으로 등록됩니다.
  keyAxis. 이 QCustomPlot 인스턴스는 QCPCurve의 소유권을 가지므로 수동으로 삭제하지 마십시오.
  QCustomPlot :: removePlottable ()을 대신 사용하십시오.
*/
QCPCurve::QCPCurve(QCPAxis *keyAxis, QCPAxis *valueAxis) :
  QCPAbstractPlottable1D<QCPCurveData>(keyAxis, valueAxis)
{
  // modify inherited properties from abstract plottable:
  // 추상 plottable에서 상속 된 속성 수정 :
  setPen(QPen(Qt::blue, 0));
  setBrush(Qt::NoBrush);
  
  setScatterStyle(QCPScatterStyle());
  setLineStyle(lsLine);
  setScatterSkip(0);
}

QCPCurve::~QCPCurve()
{
}

/*! \overload
  
  Replaces the current data container with the provided \a data container.
  
  Since a QSharedPointer is used, multiple QCPCurves may share the same data container safely.
  Modifying the data in the container will then affect all curves that share the container. Sharing
  can be achieved by simply exchanging the data containers wrapped in shared pointers:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpcurve-datasharing-1
  
  If you do not wish to share containers, but create a copy from an existing container, rather use
  the \ref QCPDataContainer<DataType>::set method on the curve's data container directly:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpcurve-datasharing-2
  
  \see addData
*/
/*! \초과 적재
  
  현재 데이터 컨테이너를 제공된 \ 데이터 컨테이너로 바꿉니다.
  
  QSharedPointer가 사용되므로 여러 QCPCurve가 동일한 데이터 컨테이너를 안전하게 공유 할 수 있습니다.
  컨테이너의 데이터를 수정하면 컨테이너를 공유하는 모든 곡선에 영향을줍니다. 나누는
  공유 포인터에 랩핑 된 데이터 컨테이너를 단순히 교환하여 얻을 수 있습니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpcurve-datasharing-1
  
  컨테이너를 공유하지 않고 기존 컨테이너에서 사본을 만들려면
  커브의 데이터 컨테이너에서 \ ref QCPDataContainer <DataType> :: set 메서드를 직접 호출합니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpcurve-datasharing-2
  
  \ addData를 참조하십시오.
*/
void QCPCurve::setData(QSharedPointer<QCPCurveDataContainer> data)
{
  mDataContainer = data;
}

/*! \overload
  
  Replaces the current data with the provided points in \a t, \a keys and \a values. The provided
  vectors should have equal length. Else, the number of added points will be the size of the
  smallest vector.
  
  If you can guarantee that the passed data points are sorted by \a t in ascending order, you can
  set \a alreadySorted to true, to improve performance by saving a sorting run.
  
  \see addData
*/
/*! \초과 적재
  
  현재 데이터를 \ at, \ a 키 및 \ a 값으로 제공된 점으로 바꿉니다. 제공된
  벡터의 길이는 동일해야합니다. 그렇지 않으면 추가 된 포인트의 수는
  가장 작은 벡터.
  
  전달 된 데이터 요소가 \에서 오름차순으로 정렬되도록 보장 할 수 있다면
  정렬 실행을 저장하여 성능을 향상 시키려면 \ a alreadySorted를 true로 설정하십시오.
  
  \ addData를 참조하십시오.
*/
void QCPCurve::setData(const QVector<double> &t, const QVector<double> &keys, const QVector<double> &values, bool alreadySorted)
{
  mDataContainer->clear();
  addData(t, keys, values, alreadySorted);
}


/*! \overload
  
  Replaces the current data with the provided points in \a keys and \a values. The provided vectors
  should have equal length. Else, the number of added points will be the size of the smallest
  vector.
  
  The t parameter of each data point will be set to the integer index of the respective key/value
  pair.
  
  \see addData
*/
/*! \초과 적재
  
  현재 데이터를 \ a 키와 \ a 값의 제공된 점으로 바꿉니다. 제공된 벡터
  길이가 같아야합니다. 그렇지 않으면 추가 된 포인트의 수는 가장 작은 것의 크기가됩니다.
  벡터.
  
  각 데이터 포인트의 t 매개 변수는 해당 키 / 값의 정수 인덱스로 설정됩니다
  쌍.
  
  \ addData를 참조하십시오.
*/
void QCPCurve::setData(const QVector<double> &keys, const QVector<double> &values)
{
  mDataContainer->clear();
  addData(keys, values);
}

/*!
  Sets the visual appearance of single data points in the plot. If set to \ref
  QCPScatterStyle::ssNone, no scatter points are drawn (e.g. for line-only plots with appropriate
  line style).
  
  \see QCPScatterStyle, setLineStyle
*/
/*!
  플롯에서 단일 데이터 요소의 시각적 모양을 설정합니다. \ ref로 설정하면
  QCPScatterStyle :: ssNone, 스 캐터 포인트가 그려지지 않습니다 (예 : 적절한
  선 스타일).
  
  \ QCPScatterStyle, setLineStyle 참조
*/
void QCPCurve::setScatterStyle(const QCPScatterStyle &style)
{
  mScatterStyle = style;
}

/*!
  If scatters are displayed (scatter style not \ref QCPScatterStyle::ssNone), \a skip number of
  scatter points are skipped/not drawn after every drawn scatter point.

  This can be used to make the data appear sparser while for example still having a smooth line,
  and to improve performance for very high density plots.

  If \a skip is set to 0 (default), all scatter points are drawn.

  \see setScatterStyle
*/
/*!
  산포가 표시되면 (산산이 스타일은 \ ref QCPScatterStyle :: ssNone이 아님) \ skip number of
  그려진 모든 스 캐터 지점 이후에 스 캐터 지점은 건너 뛰거나 그려지지 않습니다.

  이것은 예를 들어 여전히 부드러운 선을 가지고있는 동안 데이터를 더 드문 드문하게 보이게하는 데 사용될 수 있습니다.
  매우 높은 밀도 플롯의 성능을 향상시킬 수 있습니다.

  \ a skip이 0 (기본값)으로 설정되면 모든 분산 점이 그려집니다.

  \ setScatterStyle 참조
*/
void QCPCurve::setScatterSkip(int skip)
{
  mScatterSkip = qMax(0, skip);
}

/*!
  Sets how the single data points are connected in the plot or how they are represented visually
  apart from the scatter symbol. For scatter-only plots, set \a style to \ref lsNone and \ref
  setScatterStyle to the desired scatter style.
  
  \see setScatterStyle
*/
/*!
  단일 데이터 점이 플롯에서 어떻게 연결되는지 또는 시각적으로 어떻게 표시되는지 설정합니다.
  스 캐터 심볼과는 별도로 분산 형 플롯의 경우 \ a 스타일을 \ ref lsNone 및 \ ref로 설정합니다.
  setScatterStyle을 원하는 분산 스타일로 설정합니다.
  
  \ setScatterStyle 참조
*/
void QCPCurve::setLineStyle(QCPCurve::LineStyle style)
{
  mLineStyle = style;
}

/*! \overload
  
  Adds the provided points in \a t, \a keys and \a values to the current data. The provided vectors
  should have equal length. Else, the number of added points will be the size of the smallest
  vector.
  
  If you can guarantee that the passed data points are sorted by \a keys in ascending order, you
  can set \a alreadySorted to true, to improve performance by saving a sorting run.
  
  Alternatively, you can also access and modify the data directly via the \ref data method, which
  returns a pointer to the internal data container.
*/
/*! \초과 적재
  
  \ at, \ a 키 및 \ a 값에 제공된 점을 현재 데이터에 추가합니다. 제공된 벡터
  길이가 같아야합니다. 그렇지 않으면 추가 된 포인트의 수는 가장 작은 것의 크기가됩니다.
  벡터.
  
  전달 된 데이터 요소가 \ a 키에 따라 오름차순으로 정렬되도록 보장 할 수 있으면
  정렬 실행을 저장하여 성능을 향상 시키려면 \ a alreadySorted를 true로 설정할 수 있습니다.
  
  또는 \ ref 데이터 메서드를 통해 직접 데이터에 액세스하고 수정할 수도 있습니다.
  내부 데이터 컨테이너에 대한 포인터를 반환합니다.
*/
void QCPCurve::addData(const QVector<double> &t, const QVector<double> &keys, const QVector<double> &values, bool alreadySorted)
{
  if (t.size() != keys.size() || t.size() != values.size())
    qDebug() << Q_FUNC_INFO << "ts, keys and values have different sizes:" << t.size() << keys.size() << values.size();
  const int n = qMin(qMin(t.size(), keys.size()), values.size());
  QVector<QCPCurveData> tempData(n);
  QVector<QCPCurveData>::iterator it = tempData.begin();
  const QVector<QCPCurveData>::iterator itEnd = tempData.end();
  int i = 0;
  while (it != itEnd)
  {
    it->t = t[i];
    it->key = keys[i];
    it->value = values[i];
    ++it;
    ++i;
  }
  mDataContainer->add(tempData, alreadySorted); 
// don't modify tempData beyond this to prevent copy on write
// 복사시 쓰기를 방지하기 위해 tempData를이 값 이상으로 수정하지 마십시오.
}

/*! \overload
  
  Adds the provided points in \a keys and \a values to the current data. The provided vectors
  should have equal length. Else, the number of added points will be the size of the smallest
  vector.
  
  The t parameter of each data point will be set to the integer index of the respective key/value
  pair.
  
  Alternatively, you can also access and modify the data directly via the \ref data method, which
  returns a pointer to the internal data container.
*/
/*! \초과 적재
  
  \ a 키와 \ a 값에 제공된 점을 현재 데이터에 추가합니다. 제공된 벡터
  길이가 같아야합니다. 그렇지 않으면 추가 된 포인트의 수는 가장 작은 것의 크기가됩니다.
  벡터.
  
  각 데이터 포인트의 t 매개 변수는 해당 키 / 값의 정수 인덱스로 설정됩니다
  쌍.
  
  또는 \ ref 데이터 메서드를 통해 직접 데이터에 액세스하고 수정할 수도 있습니다.
  내부 데이터 컨테이너에 대한 포인터를 반환합니다.
*/

void QCPCurve::addData(const QVector<double> &keys, const QVector<double> &values)
{
  if (keys.size() != values.size())
    qDebug() << Q_FUNC_INFO << "keys and values have different sizes:" << keys.size() << values.size();
  const int n = qMin(keys.size(), values.size());
  double tStart;
  if (!mDataContainer->isEmpty())
    tStart = (mDataContainer->constEnd()-1)->t + 1.0;
  else
    tStart = 0;
  QVector<QCPCurveData> tempData(n);
  QVector<QCPCurveData>::iterator it = tempData.begin();
  const QVector<QCPCurveData>::iterator itEnd = tempData.end();
  int i = 0;
  while (it != itEnd)
  {
    it->t = tStart + i;
    it->key = keys[i];
    it->value = values[i];
    ++it;
    ++i;
  }
  mDataContainer->add(tempData, true); 
// don't modify tempData beyond this to prevent copy on write
// 복사시 쓰기를 방지하기 위해 tempData를이 값 이상으로 수정하지 마십시오.
}

/*! \overload
  Adds the provided data point as \a t, \a key and \a value to the current data.
  
  Alternatively, you can also access and modify the data directly via the \ref data method, which
  returns a pointer to the internal data container.
*/
/*! \초과 적재
  제공된 데이터 포인트를 \ at, \ a 키 및 \ a 값을 현재 데이터에 추가합니다.
  
  또는 \ ref 데이터 메서드를 통해 직접 데이터에 액세스하고 수정할 수도 있습니다.
  내부 데이터 컨테이너에 대한 포인터를 반환합니다.
*/
void QCPCurve::addData(double t, double key, double value)
{
  mDataContainer->add(QCPCurveData(t, key, value));
}

/*! \overload
  
  Adds the provided data point as \a key and \a value to the current data.
  
  The t parameter is generated automatically by increments of 1 for each point, starting at the
  highest t of previously existing data or 0, if the curve data is empty.
  
  Alternatively, you can also access and modify the data directly via the \ref data method, which
  returns a pointer to the internal data container.
*/
/*! \초과 적재
  
  제공된 데이터 요소를 \ 키와 \ 값을 현재 데이터에 추가합니다.
  
  t 매개 변수는 각 점에 대해 1 씩 증가하여 자동으로 생성됩니다.
  선행 데이터의 최고 t 또는 곡선 데이터가 비어있는 경우 0입니다.
  
  또는 \ ref 데이터 메서드를 통해 직접 데이터에 액세스하고 수정할 수도 있습니다.
  내부 데이터 컨테이너에 대한 포인터를 반환합니다.
*/
void QCPCurve::addData(double key, double value)
{
  if (!mDataContainer->isEmpty())
    mDataContainer->add(QCPCurveData((mDataContainer->constEnd()-1)->t + 1.0, key, value));
  else
    mDataContainer->add(QCPCurveData(0.0, key, value));
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPCurve::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())
    return -1;
  if (!mKeyAxis || !mValueAxis)
    return -1;
  
  if (mKeyAxis.data()->axisRect()->rect().contains(pos.toPoint()))
  {
    QCPCurveDataContainer::const_iterator closestDataPoint = mDataContainer->constEnd();
    double result = pointDistance(pos, closestDataPoint);
    if (details)
    {
      int pointIndex = closestDataPoint-mDataContainer->constBegin();
      details->setValue(QCPDataSelection(QCPDataRange(pointIndex, pointIndex+1)));
    }
    return result;
  } else
    return -1;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPRange QCPCurve::getKeyRange(bool &foundRange, QCP::SignDomain inSignDomain) const
{
  return mDataContainer->keyRange(foundRange, inSignDomain);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPRange QCPCurve::getValueRange(bool &foundRange, QCP::SignDomain inSignDomain, const QCPRange &inKeyRange) const
{
  return mDataContainer->valueRange(foundRange, inSignDomain, inKeyRange);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPCurve::draw(QCPPainter *painter)
{
  if (mDataContainer->isEmpty()) return;
  
  // allocate line vector:
  // line vector를 할당한다.
  QVector<QPointF> lines, scatters;
  
  // loop over and draw segments of unselected/selected data:
  // 선택되지 않은 / 선택한 데이터의 세그먼트를 반복 및 그립니다.
  QList<QCPDataRange> selectedSegments, unselectedSegments, allSegments;
  getDataSegments(selectedSegments, unselectedSegments);
  allSegments << unselectedSegments << selectedSegments;
  for (int i=0; i<allSegments.size(); ++i)
  {
    bool isSelectedSegment = i >= unselectedSegments.size();
    
    // fill with curve data:
    // 곡선 데이터로 채우기 :
    QPen finalCurvePen = mPen; 
// determine the final pen already here, because the line optimization depends on its stroke width
// 라인 최적화가 스트로크의 폭에 의존하기 때문에 이미 여기에있는 마지막 펜을 결정한다.
    if (isSelectedSegment && mSelectionDecorator)
      finalCurvePen = mSelectionDecorator->pen();
    
    QCPDataRange lineDataRange = isSelectedSegment ? allSegments.at(i) : allSegments.at(i).adjusted(-1, 1);
 // unselected segments extend lines to bordering selected data point (safe to exceed total data bounds in first/last segment, getCurveLines takes care)
 // 선택되지 않은 선분이 선을 선택된 데이터 점을 경계로 확장합니다 (첫 번째 / 마지막 선분에서 총 데이터 경계를 초과하지 않도록 안전하고 getCurveLines가주의를 기울입니다)
    getCurveLines(&lines, lineDataRange, finalCurvePen.widthF());
    
    // check data validity if flag set:
    // 플래그가 설정된 경우 데이터 유효성을 검사합니다.
  #ifdef QCUSTOMPLOT_CHECK_DATA
    for (QCPCurveDataContainer::const_iterator it = mDataContainer->constBegin(); it != mDataContainer->constEnd(); ++it)
    {
      if (QCP::isInvalidData(it->t) ||
          QCP::isInvalidData(it->key, it->value))
        qDebug() << Q_FUNC_INFO << "Data point at" << it->key << "invalid." << "Plottable name:" << name();
    }
  #endif
    
    // draw curve fill:
    // 곡선 채우기 그리기 :
    applyFillAntialiasingHint(painter);
    if (isSelectedSegment && mSelectionDecorator)
      mSelectionDecorator->applyBrush(painter);
    else
      painter->setBrush(mBrush);
    painter->setPen(Qt::NoPen);
    if (painter->brush().style() != Qt::NoBrush && painter->brush().color().alpha() != 0)
      painter->drawPolygon(QPolygonF(lines));
    
    // draw curve line:
    // 커브 선 그리기 :
    if (mLineStyle != lsNone)
    {
      painter->setPen(finalCurvePen);
      painter->setBrush(Qt::NoBrush);
      drawCurveLine(painter, lines);
    }
    
    // draw scatters:
    // 흩어지는 부분을 그립니다.
    QCPScatterStyle finalScatterStyle = mScatterStyle;
    if (isSelectedSegment && mSelectionDecorator)
      finalScatterStyle = mSelectionDecorator->getFinalScatterStyle(mScatterStyle);
    if (!finalScatterStyle.isNone())
    {
      getScatters(&scatters, allSegments.at(i), finalScatterStyle.size());
      drawScatterPlot(painter, scatters, finalScatterStyle);
    }
  }
  
  // draw other selection decoration that isn't just line/scatter pens and brushes:
  // 선 / 산란 펜 및 브러쉬가 아닌 다른 선택 장식을 그립니다.
  if (mSelectionDecorator)
    mSelectionDecorator->drawDecoration(painter, selection());
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPCurve::drawLegendIcon(QCPPainter *painter, const QRectF &rect) const
{
  // draw fill:
  // 채우기 :
  if (mBrush.style() != Qt::NoBrush)
  {
    applyFillAntialiasingHint(painter);
    painter->fillRect(QRectF(rect.left(), rect.top()+rect.height()/2.0, rect.width(), rect.height()/3.0), mBrush);
  }
  // draw line vertically centered:
  // 수직으로 선을 그립니다.
  if (mLineStyle != lsNone)
  {
    applyDefaultAntialiasingHint(painter);
    painter->setPen(mPen);
    painter->drawLine(QLineF(rect.left(), rect.top()+rect.height()/2.0, rect.right()+5, rect.top()+rect.height()/2.0)); // +5 on x2 else last segment is missing from dashed/dotted pens
          // x5에 +5 다른 끝 점이 점선 / 점선 펜에서 누락되었습니다.
  }
  // draw scatter symbol:
  // 스캐터 기호를 그립니다.
  if (!mScatterStyle.isNone())
  {
    applyScattersAntialiasingHint(painter);
    // scale scatter pixmap if it's too large to fit in legend icon rect:
    // 범람 pixmap이 너무 커서 범례 아이콘에 맞출 수없는 경우 rect rect :
    if (mScatterStyle.shape() == QCPScatterStyle::ssPixmap && (mScatterStyle.pixmap().size().width() > rect.width() || mScatterStyle.pixmap().size().height() > rect.height()))
    {
      QCPScatterStyle scaledStyle(mScatterStyle);
      scaledStyle.setPixmap(scaledStyle.pixmap().scaled(rect.size().toSize(), Qt::KeepAspectRatio, Qt::SmoothTransformation));
      scaledStyle.applyTo(painter, mPen);
      scaledStyle.drawShape(painter, QRectF(rect).center());
    } else
    {
      mScatterStyle.applyTo(painter, mPen);
      mScatterStyle.drawShape(painter, QRectF(rect).center());
    }
  }
}

/*!  \internal

  Draws lines between the points in \a lines, given in pixel coordinates.

  \see drawScatterPlot, getCurveLines
*/
/*! \내부의

  픽셀 좌표로 주어진 점 사이의 선을 \ a 행에 그립니다.

  \ 참조 drawScatterPlot, getCurveLines
*/
void QCPCurve::drawCurveLine(QCPPainter *painter, const QVector<QPointF> &lines) const
{
  if (painter->pen().style() != Qt::NoPen && painter->pen().color().alpha() != 0)
  {
    applyDefaultAntialiasingHint(painter);
    drawPolyline(painter, lines);
  }
}

/*! \internal

  Draws scatter symbols at every point passed in \a points, given in pixel coordinates. The
  scatters will be drawn with \a painter and have the appearance as specified in \a style.

  \see drawCurveLine, getCurveLines
*/
/*! \내부의

  픽셀 좌표로 주어지는 \ a 점으로 전달 된 모든 점에 scatter 기호를 그립니다. 그만큼
  뿌려 놓는 사람은 \ 화가와 함께 그려지며 \ 스타일로 지정된 모양을가집니다.

  \ drawCurveLine 참조, getCurveLines
*/
void QCPCurve::drawScatterPlot(QCPPainter *painter, const QVector<QPointF> &points, const QCPScatterStyle &style) const
{
  // draw scatter point symbols:
  // 스 캐터 포인트 기호를 그립니다.
  applyScattersAntialiasingHint(painter);
  style.applyTo(painter, mPen);
  for (int i=0; i<points.size(); ++i)
    if (!qIsNaN(points.at(i).x()) && !qIsNaN(points.at(i).y()))
      style.drawShape(painter,  points.at(i));
}

/*! \internal

  Called by \ref draw to generate points in pixel coordinates which represent the line of the
  curve.

  Line segments that aren't visible in the current axis rect are handled in an optimized way. They
  are projected onto a rectangle slightly larger than the visible axis rect and simplified
  regarding point count. The algorithm makes sure to preserve appearance of lines and fills inside
  the visible axis rect by generating new temporary points on the outer rect if necessary.

  \a lines will be filled with points in pixel coordinates, that can be drawn with \ref
  drawCurveLine.

  \a dataRange specifies the beginning and ending data indices that will be taken into account for
  conversion. In this function, the specified range may exceed the total data bounds without harm:
  a correspondingly trimmed data range will be used. This takes the burden off the user of this
  function to check for valid indices in \a dataRange, e.g. when extending ranges coming from \ref
  getDataSegments.

  \a penWidth specifies the pen width that will be used to later draw the lines generated by this
  function. This is needed here to calculate an accordingly wider margin around the axis rect when
  performing the line optimization.

  Methods that are also involved in the algorithm are: \ref getRegion, \ref getOptimizedPoint, \ref
  getOptimizedCornerPoints \ref mayTraverse, \ref getTraverse, \ref getTraverseCornerPoints.

  \see drawCurveLine, drawScatterPlot
*/
/*! \내부의

  \ ref draw에 의해 호출되어 픽셀 좌표계의 선을 나타내는 점을 생성합니다.
  곡선.

  현재 축 rect에 표시되지 않는 선분은 최적화 된 방식으로 처리됩니다. 그들
  가시 축 rect보다 약간 큰 직사각형에 투영되고 단순화됩니다.
  포인트 수 관련. 알고리즘은 선의 모양을 유지하고 내부를 채 웁니다.
  필요에 따라서 외측 구석에 새로운 임시 포인트를 생성 해 가시 축 rect

  \ a 라인은 \ ref로 그릴 수있는 픽셀 좌표로 채워질 것이다.
  drawCurveLine.

  \ dataRange는 시작과 끝 데이터 인덱스를 지정합니다.
  변환. 이 함수에서 지정된 범위는 피해없이 총 데이터 범위를 초과 할 수 있습니다.
  해당 트리밍 된 데이터 범위가 사용됩니다. 이것은 사용자의 부담을 덜어줍니다.
  \ dataRange에서 유효한 인덱스를 검사하는 함수. 예를 들어 \ ref에서 오는 범위를 확장 할 때
  getDataSegments.

  \ penWidth는 나중에 생성 된 선을 그릴 때 사용할 펜 너비를 지정합니다.
  기능. 여기서는 축 rect 주위의 더 넓은 마진을 계산할 때이 값이 필요합니다.
  라인 최적화를 수행합니다.

  알고리즘과 관련된 메소드는 다음과 같습니다. \ ref getRegion, \ ref getOptimizedPoint, \ ref
  getOptimizedCornerPoints \ ref mayTraverse, \ ref getTraverse, \ ref getTraverseCornerPoints.

  \ drawCurveLine 참조, drawScatterPlot
*/
void QCPCurve::getCurveLines(QVector<QPointF> *lines, const QCPDataRange &dataRange, double penWidth) const
{
  if (!lines) return;
  lines->clear();
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
  
  // add margins to rect to compensate for stroke width
  // 스트로크 너비를 보완하기 위해 여백을 rect에 추가합니다.
  const double strokeMargin = qMax(qreal(1.0), qreal(penWidth*0.75)); // stroke radius + 50% safety
                                                                      // 스트로크 반경 + 안전성 50 %
  const double keyMin = keyAxis->pixelToCoord(keyAxis->coordToPixel(keyAxis->range().lower)-strokeMargin*keyAxis->pixelOrientation());
  const double keyMax = keyAxis->pixelToCoord(keyAxis->coordToPixel(keyAxis->range().upper)+strokeMargin*keyAxis->pixelOrientation());
  const double valueMin = valueAxis->pixelToCoord(valueAxis->coordToPixel(valueAxis->range().lower)-strokeMargin*valueAxis->pixelOrientation());
  const double valueMax = valueAxis->pixelToCoord(valueAxis->coordToPixel(valueAxis->range().upper)+strokeMargin*valueAxis->pixelOrientation());
  QCPCurveDataContainer::const_iterator itBegin = mDataContainer->constBegin();
  QCPCurveDataContainer::const_iterator itEnd = mDataContainer->constEnd();
  mDataContainer->limitIteratorsToDataRange(itBegin, itEnd, dataRange);
  if (itBegin == itEnd)
    return;
  QCPCurveDataContainer::const_iterator it = itBegin;
  QCPCurveDataContainer::const_iterator prevIt = itEnd-1;
  int prevRegion = getRegion(prevIt->key, prevIt->value, keyMin, valueMax, keyMax, valueMin);
  QVector<QPointF> trailingPoints; // points that must be applied after all other points (are generated only when handling first point to get virtual segment between last and first point right)
// 다른 모든 점 다음에 적용해야하는 점 (마지막 점과 첫 번째 점 사이에서 가상 점을 가져 오는 첫 번째 점을 처리 할 때만 생성됨)
  while (it != itEnd)
  {
    const int currentRegion = getRegion(it->key, it->value, keyMin, valueMax, keyMax, valueMin);
    if (currentRegion != prevRegion) 
// changed region, possibly need to add some optimized edge points or original points if entering R
// 영역을 변경 했으므로 R을 입력하면 최적화 된 가장자리 점이나 원래 점을 추가해야 할 수도 있습니다
    {
      if (currentRegion != 5) // segment doesn't end in R, so it's a candidate for removal
                              // 세그먼트가 R에서 끝나지 않으므로 제거 후보가됩니다.
      {
        QPointF crossA, crossB;
        if (prevRegion == 5) // we're coming from R, so add this point optimized
                             // R에서 오는 것이므로이 점을 최적화에 추가하십시오.
        {
          lines->append(getOptimizedPoint(currentRegion, it->key, it->value, prevIt->key, prevIt->value, keyMin, valueMax, keyMax, valueMin));
          // in the situations 5->1/7/9/3 the segment may leave R and directly cross through two outer regions. In these cases we need to add an additional corner point
 // 상황에서 5-> 1/7/9/3 세그먼트는 R을 떠나서 두 개의 바깥 영역을 통해 직접 교차 할 수 있습니다. 이러한 경우 추가 코너 점을 추가해야합니다.

          *lines << getOptimizedCornerPoints(prevRegion, currentRegion, prevIt->key, prevIt->value, it->key, it->value, keyMin, valueMax, keyMax, valueMin);
        } else if (mayTraverse(prevRegion, currentRegion) &&
                   getTraverse(prevIt->key, prevIt->value, it->key, it->value, keyMin, valueMax, keyMax, valueMin, crossA, crossB))
        {
          // add the two cross points optimized if segment crosses R and if segment isn't virtual zeroth segment between last and first curve point:
// 세그먼트가 R을 교차하고 세그먼트가 가상이 아닌 경우 최적화 된 두 개의 교차점을 추가합니다. 마지막 및 첫 번째 곡선 점 사이의 0 번째 세그먼트 
          QVector<QPointF> beforeTraverseCornerPoints, afterTraverseCornerPoints;
          getTraverseCornerPoints(prevRegion, currentRegion, keyMin, valueMax, keyMax, valueMin, beforeTraverseCornerPoints, afterTraverseCornerPoints);
          if (it != itBegin)
          {
            *lines << beforeTraverseCornerPoints;
            lines->append(crossA);
            lines->append(crossB);
            *lines << afterTraverseCornerPoints;
          } else
          {
            lines->append(crossB);
            *lines << afterTraverseCornerPoints;
            trailingPoints << beforeTraverseCornerPoints << crossA ;
          }
        } else // doesn't cross R, line is just moving around in outside regions, so only need to add optimized point(s) at the boundary corner(s)
// R을 교차하지 않습니다. 선이 바깥 영역에서 움직이기 때문에 경계 모서리에 최적화 된 점만 추가하면됩니다.
        {
          *lines << getOptimizedCornerPoints(prevRegion, currentRegion, prevIt->key, prevIt->value, it->key, it->value, keyMin, valueMax, keyMax, valueMin);
        }
      } else 
// segment does end in R, so we add previous point optimized and this point at original position
// 세그먼트에서 R 세그먼트가 끝나기 때문에 이전 점을 원래 위치에 추가합니다.
      {
        if (it == itBegin) 
// it is first point in curve and prevIt is last one. So save optimized point for adding it to the lineData in the end
// 그것은 곡선의 첫 번째 점이고 prevIt은 마지막 점입니다. 마지막에 lineData에 추가하기 위해 최적화 된 점을 저장하십시오.
          trailingPoints << getOptimizedPoint(prevRegion, prevIt->key, prevIt->value, it->key, it->value, keyMin, valueMax, keyMax, valueMin);
        else
          lines->append(getOptimizedPoint(prevRegion, prevIt->key, prevIt->value, it->key, it->value, keyMin, valueMax, keyMax, valueMin));
        lines->append(coordsToPixels(it->key, it->value));
      }
    } else // region didn't change
    {      // 영역이 변경되지 않았습니다.
      if (currentRegion == 5) // still in R, keep adding original points
      {                       // 여전히 R에 원래 점을 계속 추가합니다.
        lines->append(coordsToPixels(it->key, it->value));
      } else // still outside R, no need to add anything
      {      // 여전히 R 밖에 있으면 아무것도 추가 할 필요가 없습니다.
        // see how this is not doing anything? That's the main optimization...
        // 이것이 어떻게 아무것도하지 않는지보십시오. 그것은 주요 최적화 ...
      }
    }
    prevIt = it;
    prevRegion = currentRegion;
    ++it;
  }
  *lines << trailingPoints;
}

/*! \internal

  Called by \ref draw to generate points in pixel coordinates which represent the scatters of the
  curve. If a scatter skip is configured (\ref setScatterSkip), the returned points are accordingly
  sparser.

  Scatters that aren't visible in the current axis rect are optimized away.

  \a scatters will be filled with points in pixel coordinates, that can be drawn with \ref
  drawScatterPlot.

  \a dataRange specifies the beginning and ending data indices that will be taken into account for
  conversion.

  \a scatterWidth specifies the scatter width that will be used to later draw the scatters at pixel
  coordinates generated by this function. This is needed here to calculate an accordingly wider
  margin around the axis rect when performing the data point reduction.

  \see draw, drawScatterPlot
*/
/*! \내부의

  \ ref draw에 의해 호출되어 픽셀 좌표의 점을 나타내는 점을 생성합니다.
  곡선. 스 캐터 스킵이 구성되면 (\ ref setScatterSkip), 반환 된 점이 그에 따라 결정됩니다.
  더 희박한.

  현재 축 rect에서 보이지 않는 흩 뿌려진 부분은 최적화 된 상태로 떨어져 있습니다.

  \ 산란자는 \ ref로 그려지는 점으로 픽셀 좌표로 채워질 것입니다
  drawScatterPlot.

  \ dataRange는 시작과 끝 데이터 인덱스를 지정합니다.
  변환.

  \ a scatterWidth는 나중에 픽셀에 산포를 그리는 데 사용할 산포 폭을 지정합니다.
  이 함수에 의해 생성 된 좌표. 이에 따라 더 넓게 계산하려면 여기가 필요합니다.
  데이터 포인트 감소를 수행 할 때 축 rect 주위의 여백.

  \ draw 그리기, drawScatterPlot
*/
void QCPCurve::getScatters(QVector<QPointF> *scatters, const QCPDataRange &dataRange, double scatterWidth) const
{
  if (!scatters) return;
  scatters->clear();
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
  
  QCPCurveDataContainer::const_iterator begin = mDataContainer->constBegin();
  QCPCurveDataContainer::const_iterator end = mDataContainer->constEnd();
  mDataContainer->limitIteratorsToDataRange(begin, end, dataRange);
  if (begin == end)
    return;
  const int scatterModulo = mScatterSkip+1;
  const bool doScatterSkip = mScatterSkip > 0;
  int endIndex = end-mDataContainer->constBegin();
  
  QCPRange keyRange = keyAxis->range();
  QCPRange valueRange = valueAxis->range();
  // extend range to include width of scatter symbols:
  // 스캐터 기호의 너비를 포함하도록 범위를 확장합니다.
  keyRange.lower = keyAxis->pixelToCoord(keyAxis->coordToPixel(keyRange.lower)-scatterWidth*keyAxis->pixelOrientation());
  keyRange.upper = keyAxis->pixelToCoord(keyAxis->coordToPixel(keyRange.upper)+scatterWidth*keyAxis->pixelOrientation());
  valueRange.lower = valueAxis->pixelToCoord(valueAxis->coordToPixel(valueRange.lower)-scatterWidth*valueAxis->pixelOrientation());
  valueRange.upper = valueAxis->pixelToCoord(valueAxis->coordToPixel(valueRange.upper)+scatterWidth*valueAxis->pixelOrientation());
  
  QCPCurveDataContainer::const_iterator it = begin;
  int itIndex = begin-mDataContainer->constBegin();
  while (doScatterSkip && it != end && itIndex % scatterModulo != 0) 
// advance begin iterator to first non-skipped scatter
// 이터레이터를 첫 번째 비 건너 뛴 스 캐터로 전진시킵니다.
  {
    ++itIndex;
    ++it;
  }
  if (keyAxis->orientation() == Qt::Vertical)
  {
    while (it != end)
    {
      if (!qIsNaN(it->value) && keyRange.contains(it->key) && valueRange.contains(it->value))
        scatters->append(QPointF(valueAxis->coordToPixel(it->value), keyAxis->coordToPixel(it->key)));
      
      // advance iterator to next (non-skipped) data point:
      // 반복자를 다음 (건너 뛰지 않은) 데이터 점으로 이동합니다.
      if (!doScatterSkip)
        ++it;
      else
      {
        itIndex += scatterModulo;
        if (itIndex < endIndex) // make sure we didn't jump over end
          it += scatterModulo;  // 끝까지 뛰어 넘지 않았는지 확인
        else
        {
          it = end;
          itIndex = endIndex;
        }
      }
    }
  } else
  {
    while (it != end)
    {
      if (!qIsNaN(it->value) && keyRange.contains(it->key) && valueRange.contains(it->value))
        scatters->append(QPointF(keyAxis->coordToPixel(it->key), valueAxis->coordToPixel(it->value)));
      
      // advance iterator to next (non-skipped) data point:
      // 반복자를 다음 (건너 뛰지 않은) 데이터 점으로 이동합니다.
      if (!doScatterSkip)
        ++it;
      else
      {
        itIndex += scatterModulo;
        if (itIndex < endIndex) // make sure we didn't jump over end
          it += scatterModulo;  // 끝까지 뛰어 넘지 않았는지 확인
        else
        {
          it = end;
          itIndex = endIndex;
        }
      }
    }
  }
}

/*! \internal

  This function is part of the curve optimization algorithm of \ref getCurveLines.

  It returns the region of the given point (\a key, \a value) with respect to a rectangle defined
  by \a keyMin, \a keyMax, \a valueMin, and \a valueMax.

  The regions are enumerated from top to bottom (\a valueMin to \a valueMax) and left to right (\a
  keyMin to \a keyMax):

  <table style="width:10em; text-align:center">
    <tr><td>1</td><td>4</td><td>7</td></tr>
    <tr><td>2</td><td style="border:1px solid black">5</td><td>8</td></tr>
    <tr><td>3</td><td>6</td><td>9</td></tr>
  </table>

  With the rectangle being region 5, and the outer regions extending infinitely outwards. In the
  curve optimization algorithm, region 5 is considered to be the visible portion of the plot.
*/
/*! \내부의

  이 함수는 \ ref getCurveLines의 곡선 최적화 알고리즘의 일부입니다.

  정의 된 사각형에 대해 주어진 점 (\ a 키, \ a 값)의 영역을 반환합니다.
  \ keyMin, \ keyMax, \ valueMin 및 \ valueMax.

  영역은 위에서 아래로 (\ a valueMin에서 \ a valueMax까지) 열거되고 왼쪽에서 오른쪽으로 (\ a
  keyMin to \ a keyMax) :

  <table style = "width : 10em; text-align : center">
    <tr> <td> 1 </ td> 4 </ td> <td> 7 </ td> </ tr>
    <td> 2 </ td> </ td> </ td> </ td>
    <tr> <td> 3 </ td> 6 </ td> 9 </ td> </ tr>
  </ table>

  사각형은 영역 5이고 바깥 쪽 영역은 무한히 바깥쪽으로 확장됩니다. 에서
  곡선 최적화 알고리즘에서 영역 5는 플롯의 가시적 인 부분으로 간주됩니다.
*/
int QCPCurve::getRegion(double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) const
{
  if (key < keyMin) // region 123
  {
    if (value > valueMax)
      return 1;
    else if (value < valueMin)
      return 3;
    else
      return 2;
  } else if (key > keyMax) // region 789
  {
    if (value > valueMax)
      return 7;
    else if (value < valueMin)
      return 9;
    else
      return 8;
  } else // region 456
  {
    if (value > valueMax)
      return 4;
    else if (value < valueMin)
      return 6;
    else
      return 5;
  }
}

/*! \internal
  
  This function is part of the curve optimization algorithm of \ref getCurveLines.
  
  This method is used in case the current segment passes from inside the visible rect (region 5,
  see \ref getRegion) to any of the outer regions (\a otherRegion). The current segment is given by
  the line connecting (\a key, \a value) with (\a otherKey, \a otherValue).
  
  It returns the intersection point of the segment with the border of region 5.
  
  For this function it doesn't matter whether (\a key, \a value) is the point inside region 5 or
  whether it's (\a otherKey, \a otherValue), i.e. whether the segment is coming from region 5 or
  leaving it. It is important though that \a otherRegion correctly identifies the other region not
  equal to 5.
*/
/*! \내부의
  
  이 함수는 \ ref getCurveLines의 곡선 최적화 알고리즘의 일부입니다.
  
  이 메소드는, 현재의 세그먼트 (segment)가 가시 선상 (영역 5,
  \ ref getRegion 참조)를 바깥 쪽 영역 (\ a otherRegion)에 추가합니다. 현재 세그먼트는에 의해 주어진다.
  (\ a key, \ a value)를 (\ a otherKey, \ a otherValue)와 연결하는 줄.
  
  세그먼트의 교차점과 영역 5의 경계를 반환합니다.
  
  이 함수의 경우 (\ 키, \ 값) 영역 5 안의 점인지 또는
  그것은 (\ a otherKey, \ a otherValue), 즉 세그먼트가 영역 5에서 왔는지 또는
  그것을 떠난다. \ otherRegion이 다른 영역을 올바르게 식별하지만 중요합니다.
  5와 같다.
*/
QPointF QCPCurve::getOptimizedPoint(int otherRegion, double otherKey, double otherValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) const
{
  // The intersection point interpolation here is done in pixel coordinates, so we don't need to
  // differentiate between different axis scale types. Note that the nomenclature
  // top/left/bottom/right/min/max is with respect to the rect in plot coordinates, wich may be
  // different in pixel coordinates (horz/vert key axes, reversed ranges)
  // 여기서 교차점 보간은 픽셀 좌표로 이루어 지므로 필요하지 않습니다.
  // 서로 다른 축척 유형을 구분합니다. 그 명명법
  // top / left / bottom / right / min / max는 플롯 좌표의 rect를 기준으로합니다.
  // 픽셀 좌표에서 다른 점 (horz / vert key 축, 반전 된 범위)
  const double keyMinPx = mKeyAxis->coordToPixel(keyMin);
  const double keyMaxPx = mKeyAxis->coordToPixel(keyMax);
  const double valueMinPx = mValueAxis->coordToPixel(valueMin);
  const double valueMaxPx = mValueAxis->coordToPixel(valueMax);
  const double otherValuePx = mValueAxis->coordToPixel(otherValue);
  const double valuePx = mValueAxis->coordToPixel(value);
  const double otherKeyPx = mKeyAxis->coordToPixel(otherKey);
  const double keyPx = mKeyAxis->coordToPixel(key);
  double intersectKeyPx = keyMinPx; // initial key just a fail-safe        // 초기 키는 훼일 세이프 (fail-safe) 만합니다.
  double intersectValuePx = valueMinPx; // initial value just a fail-safe  // 초기 값은 그냥 안전 장치
  switch (otherRegion)
  {
    case 1: // top and left edge    // 위쪽 및 왼쪽 가장자리
    {
      intersectValuePx = valueMaxPx;
      intersectKeyPx = otherKeyPx + (keyPx-otherKeyPx)/(valuePx-otherValuePx)*(intersectValuePx-otherValuePx);
      if (intersectKeyPx < qMin(keyMinPx, keyMaxPx) || intersectKeyPx > qMax(keyMinPx, keyMaxPx)) // check whether top edge is not intersected, then it must be left edge (qMin/qMax necessary since axes may be reversed)
// 위쪽 가장자리가 교차하지 않았는지 확인한 다음 왼쪽 가장자리에 있어야합니다 (축이 반전 될 수 있으므로 qMin / qMax가 필요함).
      {
        intersectKeyPx = keyMinPx;
        intersectValuePx = otherValuePx + (valuePx-otherValuePx)/(keyPx-otherKeyPx)*(intersectKeyPx-otherKeyPx);
      }
      break;
    }
    case 2: // left edge     // 왼쪽 가장자리
    {
      intersectKeyPx = keyMinPx;
      intersectValuePx = otherValuePx + (valuePx-otherValuePx)/(keyPx-otherKeyPx)*(intersectKeyPx-otherKeyPx);
      break;
    }
    case 3: // bottom and left edge    // 하단과 왼쪽 가장자리
    {
      intersectValuePx = valueMinPx;
      intersectKeyPx = otherKeyPx + (keyPx-otherKeyPx)/(valuePx-otherValuePx)*(intersectValuePx-otherValuePx);
      if (intersectKeyPx < qMin(keyMinPx, keyMaxPx) || intersectKeyPx > qMax(keyMinPx, keyMaxPx)) // check whether bottom edge is not intersected, then it must be left edge (qMin/qMax necessary since axes may be reversed)
// 하단 가장자리가 교차하지 않는지 확인한 다음 왼쪽 가장자리에 있어야합니다 (축이 반전 될 수 있으므로 qMin / qMax 필요)
      {
        intersectKeyPx = keyMinPx;
        intersectValuePx = otherValuePx + (valuePx-otherValuePx)/(keyPx-otherKeyPx)*(intersectKeyPx-otherKeyPx);
      }
      break;
    }
    case 4: // top edge   // 위쪽 가장자리
    {
      intersectValuePx = valueMaxPx;
      intersectKeyPx = otherKeyPx + (keyPx-otherKeyPx)/(valuePx-otherValuePx)*(intersectValuePx-otherValuePx);
      break;
    }
    case 5:
    {
      break; 
// case 5 shouldn't happen for this function but we add it anyway to prevent potential discontinuity in branch table
//이 함수에서는 case 5가 발생하지 않지만 어쨌든 분기 테이블에서 잠재적 인 불연속성을 방지하기 위해 추가합니다
    }
    case 6: // bottom edge   // 하단 가장자리
    {
      intersectValuePx = valueMinPx;
      intersectKeyPx = otherKeyPx + (keyPx-otherKeyPx)/(valuePx-otherValuePx)*(intersectValuePx-otherValuePx);
      break;
    }
    case 7: // top and right edge   / 위쪽 및 오른쪽 가장자리
    {
      intersectValuePx = valueMaxPx;
      intersectKeyPx = otherKeyPx + (keyPx-otherKeyPx)/(valuePx-otherValuePx)*(intersectValuePx-otherValuePx);
      if (intersectKeyPx < qMin(keyMinPx, keyMaxPx) || intersectKeyPx > qMax(keyMinPx, keyMaxPx)) // check whether top edge is not intersected, then it must be right edge (qMin/qMax necessary since axes may be reversed)
// 위쪽 가장자리가 교차하지 않는지 확인한 다음 오른쪽 가장자리 여야합니다 (축이 반전 될 수 있으므로 qMin / qMax가 필요합니다).
      {
        intersectKeyPx = keyMaxPx;
        intersectValuePx = otherValuePx + (valuePx-otherValuePx)/(keyPx-otherKeyPx)*(intersectKeyPx-otherKeyPx);
      }
      break;
    }
    case 8: // right edge    // 오른쪽 가장자리
    {
      intersectKeyPx = keyMaxPx;
      intersectValuePx = otherValuePx + (valuePx-otherValuePx)/(keyPx-otherKeyPx)*(intersectKeyPx-otherKeyPx);
      break;
    }
    case 9: // bottom and right edge  // 하단과 우측 가장자리
    {
      intersectValuePx = valueMinPx;
      intersectKeyPx = otherKeyPx + (keyPx-otherKeyPx)/(valuePx-otherValuePx)*(intersectValuePx-otherValuePx);
      if (intersectKeyPx < qMin(keyMinPx, keyMaxPx) || intersectKeyPx > qMax(keyMinPx, keyMaxPx)) // check whether bottom edge is not intersected, then it must be right edge (qMin/qMax necessary since axes may be reversed)
// 하단 가장자리가 교차하지 않는지 확인한 다음 오른쪽 가장자리 여야합니다 (축이 뒤집어 질 수 있으므로 qMin / qMax 필요)
      {
        intersectKeyPx = keyMaxPx;
        intersectValuePx = otherValuePx + (valuePx-otherValuePx)/(keyPx-otherKeyPx)*(intersectKeyPx-otherKeyPx);
      }
      break;
    }
  }
  if (mKeyAxis->orientation() == Qt::Horizontal)
    return QPointF(intersectKeyPx, intersectValuePx);
  else
    return QPointF(intersectValuePx, intersectKeyPx);
}

/*! \internal
  
  This function is part of the curve optimization algorithm of \ref getCurveLines.
  
  In situations where a single segment skips over multiple regions it might become necessary to add
  extra points at the corners of region 5 (see \ref getRegion) such that the optimized segment
  doesn't unintentionally cut through the visible area of the axis rect and create plot artifacts.
  This method provides these points that must be added, assuming the original segment doesn't
  start, end, or traverse region 5. (Corner points where region 5 is traversed are calculated by
  \ref getTraverseCornerPoints.)
  
  For example, consider a segment which directly goes from region 4 to 2 but originally is far out
  to the top left such that it doesn't cross region 5. Naively optimizing these points by
  projecting them on the top and left borders of region 5 will create a segment that surely crosses
  5, creating a visual artifact in the plot. This method prevents this by providing extra points at
  the top left corner, making the optimized curve correctly pass from region 4 to 1 to 2 without
  traversing 5.
*/
/*! \내부의
  
  이 함수는 \ ref getCurveLines의 곡선 최적화 알고리즘의 일부입니다.
  
  단일 세그먼트가 여러 지역을 건너 뛴다면
  영역 5의 모서리에있는 추가 점 (\ ref getRegion 참조). 최적화 된 세그먼트
  의도하지 않게 축 rect의 가시 영역을 잘라내어 플롯 아티팩트를 생성하지 않습니다.
  이 방법은 원본 세그먼트에
  시작, 끝 또는 가로 이동 5. (영역 5가 가로 지르는 모서리 점은
  \ ref getTraverseCornerPoints.)
  
  예를 들어, 영역 4에서 2로 직접 이동하지만 원래는 멀리있는 세그먼트를 생각해보십시오
  왼쪽 상단에 위치하여 5를 교차하지 않습니다.
  영역 5의 상단 및 왼쪽 경계에이를 투영하면 반드시 교차하는 세그먼트가 생성됩니다
  5, 음모에 시각적 인 유물을 만듭니다. 이 방법은 추가 지점을
  왼쪽 위 모서리로, 최적화 된 곡선을 영역 4에서 1에서 2로 올바르게 통과시킵니다.
  횡단 5.
*/
QVector<QPointF> QCPCurve::getOptimizedCornerPoints(int prevRegion, int currentRegion, double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) const
{
  QVector<QPointF> result;
  switch (prevRegion)
  {
    case 1:
    {
      switch (currentRegion)
      {
        case 2: { result << coordsToPixels(keyMin, valueMax); break; }
        case 4: { result << coordsToPixels(keyMin, valueMax); break; }
        case 3: { result << coordsToPixels(keyMin, valueMax) << coordsToPixels(keyMin, valueMin); break; }
        case 7: { result << coordsToPixels(keyMin, valueMax) << coordsToPixels(keyMax, valueMax); break; }
        case 6: { result << coordsToPixels(keyMin, valueMax) << coordsToPixels(keyMin, valueMin); result.append(result.last()); break; }
        case 8: { result << coordsToPixels(keyMin, valueMax) << coordsToPixels(keyMax, valueMax); result.append(result.last()); break; }
        case 9: { // in this case we need another distinction of cases: segment may pass below or above rect, requiring either bottom right or top left corner points
//이 경우 우리는 또 다른 구별이 필요하다 : 세그먼트가 rect 아래 나 위를 통과 할 수 있으며 오른쪽 아래 또는 왼쪽 위 꼭지점이 필요하다.
          if ((value-prevValue)/(key-prevKey)*(keyMin-key)+value < valueMin) // segment passes below R
                                                                             // 세그먼트가 R 아래로 전달됩니다.
          { result << coordsToPixels(keyMin, valueMax) << coordsToPixels(keyMin, valueMin); result.append(result.last()); result << coordsToPixels(keyMax, valueMin); }
          else
          { result << coordsToPixels(keyMin, valueMax) << coordsToPixels(keyMax, valueMax); result.append(result.last()); result << coordsToPixels(keyMax, valueMin); }
          break;
        }
      }
      break;
    }
    case 2:
    {
      switch (currentRegion)
      {
        case 1: { result << coordsToPixels(keyMin, valueMax); break; }
        case 3: { result << coordsToPixels(keyMin, valueMin); break; }
        case 4: { result << coordsToPixels(keyMin, valueMax); result.append(result.last()); break; }
        case 6: { result << coordsToPixels(keyMin, valueMin); result.append(result.last()); break; }
        case 7: { result << coordsToPixels(keyMin, valueMax); result.append(result.last()); result << coordsToPixels(keyMax, valueMax); break; }
        case 9: { result << coordsToPixels(keyMin, valueMin); result.append(result.last()); result << coordsToPixels(keyMax, valueMin); break; }
      }
      break;
    }
    case 3:
    {
      switch (currentRegion)
      {
        case 2: { result << coordsToPixels(keyMin, valueMin); break; }
        case 6: { result << coordsToPixels(keyMin, valueMin); break; }
        case 1: { result << coordsToPixels(keyMin, valueMin) << coordsToPixels(keyMin, valueMax); break; }
        case 9: { result << coordsToPixels(keyMin, valueMin) << coordsToPixels(keyMax, valueMin); break; }
        case 4: { result << coordsToPixels(keyMin, valueMin) << coordsToPixels(keyMin, valueMax); result.append(result.last()); break; }
        case 8: { result << coordsToPixels(keyMin, valueMin) << coordsToPixels(keyMax, valueMin); result.append(result.last()); break; }
        case 7: { // in this case we need another distinction of cases: segment may pass below or above rect, requiring either bottom right or top left corner points
//이 경우에는 다른 구별이 필요하다 : 세그먼트가 rect 아래 나 위를 통과 할 수 있으며, 오른쪽 아래 또는 왼쪽 위 꼭지점이 필요하다.
          if ((value-prevValue)/(key-prevKey)*(keyMax-key)+value < valueMin) // segment passes below R
                                                                             // 세그먼트가 R 아래로 전달됩니다.
          { result << coordsToPixels(keyMin, valueMin) << coordsToPixels(keyMax, valueMin); result.append(result.last()); result << coordsToPixels(keyMax, valueMax); }
          else
          { result << coordsToPixels(keyMin, valueMin) << coordsToPixels(keyMin, valueMax); result.append(result.last()); result << coordsToPixels(keyMax, valueMax); }
          break;
        }
      }
      break;
    }
    case 4:
    {
      switch (currentRegion)
      {
        case 1: { result << coordsToPixels(keyMin, valueMax); break; }
        case 7: { result << coordsToPixels(keyMax, valueMax); break; }
        case 2: { result << coordsToPixels(keyMin, valueMax); result.append(result.last()); break; }
        case 8: { result << coordsToPixels(keyMax, valueMax); result.append(result.last()); break; }
        case 3: { result << coordsToPixels(keyMin, valueMax); result.append(result.last()); result << coordsToPixels(keyMin, valueMin); break; }
        case 9: { result << coordsToPixels(keyMax, valueMax); result.append(result.last()); result << coordsToPixels(keyMax, valueMin); break; }
      }
      break;
    }
    case 5:
    {
      switch (currentRegion)
      {
        case 1: { result << coordsToPixels(keyMin, valueMax); break; }
        case 7: { result << coordsToPixels(keyMax, valueMax); break; }
        case 9: { result << coordsToPixels(keyMax, valueMin); break; }
        case 3: { result << coordsToPixels(keyMin, valueMin); break; }
      }
      break;
    }
    case 6:
    {
      switch (currentRegion)
      {
        case 3: { result << coordsToPixels(keyMin, valueMin); break; }
        case 9: { result << coordsToPixels(keyMax, valueMin); break; }
        case 2: { result << coordsToPixels(keyMin, valueMin); result.append(result.last()); break; }
        case 8: { result << coordsToPixels(keyMax, valueMin); result.append(result.last()); break; }
        case 1: { result << coordsToPixels(keyMin, valueMin); result.append(result.last()); result << coordsToPixels(keyMin, valueMax); break; }
        case 7: { result << coordsToPixels(keyMax, valueMin); result.append(result.last()); result << coordsToPixels(keyMax, valueMax); break; }
      }
      break;
    }
    case 7:
    {
      switch (currentRegion)
      {
        case 4: { result << coordsToPixels(keyMax, valueMax); break; }
        case 8: { result << coordsToPixels(keyMax, valueMax); break; }
        case 1: { result << coordsToPixels(keyMax, valueMax) << coordsToPixels(keyMin, valueMax); break; }
        case 9: { result << coordsToPixels(keyMax, valueMax) << coordsToPixels(keyMax, valueMin); break; }
        case 2: { result << coordsToPixels(keyMax, valueMax) << coordsToPixels(keyMin, valueMax); result.append(result.last()); break; }
        case 6: { result << coordsToPixels(keyMax, valueMax) << coordsToPixels(keyMax, valueMin); result.append(result.last()); break; }
        case 3: { // in this case we need another distinction of cases: segment may pass below or above rect, requiring either bottom right or top left corner points
//이 경우에는 다른 구별이 필요하다 : 세그먼트가 rect 아래 나 위를 통과 할 수 있으며, 오른쪽 아래 또는 왼쪽 위 꼭지점이 필요하다.
          if ((value-prevValue)/(key-prevKey)*(keyMax-key)+value < valueMin) // segment passes below R
                                                                             // 세그먼트가 R 아래로 전달됩니다.
          { result << coordsToPixels(keyMax, valueMax) << coordsToPixels(keyMax, valueMin); result.append(result.last()); result << coordsToPixels(keyMin, valueMin); }
          else
          { result << coordsToPixels(keyMax, valueMax) << coordsToPixels(keyMin, valueMax); result.append(result.last()); result << coordsToPixels(keyMin, valueMin); }
          break;
        }
      }
      break;
    }
    case 8:
    {
      switch (currentRegion)
      {
        case 7: { result << coordsToPixels(keyMax, valueMax); break; }
        case 9: { result << coordsToPixels(keyMax, valueMin); break; }
        case 4: { result << coordsToPixels(keyMax, valueMax); result.append(result.last()); break; }
        case 6: { result << coordsToPixels(keyMax, valueMin); result.append(result.last()); break; }
        case 1: { result << coordsToPixels(keyMax, valueMax); result.append(result.last()); result << coordsToPixels(keyMin, valueMax); break; }
        case 3: { result << coordsToPixels(keyMax, valueMin); result.append(result.last()); result << coordsToPixels(keyMin, valueMin); break; }
      }
      break;
    }
    case 9:
    {
      switch (currentRegion)
      {
        case 6: { result << coordsToPixels(keyMax, valueMin); break; }
        case 8: { result << coordsToPixels(keyMax, valueMin); break; }
        case 3: { result << coordsToPixels(keyMax, valueMin) << coordsToPixels(keyMin, valueMin); break; }
        case 7: { result << coordsToPixels(keyMax, valueMin) << coordsToPixels(keyMax, valueMax); break; }
        case 2: { result << coordsToPixels(keyMax, valueMin) << coordsToPixels(keyMin, valueMin); result.append(result.last()); break; }
        case 4: { result << coordsToPixels(keyMax, valueMin) << coordsToPixels(keyMax, valueMax); result.append(result.last()); break; }
        case 1: { // in this case we need another distinction of cases: segment may pass below or above rect, requiring either bottom right or top left corner points
//이 경우에는 다른 구분이 필요합니다. 세그먼트가 오른쪽 아래 또는 왼쪽 상단 구석을 필요로하는 rect 아래 또는 위를 통과 할 수 있습니다.
          if ((value-prevValue)/(key-prevKey)*(keyMin-key)+value < valueMin) // segment passes below R
                                                                             // 세그먼트가 R 아래로 전달됩니다.
          { result << coordsToPixels(keyMax, valueMin) << coordsToPixels(keyMin, valueMin); result.append(result.last()); result << coordsToPixels(keyMin, valueMax); }
          else
          { result << coordsToPixels(keyMax, valueMin) << coordsToPixels(keyMax, valueMax); result.append(result.last()); result << coordsToPixels(keyMin, valueMax); }
          break;
        }
      }
      break;
    }
  }
  return result;
}

/*! \internal
  
  This function is part of the curve optimization algorithm of \ref getCurveLines.
  
  This method returns whether a segment going from \a prevRegion to \a currentRegion (see \ref
  getRegion) may traverse the visible region 5. This function assumes that neither \a prevRegion
  nor \a currentRegion is 5 itself.
  
  If this method returns false, the segment for sure doesn't pass region 5. If it returns true, the
  segment may or may not pass region 5 and a more fine-grained calculation must be used (\ref
  getTraverse).
*/
/*! \내부의
  
  이 함수는 \ ref getCurveLines의 곡선 최적화 알고리즘의 일부입니다.
  
  이 메소드는 \ a prevRegion에서 \ currentRegion으로가는 세그먼트를 리턴합니다 (\ ref 참조).
  getRegion)는 가시 영역 (visible region) 5를 통과 할 수 있습니다.이 함수는 \ a prevRegion
  \ currentRegion도 5가 아닙니다.
  
  이 메소드가 false를 돌려 주면 (자), 세그먼트 (segment)는 확실히 영역 5를 건네주지 않습니다.
  세그먼트는 영역 5를 통과 할 수도 있고 통과하지 않을 수도 있으며보다 세분화 된 계산을 사용해야합니다 (\ ref
  getTraverse).
*/
bool QCPCurve::mayTraverse(int prevRegion, int currentRegion) const
{
  switch (prevRegion)
  {
    case 1:
    {
      switch (currentRegion)
      {
        case 4:
        case 7:
        case 2:
        case 3: return false;
        default: return true;
      }
    }
    case 2:
    {
      switch (currentRegion)
      {
        case 1:
        case 3: return false;
        default: return true;
      }
    }
    case 3:
    {
      switch (currentRegion)
      {
        case 1:
        case 2:
        case 6:
        case 9: return false;
        default: return true;
      }
    }
    case 4:
    {
      switch (currentRegion)
      {
        case 1:
        case 7: return false;
        default: return true;
      }
    }
    case 5: return false; // should never occur  
    case 6:               // 결코 발생해서는 안됩니다.
    {
      switch (currentRegion)
      {
        case 3:
        case 9: return false;
        default: return true;
      }
    }
    case 7:
    {
      switch (currentRegion)
      {
        case 1:
        case 4:
        case 8:
        case 9: return false;
        default: return true;
      }
    }
    case 8:
    {
      switch (currentRegion)
      {
        case 7:
        case 9: return false;
        default: return true;
      }
    }
    case 9:
    {
      switch (currentRegion)
      {
        case 3:
        case 6:
        case 8:
        case 7: return false;
        default: return true;
      }
    }
    default: return true;
  }
}


/*! \internal
  
  This function is part of the curve optimization algorithm of \ref getCurveLines.
  
  This method assumes that the \ref mayTraverse test has returned true, so there is a chance the
  segment defined by (\a prevKey, \a prevValue) and (\a key, \a value) goes through the visible
  region 5.
  
  The return value of this method indicates whether the segment actually traverses region 5 or not.
  
  If the segment traverses 5, the output parameters \a crossA and \a crossB indicate the entry and
  exit points of region 5. They will become the optimized points for that segment.
*/
/*! \내부의
  
  이 함수는 \ ref getCurveLines의 곡선 최적화 알고리즘의 일부입니다.
  
  이 방법은 \ ref mayTraverse 테스트가 true를 반환했다고 가정하므로
  세그먼트 (\ a prevKey, \ a prevValue)와 (\ a 키, \ a 값)에 의해 정의 된 세그먼트는
  영역 5.
  
  이 메서드의 반환 값은 세그먼트가 실제로 영역 5를 통과하는지 여부를 나타냅니다.
  
  세그먼트가 5를 통과하면 출력 매개 변수 인 \ a crossA와 \ a crossB가 항목을 나타내고
  영역 5의 종료점. 해당 세그먼트에 최적화 된 점이됩니다.
*/
bool QCPCurve::getTraverse(double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin, QPointF &crossA, QPointF &crossB) const
{
  // The intersection point interpolation here is done in pixel coordinates, so we don't need to
  // differentiate between different axis scale types. Note that the nomenclature
  // top/left/bottom/right/min/max is with respect to the rect in plot coordinates, wich may be
  // different in pixel coordinates (horz/vert key axes, reversed ranges)
  // 여기서 교차점 보간은 픽셀 좌표로 이루어 지므로 필요하지 않습니다.
  // 서로 다른 축척 유형을 구분합니다. 그 명명법
  // top / left / bottom / right / min / max는 플롯 좌표의 rect를 기준으로합니다.
  // 픽셀 좌표에서 다른 점 (horz / vert key 축, 반전 된 범위)
  
  QList<QPointF> intersections;
  const double valueMinPx = mValueAxis->coordToPixel(valueMin);
  const double valueMaxPx = mValueAxis->coordToPixel(valueMax);
  const double keyMinPx = mKeyAxis->coordToPixel(keyMin);
  const double keyMaxPx = mKeyAxis->coordToPixel(keyMax);
  const double keyPx = mKeyAxis->coordToPixel(key);
  const double valuePx = mValueAxis->coordToPixel(value);
  const double prevKeyPx = mKeyAxis->coordToPixel(prevKey);
  const double prevValuePx = mValueAxis->coordToPixel(prevValue);
  if (qFuzzyIsNull(key-prevKey)) // line is parallel to value axis
  {                              // 행이 값 축과 평행하다.
    // due to region filter in mayTraverse(), if line is parallel to value or key axis, region 5 is traversed here
    // mayTraverse ()의 영역 필터로 인해, 행이 값 또는 키 축과 평행하면 영역 5가 여기에서 통과합니다.
    intersections.append(mKeyAxis->orientation() == Qt::Horizontal ? QPointF(keyPx, valueMinPx) : QPointF(valueMinPx, keyPx)); 
    // direction will be taken care of at end of method
    // 메소드의 끝에서 direction이 처리됩니다.
    intersections.append(mKeyAxis->orientation() == Qt::Horizontal ? QPointF(keyPx, valueMaxPx) : QPointF(valueMaxPx, keyPx));
  } else if (qFuzzyIsNull(value-prevValue)) // line is parallel to key axis
  {                                         // 행이 키 축에 평행합니다.
    // due to region filter in mayTraverse(), if line is parallel to value or key axis, region 5 is traversed here
    // mayTraverse ()의 영역 필터로 인해, 행이 값 또는 키 축과 평행하면 영역 5가 여기에서 통과합니다.
    intersections.append(mKeyAxis->orientation() == Qt::Horizontal ? QPointF(keyMinPx, valuePx) : QPointF(valuePx, keyMinPx)); 
    // direction will be taken care of at end of method
    // 메소드의 끝에서 direction이 처리됩니다.
    intersections.append(mKeyAxis->orientation() == Qt::Horizontal ? QPointF(keyMaxPx, valuePx) : QPointF(valuePx, keyMaxPx));
  } else // line is skewed  // 줄이 비뚤어졌습니다.
  {
    double gamma;
    double keyPerValuePx = (keyPx-prevKeyPx)/(valuePx-prevValuePx);
    // check top of rect:   // rect of top 검색 :
    gamma = prevKeyPx + (valueMaxPx-prevValuePx)*keyPerValuePx;
    if (gamma >= qMin(keyMinPx, keyMaxPx) && gamma <= qMax(keyMinPx, keyMaxPx))
    // qMin/qMax necessary since axes may be reversed
    // 축이 역전 될 수 있기 때문에 필요한 경우
      intersections.append(mKeyAxis->orientation() == Qt::Horizontal ? QPointF(gamma, valueMaxPx) : QPointF(valueMaxPx, gamma));
    // check bottom of rect:  // rect의 하단을 확인하십시오.
    gamma = prevKeyPx + (valueMinPx-prevValuePx)*keyPerValuePx;
    if (gamma >= qMin(keyMinPx, keyMaxPx) && gamma <= qMax(keyMinPx, keyMaxPx)) 
    // qMin/qMax necessary since axes may be reversed
    // 축이 역전 될 수 있기 때문에 필요한 경우
      intersections.append(mKeyAxis->orientation() == Qt::Horizontal ? QPointF(gamma, valueMinPx) : QPointF(valueMinPx, gamma));
    const double valuePerKeyPx = 1.0/keyPerValuePx;
    // check left of rect:   // rect 왼쪽의 체크 :
    gamma = prevValuePx + (keyMinPx-prevKeyPx)*valuePerKeyPx;
    if (gamma >= qMin(valueMinPx, valueMaxPx) && gamma <= qMax(valueMinPx, valueMaxPx))
    // qMin/qMax necessary since axes may be reversed
    // 축이 역전 될 수 있기 때문에 필요한 경우
      intersections.append(mKeyAxis->orientation() == Qt::Horizontal ? QPointF(keyMinPx, gamma) : QPointF(gamma, keyMinPx));
    // check right of rect:  // rect의 오른쪽을 검사합니다.
    gamma = prevValuePx + (keyMaxPx-prevKeyPx)*valuePerKeyPx;
    if (gamma >= qMin(valueMinPx, valueMaxPx) && gamma <= qMax(valueMinPx, valueMaxPx)) 
    // qMin/qMax necessary since axes may be reversed
    // 축이 역전 될 수 있기 때문에 필요한 경우
      intersections.append(mKeyAxis->orientation() == Qt::Horizontal ? QPointF(keyMaxPx, gamma) : QPointF(gamma, keyMaxPx));
  }
  
  // handle cases where found points isn't exactly 2:
  // 발견 된 점이 정확히 2가 아닌 경우를 처리합니다.
  if (intersections.size() > 2)
  {
    // line probably goes through corner of rect, and we got duplicate points there. single out the point pair with greatest distance in between:
    // 직선이 rect의 모서리를 통과 할 가능성이 있습니다. 중복 점이 있습니다. 사이의 거리가 가장 긴 점 쌍을 하나씩 선택하십시오.
    double distSqrMax = 0;
    QPointF pv1, pv2;
    for (int i=0; i<intersections.size()-1; ++i)
    {
      for (int k=i+1; k<intersections.size(); ++k)
      {
        QPointF distPoint = intersections.at(i)-intersections.at(k);
        double distSqr = distPoint.x()*distPoint.x()+distPoint.y()+distPoint.y();
        if (distSqr > distSqrMax)
        {
          pv1 = intersections.at(i);
          pv2 = intersections.at(k);
          distSqrMax = distSqr;
        }
      }
    }
    intersections = QList<QPointF>() << pv1 << pv2;
  } else if (intersections.size() != 2)
  {
// one or even zero points found (shouldn't happen unless line perfectly tangent to corner), no need to draw segment
// 하나 또는 심지어 영점을 찾았습니다 (코너가 완벽하게 접하지 않으면 안됩니다). 세그먼트를 그릴 필요가 없습니다.
    return false;
  }
  
// possibly re-sort points so optimized point segment has same direction as original segment:
// 최적화 된 포인트 세그먼트가 원래 세그먼트와 같은 방향을 갖도록 포인트를 다시 정렬 할 수 있습니다 :
  double xDelta = keyPx-prevKeyPx;
  double yDelta = valuePx-prevValuePx;
  if (mKeyAxis->orientation() != Qt::Horizontal)
    qSwap(xDelta, yDelta);
  if (xDelta*(intersections.at(1).x()-intersections.at(0).x()) + yDelta*(intersections.at(1).y()-intersections.at(0).y()) < 0) 
// scalar product of both segments < 0 -> opposite direction
// 두 세그먼트의 스칼라 곱 <0 -> 반대 방향
    intersections.move(0, 1);
  crossA = intersections.at(0);
  crossB = intersections.at(1);
  return true;
}

/*! \internal
  
  This function is part of the curve optimization algorithm of \ref getCurveLines.
  
  This method assumes that the \ref getTraverse test has returned true, so the segment definitely
  traverses the visible region 5 when going from \a prevRegion to \a currentRegion.
  
  In certain situations it is not sufficient to merely generate the entry and exit points of the
  segment into/out of region 5, as \ref getTraverse provides. It may happen that a single segment, in
  addition to traversing region 5, skips another region outside of region 5, which makes it
  necessary to add an optimized corner point there (very similar to the job \ref
  getOptimizedCornerPoints does for segments that are completely in outside regions and don't
  traverse 5).
  
  As an example, consider a segment going from region 1 to region 6, traversing the lower left
  corner of region 5. In this configuration, the segment additionally crosses the border between
  region 1 and 2 before entering region 5. This makes it necessary to add an additional point in
  the top left corner, before adding the optimized traverse points. So in this case, the output
  parameter \a beforeTraverse will contain the top left corner point, and \a afterTraverse will be
  empty.
  
  In some cases, such as when going from region 1 to 9, it may even be necessary to add additional
  corner points before and after the traverse. Then both \a beforeTraverse and \a afterTraverse
  return the respective corner points.
*/
/*! \내부의
  
  이 함수는 \ ref getCurveLines의 곡선 최적화 알고리즘의 일부입니다.
  
  이 방법은 \ ref getTraverse 테스트가 true를 반환한다고 가정하므로 세그먼트가 명확하게
  \ a prevRegion에서 \ currentRegion으로 갈 때 보이는 영역 5를 가로 지른다.
  
  특정 상황에서 단순히 출입 지점을 생성하는 것만으로는 충분하지 않습니다.
  \ ref getTraverse가 제공하는 것과 같이, 영역 5로 / 밖으로 세그먼트. 단일 세그먼트가
  횡단 영역 5에 추가하면 영역 5 외부의 다른 영역을 건너 뜁니다.
  최적화 된 모서리 점을 추가하는 데 필요합니다 (작업 \ ref와 매우 유사 함).
  getOptimizedCornerPoints는 완전히 바깥 영역에 있고 세그먼트가 아닌 세그먼트에 적용됩니다.
  트래버스 5).
  
  예를 들어, 영역 1에서 영역 6으로 진행하는 세그먼트를 고려하여 왼쪽 아래를
  영역 (5)의 코너 (corner).이 구성에서, 세그먼트는 추가로
  영역 1과 영역 2에 추가하기 전에 2를 추가해야합니다.
  최적화 된 트래버스 점을 추가하기 전에 왼쪽 상단 모서리. 따라서이 경우 출력
  매개 변수 \ a beforeTraverse는 좌상단 점을 포함하고 \ a afterTraverse는
  빈.
  
  경우에 따라 지역 1에서 9로 갈 때와 같이 추가로 추가해야 할 수도 있습니다
  트래버스 전과 후의 코너 포인트. 그런 다음 \ a beforeTraverse와 \ a afterTraverse
  해당 구석 점을 반환하십시오.
*/
void QCPCurve::getTraverseCornerPoints(int prevRegion, int currentRegion, double keyMin, double valueMax, double keyMax, double valueMin, QVector<QPointF> &beforeTraverse, QVector<QPointF> &afterTraverse) const
{
  switch (prevRegion)
  {
    case 1:
    {
      switch (currentRegion)
      {
        case 6: { beforeTraverse << coordsToPixels(keyMin, valueMax); break; }
        case 9: { beforeTraverse << coordsToPixels(keyMin, valueMax); afterTraverse << coordsToPixels(keyMax, valueMin); break; }
        case 8: { beforeTraverse << coordsToPixels(keyMin, valueMax); break; }
      }
      break;
    }
    case 2:
    {
      switch (currentRegion)
      {
        case 7: { afterTraverse << coordsToPixels(keyMax, valueMax); break; }
        case 9: { afterTraverse << coordsToPixels(keyMax, valueMin); break; }
      }
      break;
    }
    case 3:
    {
      switch (currentRegion)
      {
        case 4: { beforeTraverse << coordsToPixels(keyMin, valueMin); break; }
        case 7: { beforeTraverse << coordsToPixels(keyMin, valueMin); afterTraverse << coordsToPixels(keyMax, valueMax); break; }
        case 8: { beforeTraverse << coordsToPixels(keyMin, valueMin); break; }
      }
      break;
    }
    case 4:
    {
      switch (currentRegion)
      {
        case 3: { afterTraverse << coordsToPixels(keyMin, valueMin); break; }
        case 9: { afterTraverse << coordsToPixels(keyMax, valueMin); break; }
      }
      break;
    }
    case 5: { break; } // shouldn't happen because this method only handles full traverses
    case 6:            //이 메서드는 전체 탐색 만 처리하기 때문에 // 발생하지 않아야합니다.
    {
      switch (currentRegion)
      {
        case 1: { afterTraverse << coordsToPixels(keyMin, valueMax); break; }
        case 7: { afterTraverse << coordsToPixels(keyMax, valueMax); break; }
      }
      break;
    }
    case 7:
    {
      switch (currentRegion)
      {
        case 2: { beforeTraverse << coordsToPixels(keyMax, valueMax); break; }
        case 3: { beforeTraverse << coordsToPixels(keyMax, valueMax); afterTraverse << coordsToPixels(keyMin, valueMin); break; }
        case 6: { beforeTraverse << coordsToPixels(keyMax, valueMax); break; }
      }
      break;
    }
    case 8:
    {
      switch (currentRegion)
      {
        case 1: { afterTraverse << coordsToPixels(keyMin, valueMax); break; }
        case 3: { afterTraverse << coordsToPixels(keyMin, valueMin); break; }
      }
      break;
    }
    case 9:
    {
      switch (currentRegion)
      {
        case 2: { beforeTraverse << coordsToPixels(keyMax, valueMin); break; }
        case 1: { beforeTraverse << coordsToPixels(keyMax, valueMin); afterTraverse << coordsToPixels(keyMin, valueMax); break; }
        case 4: { beforeTraverse << coordsToPixels(keyMax, valueMin); break; }
      }
      break;
    }
  }
}

/*! \internal
  
  Calculates the (minimum) distance (in pixels) the curve's representation has from the given \a
  pixelPoint in pixels. This is used to determine whether the curve was clicked or not, e.g. in
  \ref selectTest. The closest data point to \a pixelPoint is returned in \a closestData. Note that
  if the curve has a line representation, the returned distance may be smaller than the distance to
  the \a closestData point, since the distance to the curve line is also taken into account.
  
  If either the curve has no data or if the line style is \ref lsNone and the scatter style's shape
  is \ref QCPScatterStyle::ssNone (i.e. there is no visual representation of the curve), returns
  -1.0.
*/
/*! \내부의
  
  주어진 \ a에서 곡선 표현이 갖는 (최소) 거리 (픽셀 단위)를 계산합니다.
  픽셀 단위의 pixelPoint. 곡선이 클릭되었는지 여부를 결정하는 데 사용됩니다. 예 :
  \ ref selectTest. \ pixelPoint에 가장 근접한 데이터 포인트는 \ nearestData에 반환됩니다. 유의 사항
  커브에 선 표시가있는 경우 반환 된 거리가 다음 거리보다 작을 수 있습니다.
  커브 라인까지의 거리도 고려되기 때문에 \ a closestData 포인트.
  
  곡선에 데이터가 없거나 선 스타일이 \ ref lsNone이고 스 캐터 스타일의 모양 인 경우
  \ ref QCPScatterStyle :: ssNone입니다 (즉, 곡선의 시각적 표현이 없음).
  -1.0.
*/
double QCPCurve::pointDistance(const QPointF &pixelPoint, QCPCurveDataContainer::const_iterator &closestData) const
{
  closestData = mDataContainer->constEnd();
  if (mDataContainer->isEmpty())
    return -1.0;
  if (mLineStyle == lsNone && mScatterStyle.isNone())
    return -1.0;
  
  if (mDataContainer->size() == 1)
  {
    QPointF dataPoint = coordsToPixels(mDataContainer->constBegin()->key, mDataContainer->constBegin()->value);
    closestData = mDataContainer->constBegin();
    return QCPVector2D(dataPoint-pixelPoint).length();
  }
  
  // calculate minimum distances to curve data points and find closestData iterator:
  // 최소 거리를 계산하여 데이터 포인트를 곡선으로 만들고 closestData를 찾습니다. iterator 
  double minDistSqr = std::numeric_limits<double>::max();
  // iterate over found data points and then choose the one with the shortest distance to pos:
  // 찾은 데이터 포인트를 반복 한 다음 pos와 가장 가까운 거리를 선택합니다.
  QCPCurveDataContainer::const_iterator begin = mDataContainer->constBegin();
  QCPCurveDataContainer::const_iterator end = mDataContainer->constEnd();
  for (QCPCurveDataContainer::const_iterator it=begin; it!=end; ++it)
  {
    const double currentDistSqr = QCPVector2D(coordsToPixels(it->key, it->value)-pixelPoint).lengthSquared();
    if (currentDistSqr < minDistSqr)
    {
      minDistSqr = currentDistSqr;
      closestData = it;
    }
  }
  
  // calculate distance to line if there is one (if so, will probably be smaller than distance to closest data point):
  // 존재하는 경우 라인까지 거리를 계산합니다 (그렇다면 가장 가까운 데이터 포인트까지의 거리보다 작을 것입니다).
  if (mLineStyle != lsNone)
  {
    QVector<QPointF> lines;
    getCurveLines(&lines, QCPDataRange(0, dataCount()), mParentPlot->selectionTolerance()*1.2); 
  // optimized lines outside axis rect shouldn't respond to clicks at the edge, so use 1.2*tolerance as pen width
  // 축 rect 외부의 최적화 된 선은 가장자리의 클릭에 응답하지 않아야하므로 펜 너비로 1.2 * 공차를 사용하십시오.
    for (int i=0; i<lines.size()-1; ++i)
    {
      double currentDistSqr = QCPVector2D(pixelPoint).distanceSquaredToLine(lines.at(i), lines.at(i+1));
      if (currentDistSqr < minDistSqr)
        minDistSqr = currentDistSqr;
    }
  }
  
  return qSqrt(minDistSqr);
}
/* end of 'src/plottables/plottable-curve.cpp' */


/* including file 'src/plottables/plottable-bars.cpp', size 43512            */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / plottables / plottable-curve.cpp'의 끝 */


/* 파일 'src / plottables / plottable-bars.cpp'포함, 크기 43512 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPBarsGroup
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPBarsGroup
  \brief Groups multiple QCPBars together so they appear side by side
  
  \image html QCPBarsGroup.png
  
  When showing multiple QCPBars in one plot which have bars at identical keys, it may be desirable
  to have them appearing next to each other at each key. This is what adding the respective QCPBars
  plottables to a QCPBarsGroup achieves. (An alternative approach is to stack them on top of each
  other, see \ref QCPBars::moveAbove.)
  
  \section qcpbarsgroup-usage Usage
  
  To add a QCPBars plottable to the group, create a new group and then add the respective bars
  intances:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpbarsgroup-creation
  Alternatively to appending to the group like shown above, you can also set the group on the
  QCPBars plottable via \ref QCPBars::setBarsGroup.
  
  The spacing between the bars can be configured via \ref setSpacingType and \ref setSpacing. The
  bars in this group appear in the plot in the order they were appended. To insert a bars plottable
  at a certain index position, or to reposition a bars plottable which is already in the group, use
  \ref insert.
  
  To remove specific bars from the group, use either \ref remove or call \ref
  QCPBars::setBarsGroup "QCPBars::setBarsGroup(0)" on the respective bars plottable.
  
  To clear the entire group, call \ref clear, or simply delete the group.
  
  \section qcpbarsgroup-example Example
  
  The image above is generated with the following code:
  \snippet documentation/doc-image-generator/mainwindow.cpp qcpbarsgroup-example
*/
/*! \ class QCPBarsGroup
  \ brief 여러 QCPBars를 나란히 그룹화하여 그룹화합니다.
  
  \ image html QCPBarsGroup.png
  
  동일한 키에 막대가있는 하나의 플롯에 여러 개의 QCPBar를 표시하는 경우 바람직 할 수 있습니다
  각 키마다 서로 옆에 나타나게합니다. 이것은 각각의 QCPBars를 추가하는 것입니다.
  QCPBarsGroup에 대한 plottables가 성취합니다. (대체 접근법은 각각의 위에 스택을 쌓는 것이다.
  기타, \ ref QCPBars :: moveAbove를 참조하십시오.)
  
  \ section qcpbarsgroup-usage 사용법
  
  그룹에 QCPBars 플롯 테이블을 추가하려면 새 그룹을 만든 다음 해당 막대를 추가하십시오
  intances :
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpbarsgroup-creation
  위에 표시된 것과 같이 그룹에 추가하는 대신 그룹을
  \ ref QCPBars :: setBarsGroup을 통해 플롯 가능한 QCPBars.
  
  막대 사이의 간격은 \ ref setSpacingType 및 \ ref setSpacing을 통해 구성 할 수 있습니다. 그만큼
  이 그룹의 막대는 추가 된 순서대로 플롯에 나타납니다. 막대 plottable을 삽입하려면
  특정 인덱스 위치에서, 또는 이미 그룹에있는 바 plottable의 위치를 ​​변경하려면 다음을 사용합니다.
  \ ref 삽입.
  
  그룹에서 특정 막대를 제거하려면 \ ref 제거 또는 \ ref를 호출하십시오.
  QCPBars :: setBarsGroup "QCPBars :: setBarsGroup (0)"각 막대에 plottable.
  
  전체 그룹을 지우려면 \ ref 지우기를 호출하거나 단순히 그룹을 지우십시오.
  
  \ section qcpbarsgroup-example 예제
  
  위의 이미지는 다음 코드로 생성됩니다.
  \ snippet documentation / doc-image-generator / mainwindow.cpp qcpbarsgroup-example
*/

/* start of documentation of inline functions */
/* 인라인 함수의 문서화 시작 */

/*! \fn QList<QCPBars*> QCPBarsGroup::bars() const
  
  Returns all bars currently in this group.
  
  \see bars(int index)
*/
/*! \ fn QList <QCPBars *> QCPBarsGroup :: bars () const
  
  이 그룹에 현재있는 모든 막대를 반환합니다.
  
  \ 바 표시 (int index)
*/

/*! \fn int QCPBarsGroup::size() const
  
  Returns the number of QCPBars plottables that are part of this group.
  
*/
/*! \ fn int QCPBarsGroup :: size () const
  
  이 그룹의 일부인 QCPBars 플롯 테이블의 수를 반환합니다.
  
*/

/*! \fn bool QCPBarsGroup::isEmpty() const
  
  Returns whether this bars group is empty.
  
  \see size
*/
/*! \ fn bool QCPBarsGroup :: isEmpty () const
  
  이 바 그룹이 비어 있는지 여부를 반환합니다.
  
  \ 크기를 참조하십시오.
*/

/*! \fn bool QCPBarsGroup::contains(QCPBars *bars)
  
  Returns whether the specified \a bars plottable is part of this group.
  
*/
/*! \ fn bool QCPBarsGroup :: contains (QCPBars * bars)
  
  지정된 \ a bars plottable가이 그룹에 속하는지 여부를 반환합니다.
  
*/

/* end of documentation of inline functions */
/* 인라인 함수의 문서 끝 */

/*!
  Constructs a new bars group for the specified QCustomPlot instance.
*/

/*!
  지정된 QCustomPlot 인스턴스에 대한 새 막대 그룹을 구성합니다.
*/
QCPBarsGroup::QCPBarsGroup(QCustomPlot *parentPlot) :
  QObject(parentPlot),
  mParentPlot(parentPlot),
  mSpacingType(stAbsolute),
  mSpacing(4)
{
}

QCPBarsGroup::~QCPBarsGroup()
{
  clear();
}

/*!
  Sets how the spacing between adjacent bars is interpreted. See \ref SpacingType.
  
  The actual spacing can then be specified with \ref setSpacing.

  \see setSpacing
*/
/*!
  인접한 막대 사이의 간격을 해석하는 방법을 설정합니다. \ ref SpacingType을 참조하십시오.
  
  실제 간격은 \ ref setSpacing으로 지정할 수 있습니다.

  \ setSpacing 참조
*/
void QCPBarsGroup::setSpacingType(SpacingType spacingType)
{
  mSpacingType = spacingType;
}

/*!
  Sets the spacing between adjacent bars. What the number passed as \a spacing actually means, is
  defined by the current \ref SpacingType, which can be set with \ref setSpacingType.

  \see setSpacingType
*/
/*!
  인접한 막대 사이의 간격을 설정합니다. \ 간격이 실제로 전달한 수는 실제로 무엇입니까?
  현재 \ ref SpacingType으로 정의되며 \ ref setSpacingType으로 설정할 수 있습니다.

  \ setSpacingType을 참조하십시오.
*/
void QCPBarsGroup::setSpacing(double spacing)
{
  mSpacing = spacing;
}

/*!
  Returns the QCPBars instance with the specified \a index in this group. If no such QCPBars
  exists, returns 0.

  \see bars(), size
*/
/*!
  이 그룹에 지정된 \ a 인덱스가있는 QCPBars 인스턴스를 반환합니다. 그러한 QCPBars가없는 경우
  존재하면 0을 반환합니다.

  \ bar (), 크기 참조
*/
QCPBars *QCPBarsGroup::bars(int index) const
{
  if (index >= 0 && index < mBars.size())
  {
    return mBars.at(index);
  } else
  {
    qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;
    return 0;
  }
}

/*!
  Removes all QCPBars plottables from this group.

  \see isEmpty
*/
/*!
  이 그룹에서 모든 QCPBars 플롯을 제거합니다.

  \ isEmpty를 참조하십시오.
*/
void QCPBarsGroup::clear()
{
  foreach (QCPBars *bars, mBars) // since foreach takes a copy, removing bars in the loop is okay
                                 // foreach는 복사본을 취하기 때문에 루프의 막대를 제거하는 것이 좋습니다.
    bars->setBarsGroup(0); // removes itself via removeBars
                           // removeBars를 통해 자체를 제거합니다.
}

/*!
  Adds the specified \a bars plottable to this group. Alternatively, you can also use \ref
  QCPBars::setBarsGroup on the \a bars instance.

  \see insert, remove
*/
/*!
  이 그룹에 지정된 \ a bars plottable을 추가합니다. 또는 \ ref도 사용할 수 있습니다.
  \ a bars 인스턴스의 QCPBars :: setBarsGroup.

  \ 삽입물보기, 제거
*/
void QCPBarsGroup::append(QCPBars *bars)
{
  if (!bars)
  {
    qDebug() << Q_FUNC_INFO << "bars is 0";
    return;
  }
    
  if (!mBars.contains(bars))
    bars->setBarsGroup(this);
  else
    qDebug() << Q_FUNC_INFO << "bars plottable is already in this bars group:" << reinterpret_cast<quintptr>(bars);
}

/*!
  Inserts the specified \a bars plottable into this group at the specified index position \a i.
  This gives you full control over the ordering of the bars.
  
  \a bars may already be part of this group. In that case, \a bars is just moved to the new index
  position.

  \see append, remove
*/
/*!
  이 그룹에 지정된 \ a 막대 plottable을 지정된 색인 위치 \ a i에 삽입합니다.
  이렇게하면 막대의 순서를 완전히 제어 할 수 있습니다.
  
  \ bar는 이미이 그룹의 일부일 수 있습니다. 이 경우 \ bar가 새 색인으로 이동됩니다.
  위치.

  \ 추가 참조, 제거
*/
void QCPBarsGroup::insert(int i, QCPBars *bars)
{
  if (!bars)
  {
    qDebug() << Q_FUNC_INFO << "bars is 0";
    return;
  }
  
  // first append to bars list normally:
  // 처음에는 막대 목록에 추가합니다.
  if (!mBars.contains(bars))
    bars->setBarsGroup(this);
  // then move to according position:
  // 다음 위치로 이동 :
  mBars.move(mBars.indexOf(bars), qBound(0, i, mBars.size()-1));
}

/*!
  Removes the specified \a bars plottable from this group.
  
  \see contains, clear
*/
/*!
  이 그룹에서 지정된 \ a bars plottable을 제거합니다.
  
  \ 포함 된 내용보기, 지우기
*/
void QCPBarsGroup::remove(QCPBars *bars)
{
  if (!bars)
  {
    qDebug() << Q_FUNC_INFO << "bars is 0";
    return;
  }
  
  if (mBars.contains(bars))
    bars->setBarsGroup(0);
  else
    qDebug() << Q_FUNC_INFO << "bars plottable is not in this bars group:" << reinterpret_cast<quintptr>(bars);
}

/*! \internal
  
  Adds the specified \a bars to the internal mBars list of bars. This method does not change the
  barsGroup property on \a bars.
  
  \see unregisterBars
*/
/*! \내부의
  
  지정된 \ a 막대를 내부 mBars 막대 목록에 추가합니다. 이 메소드는
  \ bars에 barGroup 속성이 있습니다.
  
  \ unregisterBars를 보라.
*/
void QCPBarsGroup::registerBars(QCPBars *bars)
{
  if (!mBars.contains(bars))
    mBars.append(bars);
}

/*! \internal
  
  Removes the specified \a bars from the internal mBars list of bars. This method does not change
  the barsGroup property on \a bars.
  
  \see registerBars
*/
/*! \내부의
  
  내부 mBars 막대 목록에서 지정된 \ a 막대를 제거합니다. 이 방법은 변경되지 않습니다.
  \ bars에 barGroup 속성이 있습니다.
  
  \ 참조 registerBars
*/

void QCPBarsGroup::unregisterBars(QCPBars *bars)
{
  mBars.removeOne(bars);
}

/*! \internal
  
  Returns the pixel offset in the key dimension the specified \a bars plottable should have at the
  given key coordinate \a keyCoord. The offset is relative to the pixel position of the key
  coordinate \a keyCoord.
*/
/*! \내부의
  
  지정된 \ a bars plottable가 그 키 치수의 픽셀 오프셋을 돌려줍니다.
  지정된 키 좌표 \ a keyCoord. 오프셋은 키의 픽셀 위치를 기준으로합니다.
  좌표 \ a keyCoord.
*/
double QCPBarsGroup::keyPixelOffset(const QCPBars *bars, double keyCoord)
{
  // find list of all base bars in case some mBars are stacked:
  // 일부 mBars가 스택 될 경우 모든 기본 막대 목록 찾기 :
  QList<const QCPBars*> baseBars;
  foreach (const QCPBars *b, mBars)
  {
    while (b->barBelow())
      b = b->barBelow();
    if (!baseBars.contains(b))
      baseBars.append(b);
  }
  // find base bar this "bars" is stacked on:
  //이 "bars"가 적재 된 기본 막대를 찾습니다.
  const QCPBars *thisBase = bars;
  while (thisBase->barBelow())
    thisBase = thisBase->barBelow();
  
  // determine key pixel offset of this base bars considering all other base bars in this barsgroup:
  //이 바 그룹의 다른 모든 기본 바를 고려하여이 기본 막대의 키 픽셀 오프셋을 결정합니다.
  double result = 0;
  int index = baseBars.indexOf(thisBase);
  if (index >= 0)
  {
    if (baseBars.size() % 2 == 1 && index == (baseBars.size()-1)/2) // is center bar (int division on purpose)
    {                                                               // center bar (의도적으로 int division)
      return result;
    } else
    {
      double lowerPixelWidth, upperPixelWidth;
      int startIndex;
      int dir = (index <= (baseBars.size()-1)/2) ? -1 : 1; // if bar is to lower keys of center, dir is negative
                                                           // bar가 중심의 키를 낮추려면 dir은 음수입니다.
      if (baseBars.size() % 2 == 0) // even number of bars
      {                             // 짝수 개의 막대
        startIndex = baseBars.size()/2 + (dir < 0 ? -1 : 0);
        result += getPixelSpacing(baseBars.at(startIndex), keyCoord)*0.5; // half of middle spacing
                                                                          // 중간 간격의 절반
      } else // uneven number of bars
      {      // 바의 고르지 않은 수
        startIndex = (baseBars.size()-1)/2+dir;
        baseBars.at((baseBars.size()-1)/2)->getPixelWidth(keyCoord, lowerPixelWidth, upperPixelWidth);
        result += qAbs(upperPixelWidth-lowerPixelWidth)*0.5; // half of center bar
                                                             // 가운데 막대의 절반
        result += getPixelSpacing(baseBars.at((baseBars.size()-1)/2), keyCoord); // center bar spacing
      }                                                                          // 가운데 막대 간격
      for (int i = startIndex; i != index; i += dir) // add widths and spacings of bars in between center and our bars
      {                                              // 가운데와 막대 사이에 막대의 너비와 간격을 추가합니다.
        baseBars.at(i)->getPixelWidth(keyCoord, lowerPixelWidth, upperPixelWidth);
        result += qAbs(upperPixelWidth-lowerPixelWidth);
        result += getPixelSpacing(baseBars.at(i), keyCoord);
      }
      // finally half of our bars width:
      // 마침내 막대의 절반 width :
      baseBars.at(index)->getPixelWidth(keyCoord, lowerPixelWidth, upperPixelWidth);
      result += qAbs(upperPixelWidth-lowerPixelWidth)*0.5;
      // correct sign of result depending on orientation and direction of key axis:
      // 방향 및 키 축의 방향에 따라 결과의 부호를 수정하십시오.
      result *= dir*thisBase->keyAxis()->pixelOrientation();
    }
  }
  return result;
}

/*! \internal
  
  Returns the spacing in pixels which is between this \a bars and the following one, both at the
  key coordinate \a keyCoord.
  
  \note Typically the returned value doesn't depend on \a bars or \a keyCoord. \a bars is only
  needed to get access to the key axis transformation and axis rect for the modes \ref
  stAxisRectRatio and \ref stPlotCoords. The \a keyCoord is only relevant for spacings given in
  \ref stPlotCoords on a logarithmic axis.
*/
/*! \내부의
  
  이 \ a 막대와 다음 막대 사이의 간격을 픽셀 단위로 반환합니다.
  키 좌표 \ 키 코드.
  
  \ note 일반적으로 반환 값은 \ a bars 또는 \ keyCoord에 의존하지 않습니다. \ a 바는 단지
  모드에 대한 키 축 변형 및 축 rect에 액세스하는 데 필요합니다. \ ref
  stAxisRectRatio 및 \ ref stPlotCoords가 있습니다. \ keyCoord는 다음에 주어진 간격과 관련이 있습니다.
  \ ref stPlotCoords 대수 축입니다.
*/
double QCPBarsGroup::getPixelSpacing(const QCPBars *bars, double keyCoord)
{
  switch (mSpacingType)
  {
    case stAbsolute:
    {
      return mSpacing;
    }
    case stAxisRectRatio:
    {
      if (bars->keyAxis()->orientation() == Qt::Horizontal)
        return bars->keyAxis()->axisRect()->width()*mSpacing;
      else
        return bars->keyAxis()->axisRect()->height()*mSpacing;
    }
    case stPlotCoords:
    {
      double keyPixel = bars->keyAxis()->coordToPixel(keyCoord);
      return qAbs(bars->keyAxis()->coordToPixel(keyCoord+mSpacing)-keyPixel);
    }
  }
  return 0;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPBarsData
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPBarsData
  \brief Holds the data of one single data point (one bar) for QCPBars.
  
  The stored data is:
  \li \a key: coordinate on the key axis of this bar (this is the \a mainKey and the \a sortKey)
  \li \a value: height coordinate on the value axis of this bar (this is the \a mainValue)
  
  The container for storing multiple data points is \ref QCPBarsDataContainer. It is a typedef for
  \ref QCPDataContainer with \ref QCPBarsData as the DataType template parameter. See the
  documentation there for an explanation regarding the data type's generic methods.
  
  \see QCPBarsDataContainer
*/
/*! \ class QCPBarsData
  \ brief QCPBars의 단일 데이터 요소 (한 막대)의 데이터를 보유합니다.
  
  저장된 데이터는 다음과 같습니다.
  \ li \ a key :이 막대의 키 축에서 좌표를 지정합니다 (이 값은 mainKey와 \ a sortKey입니다)
  \ li \ a value :이 막대의 값 축에있는 높이 좌표 (이 값은 \ a mainValue 임)
  
  여러 데이터 요소를 저장하는 컨테이너는 \ ref QCPBarsDataContainer입니다. 그것은에 대한 typedef입니다.
  \ ref QCPDataContainer는 \ ref QCPBarsData를 DataType 템플릿 매개 변수로 사용합니다. 자세한 내용은
  데이터 유형의 제네릭 메소드에 대한 설명은 문서를 참조하십시오.
  
  \ QCPBarsDataContainer 참조
*/

/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */

/*! \fn double QCPBarsData::sortKey() const
  
  Returns the \a key member of this data point.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn 두 번 QCPBarsData :: sortKey () const
  
  이 데이터 포인트의 키 멤버를 돌려줍니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn static QCPBarsData QCPBarsData::fromSortKey(double sortKey)
  
  Returns a data point with the specified \a sortKey. All other members are set to zero.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn 정적 QCPBarsData QCPBarsData :: fromSortKey (double sortKey)
  
  지정된 \ a sortKey를 가지는 데이터 포인트를 돌려줍니다. 다른 모든 멤버는 0으로 설정됩니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn static static bool QCPBarsData::sortKeyIsMainKey()
  
  Since the member \a key is both the data point key coordinate and the data ordering parameter,
  this method returns true.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn 정적 정적 bool QCPBarsData :: sortKeyIsMainKey ()
  
  member \ a 키는 데이터 포인트 키 좌표와 데이터 정렬 매개 변수이기 때문에,
  이 메소드는 true를 리턴합니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn double QCPBarsData::mainKey() const
  
  Returns the \a key member of this data point.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn 두 번 QCPBarsData :: mainKey () const
  
  이 데이터 포인트의 키 멤버를 돌려줍니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn double QCPBarsData::mainValue() const
  
  Returns the \a value member of this data point.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn 두 번 QCPBarsData :: mainValue () const
  
  이 데이터 포인트의 \ a 값 멤버를 반환합니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn QCPRange QCPBarsData::valueRange() const
  
  Returns a QCPRange with both lower and upper boundary set to \a value of this data point.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn QCPRange QCPBarsData :: valueRange () const
  
  이 데이터 포인트의 값에 상한과 하한을 모두 설정 한 QCPRange를 반환합니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */

/*!
  Constructs a bar data point with key and value set to zero.
*/
/*!
  key와 value를 제로로 설정해, bar 데이터 포인트를 구축합니다.
*/

QCPBarsData::QCPBarsData() :
  key(0),
  value(0)
{
}

/*!
  Constructs a bar data point with the specified \a key and \a value.
*/
/*!
  지정된 \ a 키와 \ a 치를 가지는 바 데이타 포인트를 구축합니다.
*/
QCPBarsData::QCPBarsData(double key, double value) :
  key(key),
  value(value)
{
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPBars
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPBars
  \brief A plottable representing a bar chart in a plot.

  \image html QCPBars.png
  
  To plot data, assign it with the \ref setData or \ref addData functions.
  
  \section qcpbars-appearance Changing the appearance
  
  The appearance of the bars is determined by the pen and the brush (\ref setPen, \ref setBrush).
  The width of the individual bars can be controlled with \ref setWidthType and \ref setWidth.
  
  Bar charts are stackable. This means, two QCPBars plottables can be placed on top of each other
  (see \ref QCPBars::moveAbove). So when two bars are at the same key position, they will appear
  stacked.
  
  If you would like to group multiple QCPBars plottables together so they appear side by side as
  shown below, use QCPBarsGroup.
  
  \image html QCPBarsGroup.png
  
  \section qcpbars-usage Usage
  
  Like all data representing objects in QCustomPlot, the QCPBars is a plottable
  (QCPAbstractPlottable). So the plottable-interface of QCustomPlot applies
  (QCustomPlot::plottable, QCustomPlot::removePlottable, etc.)
  
  Usually, you first create an instance:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpbars-creation-1
  which registers it with the QCustomPlot instance of the passed axes. Note that this QCustomPlot instance takes
  ownership of the plottable, so do not delete it manually but use QCustomPlot::removePlottable() instead.
  The newly created plottable can be modified, e.g.:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpbars-creation-2
*/
/*! \ class QCPBars
  \ brief 플롯에서 가로 막 대형 차트를 나타내는 플롯.

  \ image html QCPBars.png
  
  데이터를 플롯하려면 \ ref setData 또는 \ ref addData 함수로 지정하십시오.
  
  \ section qcpbars-appearance 모양 변경
  
  막대의 모양은 펜과 브러시 (\ ref setPen, \ ref setBrush)에 의해 결정됩니다.
  개별 막대의 너비는 \ ref setWidthType 및 \ ref setWidth를 사용하여 제어 할 수 있습니다.
  
  막 대형 차트는 스택 가능합니다. 즉, 두 개의 QCPBars 플롯 테이블을 서로의 위에 배치 할 수 있습니다.
  (\ ref QCPBars :: moveAbove 참조). 두 막대가 같은 키 위치에 있으면
  스택.
  
  여러 개의 QCPBars 플래 튼을 함께 그룹화하여 다음과 같이 나란히 표시하려는 경우
  QCPBarsGroup을 사용하십시오.
  
  \ image html QCPBarsGroup.png
  
  \ section qcpbars-usage 사용법
  
  QCustomPlot의 객체를 나타내는 모든 데이터와 마찬가지로 QCPBars는 plottable입니다.
  (QCPAbstractPlottable). QCustomPlot의 plottable-interface가 적용됩니다.
  (QCustomPlot :: plottable, QCustomPlot :: removePlottable 등)
  
  일반적으로 먼저 인스턴스를 만듭니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpbars-creation-1
  전달 된 축의 QCustomPlot 인스턴스에이를 등록합니다. 이 QCustomPlot 인스턴스는
  plottable의 소유권이므로 수동으로 삭제하지 말고 QCustomPlot :: removePlottable ()을 대신 사용하십시오.
  새로 생성 된 플롯 테이블은 다음과 같이 수정할 수 있습니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpbars-creation-2
*/

/* start of documentation of inline functions */
/* 인라인 함수의 문서화 시작 */

/*! \fn QSharedPointer<QCPBarsDataContainer> QCPBars::data() const
  
  Returns a shared pointer to the internal data storage of type \ref QCPBarsDataContainer. You may
  use it to directly manipulate the data, which may be more convenient and faster than using the
  regular \ref setData or \ref addData methods.
*/
/*! \ fn QSharedPointer <QCPBarsDataContainer> QCPBars :: data () const
  
  \ ref QCPBarsDataContainer 유형의 내부 데이터 저장소에 대한 공유 포인터를 반환합니다. 당신은 할 수있다
  그것을 사용하여 데이터를 직접 조작하십시오. 이는 데이터를 사용하는 것보다 더 편리하고 빠릅니다.
  정규 \ ref setData 또는 \ ref addData 메소드.
*/

/*! \fn QCPBars *QCPBars::barBelow() const
  Returns the bars plottable that is directly below this bars plottable.
  If there is no such plottable, returns 0.
  
  \see barAbove, moveBelow, moveAbove
*/
/*! \ fn QCPBars * QCPBars :: barBelow () const
  이 막대 plottable 바로 아래에있는 막대 plottable을 반환합니다.
  그러한 플롯 테이블이 없으면 0을 반환합니다.
  
  \ barAbove, moveBelow, moveAbove를 참조하십시오.
*/

/*! \fn QCPBars *QCPBars::barAbove() const
  Returns the bars plottable that is directly above this bars plottable.
  If there is no such plottable, returns 0.
  
  \see barBelow, moveBelow, moveAbove
*/
/*! \ fn QCPBars * QCPBars :: barAbove () const
  이 막대 plottable 바로 위에있는 막대 plottable을 반환합니다.
  그러한 플롯 테이블이 없으면 0을 반환합니다.
  
  \ barBelow, moveBelow, moveAbove를 참조하십시오.
*/

/* end of documentation of inline functions */
/* 인라인 함수의 문서 끝 */

/*!
  Constructs a bar chart which uses \a keyAxis as its key axis ("x") and \a valueAxis as its value
  axis ("y"). \a keyAxis and \a valueAxis must reside in the same QCustomPlot instance and not have
  the same orientation. If either of these restrictions is violated, a corresponding message is
  printed to the debug output (qDebug), the construction is not aborted, though.
  
  The created QCPBars is automatically registered with the QCustomPlot instance inferred from \a
  keyAxis. This QCustomPlot instance takes ownership of the QCPBars, so do not delete it manually
  but use QCustomPlot::removePlottable() instead.
*/
/*!
  \ a keyAxis를 키 축 ( "x")으로 사용하는 막대 그래프를 작성해, 값으로서 \ valueAxis를 작성합니다
  축 ( "y"). \ a keyAxis 및 \ a valueAxis는 동일한 QCustomPlot 인스턴스에 있어야하며
  같은 방향. 이러한 제한 사항 중 하나라도 위반하면 해당 메시지가 다음과 같습니다.
  디버그 출력 (qDebug)에 인쇄되면, 구성은 중단되지 않습니다.
  
  생성 된 QCPBars는 \ a에서 유추 한 QCustomPlot 인스턴스에 자동으로 등록됩니다.
  keyAxis. 이 QCustomPlot 인스턴스는 QCPBars의 소유권을 가지므로 수동으로 삭제하지 마십시오.
  QCustomPlot :: removePlottable ()을 대신 사용하십시오.
*/
QCPBars::QCPBars(QCPAxis *keyAxis, QCPAxis *valueAxis) :
  QCPAbstractPlottable1D<QCPBarsData>(keyAxis, valueAxis),
  mWidth(0.75),
  mWidthType(wtPlotCoords),
  mBarsGroup(0),
  mBaseValue(0),
  mStackingGap(0)
{
  // modify inherited properties from abstract plottable:
  // 추상 plottable에서 상속 된 속성 수정 :
  mPen.setColor(Qt::blue);
  mPen.setStyle(Qt::SolidLine);
  mBrush.setColor(QColor(40, 50, 255, 30));
  mBrush.setStyle(Qt::SolidPattern);
  mSelectionDecorator->setBrush(QBrush(QColor(160, 160, 255)));
}

QCPBars::~QCPBars()
{
  setBarsGroup(0);
  if (mBarBelow || mBarAbove)
    connectBars(mBarBelow.data(), mBarAbove.data()); // take this bar out of any stacking
                                                     // 스태킹에서이 막대를 가져옵니다.
}

/*! \overload
  
  Replaces the current data container with the provided \a data container.
  
  Since a QSharedPointer is used, multiple QCPBars may share the same data container safely.
  Modifying the data in the container will then affect all bars that share the container. Sharing
  can be achieved by simply exchanging the data containers wrapped in shared pointers:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpbars-datasharing-1
  
  If you do not wish to share containers, but create a copy from an existing container, rather use
  the \ref QCPDataContainer<DataType>::set method on the bar's data container directly:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpbars-datasharing-2
  
  \see addData
*/
/*! \초과 적재
  
  현재 데이터 컨테이너를 제공된 \ 데이터 컨테이너로 바꿉니다.
  
  QSharedPointer가 사용되므로 여러 QCPBars가 동일한 데이터 컨테이너를 안전하게 공유 할 수 있습니다.
  컨테이너의 데이터를 수정하면 컨테이너를 공유하는 모든 막대에 영향을줍니다. 나누는
  공유 포인터에 랩핑 된 데이터 컨테이너를 단순히 교환하여 얻을 수 있습니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpbars-datasharing-1
  
  컨테이너를 공유하지 않고 기존 컨테이너에서 사본을 만들려면
  bar의 데이터 컨테이너에있는 \ ref QCPDataContainer <DataType> :: set 메서드를 직접 호출합니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpbars-datasharing-2
  
  \ addData를 참조하십시오.
*/
void QCPBars::setData(QSharedPointer<QCPBarsDataContainer> data)
{
  mDataContainer = data;
}

/*! \overload
  
  Replaces the current data with the provided points in \a keys and \a values. The provided
  vectors should have equal length. Else, the number of added points will be the size of the
  smallest vector.
  
  If you can guarantee that the passed data points are sorted by \a keys in ascending order, you
  can set \a alreadySorted to true, to improve performance by saving a sorting run.
  
  \see addData
*/
/*! \초과 적재
  
  현재 데이터를 \ a 키와 \ a 값의 제공된 점으로 바꿉니다. 제공된
  벡터의 길이는 동일해야합니다. 그렇지 않으면 추가 된 포인트의 수는
  가장 작은 벡터.
  
  전달 된 데이터 요소가 \ a 키에 따라 오름차순으로 정렬되도록 보장 할 수 있으면
  정렬 실행을 저장하여 성능을 향상 시키려면 \ a alreadySorted를 true로 설정할 수 있습니다.
  
  \ addData를 참조하십시오.
*/
void QCPBars::setData(const QVector<double> &keys, const QVector<double> &values, bool alreadySorted)
{
  mDataContainer->clear();
  addData(keys, values, alreadySorted);
}

/*!
  Sets the width of the bars.

  How the number passed as \a width is interpreted (e.g. screen pixels, plot coordinates,...),
  depends on the currently set width type, see \ref setWidthType and \ref WidthType.
*/

/*!
  막대의 너비를 설정합니다.

  폭이 해석 될 때 숫자가 전달되는 방식 (예 : 화면 픽셀, 플롯 좌표, ...),
  현재 설정된 너비 유형에 따라 다릅니다. \ ref setWidthType 및 \ ref WidthType을 참조하십시오.
*/
void QCPBars::setWidth(double width)
{
  mWidth = width;
}

/*!
  Sets how the width of the bars is defined. See the documentation of \ref WidthType for an
  explanation of the possible values for \a widthType.
  
  The default value is \ref wtPlotCoords.
  
  \see setWidth
*/
/*!
  막대의 폭을 정의하는 방법을 설정합니다. \ ref WidthType 문서를 참조하십시오.
  \ a widthType에 가능한 값 설명.
  
  기본값은 \ ref wtPlotCoords입니다.
  
  \ 참조 setWidth
*/
void QCPBars::setWidthType(QCPBars::WidthType widthType)
{
  mWidthType = widthType;
}

/*!
  Sets to which QCPBarsGroup this QCPBars instance belongs to. Alternatively, you can also use \ref
  QCPBarsGroup::append.
  
  To remove this QCPBars from any group, set \a barsGroup to 0.
*/
/*!
  이 QCPBars 인스턴스가 속한 QCPBarsGroup을 설정합니다. 또는 \ ref도 사용할 수 있습니다.
  QCPBarsGroup :: append.
  
  모든 그룹에서이 QCPBars를 제거하려면 \ a barsGroup을 0으로 설정하십시오.
*/
void QCPBars::setBarsGroup(QCPBarsGroup *barsGroup)
{
  // deregister at old group:
  // 이전 그룹에서 등록 취소 :
  if (mBarsGroup)
    mBarsGroup->unregisterBars(this);
  mBarsGroup = barsGroup;
  // register at new group:
  // 새 그룹에 등록 :
  if (mBarsGroup)
    mBarsGroup->registerBars(this);
}

/*!
  Sets the base value of this bars plottable.

  The base value defines where on the value coordinate the bars start. How far the bars extend from
  the base value is given by their individual value data. For example, if the base value is set to
  1, a bar with data value 2 will have its lowest point at value coordinate 1 and highest point at
  3.
  
  For stacked bars, only the base value of the bottom-most QCPBars has meaning.
  
  The default base value is 0.
*/
/*!
  이 막대의 기본 값을 plottable로 설정합니다.

  기본 값은 막대가 시작하는 값 좌표의 위치를 ​​정의합니다. 막대가 얼마나 멀리에서 연장하는지
  기본 값은 개별 값 데이터로 제공됩니다. 예를 들어, 기본 값이로 설정된 경우
  1 인 경우, 데이터 값 2 인 막대는 값 좌표 1에서 가장 낮은 점을 가지며 가장 높은 점은
  삼.
  
  스택 막대의 경우 맨 아래에있는 QCPBars의 기본 값만 의미가 있습니다.
  
  기본 기본 값은 0입니다.
*/
void QCPBars::setBaseValue(double baseValue)
{
  mBaseValue = baseValue;
}

/*!
  If this bars plottable is stacked on top of another bars plottable (\ref moveAbove), this method
  allows specifying a distance in \a pixels, by which the drawn bar rectangles will be separated by
  the bars below it.
*/
/*!
  이 막대 plottable이 다른 막대 plottable (\ ref moveAbove) 위에 쌓인 경우이 방법
  그려진 막대 사각형이 픽셀 단위로 거리를 지정할 수 있습니다.
  그 아래의 바.
*/
void QCPBars::setStackingGap(double pixels)
{
  mStackingGap = pixels;
}

/*! \overload
  
  Adds the provided points in \a keys and \a values to the current data. The provided vectors
  should have equal length. Else, the number of added points will be the size of the smallest
  vector.
  
  If you can guarantee that the passed data points are sorted by \a keys in ascending order, you
  can set \a alreadySorted to true, to improve performance by saving a sorting run.
  
  Alternatively, you can also access and modify the data directly via the \ref data method, which
  returns a pointer to the internal data container.
*/
/*! \초과 적재
  
  \ a 키와 \ a 값에 제공된 점을 현재 데이터에 추가합니다. 제공된 벡터
  길이가 같아야합니다. 그렇지 않으면 추가 된 포인트의 수는 가장 작은 것의 크기가됩니다.
  벡터.
  
  전달 된 데이터 요소가 \ a 키에 따라 오름차순으로 정렬되도록 보장 할 수 있으면
  정렬 실행을 저장하여 성능을 향상 시키려면 \ a alreadySorted를 true로 설정할 수 있습니다.
  
  또는 \ ref 데이터 메서드를 통해 직접 데이터에 액세스하고 수정할 수도 있습니다.
  내부 데이터 컨테이너에 대한 포인터를 반환합니다.
*/
void QCPBars::addData(const QVector<double> &keys, const QVector<double> &values, bool alreadySorted)
{
  if (keys.size() != values.size())
    qDebug() << Q_FUNC_INFO << "keys and values have different sizes:" << keys.size() << values.size();
  const int n = qMin(keys.size(), values.size());
  QVector<QCPBarsData> tempData(n);
  QVector<QCPBarsData>::iterator it = tempData.begin();
  const QVector<QCPBarsData>::iterator itEnd = tempData.end();
  int i = 0;
  while (it != itEnd)
  {
    it->key = keys[i];
    it->value = values[i];
    ++it;
    ++i;
  }
  mDataContainer->add(tempData, alreadySorted); // don't modify tempData beyond this to prevent copy on write
                                                // 복사시 쓰기를 방지하기 위해 tempData를이 값 이상으로 수정하지 마십시오.
}

/*! \overload
  Adds the provided data point as \a key and \a value to the current data.
  
  Alternatively, you can also access and modify the data directly via the \ref data method, which
  returns a pointer to the internal data container.
*/
/*! \초과 적재
  제공된 데이터 요소를 \ 키와 \ 값을 현재 데이터에 추가합니다.
  
  또는 \ ref 데이터 메서드를 통해 직접 데이터에 액세스하고 수정할 수도 있습니다.
  내부 데이터 컨테이너에 대한 포인터를 반환합니다.
*/
void QCPBars::addData(double key, double value)
{
  mDataContainer->add(QCPBarsData(key, value));
}

/*!
  Moves this bars plottable below \a bars. In other words, the bars of this plottable will appear
  below the bars of \a bars. The move target \a bars must use the same key and value axis as this
  plottable.
  
  Inserting into and removing from existing bar stacking is handled gracefully. If \a bars already
  has a bars object below itself, this bars object is inserted between the two. If this bars object
  is already between two other bars, the two other bars will be stacked on top of each other after
  the operation.
  
  To remove this bars plottable from any stacking, set \a bars to 0.
  
  \see moveBelow, barAbove, barBelow
*/
/*!
  이 막대를 막대 아래로 이동합니다. 즉,이 플롯 테이블의 막대가 나타납니다.
  \ bar의 바 아래. 이동 대상 \ 막대는 동일한 키와 값 축을 사용해야합니다.
  plottable.
  
  기존의 스태킹을 삽입하거나 제거하는 작업은 정상적으로 처리됩니다. \ a 바가 이미있는 경우
  아래에 막대 객체가 있고이 막대 객체는 두 객체 사이에 삽입됩니다. 이 막대 객체가
  두 개의 다른 막대 사이에 이미 있습니다. 두 개의 막대가 서로 겹쳐집니다.
  수술.
  
  스태킹에서이 막대 plottable을 제거하려면 \ a bars를 0으로 설정하십시오.
  
  \ see moveBelow, barAbove, barBelow
*/
void QCPBars::moveBelow(QCPBars *bars)
{
  if (bars == this) return;
  if (bars && (bars->keyAxis() != mKeyAxis.data() || bars->valueAxis() != mValueAxis.data()))
  {
    qDebug() << Q_FUNC_INFO << "passed QCPBars* doesn't have same key and value axis as this QCPBars";
    return;
  }
  // remove from stacking:
  // 스태킹에서 제거 :
  connectBars(mBarBelow.data(), mBarAbove.data()); // Note: also works if one (or both) of them is 0
                                                   // 참고 : 둘 중 하나 (또는 ​​둘 다)가 0 인 경우에도 작동합니다.
  // if new bar given, insert this bar below it:
  // 새로운 bar가 주어진다면, 아래에이 막대를 삽입하십시오 :
  if (bars)
  {
    if (bars->mBarBelow)
      connectBars(bars->mBarBelow.data(), this);
    connectBars(this, bars);
  }
}

/*!
  Moves this bars plottable above \a bars. In other words, the bars of this plottable will appear
  above the bars of \a bars. The move target \a bars must use the same key and value axis as this
  plottable.
  
  Inserting into and removing from existing bar stacking is handled gracefully. If \a bars already
  has a bars object above itself, this bars object is inserted between the two. If this bars object
  is already between two other bars, the two other bars will be stacked on top of each other after
  the operation.
  
  To remove this bars plottable from any stacking, set \a bars to 0.
  
  \see moveBelow, barBelow, barAbove
*/
/*!
  이 바를 \ a 바 위로 움직입니다. 즉,이 플롯 테이블의 막대가 나타납니다.
  \ bar의 바 위에. 이동 대상 \ 막대는 동일한 키와 값 축을 사용해야합니다.
  plottable.
  
  기존의 스태킹을 삽입하거나 제거하는 작업은 정상적으로 처리됩니다. \ a 바가 이미있는 경우
  이 바 개체는 두 개체 사이에 삽입됩니다. 이 막대 객체가
  두 개의 다른 막대 사이에 이미 있습니다. 두 개의 막대가 서로 겹쳐집니다.
  수술.
  
  스태킹에서이 막대 plottable을 제거하려면 \ a bars를 0으로 설정하십시오.
  
  \ see moveBelow, barBelow, barAbove
*/
void QCPBars::moveAbove(QCPBars *bars)
{
  if (bars == this) return;
  if (bars && (bars->keyAxis() != mKeyAxis.data() || bars->valueAxis() != mValueAxis.data()))
  {
    qDebug() << Q_FUNC_INFO << "passed QCPBars* doesn't have same key and value axis as this QCPBars";
    return;
  }
  // remove from stacking:
  // 스태킹에서 제거 :
  connectBars(mBarBelow.data(), mBarAbove.data()); // Note: also works if one (or both) of them is 0
                                                   // 참고 : 둘 중 하나 (또는 ​​둘 다)가 0 인 경우에도 작동합니다.
  // if new bar given, insert this bar above it:
  // 새로운 바가 주어진다면, 위에 막대를 삽입하십시오 :
  if (bars)
  {
    if (bars->mBarAbove)
      connectBars(this, bars->mBarAbove.data());
    connectBars(bars, this);
  }
}

/*!
  \copydoc QCPPlottableInterface1D::selectTestRect
*/
QCPDataSelection QCPBars::selectTestRect(const QRectF &rect, bool onlySelectable) const
{
  QCPDataSelection result;
  if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())
    return result;
  if (!mKeyAxis || !mValueAxis)
    return result;
  
  QCPBarsDataContainer::const_iterator visibleBegin, visibleEnd;
  getVisibleDataBounds(visibleBegin, visibleEnd);
  
  for (QCPBarsDataContainer::const_iterator it=visibleBegin; it!=visibleEnd; ++it)
  {
    if (rect.intersects(getBarRect(it->key, it->value)))
      result.addDataRange(QCPDataRange(it-mDataContainer->constBegin(), it-mDataContainer->constBegin()+1), false);
  }
  result.simplify();
  return result;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPBars::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  Q_UNUSED(details)
  if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())
    return -1;
  if (!mKeyAxis || !mValueAxis)
    return -1;
  
  if (mKeyAxis.data()->axisRect()->rect().contains(pos.toPoint()))
  {
    // get visible data range:
    // 표시되는 데이터 범위 가져 오기 :
    QCPBarsDataContainer::const_iterator visibleBegin, visibleEnd;
    getVisibleDataBounds(visibleBegin, visibleEnd);
    for (QCPBarsDataContainer::const_iterator it=visibleBegin; it!=visibleEnd; ++it)
    {
      if (getBarRect(it->key, it->value).contains(pos))
      {
        if (details)
        {
          int pointIndex = it-mDataContainer->constBegin();
          details->setValue(QCPDataSelection(QCPDataRange(pointIndex, pointIndex+1)));
        }
        return mParentPlot->selectionTolerance()*0.99;
      }
    }
  }
  return -1;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPRange QCPBars::getKeyRange(bool &foundRange, QCP::SignDomain inSignDomain) const
{
  /* Note: If this QCPBars uses absolute pixels as width (or is in a QCPBarsGroup with spacing in
  absolute pixels), using this method to adapt the key axis range to fit the bars into the
  currently visible axis range will not work perfectly. Because in the moment the axis range is
  changed to the new range, the fixed pixel widths/spacings will represent different coordinate
  spans than before, which in turn would require a different key range to perfectly fit, and so on.
  The only solution would be to iteratively approach the perfect fitting axis range, but the
  mismatch isn't large enough in most applications, to warrant this here. If a user does need a
  better fit, he should call the corresponding axis rescale multiple times in a row.
  */
  /* 참고 :이 QCPBars가 절대 픽셀을 너비로 사용하거나 (또는 ​​QCPBarsGroup에있는 경우)
  절대 픽셀),이 방법을 사용하여 바를 축에 맞게 키 축 범위를 조정합니다
  현재 보이는 축 범위는 완벽하게 작동하지 않습니다. 순간적으로 축 범위는
  새로운 범위로 변경되면 고정 된 픽셀 너비 / 간격은 다른 좌표를 나타냅니다
  예전보다 길고 완벽하게 맞는 다른 키 범위가 필요합니다.
  유일한 해결책은 완벽한 맞춤 축 범위에 반복적으로 접근하는 것이지만
  불일치가 대부분의 응용 프로그램에서 충분히 크지 않아 여기에서이를 보증해야합니다. 사용자가
  더 잘 맞으면, 해당 축을 rescale을 연속으로 여러 번 호출해야합니다.
  */
  QCPRange range;
  range = mDataContainer->keyRange(foundRange, inSignDomain);
  
  // determine exact range of bars by including bar width and barsgroup offset:
  // 바 너비 및 바 그룹 오프셋을 포함하여 바의 정확한 범위를 결정합니다.
  if (foundRange && mKeyAxis)
  {
    double lowerPixelWidth, upperPixelWidth, keyPixel;
    // lower range bound:
    // 더 낮은 범위의 경계 :
    getPixelWidth(range.lower, lowerPixelWidth, upperPixelWidth);
    keyPixel = mKeyAxis.data()->coordToPixel(range.lower) + lowerPixelWidth;
    if (mBarsGroup)
      keyPixel += mBarsGroup->keyPixelOffset(this, range.lower);
    const double lowerCorrected = mKeyAxis.data()->pixelToCoord(keyPixel);
    if (!qIsNaN(lowerCorrected) && qIsFinite(lowerCorrected) && range.lower > lowerCorrected)
      range.lower = lowerCorrected;
    // upper range bound:
    // 상한 범위 :
    getPixelWidth(range.upper, lowerPixelWidth, upperPixelWidth);
    keyPixel = mKeyAxis.data()->coordToPixel(range.upper) + upperPixelWidth;
    if (mBarsGroup)
      keyPixel += mBarsGroup->keyPixelOffset(this, range.upper);
    const double upperCorrected = mKeyAxis.data()->pixelToCoord(keyPixel);
    if (!qIsNaN(upperCorrected) && qIsFinite(upperCorrected) && range.upper < upperCorrected)
      range.upper = upperCorrected;
  }
  return range;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPRange QCPBars::getValueRange(bool &foundRange, QCP::SignDomain inSignDomain, const QCPRange &inKeyRange) const
{
  // Note: can't simply use mDataContainer->valueRange here because we need to
  // take into account bar base value and possible stacking of multiple bars
  // 참고 : 단순히 mDataContainer-> valueRange를 사용할 수 없습니다.
  // 막대 기본 값과 다중 막대의 가능한 스태킹을 고려합니다.
  QCPRange range;
  range.lower = mBaseValue;
  range.upper = mBaseValue;
  bool haveLower = true; // set to true, because baseValue should always be visible in bar charts
                         // baseValue는 막대 차트에 항상 표시되어야하므로 true로 설정합니다.
  bool haveUpper = true; // set to true, because baseValue should always be visible in bar charts
                         // baseValue는 막대 차트에 항상 표시되어야하므로 true로 설정합니다.
  QCPBarsDataContainer::const_iterator itBegin = mDataContainer->constBegin();
  QCPBarsDataContainer::const_iterator itEnd = mDataContainer->constEnd();
  if (inKeyRange != QCPRange())
  {
    itBegin = mDataContainer->findBegin(inKeyRange.lower);
    itEnd = mDataContainer->findEnd(inKeyRange.upper);
  }
  for (QCPBarsDataContainer::const_iterator it = itBegin; it != itEnd; ++it)
  {
    const double current = it->value + getStackedBaseValue(it->key, it->value >= 0);
    if (qIsNaN(current)) continue;
    if (inSignDomain == QCP::sdBoth || (inSignDomain == QCP::sdNegative && current < 0) || (inSignDomain == QCP::sdPositive && current > 0))
    {
      if (current < range.lower || !haveLower)
      {
        range.lower = current;
        haveLower = true;
      }
      if (current > range.upper || !haveUpper)
      {
        range.upper = current;
        haveUpper = true;
      }
    }
  }
  
  foundRange = true; // return true because bar charts always have the 0-line visible
  return range;      //막 대형 차트는 항상 0 행을 볼 수 있기 때문에 true를 반환합니다.
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QPointF QCPBars::dataPixelPosition(int index) const
{
  if (index >= 0 && index < mDataContainer->size())
  {
    QCPAxis *keyAxis = mKeyAxis.data();
    QCPAxis *valueAxis = mValueAxis.data();
    if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QPointF(); }
    
    const QCPDataContainer<QCPBarsData>::const_iterator it = mDataContainer->constBegin()+index;
    const double valuePixel = valueAxis->coordToPixel(getStackedBaseValue(it->key, it->value >= 0) + it->value);
    const double keyPixel = keyAxis->coordToPixel(it->key) + (mBarsGroup ? mBarsGroup->keyPixelOffset(this, it->key) : 0);
    if (keyAxis->orientation() == Qt::Horizontal)
      return QPointF(keyPixel, valuePixel);
    else
      return QPointF(valuePixel, keyPixel);
  } else
  {
    qDebug() << Q_FUNC_INFO << "Index out of bounds" << index;
    return QPointF();
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPBars::draw(QCPPainter *painter)
{
  if (!mKeyAxis || !mValueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
  if (mDataContainer->isEmpty()) return;
  
  QCPBarsDataContainer::const_iterator visibleBegin, visibleEnd;
  getVisibleDataBounds(visibleBegin, visibleEnd);
  
  // loop over and draw segments of unselected/selected data:
  // 선택되지 않은 / 선택한 데이터의 세그먼트를 반복 및 그립니다.
  QList<QCPDataRange> selectedSegments, unselectedSegments, allSegments;
  getDataSegments(selectedSegments, unselectedSegments);
  allSegments << unselectedSegments << selectedSegments;
  for (int i=0; i<allSegments.size(); ++i)
  {
    bool isSelectedSegment = i >= unselectedSegments.size();
    QCPBarsDataContainer::const_iterator begin = visibleBegin;
    QCPBarsDataContainer::const_iterator end = visibleEnd;
    mDataContainer->limitIteratorsToDataRange(begin, end, allSegments.at(i));
    if (begin == end)
      continue;
    
    for (QCPBarsDataContainer::const_iterator it=begin; it!=end; ++it)
    {
      // check data validity if flag set:
      // 플래그가 설정된 경우 데이터 유효성을 검사합니다.
#ifdef QCUSTOMPLOT_CHECK_DATA
      if (QCP::isInvalidData(it->key, it->value))
        qDebug() << Q_FUNC_INFO << "Data point at" << it->key << "of drawn range invalid." << "Plottable name:" << name();
#endif
      // draw bar:
      // 막대를 그립니다.
      if (isSelectedSegment && mSelectionDecorator)
      {
        mSelectionDecorator->applyBrush(painter);
        mSelectionDecorator->applyPen(painter);
      } else
      {
        painter->setBrush(mBrush);
        painter->setPen(mPen);
      }
      applyDefaultAntialiasingHint(painter);
      painter->drawPolygon(getBarRect(it->key, it->value));
    }
  }
  
  // draw other selection decoration that isn't just line/scatter pens and brushes:
  // 선 / 산란 펜 및 브러쉬가 아닌 다른 선택 장식을 그립니다.
  if (mSelectionDecorator)
    mSelectionDecorator->drawDecoration(painter, selection());
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPBars::drawLegendIcon(QCPPainter *painter, const QRectF &rect) const
{
  // draw filled rect:
  // 채워진 rect를 그립니다.
  applyDefaultAntialiasingHint(painter);
  painter->setBrush(mBrush);
  painter->setPen(mPen);
  QRectF r = QRectF(0, 0, rect.width()*0.67, rect.height()*0.67);
  r.moveCenter(rect.center());
  painter->drawRect(r);
}

/*!  \internal
  
  called by \ref draw to determine which data (key) range is visible at the current key axis range
  setting, so only that needs to be processed. It also takes into account the bar width.
  
  \a begin returns an iterator to the lowest data point that needs to be taken into account when
  plotting. Note that in order to get a clean plot all the way to the edge of the axis rect, \a
  lower may still be just outside the visible range.
  
  \a end returns an iterator one higher than the highest visible data point. Same as before, \a end
  may also lie just outside of the visible range.
  
  if the plottable contains no data, both \a begin and \a end point to constEnd.
*/
/*! \내부의
  
  현재 키 축 범위에서 볼 수있는 데이터 (키) 범위를 결정하기 위해 \ ref draw에 의해 호출됩니다.
  설정이므로 처리해야합니다. 또한 막대 너비도 고려합니다.
  
  \ a begin은 가장 낮은 데이터 점에 대한 반복자를 반환합니다.
  플로팅. 깨끗한 그림을 축 rect의 끝까지 가져 오려면 \ a
  lower는 여전히 가시 범위 밖에있을 수 있습니다.
  
  \ end는 가장 높은 가시적 인 데이터 포인트보다 하나 높은 반복자를 반환합니다. 이전과 같음, 끝
  또한 가시 범위 밖에있을 수 있습니다.
  
  plottable에 데이터가 없으면 \ begin과 \ end는 모두 constEnd를 가리 킵니다.
*/
void QCPBars::getVisibleDataBounds(QCPBarsDataContainer::const_iterator &begin, QCPBarsDataContainer::const_iterator &end) const
{
  if (!mKeyAxis)
  {
    qDebug() << Q_FUNC_INFO << "invalid key axis";
    begin = mDataContainer->constEnd();
    end = mDataContainer->constEnd();
    return;
  }
  if (mDataContainer->isEmpty())
  {
    begin = mDataContainer->constEnd();
    end = mDataContainer->constEnd();
    return;
  }
  
  // get visible data range as QMap iterators
  // 보이는 데이터 범위를 QMap 반복자로 가져옵니다.
  begin = mDataContainer->findBegin(mKeyAxis.data()->range().lower);
  end = mDataContainer->findEnd(mKeyAxis.data()->range().upper);
  double lowerPixelBound = mKeyAxis.data()->coordToPixel(mKeyAxis.data()->range().lower);
  double upperPixelBound = mKeyAxis.data()->coordToPixel(mKeyAxis.data()->range().upper);
  bool isVisible = false;
  // walk left from begin to find lower bar that actually is completely outside visible pixel range:
  // 실제로 보이는 픽셀 범위 바깥에있는 아래쪽 막대를 찾기 위해 왼쪽에서부터 시작합니다.
  QCPBarsDataContainer::const_iterator it = begin;
  while (it != mDataContainer->constBegin())
  {
    --it;
    const QRectF barRect = getBarRect(it->key, it->value);
    if (mKeyAxis.data()->orientation() == Qt::Horizontal)
      isVisible = ((!mKeyAxis.data()->rangeReversed() && barRect.right() >= lowerPixelBound) || (mKeyAxis.data()->rangeReversed() && barRect.left() <= lowerPixelBound));
    else // keyaxis is vertical
         // 키 축은 수직입니다.
      isVisible = ((!mKeyAxis.data()->rangeReversed() && barRect.top() <= lowerPixelBound) || (mKeyAxis.data()->rangeReversed() && barRect.bottom() >= lowerPixelBound));
    if (isVisible)
      begin = it;
    else
      break;
  }
  // walk right from ubound to find upper bar that actually is completely outside visible pixel range:
  // 실제 보이는 픽셀 범위 바깥에있는 위쪽 막대를 찾으려면 ubound에서 오른쪽으로 걷습니다.
  it = end;
  while (it != mDataContainer->constEnd())
  {
    const QRectF barRect = getBarRect(it->key, it->value);
    if (mKeyAxis.data()->orientation() == Qt::Horizontal)
      isVisible = ((!mKeyAxis.data()->rangeReversed() && barRect.left() <= upperPixelBound) || (mKeyAxis.data()->rangeReversed() && barRect.right() >= upperPixelBound));
    else // keyaxis is vertical
         // 키 축은 수직입니다.
      isVisible = ((!mKeyAxis.data()->rangeReversed() && barRect.bottom() >= upperPixelBound) || (mKeyAxis.data()->rangeReversed() && barRect.top() <= upperPixelBound));
    if (isVisible)
      end = it+1;
    else
      break;
    ++it;
  }
}

/*! \internal
  
  Returns the rect in pixel coordinates of a single bar with the specified \a key and \a value. The
  rect is shifted according to the bar stacking (see \ref moveAbove) and base value (see \ref
  setBaseValue), and to have non-overlapping border lines with the bars stacked below.
*/
/*! \내부의
  
  지정된 \ a 키와 \ a 값을 가지는 단일 막대의 픽셀 좌표로 rect를 리턴합니다. 그만큼
  rect는 막대 스태킹 (\ ref moveAbove 참조) 및 기준 값에 따라 이동합니다 (\ ref 참조).
  setBaseValue), 아래에 막대가 쌓인 겹치지 않는 경계선이 있어야합니다.
*/
QRectF QCPBars::getBarRect(double key, double value) const
{
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QRectF(); }
  
  double lowerPixelWidth, upperPixelWidth;
  getPixelWidth(key, lowerPixelWidth, upperPixelWidth);
  double base = getStackedBaseValue(key, value >= 0);
  double basePixel = valueAxis->coordToPixel(base);
  double valuePixel = valueAxis->coordToPixel(base+value);
  double keyPixel = keyAxis->coordToPixel(key);
  if (mBarsGroup)
    keyPixel += mBarsGroup->keyPixelOffset(this, key);
  double bottomOffset = (mBarBelow && mPen != Qt::NoPen ? 1 : 0)*(mPen.isCosmetic() ? 1 : mPen.widthF());
  bottomOffset += mBarBelow ? mStackingGap : 0;
  bottomOffset *= (value<0 ? -1 : 1)*valueAxis->pixelOrientation();
  if (qAbs(valuePixel-basePixel) <= qAbs(bottomOffset))
    bottomOffset = valuePixel-basePixel;
  if (keyAxis->orientation() == Qt::Horizontal)
  {
    return QRectF(QPointF(keyPixel+lowerPixelWidth, valuePixel), QPointF(keyPixel+upperPixelWidth, basePixel+bottomOffset)).normalized();
  } else
  {
    return QRectF(QPointF(basePixel+bottomOffset, keyPixel+lowerPixelWidth), QPointF(valuePixel, keyPixel+upperPixelWidth)).normalized();
  }
}

/*! \internal
  
  This function is used to determine the width of the bar at coordinate \a key, according to the
  specified width (\ref setWidth) and width type (\ref setWidthType).
  
  The output parameters \a lower and \a upper return the number of pixels the bar extends to lower
  and higher keys, relative to the \a key coordinate (so with a non-reversed horizontal axis, \a
  lower is negative and \a upper positive).
*/
/*! \내부의
  
  이 함수는 좌표 \ a 키에있는 막대의 너비를 결정하는 데 사용됩니다.
  지정된 너비 (\ ref setWidth)와 너비 유형 (\ ref setWidthType).
  
  출력 매개 변수 \ a lower 및 \ a upper는 막대가 아래로 확장하는 픽셀 수를 반환합니다.
  및 상위 키를 \ a 키 좌표와 비교하면됩니다 (역상이 아닌 가로 축 인 경우 \ a
  하위는 음수이고 \ a는 상위 양수).
*/
void QCPBars::getPixelWidth(double key, double &lower, double &upper) const
{
  lower = 0;
  upper = 0;
  switch (mWidthType)
  {
    case wtAbsolute:
    {
      upper = mWidth*0.5*mKeyAxis.data()->pixelOrientation();
      lower = -upper;
      break;
    }
    case wtAxisRectRatio:
    {
      if (mKeyAxis && mKeyAxis.data()->axisRect())
      {
        if (mKeyAxis.data()->orientation() == Qt::Horizontal)
          upper = mKeyAxis.data()->axisRect()->width()*mWidth*0.5*mKeyAxis.data()->pixelOrientation();
        else
          upper = mKeyAxis.data()->axisRect()->height()*mWidth*0.5*mKeyAxis.data()->pixelOrientation();
        lower = -upper;
      } else
        qDebug() << Q_FUNC_INFO << "No key axis or axis rect defined";
      break;
    }
    case wtPlotCoords:
    {
      if (mKeyAxis)
      {
        double keyPixel = mKeyAxis.data()->coordToPixel(key);
        upper = mKeyAxis.data()->coordToPixel(key+mWidth*0.5)-keyPixel;
        lower = mKeyAxis.data()->coordToPixel(key-mWidth*0.5)-keyPixel;
        // no need to qSwap(lower, higher) when range reversed, because higher/lower are gained by
        // coordinate transform which includes range direction
        // 범위가 바뀔 때 qSwap (낮추거나 높게) 할 필요가 없습니다.
        // 범위 방향을 포함하는 좌표 변환
      } else
        qDebug() << Q_FUNC_INFO << "No key axis defined";
      break;
    }
  }
}

/*! \internal
  
  This function is called to find at which value to start drawing the base of a bar at \a key, when
  it is stacked on top of another QCPBars (e.g. with \ref moveAbove).
  
  positive and negative bars are separated per stack (positive are stacked above baseValue upwards,
  negative are stacked below baseValue downwards). This can be indicated with \a positive. So if the
  bar for which we need the base value is negative, set \a positive to false.
*/

/*! \내부의
  
  이 함수는 \ a 키에서 막대의 밑을 그리기 시작하는 값을 찾을 때 호출됩니다.
  그것은 다른 QCPBars (예를 들어 \ ref moveAbove) 위에 쌓여 있습니다.
  
  스택마다 양수 막대와 음수 막대가 구분됩니다 (양수는 baseValue 위쪽으로 스택되고,
  negative는 baseValue 아래에 아래로 스택 됨). 이것은 \ a 긍정으로 표시 할 수 있습니다. 그래서
  기본 값이 필요한 bar는 음수이고, \ a 양수를 false로 설정하십시오.
*/
double QCPBars::getStackedBaseValue(double key, bool positive) const
{
  if (mBarBelow)
  {
    double max = 0; 
    // don't initialize with mBaseValue here because only base value of bottom-most bar has meaning in a bar stack
    // 맨 아래 막대의 기본 값만 막대 스택에서 의미를 가지기 때문에 여기에서 mBaseValue로 초기화하지 않습니다.
    // find bars of mBarBelow that are approximately at key and find largest one:
    // 대략 키에 있고 가장 큰 것을 찾은 mBarBelow 막대 찾기 :
    double epsilon = qAbs(key)*(sizeof(key)==4 ? 1e-6 : 1e-14); 
    // should be safe even when changed to use float at some point
    // 어떤 시점에서 float를 사용하도록 변경하더라도 안전해야합니다.
    if (key == 0)
      epsilon = (sizeof(key)==4 ? 1e-6 : 1e-14);
    QCPBarsDataContainer::const_iterator it = mBarBelow.data()->mDataContainer->findBegin(key-epsilon);
    QCPBarsDataContainer::const_iterator itEnd = mBarBelow.data()->mDataContainer->findEnd(key+epsilon);
    while (it != itEnd)
    {
      if (it->key > key-epsilon && it->key < key+epsilon)
      {
        if ((positive && it->value > max) ||
            (!positive && it->value < max))
          max = it->value;
      }
      ++it;
    }
    // recurse down the bar-stack to find the total height:
    // bar-stack을 재귀 적으로 내려 총 높이를 찾습니다.
    return max + mBarBelow.data()->getStackedBaseValue(key, positive);
  } else
    return mBaseValue;
}

/*! \internal

  Connects \a below and \a above to each other via their mBarAbove/mBarBelow properties. The bar(s)
  currently above lower and below upper will become disconnected to lower/upper.
  
  If lower is zero, upper will be disconnected at the bottom.
  If upper is zero, lower will be disconnected at the top.
*/
/*! \내부의

  mBarAbove / mBarBelow 속성을 통해 \ a와 \ a를 위에 연결합니다. 바 (들)
  현재 위 아래와 위 아래는 위 / 아래로 연결이 끊어집니다.
  
  lower가 0이면 상단에서 연결이 끊어집니다.
  upper가 0이면 상단에서 연결이 끊어집니다.
*/
void QCPBars::connectBars(QCPBars *lower, QCPBars *upper)
{
  if (!lower && !upper) return;
  
  if (!lower) // disconnect upper at bottom
  {           // 맨 아래에서 연결 끊기
    // disconnect old bar below upper:
    // 위쪽 아래의 오래된 막대 연결 끊기 :
    if (upper->mBarBelow && upper->mBarBelow.data()->mBarAbove.data() == upper)
      upper->mBarBelow.data()->mBarAbove = 0;
    upper->mBarBelow = 0;
  } else if (!upper) // disconnect lower at top
  {                  // 맨 아래에서 연결 해제
    // disconnect old bar above lower:
    // 아래쪽의 오래된 막대를 연결 해제합니다.
    if (lower->mBarAbove && lower->mBarAbove.data()->mBarBelow.data() == lower)
      lower->mBarAbove.data()->mBarBelow = 0;
    lower->mBarAbove = 0;
  } else // connect lower and upper
  {      // 아래쪽과 위쪽을 연결합니다.
    // disconnect old bar above lower:
    // 아래쪽의 오래된 막대를 연결 해제합니다.
    if (lower->mBarAbove && lower->mBarAbove.data()->mBarBelow.data() == lower)
      lower->mBarAbove.data()->mBarBelow = 0;
    // disconnect old bar below upper:
    // 위쪽 아래의 오래된 막대 연결 끊기 :
    if (upper->mBarBelow && upper->mBarBelow.data()->mBarAbove.data() == upper)
      upper->mBarBelow.data()->mBarAbove = 0;
    lower->mBarAbove = upper;
    upper->mBarBelow = lower;
  }
}
/* end of 'src/plottables/plottable-bars.cpp' */


/* including file 'src/plottables/plottable-statisticalbox.cpp', size 28622  */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / plottables / plottable-bars.cpp'의 끝 */


/* 'src / plottables / plottable-statisticalbox.cpp'파일 포함, 크기 28622 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPStatisticalBoxData
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPStatisticalBoxData
  \brief Holds the data of one single data point for QCPStatisticalBox.
  
  The stored data is:
  
  \li \a key: coordinate on the key axis of this data point (this is the \a mainKey and the \a sortKey)
  
  \li \a minimum: the position of the lower whisker, typically the minimum measurement of the
  sample that's not considered an outlier.
  
  \li \a lowerQuartile: the lower end of the box. The lower and the upper quartiles are the two
  statistical quartiles around the median of the sample, they should contain 50% of the sample
  data.
  
  \li \a median: the value of the median mark inside the quartile box. The median separates the
  sample data in half (50% of the sample data is below/above the median). (This is the \a mainValue)
  
  \li \a upperQuartile: the upper end of the box. The lower and the upper quartiles are the two
  statistical quartiles around the median of the sample, they should contain 50% of the sample
  data.
  
  \li \a maximum: the position of the upper whisker, typically the maximum measurement of the
  sample that's not considered an outlier.
  
  \li \a outliers: a QVector of outlier values that will be drawn as scatter points at the \a key
  coordinate of this data point (see \ref QCPStatisticalBox::setOutlierStyle)
  
  The container for storing multiple data points is \ref QCPStatisticalBoxDataContainer. It is a
  typedef for \ref QCPDataContainer with \ref QCPStatisticalBoxData as the DataType template
  parameter. See the documentation there for an explanation regarding the data type's generic
  methods.
  
  \see QCPStatisticalBoxDataContainer
*/
/*! \ class QCPStatisticalBoxData
  \ brief QCPStatisticalBox에 대한 하나의 단일 데이터 포인트의 데이터를 보유합니다.
  
  저장된 데이터는 다음과 같습니다.
  
  \ li \ a key :이 데이터 포인트의 키 축의 좌표입니다 (이것은 mainKey와 \ a sortKey입니다)
  
  \ li \ a 최소 : 위스커의 위치, 일반적으로
  outlier로 간주되지 않는 샘플.
  
  \ li \ a lowerQuartile : 상자의 하단입니다. 더 낮은 것과 더 높은 사 분위수는 2
  샘플 중앙값 주위의 통계적 4 분위수, 샘플의 50 %를 포함해야합니다
  데이터.
  
  \ li \ a 중앙값 : 사 분위수 상자 안의 중앙값 표시의 값. 중앙값은
  샘플 데이터의 절반 (샘플 데이터의 50 %가 중앙값보다 높거나 위). (이것은 \ mainValue입니다)
  
  \ li \ a upperQuartile : 상자의 위쪽 끝입니다. 더 낮은 것과 더 높은 사 분위수는 2
  샘플 중앙값 주위의 통계적 4 분위수, 샘플의 50 %를 포함해야합니다
  데이터.
  
  \ li \ a 최대 : 위스커의 위치, 일반적으로
  outlier로 간주되지 않는 샘플.
  
  \ li \ a 아웃 라이어 (outliers) : 키에 스 캐터 포인트로 그려지는 아웃 라이어 값의 QVector
  이 데이터 포인트의 좌표 (\ ref QCPStatisticalBox :: setOutlierStyle 참조)
  
  여러 데이터 요소를 저장하는 컨테이너는 \ ref QCPStatisticalBoxDataContainer입니다. 이것은
  \ ref QCPDataContainer에 대한 typedef는 \ ref QCPStatisticalBoxData를 DataType 템플리트로 사용합니다.
  매개 변수. 데이터 유형의 제네릭에 대한 설명은 해당 문서를 참조하십시오.
  행동 양식.
  
  \ see QCPStatisticalBoxDataContainer
*/


/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */

/*! \fn double QCPStatisticalBoxData::sortKey() const
  
  Returns the \a key member of this data point.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn double QCPStatisticalBoxData :: sortKey () const
  
  이 데이터 포인트의 키 멤버를 돌려줍니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/


/*! \fn static QCPStatisticalBoxData QCPStatisticalBoxData::fromSortKey(double sortKey)
  
  Returns a data point with the specified \a sortKey. All other members are set to zero.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn 정적 QCPStatisticalBoxData QCPStatisticalBoxData :: fromSortKey (double sortKey)
  
  지정된 \ a sortKey를 가지는 데이터 포인트를 돌려줍니다. 다른 모든 멤버는 0으로 설정됩니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn static static bool QCPStatisticalBoxData::sortKeyIsMainKey()
  
  Since the member \a key is both the data point key coordinate and the data ordering parameter,
  this method returns true.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn 정적 정적 bool QCPStatisticalBoxData :: sortKeyIsMainKey ()
  
  member \ a 키는 데이터 포인트 키 좌표와 데이터 정렬 매개 변수이기 때문에,
  이 메소드는 true를 리턴합니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn double QCPStatisticalBoxData::mainKey() const
  
  Returns the \a key member of this data point.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn 두 번 QCPStatisticalBoxData :: mainKey () const
  
  이 데이터 포인트의 키 멤버를 돌려줍니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn double QCPStatisticalBoxData::mainValue() const
  
  Returns the \a median member of this data point.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn 두 번 QCPStatisticalBoxData :: mainValue () const
  
  이 데이터 포인트의 중간 값 멤버를 반환합니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn QCPRange QCPStatisticalBoxData::valueRange() const
  
  Returns a QCPRange spanning from the \a minimum to the \a maximum member of this statistical box
  data point, possibly further expanded by outliers.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn QCPRange QCPStatisticalBoxData :: valueRange () const
  
  최소값에서이 통계 상자의 최대 값에 이르는 QCPRange를 반환합니다.
  가능하다면 특이 치에 의해 확장 된 데이터 포인트.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */

/*!
  Constructs a data point with key and all values set to zero.
*/
/*!
  key 및 모든 값을 0으로 설정하여 데이터 요소를 구성합니다.
*/
QCPStatisticalBoxData::QCPStatisticalBoxData() :
  key(0),
  minimum(0),
  lowerQuartile(0),
  median(0),
  upperQuartile(0),
  maximum(0)
{
}

/*!
  Constructs a data point with the specified \a key, \a minimum, \a lowerQuartile, \a median, \a
  upperQuartile, \a maximum and optionally a number of \a outliers.
*/

/*!
  지정된 \ a 키, \ a 최소값, \ lowerQuartile, \ median, \ a를 사용하여 데이터 요소를 구성합니다.
  upperQuartile, \ a 최대 및 선택적으로 임의의 수의 \ outliers.
*/
QCPStatisticalBoxData::QCPStatisticalBoxData(double key, double minimum, double lowerQuartile, double median, double upperQuartile, double maximum, const QVector<double> &outliers) :
  key(key),
  minimum(minimum),
  lowerQuartile(lowerQuartile),
  median(median),
  upperQuartile(upperQuartile),
  maximum(maximum),
  outliers(outliers)
{
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPStatisticalBox
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPStatisticalBox
  \brief A plottable representing a single statistical box in a plot.

  \image html QCPStatisticalBox.png
  
  To plot data, assign it with the \ref setData or \ref addData functions. Alternatively, you can
  also access and modify the data via the \ref data method, which returns a pointer to the internal
  \ref QCPStatisticalBoxDataContainer.
  
  Additionally each data point can itself have a list of outliers, drawn as scatter points at the
  key coordinate of the respective statistical box data point. They can either be set by using the
  respective \ref addData(double,double,double,double,double,double,const QVector<double>&)
  "addData" method or accessing the individual data points through \ref data, and setting the
  <tt>QVector<double> outliers</tt> of the data points directly.
  
  \section qcpstatisticalbox-appearance Changing the appearance
  
  The appearance of each data point box, ranging from the lower to the upper quartile, is
  controlled via \ref setPen and \ref setBrush. You may change the width of the boxes with \ref
  setWidth in plot coordinates.

  Each data point's visual representation also consists of two whiskers. Whiskers are the lines
  which reach from the upper quartile to the maximum, and from the lower quartile to the minimum.
  The appearance of the whiskers can be modified with: \ref setWhiskerPen, \ref setWhiskerBarPen,
  \ref setWhiskerWidth. The whisker width is the width of the bar perpendicular to the whisker at
  the top (for maximum) and bottom (for minimum). If the whisker pen is changed, make sure to set
  the \c capStyle to \c Qt::FlatCap. Otherwise the backbone line might exceed the whisker bars by a
  few pixels due to the pen cap being not perfectly flat.
  
  The median indicator line inside the box has its own pen, \ref setMedianPen.
  
  The outlier data points are drawn as normal scatter points. Their look can be controlled with
  \ref setOutlierStyle
  
  \section qcpstatisticalbox-usage Usage
  
  Like all data representing objects in QCustomPlot, the QCPStatisticalBox is a plottable
  (QCPAbstractPlottable). So the plottable-interface of QCustomPlot applies
  (QCustomPlot::plottable, QCustomPlot::removePlottable, etc.)
  
  Usually, you first create an instance:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpstatisticalbox-creation-1
  which registers it with the QCustomPlot instance of the passed axes. Note that this QCustomPlot instance takes
  ownership of the plottable, so do not delete it manually but use QCustomPlot::removePlottable() instead.
  The newly created plottable can be modified, e.g.:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpstatisticalbox-creation-2
*/
/*! \ class QCPStatisticalBox
  \ brief 플롯에서 단일 통계 상자를 나타내는 플롯.

  \ image html QCPStatisticalBox.png
  
  데이터를 플롯하려면 \ ref setData 또는 \ ref addData 함수로 지정하십시오. 또는
  \ ref 데이터 메서드를 통해 데이터에 액세스하고 수정합니다.이 메서드는 내부에 대한 포인터를 반환합니다.
  \ ref QCPStatisticalBoxDataContainer입니다.
  
  또한 각 데이터 포인트 자체는 스칼라 포인트로 그려진 아웃 라이어 목록을 가질 수 있습니다.
  각각의 통계 박스 데이터 포인트의 키 좌표. 그들은 다음 중 하나를 사용하여 설정할 수 있습니다.
  각각의 \ ref addData (double, double, double, double, double, double, const QVector <double> &)
  "addData"메소드를 사용하거나 \ ref 데이터를 통해 개별 데이터 포인트에 액세스하고
  데이터 포인트의 <tt> QVector <double> 아웃 라이어 </ tt>.
  
  \ section qcpstatisticalbox-appearance 모양 변경
  
  각 데이터 포인트 박스의 모양은 낮은 곳부터 높은 곳까지 다양합니다.
  \ ref setPen 및 \ ref setBrush를 통해 제어됩니다. \ ref로 상자의 너비를 바꿀 수 있습니다.
  플롯 좌표의 setWidth.

  각 데이터 포인트의 시각적 표현은 또한 두 개의 수염으로 구성됩니다. 수염이 줄입니다.
  상위 4 분의 1에서 최대로, 하위 4 분의 1에서 최하위까지 도달합니다.
  수염 모양은 다음과 같이 수정할 수 있습니다 : \ ref setWhiskerPen, \ ref setWhiskerBarPen,
  \ ref setWhiskerWidth. 위스커 폭은 위스커에 수직 인 막대의 폭입니다.
  상단 (최대) 및 하단 (최소). 수염 모양 펜이 변경된 경우
  \ c Qt :: FlatCap에 대한 \ c capsStyle. 그렇지 않으면 백본 라인이 수염 바를 초과 할 수 있습니다.
  펜 캡이 완벽하게 평평하지 않아서 픽셀이 거의 없습니다.
  
  상자 내부의 중앙 표시기 선은 자체 펜, \ ref setMedianPen을가집니다.
  
  이상치 데이터 포인트는 정상적인 산점으로 그려집니다. 그들의 모습을 다음과 같이 제어 할 수 있습니다.
  \ ref setOutlierStyle
  
  \ section qcpstatisticalbox-usage 사용법
  
  QCustomPlot의 객체를 나타내는 모든 데이터와 마찬가지로 QCPStatisticalBox는 플롯 테이블입니다.
  (QCPAbstractPlottable). QCustomPlot의 plottable-interface가 적용됩니다.
  (QCustomPlot :: plottable, QCustomPlot :: removePlottable 등)
  
  일반적으로 먼저 인스턴스를 만듭니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpstatisticalbox-creation-1
  전달 된 축의 QCustomPlot 인스턴스에이를 등록합니다. 이 QCustomPlot 인스턴스는
  plottable의 소유권이므로 수동으로 삭제하지 말고 QCustomPlot :: removePlottable ()을 대신 사용하십시오.
  새로 생성 된 플롯 테이블은 다음과 같이 수정할 수 있습니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpstatisticalbox-creation-2
*/


/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */

/*! \fn QSharedPointer<QCPStatisticalBoxDataContainer> QCPStatisticalBox::data() const
  
  Returns a shared pointer to the internal data storage of type \ref
  QCPStatisticalBoxDataContainer. You may use it to directly manipulate the data, which may be more
  convenient and faster than using the regular \ref setData or \ref addData methods.
*/
/*! \ fn QSharedPointer <QCPStatisticalBoxDataContainer> QCPStatisticalBox :: data () const
  
  \ ref 유형의 내부 데이터 저장소에 대한 공유 포인터를 반환합니다.
  QCPStatisticalBoxDataContainer. 이 도구를 사용하여 데이터를 직접 조작 할 수 있습니다.
  편리하고 빠른 \ ref setData 또는 \ ref addData 메소드를 사용하는 것보다 빠릅니다.
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */

/*!
  Constructs a statistical box which uses \a keyAxis as its key axis ("x") and \a valueAxis as its
  value axis ("y"). \a keyAxis and \a valueAxis must reside in the same QCustomPlot instance and
  not have the same orientation. If either of these restrictions is violated, a corresponding
  message is printed to the debug output (qDebug), the construction is not aborted, though.
  
  The created QCPStatisticalBox is automatically registered with the QCustomPlot instance inferred
  from \a keyAxis. This QCustomPlot instance takes ownership of the QCPStatisticalBox, so do not
  delete it manually but use QCustomPlot::removePlottable() instead.
*/
/*!
  \ a keyAxis를 키 축 ( "x")으로 사용하고 \ a valueAxis를 키 축으로 사용하는 통계 상자를 생성합니다.
  값 축 ( "y"). \ a keyAxis와 \ valueAxis는 동일한 QCustomPlot 인스턴스에 있어야하며
  같은 방향이 아닙니다. 이러한 제한 사항 중 하나가 위반되면 해당하는
  메시지가 디버그 출력 (qDebug)에 인쇄되면 구성은 중단되지 않습니다.
  
  생성 된 QCPStatisticalBox는 유추 된 QCustomPlot 인스턴스와 함께 자동으로 등록됩니다.
  \ a keyAxis에서. 이 QCustomPlot 인스턴스는 QCPStatisticalBox의 소유권을 가지므로 그렇게하지 마십시오.
  수동으로 삭제하지만 대신 QCustomPlot :: removePlottable ()을 사용하십시오.
*/
QCPStatisticalBox::QCPStatisticalBox(QCPAxis *keyAxis, QCPAxis *valueAxis) :
  QCPAbstractPlottable1D<QCPStatisticalBoxData>(keyAxis, valueAxis),
  mWidth(0.5),
  mWhiskerWidth(0.2),
  mWhiskerPen(Qt::black, 0, Qt::DashLine, Qt::FlatCap),
  mWhiskerBarPen(Qt::black),
  mWhiskerAntialiased(false),
  mMedianPen(Qt::black, 3, Qt::SolidLine, Qt::FlatCap),
  mOutlierStyle(QCPScatterStyle::ssCircle, Qt::blue, 6)
{
  setPen(QPen(Qt::black));
  setBrush(Qt::NoBrush);
}

/*! \overload
  
  Replaces the current data container with the provided \a data container.
  
  Since a QSharedPointer is used, multiple QCPStatisticalBoxes may share the same data container
  safely. Modifying the data in the container will then affect all statistical boxes that share the
  container. Sharing can be achieved by simply exchanging the data containers wrapped in shared
  pointers:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpstatisticalbox-datasharing-1
  
  If you do not wish to share containers, but create a copy from an existing container, rather use
  the \ref QCPDataContainer<DataType>::set method on the statistical box data container directly:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpstatisticalbox-datasharing-2
  
  \see addData
*/
/*! \초과 적재
  
  현재 데이터 컨테이너를 제공된 \ 데이터 컨테이너로 바꿉니다.
  
  QSharedPointer가 사용되므로 여러 QCPStatisticalBox가 동일한 데이터 컨테이너를 공유 할 수 있습니다
  안전하게. 컨테이너의 데이터를 수정하면 해당 데이터를 공유하는 모든 통계 상자에 영향을줍니다.
  컨테이너. 공유는 간단하게 공유 된 데이터 컨테이너를 교환하여 공유 할 수 있습니다.
  포인터 :
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpstatisticalbox-datasharing-1
  
  컨테이너를 공유하지 않고 기존 컨테이너에서 사본을 만들려면
  통계 상자 데이터 컨테이너에서 \ ref QCPDataContainer <DataType> :: set 메서드를 직접 호출합니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpstatisticalbox-datasharing-2
  
  \ addData를 참조하십시오.
*/
void QCPStatisticalBox::setData(QSharedPointer<QCPStatisticalBoxDataContainer> data)
{
  mDataContainer = data;
}
/*! \overload
  
  Replaces the current data with the provided points in \a keys, \a minimum, \a lowerQuartile, \a
  median, \a upperQuartile and \a maximum. The provided vectors should have equal length. Else, the
  number of added points will be the size of the smallest vector.
  
  If you can guarantee that the passed data points are sorted by \a keys in ascending order, you
  can set \a alreadySorted to true, to improve performance by saving a sorting run.
  
  \see addData
*/
/*! \초과 적재
  
  현재 데이터를 \ a 키, 최소값, lowerQuartile, \ a의 제공된 점으로 대체합니다.
  중간 값, 최대 값 및 최대 값. 제공된 벡터의 길이는 동일해야합니다. 그렇지 않으면
  추가 된 점의 수는 가장 작은 벡터의 크기가됩니다.
  
  전달 된 데이터 요소가 \ a 키에 따라 오름차순으로 정렬되도록 보장 할 수 있으면
  정렬 실행을 저장하여 성능을 향상 시키려면 \ a alreadySorted를 true로 설정할 수 있습니다.
  
  \ addData를 참조하십시오.
*/
void QCPStatisticalBox::setData(const QVector<double> &keys, const QVector<double> &minimum, const QVector<double> &lowerQuartile, const QVector<double> &median, const QVector<double> &upperQuartile, const QVector<double> &maximum, bool alreadySorted)
{
  mDataContainer->clear();
  addData(keys, minimum, lowerQuartile, median, upperQuartile, maximum, alreadySorted);
}

/*!
  Sets the width of the boxes in key coordinates.
  
  \see setWhiskerWidth
*/
/*!
  상자의 폭을 키 좌표로 설정합니다.
  
  \ 참조 setWhiskerWidth
*/
void QCPStatisticalBox::setWidth(double width)
{
  mWidth = width;
}

/*!
  Sets the width of the whiskers in key coordinates.
  
  Whiskers are the lines which reach from the upper quartile to the maximum, and from the lower
  quartile to the minimum.
  
  \see setWidth
*/
/*!
  키 좌표로 수염의 폭을 설정합니다.
  
  수염은 상단 사 분위수에서 최대치까지 그리고 하단
  최소 4 분위.
  
  \ 참조 setWidth
*/
void QCPStatisticalBox::setWhiskerWidth(double width)
{
  mWhiskerWidth = width;
}

/*!
  Sets the pen used for drawing the whisker backbone.
  
  Whiskers are the lines which reach from the upper quartile to the maximum, and from the lower
  quartile to the minimum.
  
  Make sure to set the \c capStyle of the passed \a pen to \c Qt::FlatCap. Otherwise the backbone
  line might exceed the whisker bars by a few pixels due to the pen cap being not perfectly flat.
  
  \see setWhiskerBarPen
*/
/*!
  위스커 백본 그리기에 사용되는 펜을 설정합니다.
  
  수염은 상단 사 분위수에서 최대치까지 그리고 하단
  최소 4 분위.
  
  전달 된 \ pen의 \ c capsStyle이 \ c Qt :: FlatCap으로 설정되어 있는지 확인하십시오. 그렇지 않으면 백본
  펜 캡이 완전히 평평하지 않아 라인이 수 픽셀 바를 초과 할 수 있습니다.
  
  \ 참조 setWhiskerBarPen
*/
void QCPStatisticalBox::setWhiskerPen(const QPen &pen)
{
  mWhiskerPen = pen;
}

/*!
  Sets the pen used for drawing the whisker bars. Those are the lines parallel to the key axis at
  each end of the whisker backbone.
  
  Whiskers are the lines which reach from the upper quartile to the maximum, and from the lower
  quartile to the minimum.
  
  \see setWhiskerPen
*/
/*!
  수염 바를 그리는 데 사용되는 펜을 설정합니다. 그것들은 키 축에 평행 한 선들입니다.
  각 위턱 백본의 각 끝.
  
  수염은 상단 사 분위수에서 최대치까지 그리고 하단
  최소 4 분위.
  
  \ 참조 setWhiskerPen
*/
void QCPStatisticalBox::setWhiskerBarPen(const QPen &pen)
{
  mWhiskerBarPen = pen;
}

/*!
  Sets whether the statistical boxes whiskers are drawn with antialiasing or not.

  Note that antialiasing settings may be overridden by QCustomPlot::setAntialiasedElements and
  QCustomPlot::setNotAntialiasedElements.
*/
/*!
  통계 상자 위스커가 에일 리어 징 제거로 그려지는지 여부를 설정합니다.

  안티 앨리어싱 설정은 QCustomPlot :: setAntialiasedElements 및
  QCustomPlot :: setNotAntialiasedElements.
*/
void QCPStatisticalBox::setWhiskerAntialiased(bool enabled)
{
  mWhiskerAntialiased = enabled;
}

/*!
  Sets the pen used for drawing the median indicator line inside the statistical boxes.
*/
/*!
  통계 박스 안에 중앙 표시기 선을 그릴 때 사용할 펜을 설정합니다.
*/
void QCPStatisticalBox::setMedianPen(const QPen &pen)
{
  mMedianPen = pen;
}

/*!
  Sets the appearance of the outlier data points.

  Outliers can be specified with the method
  \ref addData(double key, double minimum, double lowerQuartile, double median, double upperQuartile, double maximum, const QVector<double> &outliers)
*/
/*!
  특이 치 데이터 포인트의 외형을 설정합니다.

  이상 치는 메소드로 지정할 수 있습니다.
  \ ref addData (double 키, double 최소값, double lower 분위 수, double 중앙값, double upper 분위수, 최대 최대 값, const QVector <double> 및 outliers)
*/
void QCPStatisticalBox::setOutlierStyle(const QCPScatterStyle &style)
{
  mOutlierStyle = style;
}

/*! \overload
   
  Adds the provided points in \a keys, \a minimum, \a lowerQuartile, \a median, \a upperQuartile and
  \a maximum to the current data. The provided vectors should have equal length. Else, the number
  of added points will be the size of the smallest vector.
   
  If you can guarantee that the passed data points are sorted by \a keys in ascending order, you
  can set \a alreadySorted to true, to improve performance by saving a sorting run.
   
  Alternatively, you can also access and modify the data directly via the \ref data method, which
  returns a pointer to the internal data container.
*/
/*! \초과 적재
   
  제공된 포인트를 \ a 키, \ a 최소값, \ lowerQuartile, \ median, \ upperQuartile 및
  현재 데이터에 최대 값. 제공된 벡터의 길이는 동일해야합니다. 그렇지 않으면 번호
  추가 점의 수는 가장 작은 벡터의 크기가됩니다.
   
  전달 된 데이터 요소가 \ a 키에 따라 오름차순으로 정렬되도록 보장 할 수 있으면
  정렬 실행을 저장하여 성능을 향상 시키려면 \ a alreadySorted를 true로 설정할 수 있습니다.
   
  또는 \ ref 데이터 메서드를 통해 직접 데이터에 액세스하고 수정할 수도 있습니다.
  내부 데이터 컨테이너에 대한 포인터를 반환합니다.
*/
void QCPStatisticalBox::addData(const QVector<double> &keys, const QVector<double> &minimum, const QVector<double> &lowerQuartile, const QVector<double> &median, const QVector<double> &upperQuartile, const QVector<double> &maximum, bool alreadySorted)
{
  if (keys.size() != minimum.size() || minimum.size() != lowerQuartile.size() || lowerQuartile.size() != median.size() ||
      median.size() != upperQuartile.size() || upperQuartile.size() != maximum.size() || maximum.size() != keys.size())
    qDebug() << Q_FUNC_INFO << "keys, minimum, lowerQuartile, median, upperQuartile, maximum have different sizes:"
             << keys.size() << minimum.size() << lowerQuartile.size() << median.size() << upperQuartile.size() << maximum.size();
  const int n = qMin(keys.size(), qMin(minimum.size(), qMin(lowerQuartile.size(), qMin(median.size(), qMin(upperQuartile.size(), maximum.size())))));
  QVector<QCPStatisticalBoxData> tempData(n);
  QVector<QCPStatisticalBoxData>::iterator it = tempData.begin();
  const QVector<QCPStatisticalBoxData>::iterator itEnd = tempData.end();
  int i = 0;
  while (it != itEnd)
  {
    it->key = keys[i];
    it->minimum = minimum[i];
    it->lowerQuartile = lowerQuartile[i];
    it->median = median[i];
    it->upperQuartile = upperQuartile[i];
    it->maximum = maximum[i];
    ++it;
    ++i;
  }
  mDataContainer->add(tempData, alreadySorted); 
// don't modify tempData beyond this to prevent copy on write
// 복사시 쓰기를 방지하기 위해 tempData를이 값 이상으로 수정하지 마십시오.
}

/*! \overload
  
  Adds the provided data point as \a key, \a minimum, \a lowerQuartile, \a median, \a upperQuartile
  and \a maximum to the current data.
  
  Alternatively, you can also access and modify the data directly via the \ref data method, which
  returns a pointer to the internal data container.
*/
/*! \초과 적재
  
  제공된 데이터 요소를 \ 키, 최소값, 하위 값, 중간 값, 상위 값으로 추가합니다.
  현재 데이터의 최대 값은 \ a입니다.
  
  또는 \ ref 데이터 메서드를 통해 직접 데이터에 액세스하고 수정할 수도 있습니다.
  내부 데이터 컨테이너에 대한 포인터를 반환합니다.
*/
void QCPStatisticalBox::addData(double key, double minimum, double lowerQuartile, double median, double upperQuartile, double maximum, const QVector<double> &outliers)
{
  mDataContainer->add(QCPStatisticalBoxData(key, minimum, lowerQuartile, median, upperQuartile, maximum, outliers));
}

/*!
  \copydoc QCPPlottableInterface1D::selectTestRect
*/
QCPDataSelection QCPStatisticalBox::selectTestRect(const QRectF &rect, bool onlySelectable) const
{
  QCPDataSelection result;
  if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())
    return result;
  if (!mKeyAxis || !mValueAxis)
    return result;
  
  QCPStatisticalBoxDataContainer::const_iterator visibleBegin, visibleEnd;
  getVisibleDataBounds(visibleBegin, visibleEnd);
  
  for (QCPStatisticalBoxDataContainer::const_iterator it=visibleBegin; it!=visibleEnd; ++it)
  {
    if (rect.intersects(getQuartileBox(it)))
      result.addDataRange(QCPDataRange(it-mDataContainer->constBegin(), it-mDataContainer->constBegin()+1), false);
  }
  result.simplify();
  return result;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPStatisticalBox::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  Q_UNUSED(details)
  if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())
    return -1;
  if (!mKeyAxis || !mValueAxis)
    return -1;
  
  if (mKeyAxis->axisRect()->rect().contains(pos.toPoint()))
  {
    // get visible data range:
    // 표시되는 데이터 범위 가져 오기 
    QCPStatisticalBoxDataContainer::const_iterator visibleBegin, visibleEnd;
    QCPStatisticalBoxDataContainer::const_iterator closestDataPoint = mDataContainer->constEnd();
    getVisibleDataBounds(visibleBegin, visibleEnd);
    double minDistSqr = std::numeric_limits<double>::max();
    for (QCPStatisticalBoxDataContainer::const_iterator it=visibleBegin; it!=visibleEnd; ++it)
    {
      if (getQuartileBox(it).contains(pos)) // quartile box   // 4 분위수 상자
      {                                    
        double currentDistSqr = mParentPlot->selectionTolerance()*0.99 * mParentPlot->selectionTolerance()*0.99;
        if (currentDistSqr < minDistSqr)
        {
          minDistSqr = currentDistSqr;
          closestDataPoint = it;
        }
      } else // whiskers  // 수염
      {
        const QVector<QLineF> whiskerBackbones(getWhiskerBackboneLines(it));
        for (int i=0; i<whiskerBackbones.size(); ++i)
        {
          double currentDistSqr = QCPVector2D(pos).distanceSquaredToLine(whiskerBackbones.at(i));
          if (currentDistSqr < minDistSqr)
          {
            minDistSqr = currentDistSqr;
            closestDataPoint = it;
          }
        }
      }
    }
    if (details)
    {
      int pointIndex = closestDataPoint-mDataContainer->constBegin();
      details->setValue(QCPDataSelection(QCPDataRange(pointIndex, pointIndex+1)));
    }
    return qSqrt(minDistSqr);
  }
  return -1;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPRange QCPStatisticalBox::getKeyRange(bool &foundRange, QCP::SignDomain inSignDomain) const
{
  QCPRange range = mDataContainer->keyRange(foundRange, inSignDomain);
  // determine exact range by including width of bars/flags:
  // 막대 / 플래그의 너비를 포함하여 정확한 범위를 결정합니다.
  if (foundRange)
  {
    if (inSignDomain != QCP::sdPositive || range.lower-mWidth*0.5 > 0)
      range.lower -= mWidth*0.5;
    if (inSignDomain != QCP::sdNegative || range.upper+mWidth*0.5 < 0)
      range.upper += mWidth*0.5;
  }
  return range;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPRange QCPStatisticalBox::getValueRange(bool &foundRange, QCP::SignDomain inSignDomain, const QCPRange &inKeyRange) const
{
  return mDataContainer->valueRange(foundRange, inSignDomain, inKeyRange);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPStatisticalBox::draw(QCPPainter *painter)
{
  if (mDataContainer->isEmpty()) return;
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
  
  QCPStatisticalBoxDataContainer::const_iterator visibleBegin, visibleEnd;
  getVisibleDataBounds(visibleBegin, visibleEnd);
  
  // loop over and draw segments of unselected/selected data:
  // 선택되지 않은 / 선택한 데이터의 세그먼트를 반복 및 그립니다.
  QList<QCPDataRange> selectedSegments, unselectedSegments, allSegments;
  getDataSegments(selectedSegments, unselectedSegments);
  allSegments << unselectedSegments << selectedSegments;
  for (int i=0; i<allSegments.size(); ++i)
  {
    bool isSelectedSegment = i >= unselectedSegments.size();
    QCPStatisticalBoxDataContainer::const_iterator begin = visibleBegin;
    QCPStatisticalBoxDataContainer::const_iterator end = visibleEnd;
    mDataContainer->limitIteratorsToDataRange(begin, end, allSegments.at(i));
    if (begin == end)
      continue;
    
    for (QCPStatisticalBoxDataContainer::const_iterator it=begin; it!=end; ++it)
    {
      // check data validity if flag set:
      // 플래그가 설정된 경우 데이터 유효성을 검사합니다.
# ifdef QCUSTOMPLOT_CHECK_DATA
      if (QCP::isInvalidData(it->key, it->minimum) ||
          QCP::isInvalidData(it->lowerQuartile, it->median) ||
          QCP::isInvalidData(it->upperQuartile, it->maximum))
        qDebug() << Q_FUNC_INFO << "Data point at" << it->key << "of drawn range has invalid data." << "Plottable name:" << name();
      for (int i=0; i<it->outliers.size(); ++i)
        if (QCP::isInvalidData(it->outliers.at(i)))
          qDebug() << Q_FUNC_INFO << "Data point outlier at" << it->key << "of drawn range invalid." << "Plottable name:" << name();
# endif
      
      if (isSelectedSegment && mSelectionDecorator)
      {
        mSelectionDecorator->applyPen(painter);
        mSelectionDecorator->applyBrush(painter);
      } else
      {
        painter->setPen(mPen);
        painter->setBrush(mBrush);
      }
      QCPScatterStyle finalOutlierStyle = mOutlierStyle;
      if (isSelectedSegment && mSelectionDecorator)
        finalOutlierStyle = mSelectionDecorator->getFinalScatterStyle(mOutlierStyle);
      drawStatisticalBox(painter, it, finalOutlierStyle);
    }
  }
  
  // draw other selection decoration that isn't just line/scatter pens and brushes:
  // 선 / 산란 펜 및 브러쉬가 아닌 다른 선택 장식을 그립니다.
  if (mSelectionDecorator)
    mSelectionDecorator->drawDecoration(painter, selection());
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPStatisticalBox::drawLegendIcon(QCPPainter *painter, const QRectF &rect) const
{
  // draw filled rect:
  // 채워진 rect를 그립니다.
  applyDefaultAntialiasingHint(painter);
  painter->setPen(mPen);
  painter->setBrush(mBrush);
  QRectF r = QRectF(0, 0, rect.width()*0.67, rect.height()*0.67);
  r.moveCenter(rect.center());
  painter->drawRect(r);
}

/*!
  Draws the graphical representation of a single statistical box with the data given by the
  iterator \a it with the provided \a painter.

  If the statistical box has a set of outlier data points, they are drawn with \a outlierStyle.

  \see getQuartileBox, getWhiskerBackboneLines, getWhiskerBarLines
*/

/*!
  주어진 통계 데이터 상자를 그래픽으로 그립니다.
  iterator \ a it \ a 화가와 함께 제공됩니다.

  통계 박스에 비정상 값 데이터 포인트 집합이 있으면 \ a outlierStyle로 그려집니다.

  \ getQuartileBox 참조, getWhiskerBackboneLines, getWhiskerBarLines
*/
void QCPStatisticalBox::drawStatisticalBox(QCPPainter *painter, QCPStatisticalBoxDataContainer::const_iterator it, const QCPScatterStyle &outlierStyle) const
{
  // draw quartile box:
  // 4 분위수 상자를 그립니다.
  applyDefaultAntialiasingHint(painter);
  const QRectF quartileBox = getQuartileBox(it);
  painter->drawRect(quartileBox);
  // draw median line with cliprect set to quartile box:
  // quartile box로 설정된 cliprect가있는 중간 선을 그립니다.
  painter->save();
  painter->setClipRect(quartileBox, Qt::IntersectClip);
  painter->setPen(mMedianPen);
  painter->drawLine(QLineF(coordsToPixels(it->key-mWidth*0.5, it->median), coordsToPixels(it->key+mWidth*0.5, it->median)));
  painter->restore();
  // draw whisker lines:
  // 수염 줄을 그립니다.
  applyAntialiasingHint(painter, mWhiskerAntialiased, QCP::aePlottables);
  painter->setPen(mWhiskerPen);
  painter->drawLines(getWhiskerBackboneLines(it));
  painter->setPen(mWhiskerBarPen);
  painter->drawLines(getWhiskerBarLines(it));
  // draw outliers:
  // 이상 치를 그린다 :
  applyScattersAntialiasingHint(painter);
  outlierStyle.applyTo(painter, mPen);
  for (int i=0; i<it->outliers.size(); ++i)
    outlierStyle.drawShape(painter, coordsToPixels(it->key, it->outliers.at(i)));
}

/*!  \internal
  
  called by \ref draw to determine which data (key) range is visible at the current key axis range
  setting, so only that needs to be processed. It also takes into account the bar width.
  
  \a begin returns an iterator to the lowest data point that needs to be taken into account when
  plotting. Note that in order to get a clean plot all the way to the edge of the axis rect, \a
  lower may still be just outside the visible range.
  
  \a end returns an iterator one higher than the highest visible data point. Same as before, \a end
  may also lie just outside of the visible range.
  
  if the plottable contains no data, both \a begin and \a end point to constEnd.
*/
/*! \내부의
  
  현재 키 축 범위에서 볼 수있는 데이터 (키) 범위를 결정하기 위해 \ ref draw에 의해 호출됩니다.
  설정이므로 처리해야합니다. 또한 막대 너비도 고려합니다.
  
  \ a begin은 가장 낮은 데이터 점에 대한 반복자를 반환합니다.
  플로팅. 깨끗한 그림을 축 rect의 끝까지 가져 오려면 \ a
  lower는 여전히 가시 범위 밖에있을 수 있습니다.
  
  \ end는 가장 높은 가시적 인 데이터 포인트보다 하나 높은 반복자를 반환합니다. 이전과 같음, 끝
  또한 가시 범위 밖에있을 수 있습니다.
  
  plottable에 데이터가 없으면 \ begin과 \ end는 모두 constEnd를 가리 킵니다.
*/
void QCPStatisticalBox::getVisibleDataBounds(QCPStatisticalBoxDataContainer::const_iterator &begin, QCPStatisticalBoxDataContainer::const_iterator &end) const
{
  if (!mKeyAxis)
  {
    qDebug() << Q_FUNC_INFO << "invalid key axis";
    begin = mDataContainer->constEnd();
    end = mDataContainer->constEnd();
    return;
  }
  begin = mDataContainer->findBegin(mKeyAxis.data()->range().lower-mWidth*0.5); 
// subtract half width of box to include partially visible data points
// 부분적으로 보이는 데이터 포인트를 포함하기 위해 상자의 반 너비를 뺍니다.
  end = mDataContainer->findEnd(mKeyAxis.data()->range().upper+mWidth*0.5); 
// add half width of box to include partially visible data points
// 부분적으로 표시되는 데이터 요소를 포함하도록 상자의 너비를 더합니다.
}

/*!  \internal

  Returns the box in plot coordinates (keys in x, values in y of the returned rect) that covers the
  value range from the lower to the upper quartile, of the data given by \a it.

  \see drawStatisticalBox, getWhiskerBackboneLines, getWhiskerBarLines
*/
/*! \내부의

  상자를 덮는 플롯 좌표 (x의 키, 반환 된 rect의 y 값)를 반환합니다.
  값의 범위는 낮은 값에서 상위 값까지, 그 값에 의해 주어진 값이다.

  \ drawStatisticalBox보기, getWhiskerBackboneLines, getWhiskerBarLines
*/
QRectF QCPStatisticalBox::getQuartileBox(QCPStatisticalBoxDataContainer::const_iterator it) const
{
  QRectF result;
  result.setTopLeft(coordsToPixels(it->key-mWidth*0.5, it->upperQuartile));
  result.setBottomRight(coordsToPixels(it->key+mWidth*0.5, it->lowerQuartile));
  return result;
}

/*!  \internal

  Returns the whisker backbones (keys in x, values in y of the returned lines) that cover the value
  range from the minimum to the lower quartile, and from the upper quartile to the maximum of the
  data given by \a it.

  \see drawStatisticalBox, getQuartileBox, getWhiskerBarLines
*/
/*! \내부의

  값을 포함하는 수염 뼈대 (x의 키, 반환 된 선의 y 값)를 반환합니다.
  최소 사 분위수부터 저 사 분위수까지, 그리고 상위 사 분위수에서 최대 사 분위수까지
  \ a에 의해 주어진 데이터.

  \ drawStatisticalBox, getQuartileBox, getWhiskerBarLines를 참조하십시오.
*/
QVector<QLineF> QCPStatisticalBox::getWhiskerBackboneLines(QCPStatisticalBoxDataContainer::const_iterator it) const
{
  QVector<QLineF> result(2);
  result[0].setPoints(coordsToPixels(it->key, it->lowerQuartile), coordsToPixels(it->key, it->minimum)); 
// min backbone
// 최소 백본
  result[1].setPoints(coordsToPixels(it->key, it->upperQuartile), coordsToPixels(it->key, it->maximum));
// max backbone
// 최대 백본
  return result;
}

/*!  \internal

  Returns the whisker bars (keys in x, values in y of the returned lines) that are placed at the
  end of the whisker backbones, at the minimum and maximum of the data given by \a it.

  \see drawStatisticalBox, getQuartileBox, getWhiskerBackboneLines
*/
/*! \내부의

  물결 모양 막대 (x의 키, 반환 된 선의 y 값)를 반환합니다.
  수염 (whisker) 백본의 끝 부분은 최소값과 최대 값으로 주어진다.

  \ drawStatisticalBox, getQuartileBox, getWhiskerBackboneLines를 참조하십시오.
*/
QVector<QLineF> QCPStatisticalBox::getWhiskerBarLines(QCPStatisticalBoxDataContainer::const_iterator it) const
{
  QVector<QLineF> result(2);
  result[0].setPoints(coordsToPixels(it->key-mWhiskerWidth*0.5, it->minimum), coordsToPixels(it->key+mWhiskerWidth*0.5, it->minimum)); // min bar
  result[1].setPoints(coordsToPixels(it->key-mWhiskerWidth*0.5, it->maximum), coordsToPixels(it->key+mWhiskerWidth*0.5, it->maximum)); // max bar
  return result;
}
/* end of 'src/plottables/plottable-statisticalbox.cpp' */


/* including file 'src/plottables/plottable-colormap.cpp', size 47881        */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / plottables / plottable-statisticalbox.cpp'의 끝 */


/* 파일 'src / plottables / plottable-colormap.cpp'포함, 크기 47881 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPColorMapData
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPColorMapData
  \brief Holds the two-dimensional data of a QCPColorMap plottable.
  
  This class is a data storage for \ref QCPColorMap. It holds a two-dimensional array, which \ref
  QCPColorMap then displays as a 2D image in the plot, where the array values are represented by a
  color, depending on the value.
  
  The size of the array can be controlled via \ref setSize (or \ref setKeySize, \ref setValueSize).
  Which plot coordinates these cells correspond to can be configured with \ref setRange (or \ref
  setKeyRange, \ref setValueRange).
  
  The data cells can be accessed in two ways: They can be directly addressed by an integer index
  with \ref setCell. This is the fastest method. Alternatively, they can be addressed by their plot
  coordinate with \ref setData. plot coordinate to cell index transformations and vice versa are
  provided by the functions \ref coordToCell and \ref cellToCoord.
  
  A \ref QCPColorMapData also holds an on-demand two-dimensional array of alpha values which (if
  allocated) has the same size as the data map. It can be accessed via \ref setAlpha, \ref
  fillAlpha and \ref clearAlpha. The memory for the alpha map is only allocated if needed, i.e. on
  the first call of \ref setAlpha. \ref clearAlpha restores full opacity and frees the alpha map.
  
  This class also buffers the minimum and maximum values that are in the data set, to provide
  QCPColorMap::rescaleDataRange with the necessary information quickly. Setting a cell to a value
  that is greater than the current maximum increases this maximum to the new value. However,
  setting the cell that currently holds the maximum value to a smaller value doesn't decrease the
  maximum again, because finding the true new maximum would require going through the entire data
  array, which might be time consuming. The same holds for the data minimum. This functionality is
  given by \ref recalculateDataBounds, such that you can decide when it is sensible to find the
  true current minimum and maximum. The method QCPColorMap::rescaleDataRange offers a convenience
  parameter \a recalculateDataBounds which may be set to true to automatically call \ref
  recalculateDataBounds internally.
*/
/*! \ class QCPColorMapData
  \ brief QCPColorMap 플롯 테이블의 2 차원 데이터를 보유합니다.
  
  이 클래스는 \ ref QCPColorMap의 데이터 저장소입니다. 2 차원 배열을 가지고 있는데, \ ref
  그런 다음 QCPColorMap은 플롯에 2D 이미지로 표시됩니다. 여기서 배열 값은
  색상, 값에 따라.
  
  배열의 크기는 \ ref setSize (또는 \ ref setKeySize, \ ref setValueSize)를 통해 제어 할 수 있습니다.
  이 셀들이 대응하는 플롯 좌표는 \ ref setRange (또는 \ ref
  setKeyRange, \ ref setValueRange).
  
  데이터 셀은 두 가지 방법으로 액세스 할 수 있습니다. 즉, 정수 인덱스로 직접 주소 지정 될 수 있습니다
  \ ref setCell과 함께. 이것은 가장 빠른 방법입니다. 대안으로, 그것들은 그들의 플롯에 의해 언급 될 수있다.
  \ ref setData로 조정하십시오. 플롯 좌표를 셀 인덱스 변환으로 변환하고 그 반대의 경우도 마찬가지입니다.
  \ ref coordToCell 및 \ ref cellToCoord 함수에서 제공합니다.
  
  \ ref QCPColorMapData는 주문형 2 차원 알파 값 배열도 보유합니다.
  할당 된)은 데이터 맵과 동일한 크기입니다. \ ref setAlpha, \ ref를 통해 액세스 할 수 있습니다.
  fillAlpha 및 \ ref clearAlpha. 알파 맵의 메모리는 필요한 경우에만 할당됩니다.
  \ ref setAlpha의 첫 번째 호출. \ ref clearAlpha는 전체 불투명도를 복원하고 알파 맵을 해제합니다.
  
  이 클래스는 또한 데이터 세트에있는 최소값과 최대 값을 버퍼링하여
  필요한 정보를 빠르게 QCPColorMap :: rescaleDataRange에 저장하십시오. 셀을 값으로 설정하기
  현재 최대 값보다 큰 값은이 최대 값을 새 값으로 증가시킵니다. 하나,
  현재 최대 값을 유지하는 셀을 더 작은 값으로 설정해도
  최대 값을 다시 찾으면 실제 최대 값을 찾으면 전체 데이터를 검토해야하므로
  배열, 시간이 오래 걸릴 수 있습니다. 데이터 최소값에 대해서도 동일하게 적용됩니다. 이 기능은
  \ ref recalculateDataBounds에 의해 주어 지므로, 당신이 그것을 발견하는 것이 현명 할 때를 결정할 수있다.
  실제 현재 최소 및 최대. QCPColorMap :: rescaleDataRange 메소드는 편리함을 제공합니다.
  매개 변수 \ a recalculateDataBounds 자동으로 \ ref를 호출하려면 true로 설정할 수 있습니다.
  내부적으로 recalculateDataBounds.
*/

/* start of documentation of inline functions */
/* 인라인 함수의 문서화 시작 */

/*! \fn bool QCPColorMapData::isEmpty() const
  
  Returns whether this instance carries no data. This is equivalent to having a size where at least
  one of the dimensions is 0 (see \ref setSize).
*/
/*! \ fn bool QCPColorMapData :: isEmpty () const
  
  이 인스턴스가 데이터를 전송하고 있을지 어떨지를 돌려줍니다. 이것은 최소한 크기가있는 것과 같습니다.
  치수 중 하나는 0입니다 (\ ref setSize 참조).
*/

/* end of documentation of inline functions */
/* 인라인 함수의 문서 끝 */

/*!
  Constructs a new QCPColorMapData instance. The instance has \a keySize cells in the key direction
  and \a valueSize cells in the value direction. These cells will be displayed by the \ref QCPColorMap
  at the coordinates \a keyRange and \a valueRange.
  
  \see setSize, setKeySize, setValueSize, setRange, setKeyRange, setValueRange
*/
/*!
  새로운 QCPColorMapData 인스턴스를 구축합니다. 인스턴스의 키 방향에 \ a keySize 셀이 있습니다.
  값의 방향으로 셀을 \ a valueSize합니다. 이 셀은 \ ref QCPColorMap에 의해 표시됩니다.
  \ a keyRange 및 \ valueRange 좌표에서.
  
  \ setSize, setKeySize, setValueSize, setRange, setKeyRange, setValueRange를 참조하십시오.
*/
QCPColorMapData::QCPColorMapData(int keySize, int valueSize, const QCPRange &keyRange, const QCPRange &valueRange) :
  mKeySize(0),
  mValueSize(0),
  mKeyRange(keyRange),
  mValueRange(valueRange),
  mIsEmpty(true),
  mData(0),
  mAlpha(0),
  mDataModified(true)
{
  setSize(keySize, valueSize);
  fill(0);
}

QCPColorMapData::~QCPColorMapData()
{
  if (mData)
    delete[] mData;
  if (mAlpha)
    delete[] mAlpha;
}

/*!
  Constructs a new QCPColorMapData instance copying the data and range of \a other.
*/
/*!
  \ another의 데이터와 범위를 복사 해, 새로운 QCPColorMapData 인스턴스를 구축합니다.
*/
QCPColorMapData::QCPColorMapData(const QCPColorMapData &other) :
  mKeySize(0),
  mValueSize(0),
  mIsEmpty(true),
  mData(0),
  mAlpha(0),
  mDataModified(true)
{
  *this = other;
}

/*!
  Overwrites this color map data instance with the data stored in \a other. The alpha map state is
  transferred, too.
*/
/*!
  이 컬러 맵 데이터 인스턴스를 \ a에 저장된 데이터로 덮어 씁니다. 알파지도 상태는 다음과 같습니다.
  옮겨졌다.
*/
QCPColorMapData &QCPColorMapData::operator=(const QCPColorMapData &other)
{
  if (&other != this)
  {
    const int keySize = other.keySize();
    const int valueSize = other.valueSize();
    if (!other.mAlpha && mAlpha)
      clearAlpha();
    setSize(keySize, valueSize);
    if (other.mAlpha && !mAlpha)
      createAlpha(false);
    setRange(other.keyRange(), other.valueRange());
    if (!isEmpty())
    {
      memcpy(mData, other.mData, sizeof(mData[0])*keySize*valueSize);
      if (mAlpha)
        memcpy(mAlpha, other.mAlpha, sizeof(mAlpha[0])*keySize*valueSize);
    }
    mDataBounds = other.mDataBounds;
    mDataModified = true;
  }
  return *this;
}

/* undocumented getter */
/* 문서화되지 않은 getter */
double QCPColorMapData::data(double key, double value)
{
  int keyCell = (key-mKeyRange.lower)/(mKeyRange.upper-mKeyRange.lower)*(mKeySize-1)+0.5;
  int valueCell = (value-mValueRange.lower)/(mValueRange.upper-mValueRange.lower)*(mValueSize-1)+0.5;
  if (keyCell >= 0 && keyCell < mKeySize && valueCell >= 0 && valueCell < mValueSize)
    return mData[valueCell*mKeySize + keyCell];
  else
    return 0;
}

/* undocumented getter */
/* 문서화되지 않은 getter */
double QCPColorMapData::cell(int keyIndex, int valueIndex)
{
  if (keyIndex >= 0 && keyIndex < mKeySize && valueIndex >= 0 && valueIndex < mValueSize)
    return mData[valueIndex*mKeySize + keyIndex];
  else
    return 0;
}

/*!
  Returns the alpha map value of the cell with the indices \a keyIndex and \a valueIndex.

  If this color map data doesn't have an alpha map (because \ref setAlpha was never called after
  creation or after a call to \ref clearAlpha), returns 255, which corresponds to full opacity.

  \see setAlpha
*/
/*!
  indices \ a keyIndex 및 \ a valueIndex를 가지는 셀의 알파 맵 값을 리턴합니다.

  이 컬러 맵 데이터에 알파 맵이없는 경우 (\ ref setAlpha는
  생성 또는 \ ref clearAlpha 호출 후), 완전 불투명도에 해당하는 255를 반환합니다.

  \ 참조 setAlpha
*/
unsigned char QCPColorMapData::alpha(int keyIndex, int valueIndex)
{
  if (mAlpha && keyIndex >= 0 && keyIndex < mKeySize && valueIndex >= 0 && valueIndex < mValueSize)
    return mAlpha[valueIndex*mKeySize + keyIndex];
  else
    return 255;
}

/*!
  Resizes the data array to have \a keySize cells in the key dimension and \a valueSize cells in
  the value dimension.

  The current data is discarded and the map cells are set to 0, unless the map had already the
  requested size.
  
  Setting at least one of \a keySize or \a valueSize to zero frees the internal data array and \ref
  isEmpty returns true.

  \see setRange, setKeySize, setValueSize
*/
/*!
  키 차원에서 \ keySize 셀을 가지도록 데이터 배열의 크기를 조정하고 \ dimensionSize 셀에서
  값 차원

  현재 데이터가 삭제되고지도 셀은 0으로 설정됩니다. 단,지도에 이미
  요청한 크기.
  
  \ keySize 또는 \ valueSize 중 하나 이상을 0으로 설정하면 내부 데이터 배열과 \ ref가 해제됩니다.
  isEmpty는 true를 리턴합니다.

  \ setRange, setKeySize, setValueSize를 참조하십시오.
*/
void QCPColorMapData::setSize(int keySize, int valueSize)
{
  if (keySize != mKeySize || valueSize != mValueSize)
  {
    mKeySize = keySize;
    mValueSize = valueSize;
    if (mData)
      delete[] mData;
    mIsEmpty = mKeySize == 0 || mValueSize == 0;
    if (!mIsEmpty)
    {
#ifdef __EXCEPTIONS
      try { // 2D arrays get memory intensive fast. So if the allocation fails, at least output debug message
            // 2D 배열은 메모리를 많이 소비합니다. 따라서 할당이 실패하면 적어도 디버그 메시지를 출력합니다.
#endif
      mData = new double[mKeySize*mValueSize];
#ifdef __EXCEPTIONS
      } catch (...) { mData = 0; }
#endif
      if (mData)
        fill(0);
      else
        qDebug() << Q_FUNC_INFO << "out of memory for data dimensions "<< mKeySize << "*" << mValueSize;
    } else
      mData = 0;
    
    if (mAlpha) // if we had an alpha map, recreate it with new size
                // 알파 맵이 있으면 새로운 크기로 다시 만듭니다.
      createAlpha();
    
    mDataModified = true;
  }
}

/*!
  Resizes the data array to have \a keySize cells in the key dimension.

  The current data is discarded and the map cells are set to 0, unless the map had already the
  requested size.
  
  Setting \a keySize to zero frees the internal data array and \ref isEmpty returns true.

  \see setKeyRange, setSize, setValueSize
*/
/*!
  키 차원에서 keySize 셀을 갖도록 데이터 배열의 크기를 조정합니다.

  현재 데이터가 삭제되고지도 셀은 0으로 설정됩니다. 단,지도에 이미
  요청한 크기.
  
  \ keySize를 0으로 설정하면 내부 데이터 배열이 해제되고 \ ref isEmpty는 true를 반환합니다.

  \ setKeyRange, setSize, setValueSize를 참조하십시오.
*/
void QCPColorMapData::setKeySize(int keySize)
{
  setSize(keySize, mValueSize);
}

/*!
  Resizes the data array to have \a valueSize cells in the value dimension.

  The current data is discarded and the map cells are set to 0, unless the map had already the
  requested size.
  
  Setting \a valueSize to zero frees the internal data array and \ref isEmpty returns true.

  \see setValueRange, setSize, setKeySize
*/
/*!
  값 차원에서 값 셀의 크기를 갖도록 데이터 배열의 크기를 조정합니다.

  현재 데이터가 삭제되고지도 셀은 0으로 설정됩니다. 단,지도에 이미
  요청한 크기.
  
  \ valueSize를 0으로 설정하면 내부 데이터 배열이 해제되고 \ ref isEmpty는 true를 반환합니다.

  \ setValueRange, setSize, setKeySize를 참조하십시오.
*/
void QCPColorMapData::setValueSize(int valueSize)
{
  setSize(mKeySize, valueSize);
}

/*!
  Sets the coordinate ranges the data shall be distributed over. This defines the rectangular area
  covered by the color map in plot coordinates.
  
  The outer cells will be centered on the range boundaries given to this function. For example, if
  the key size (\ref setKeySize) is 3 and \a keyRange is set to <tt>QCPRange(2, 3)</tt> there will
  be cells centered on the key coordinates 2, 2.5 and 3.
 
  \see setSize
*/
/*!
  데이터가 분산되는 좌표 범위를 설정합니다. 직사각형 영역을 정의합니다.
  플롯 좌표에서 컬러 맵으로 덮여 있습니다.
  
  바깥 쪽 셀은이 함수에 주어진 범위 경계에 집중됩니다. 예를 들어, if
  키 크기 (\ ref setKeySize)는 3이고 \ keyRange는 <tt> QCPRange (2, 3) </ tt>로 설정됩니다.
  키 좌표 2, 2.5 및 3에 중심을 둔 셀입니다.
 
  \ setSize를 참조하십시오.
*/
void QCPColorMapData::setRange(const QCPRange &keyRange, const QCPRange &valueRange)
{
  setKeyRange(keyRange);
  setValueRange(valueRange);
}

/*!
  Sets the coordinate range the data shall be distributed over in the key dimension. Together with
  the value range, This defines the rectangular area covered by the color map in plot coordinates.
  
  The outer cells will be centered on the range boundaries given to this function. For example, if
  the key size (\ref setKeySize) is 3 and \a keyRange is set to <tt>QCPRange(2, 3)</tt> there will
  be cells centered on the key coordinates 2, 2.5 and 3.
 
  \see setRange, setValueRange, setSize
*/
/*!
  데이터가 키 차원에서 분산되어야하는 좌표 범위를 설정합니다. 함께
  값 범위, 이것은 플롯 좌표에서 컬러 맵에 의해 커버되는 직사각형 영역을 정의합니다.
  
  바깥 쪽 셀은이 함수에 주어진 범위 경계에 집중됩니다. 예를 들어, if
  키 크기 (\ ref setKeySize)는 3이고 \ keyRange는 <tt> QCPRange (2, 3) </ tt>로 설정됩니다.
  키 좌표 2, 2.5 및 3에 중심을 둔 셀입니다.
 
  \ setRange, setValueRange, setSize를 참조하십시오.
*/
void QCPColorMapData::setKeyRange(const QCPRange &keyRange)
{
  mKeyRange = keyRange;
}

/*!
  Sets the coordinate range the data shall be distributed over in the value dimension. Together with
  the key range, This defines the rectangular area covered by the color map in plot coordinates.
  
  The outer cells will be centered on the range boundaries given to this function. For example, if
  the value size (\ref setValueSize) is 3 and \a valueRange is set to <tt>QCPRange(2, 3)</tt> there
  will be cells centered on the value coordinates 2, 2.5 and 3.
 
  \see setRange, setKeyRange, setSize
*/
/*!
  데이터가 값 차원에서 분산되어야하는 좌표 범위를 설정합니다. 함께
  키 범위, 이것은 플롯 좌표에서 컬러 맵으로 덮힌 직사각형 영역을 정의합니다.
  
  바깥 쪽 셀은이 함수에 주어진 범위 경계에 집중됩니다. 예를 들어, if
  값 크기 (\ ref setValueSize)는 3이고 \ valueRange는 <tt> QCPRange (2, 3) </ tt>로 설정됩니다.
  값 좌표 2, 2.5 및 3을 중심으로하는 셀입니다.
 
  \ setRange, setKeyRange, setSize를 참조하십시오.
*/
void QCPColorMapData::setValueRange(const QCPRange &valueRange)
{
  mValueRange = valueRange;
}

/*!
  Sets the data of the cell, which lies at the plot coordinates given by \a key and \a value, to \a
  z.
  
  \note The QCPColorMap always displays the data at equal key/value intervals, even if the key or
  value axis is set to a logarithmic scaling. If you want to use QCPColorMap with logarithmic axes,
  you shouldn't use the \ref QCPColorMapData::setData method as it uses a linear transformation to
  determine the cell index. Rather directly access the cell index with \ref
  QCPColorMapData::setCell.
 
  \see setCell, setRange
*/
/*!
  \ a 키와 \ a 값으로 주어진 플롯 좌표에있는 셀의 데이터를 \ a로 설정합니다.
  지.
  
  \ note QCPColorMap은 키 또는 값 간격이 동일한 키 또는 값 간격으로 항상 데이터를 표시합니다.
  값 축은 대수 배율로 설정됩니다. 대수 축과 함께 QCPColorMap을 사용하려면,
  \ ref QCPColorMapData :: setData 메서드는 선형 변환을 사용하기 때문에 사용하면 안됩니다.
  셀 인덱스를 결정하십시오. 오히려 \ ref를 사용하여 셀 색인에 직접 액세스하십시오.
  QCPColorMapData :: setCell.
 
  \ setCell, setRange를 참조하십시오.
*/
void QCPColorMapData::setData(double key, double value, double z)
{
  int keyCell = (key-mKeyRange.lower)/(mKeyRange.upper-mKeyRange.lower)*(mKeySize-1)+0.5;
  int valueCell = (value-mValueRange.lower)/(mValueRange.upper-mValueRange.lower)*(mValueSize-1)+0.5;
  if (keyCell >= 0 && keyCell < mKeySize && valueCell >= 0 && valueCell < mValueSize)
  {
    mData[valueCell*mKeySize + keyCell] = z;
    if (z < mDataBounds.lower)
      mDataBounds.lower = z;
    if (z > mDataBounds.upper)
      mDataBounds.upper = z;
     mDataModified = true;
  }
}

/*!
  Sets the data of the cell with indices \a keyIndex and \a valueIndex to \a z. The indices
  enumerate the cells starting from zero, up to the map's size-1 in the respective dimension (see
  \ref setSize).
  
  In the standard plot configuration (horizontal key axis and vertical value axis, both not
  range-reversed), the cell with indices (0, 0) is in the bottom left corner and the cell with
  indices (keySize-1, valueSize-1) is in the top right corner of the color map.
  
  \see setData, setSize
*/
/*!
  indices \ a keyIndex 및 \ valueIndex를 사용하여 셀의 데이터를 \ a z로 설정합니다. 색인
  0부터 시작하여 각 차원에서지도의 크기 -1까지 셀을 열거합니다 (
  \ ref setSize).
  
  표준 플롯 구성 (수평 키 축 및 수직 값 축 모두에서
  range-reversed), 인덱스가있는 셀 (0, 0)은 왼쪽 하단 모서리에 있고 셀은
  인덱스 (keySize-1, valueSize-1)는 컬러 맵의 오른쪽 위 모서리에 있습니다.
  
  \ setData, setSize를 참조하십시오.
*/
void QCPColorMapData::setCell(int keyIndex, int valueIndex, double z)
{
  if (keyIndex >= 0 && keyIndex < mKeySize && valueIndex >= 0 && valueIndex < mValueSize)
  {
    mData[valueIndex*mKeySize + keyIndex] = z;
    if (z < mDataBounds.lower)
      mDataBounds.lower = z;
    if (z > mDataBounds.upper)
      mDataBounds.upper = z;
     mDataModified = true;
  } else
    qDebug() << Q_FUNC_INFO << "index out of bounds:" << keyIndex << valueIndex;
}

/*!
  Sets the alpha of the color map cell given by \a keyIndex and \a valueIndex to \a alpha. A value
  of 0 for \a alpha results in a fully transparent cell, and a value of 255 results in a fully
  opaque cell.

  If an alpha map doesn't exist yet for this color map data, it will be created here. If you wish
  to restore full opacity and free any allocated memory of the alpha map, call \ref clearAlpha.

  Note that the cell-wise alpha which can be configured here is independent of any alpha configured
  in the color map's gradient (\ref QCPColorGradient). If a cell is affected both by the cell-wise
  and gradient alpha, the alpha values will be blended accordingly during rendering of the color
  map.

  \see fillAlpha, clearAlpha
*/
/*!
  \ keyIndex 및 \ valueIndex에 의해 주어진 컬러 맵 셀의 알파를 \ alpha로 설정합니다. 가치
  \ a 알파에 대해 0을 사용하면 완전히 투명한 셀이되고 255 값을 지정하면 완전히 투명하게됩니다
  불투명 셀.

  알파 맵이 아직이 컬러 맵 데이터에 없으면 여기에 생성됩니다. 당신이 원하는 경우
  완전 불투명도를 복원하고 알파 맵의 할당 된 메모리를 해제하려면 \ ref clearAlpha를 호출하십시오.

  여기서 구성 할 수있는 셀 단위 알파는 구성된 알파와는 독립적입니다.
  컬러 맵의 그라디언트 (\ ref QCPColorGradient)에서. 세포가 세포에 의해 영향을받는 경우
  및 그라디언트 알파를 사용하면 알파 값은 색상 렌더링 중에 그에 따라 혼합됩니다
  지도.

  \ see fillAlpha, clearAlpha
*/
void QCPColorMapData::setAlpha(int keyIndex, int valueIndex, unsigned char alpha)
{
  if (keyIndex >= 0 && keyIndex < mKeySize && valueIndex >= 0 && valueIndex < mValueSize)
  {
    if (mAlpha || createAlpha())
    {
      mAlpha[valueIndex*mKeySize + keyIndex] = alpha;
      mDataModified = true;
    }
  } else
    qDebug() << Q_FUNC_INFO << "index out of bounds:" << keyIndex << valueIndex;
}

/*!
  Goes through the data and updates the buffered minimum and maximum data values.
  
  Calling this method is only advised if you are about to call \ref QCPColorMap::rescaleDataRange
  and can not guarantee that the cells holding the maximum or minimum data haven't been overwritten
  with a smaller or larger value respectively, since the buffered maximum/minimum values have been
  updated the last time. Why this is the case is explained in the class description (\ref
  QCPColorMapData).
  
  Note that the method \ref QCPColorMap::rescaleDataRange provides a parameter \a
  recalculateDataBounds for convenience. Setting this to true will call this method for you, before
  doing the rescale.
*/
/*!
  데이터를 이동하여 버퍼링 된 최소 및 최대 데이터 값을 업데이트합니다.
  
  이 메소드를 호출하는 것은 \ ref QCPColorMap :: rescaleDataRange를 호출하려는 경우에만 권장된다.
  최대 또는 최소 데이터를 보유하는 셀이 겹쳐 쓰여지지 않았다고 보장 할 수는 없습니다
  더 작은 값 또는 더 큰 값으로 버퍼링 된 최대 / 최소값은
  마지막으로 업데이트되었습니다. 이 경우의 이유는 클래스 설명 (\ ref
  QCPColorMapData).
  
  \ ref QCPColorMap :: rescaleDataRange 메소드는 매개 변수 \ a를 제공합니다.
  편의상 recalculateDataBounds. 이것을 true로 설정하면이 메소드가 호출됩니다.
  재조정.
*/
void QCPColorMapData::recalculateDataBounds()
{
  if (mKeySize > 0 && mValueSize > 0)
  {
    double minHeight = mData[0];
    double maxHeight = mData[0];
    const int dataCount = mValueSize*mKeySize;
    for (int i=0; i<dataCount; ++i)
    {
      if (mData[i] > maxHeight)
        maxHeight = mData[i];
      if (mData[i] < minHeight)
        minHeight = mData[i];
    }
    mDataBounds.lower = minHeight;
    mDataBounds.upper = maxHeight;
  }
}

/*!
  Frees the internal data memory.
  
  This is equivalent to calling \ref setSize "setSize(0, 0)".
*/
/*!
  내부 데이터 메모리를 비 웁니다.
  
  이것은 \ ref setSize "setSize (0, 0)"를 호출하는 것과 같습니다.
*/
void QCPColorMapData::clear()
{
  setSize(0, 0);
}

/*!
  Frees the internal alpha map. The color map will have full opacity again.
*/
/*!
  내부 알파 맵을 해제합니다. 컬러 맵은 완전히 불투명 해집니다.
*/
void QCPColorMapData::clearAlpha()
{
  if (mAlpha)
  {
    delete[] mAlpha;
    mAlpha = 0;
    mDataModified = true;
  }
}

/*!
  Sets all cells to the value \a z.
*/
/*!
  모든 셀을 \ a z 값으로 설정합니다.
*/
void QCPColorMapData::fill(double z)
{
  const int dataCount = mValueSize*mKeySize;
  for (int i=0; i<dataCount; ++i)
    mData[i] = z;
  mDataBounds = QCPRange(z, z);
  mDataModified = true;
}

/*!
  Sets the opacity of all color map cells to \a alpha. A value of 0 for \a alpha results in a fully
  transparent color map, and a value of 255 results in a fully opaque color map.

  If you wish to restore opacity to 100% and free any used memory for the alpha map, rather use
  \ref clearAlpha.

  \see setAlpha
*/
/*!
  모든 컬러 맵 셀의 불투명도를 \ alpha로 설정합니다. \ a 알파의 값이 0이면 완전히
  투명한 색상 맵을 사용하고 255 값을 지정하면 완전히 불투명 한 색상 맵이 생성됩니다.

  불투명도를 100 %로 복원하고 알파 맵에 사용 된 메모리를 모두 사용하려면 오히려
  \ ref clearAlpha.

  \ 참조 setAlpha
*/
void QCPColorMapData::fillAlpha(unsigned char alpha)
{
  if (mAlpha || createAlpha(false))
  {
    const int dataCount = mValueSize*mKeySize;
    for (int i=0; i<dataCount; ++i)
      mAlpha[i] = alpha;
    mDataModified = true;
  }
}

/*!
  Transforms plot coordinates given by \a key and \a value to cell indices of this QCPColorMapData
  instance. The resulting cell indices are returned via the output parameters \a keyIndex and \a
  valueIndex.
  
  The retrieved key/value cell indices can then be used for example with \ref setCell.
  
  If you are only interested in a key or value index, you may pass 0 as \a valueIndex or \a
  keyIndex.
  
  \note The QCPColorMap always displays the data at equal key/value intervals, even if the key or
  value axis is set to a logarithmic scaling. If you want to use QCPColorMap with logarithmic axes,
  you shouldn't use the \ref QCPColorMapData::coordToCell method as it uses a linear transformation to
  determine the cell index.
  
  \see cellToCoord, QCPAxis::coordToPixel
*/
/*!
  키와 \ a에 의해 주어진 좌표를이 QCPColorMapData의 셀 인덱스로 변환합니다.
  예. 결과 셀 인덱스는 출력 매개 변수 \ a keyIndex 및 \ a를 통해 반환됩니다.
  valueIndex.
  
  검색된 키 / 값 셀 인덱스는 예를 들어 \ ref setCell과 함께 사용할 수 있습니다.
  
  키 또는 값 인덱스에만 관심이있는 경우 \ valueIndex 또는 \ a를 0으로 전달할 수 있습니다.
  keyIndex.
  
  \ note QCPColorMap은 키 또는 값 간격이 동일한 키 또는 값 간격으로 항상 데이터를 표시합니다.
  값 축은 대수 배율로 설정됩니다. 대수 축과 함께 QCPColorMap을 사용하려면,
  \ ref QCPColorMapData :: coordToCell 메서드는 선형 변환을 사용하므로이 메서드를 사용하면 안됩니다.
  셀 인덱스를 결정하십시오.
  
  \ cellToCoord 참조, QCPAxis :: coordToPixel
*/
void QCPColorMapData::coordToCell(double key, double value, int *keyIndex, int *valueIndex) const
{
  if (keyIndex)
    *keyIndex = (key-mKeyRange.lower)/(mKeyRange.upper-mKeyRange.lower)*(mKeySize-1)+0.5;
  if (valueIndex)
    *valueIndex = (value-mValueRange.lower)/(mValueRange.upper-mValueRange.lower)*(mValueSize-1)+0.5;
}

/*!
  Transforms cell indices given by \a keyIndex and \a valueIndex to cell indices of this QCPColorMapData
  instance. The resulting coordinates are returned via the output parameters \a key and \a
  value.
  
  If you are only interested in a key or value coordinate, you may pass 0 as \a key or \a
  value.
  
  \note The QCPColorMap always displays the data at equal key/value intervals, even if the key or
  value axis is set to a logarithmic scaling. If you want to use QCPColorMap with logarithmic axes,
  you shouldn't use the \ref QCPColorMapData::cellToCoord method as it uses a linear transformation to
  determine the cell index.
  
  \see coordToCell, QCPAxis::pixelToCoord
*/
/*!
  \ keyIndex 및 \ valueIndex에 의해 주어진 셀 인덱스를이 QCPColorMapData의 셀 인덱스로 변환합니다.
  예. 결과 좌표는 출력 매개 변수 \ a key와 \ a를 통해 반환됩니다.
  값.
  
  키 또는 값 좌표에만 관심이있는 경우 \ a 키 또는 \ a를 0으로 전달할 수 있습니다
  값.
  
  \ note QCPColorMap은 키 또는 값 간격이 동일한 키 또는 값 간격으로 항상 데이터를 표시합니다.
  값 축은 대수 배율로 설정됩니다. 대수 축과 함께 QCPColorMap을 사용하려면,
  \ ref QCPColorMapData :: cellToCoord 메서드는 선형 변환을 사용하므로이 메서드를 사용하면 안됩니다.
  셀 인덱스를 결정하십시오.
  
  \ coordToCell, QCPAxis :: pixelToCoord를보십시오.
*/
void QCPColorMapData::cellToCoord(int keyIndex, int valueIndex, double *key, double *value) const
{
  if (key)
    *key = keyIndex/(double)(mKeySize-1)*(mKeyRange.upper-mKeyRange.lower)+mKeyRange.lower;
  if (value)
    *value = valueIndex/(double)(mValueSize-1)*(mValueRange.upper-mValueRange.lower)+mValueRange.lower;
}

/*! \internal

  Allocates the internal alpha map with the current data map key/value size and, if \a
  initializeOpaque is true, initializes all values to 255. If \a initializeOpaque is false, the
  values are not initialized at all. In this case, the alpha map should be initialized manually,
  e.g. with \ref fillAlpha.

  If an alpha map exists already, it is deleted first. If this color map is empty (has either key
  or value size zero, see \ref isEmpty), the alpha map is cleared.

  The return value indicates the existence of the alpha map after the call. So this method returns
  true if the data map isn't empty and an alpha map was successfully allocated.
*/
/*! \내부의

  내부 알파 맵을 현재 데이터 맵 키 / 값 크기로 할당하고, \ a
  initializeOpaque가 true이면 255로 모든 값을 초기화합니다. \ a initializeOpaque가 false이면
  값은 전혀 초기화되지 않습니다. 이 경우 알파 맵은 수동으로 초기화해야하며,
  예 : \ ref fillAlpha.

  알파지도가 이미 있으면 먼저 삭제됩니다. 이 칼라 맵이 하늘의 경우 (키
  또는 값 크기가 0 인 경우 \ ref isEmpty 참조), 알파 맵이 지워집니다.

  반환 값은 호출 후 알파 맵의 존재를 나타냅니다. 따라서이 메소드는
  데이터 맵이 하늘이 아니고 알파 맵이 성공적으로 할당 된 경우 true.
*/
bool QCPColorMapData::createAlpha(bool initializeOpaque)
{
  clearAlpha();
  if (isEmpty())
    return false;
  
#ifdef __EXCEPTIONS
  try { // 2D arrays get memory intensive fast. So if the allocation fails, at least output debug message
        // 2D 배열은 메모리를 많이 소비합니다. 따라서 할당이 실패하면 적어도 디버그 메시지를 출력합니다.
#endif  
    mAlpha = new unsigned char[mKeySize*mValueSize];
#ifdef __EXCEPTIONS
  } catch (...) { mAlpha = 0; }
#endif
  if (mAlpha)
  {
    if (initializeOpaque)
      fillAlpha(255);
    return true;
  } else
  {
    qDebug() << Q_FUNC_INFO << "out of memory for data dimensions "<< mKeySize << "*" << mValueSize;
    return false;
  }
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPColorMap
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPColorMap
  \brief A plottable representing a two-dimensional color map in a plot.

  \image html QCPColorMap.png
  
  The data is stored in the class \ref QCPColorMapData, which can be accessed via the data()
  method.
  
  A color map has three dimensions to represent a data point: The \a key dimension, the \a value
  dimension and the \a data dimension. As with other plottables such as graphs, \a key and \a value
  correspond to two orthogonal axes on the QCustomPlot surface that you specify in the QCPColorMap
  constructor. The \a data dimension however is encoded as the color of the point at (\a key, \a
  value).

  Set the number of points (or \a cells) in the key/value dimension via \ref
  QCPColorMapData::setSize. The plot coordinate range over which these points will be displayed is
  specified via \ref QCPColorMapData::setRange. The first cell will be centered on the lower range
  boundary and the last cell will be centered on the upper range boundary. The data can be set by
  either accessing the cells directly with QCPColorMapData::setCell or by addressing the cells via
  their plot coordinates with \ref QCPColorMapData::setData. If possible, you should prefer
  setCell, since it doesn't need to do any coordinate transformation and thus performs a bit
  better.
  
  The cell with index (0, 0) is at the bottom left, if the color map uses normal (i.e. not reversed)
  key and value axes.
  
  To show the user which colors correspond to which \a data values, a \ref QCPColorScale is
  typically placed to the right of the axis rect. See the documentation there for details on how to
  add and use a color scale.
  
  \section qcpcolormap-appearance Changing the appearance
  
  The central part of the appearance is the color gradient, which can be specified via \ref
  setGradient. See the documentation of \ref QCPColorGradient for details on configuring a color
  gradient.
  
  The \a data range that is mapped to the colors of the gradient can be specified with \ref
  setDataRange. To make the data range encompass the whole data set minimum to maximum, call \ref
  rescaleDataRange.
  
  \section qcpcolormap-transparency Transparency
  
  Transparency in color maps can be achieved by two mechanisms. On one hand, you can specify alpha
  values for color stops of the \ref QCPColorGradient, via the regular QColor interface. This will
  cause the color map data which gets mapped to colors around those color stops to appear with the
  accordingly interpolated transparency.
  
  On the other hand you can also directly apply an alpha value to each cell independent of its
  data, by using the alpha map feature of \ref QCPColorMapData. The relevant methods are \ref
  QCPColorMapData::setAlpha, QCPColorMapData::fillAlpha and \ref QCPColorMapData::clearAlpha().
  
  The two transparencies will be joined together in the plot and otherwise not interfere with each
  other. They are mixed in a multiplicative matter, so an alpha of e.g. 50% (128/255) in both modes
  simultaneously, will result in a total transparency of 25% (64/255).
  
  \section qcpcolormap-usage Usage
  
  Like all data representing objects in QCustomPlot, the QCPColorMap is a plottable
  (QCPAbstractPlottable). So the plottable-interface of QCustomPlot applies
  (QCustomPlot::plottable, QCustomPlot::removePlottable, etc.)
  
  Usually, you first create an instance:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpcolormap-creation-1
  which registers it with the QCustomPlot instance of the passed axes. Note that this QCustomPlot instance takes
  ownership of the plottable, so do not delete it manually but use QCustomPlot::removePlottable() instead.
  The newly created plottable can be modified, e.g.:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpcolormap-creation-2
  
  \note The QCPColorMap always displays the data at equal key/value intervals, even if the key or
  value axis is set to a logarithmic scaling. If you want to use QCPColorMap with logarithmic axes,
  you shouldn't use the \ref QCPColorMapData::setData method as it uses a linear transformation to
  determine the cell index. Rather directly access the cell index with \ref
  QCPColorMapData::setCell.
*/
/*! \ class QCPColorMap
  \ brief 플롯에서 2 차원 컬러 맵을 나타내는 플롯.

  \ image html QCPColorMap.png
  
  데이터는 \ ref QCPColorMapData 클래스에 저장되며 data ()를 통해 액세스 할 수 있습니다.
  방법.
  
  컬러 맵에는 데이터 요소를 나타내는 3 가지 차원이 있습니다. \ a 키 차원, \ a 값
  차원 및 \ a 데이터 차원 그래프, \ a 키 및 \ a 값과 같은 다른 플롯 테이블과 마찬가지로
  QCPColorMap에 지정한 QCustomPlot 표면의 두 직교 축에 해당합니다.
  건설자. 그러나 \ a 데이터 차원은 (\ a 키, \ a에있는 점의 색상으로 인코딩됩니다.
  값).

  \ ref를 통해 키 / 값 차원에서 포인트 수 (또는 \ a 셀)를 설정합니다.
  QCPColorMapData :: setSize. 이 점이 표시 될 플롯 좌표 범위는
  \ ref QCPColorMapData :: setRange를 통해 지정됩니다. 첫 번째 셀은 낮은 범위의 중앙에 배치됩니다.
  마지막 셀은 위쪽 범위 경계의 가운데에 배치됩니다. 데이터는
  QCPColorMapData :: setCell로 직접 셀에 액세스하거나 셀을 주소 지정하여
  그들의 플롯은 \ ref QCPColorMapData :: setData와 함께 조정됩니다. 가능하다면,
  setCell. 좌표 변환을 할 필요가 없으므로 조금만 수행합니다.
  보다 나은.
  
  컬러 맵이 정상 (즉, 반전되지 않음)을 사용하는 경우 색인 (0, 0)이있는 셀이 왼쪽 하단에 있습니다.
  키 및 값 축.
  
  어떤 색이 어떤 \ 데이터 값과 일치하는지 사용자에게 보여주기 위해 \ ref QCPColorScale은
  일반적으로 축 rect의 오른쪽에 배치됩니다. 방법에 대한 자세한 내용은 해당 설명서를 참조하십시오.
  컬러 스케일을 추가하고 사용하십시오.
  
  \ section qcpcolormap-appearance 모양 변경
  
  외관의 중심 부분은 색상 그라디언트이며 \ ref를 통해 지정할 수 있습니다.
  setGradient. 색상 구성에 대한 자세한 내용은 \ ref QCPColorGradient의 설명서를 참조하십시오.
  구배.
  
  그라데이션의 색상에 매핑되는 \ a 데이터 범위는 \ ref로 지정할 수 있습니다.
  setDataRange. 데이터 범위가 전체 데이터 집합을 최소에서 최대까지 포함하도록하려면 \ ref를 호출합니다.
  rescaleDataRange.
  
  \ section qcpcolormap-transparency 투명도
  
  컬러 맵의 투명성은 두 가지 메커니즘으로 얻을 수 있습니다. 한편으로, 알파를 지정할 수 있습니다.
  일반 QColor 인터페이스를 통해 \ ref QCPColorGradient의 색상 중지 값. 이것은
  해당 색상 멈춤 주위의 색상에 매핑되는 색상지도 데이터가
  따라서 보간 된 투명도.
  
  반면에 각 셀에 독립적으로 알파 값을 직접 적용 할 수도 있습니다.
  데이터, \ ref QCPColorMapData의 알파 맵 기능을 사용하여. 관련 메소드는 \ ref
  QCPColorMapData :: setAlpha, QCPColorMapData :: fillAlpha 및 \ ref QCPColorMapData :: clearAlpha ()입니다.
  
  두 투명 필름은 플롯에서 함께 결합되며 그렇지 않으면 각각의 투명 필름이 간섭을받지 않습니다.
  다른. 그것들은 곱셈 적 (multiplicative) 물질로 섞여서, 예를 들어 양쪽 모드에서 50 % (128/255)의 알파
  동시에 전체 투명도는 25 % (64/255)가됩니다.
  
  \ section qcpcolormap-usage 사용법
  
  QCustomPlot의 객체를 나타내는 모든 데이터와 마찬가지로 QCPColorMap은 plottable입니다.
  (QCPAbstractPlottable). QCustomPlot의 plottable-interface가 적용됩니다.
  (QCustomPlot :: plottable, QCustomPlot :: removePlottable 등)
  
  일반적으로 먼저 인스턴스를 만듭니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpcolormap-creation-1
  전달 된 축의 QCustomPlot 인스턴스에이를 등록합니다. 이 QCustomPlot 인스턴스는
  plottable의 소유권이므로 수동으로 삭제하지 말고 QCustomPlot :: removePlottable ()을 대신 사용하십시오.
  새로 생성 된 플롯 테이블은 다음과 같이 수정할 수 있습니다.
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpcolormap-creation-2
  
  \ note QCPColorMap은 키 또는 값 간격이 동일한 키 또는 값 간격으로 항상 데이터를 표시합니다.
  값 축은 대수 배율로 설정됩니다. 대수 축과 함께 QCPColorMap을 사용하려면,
  \ ref QCPColorMapData :: setData 메서드는 선형 변환을 사용하기 때문에 사용하면 안됩니다.
  셀 인덱스를 결정하십시오. 오히려 \ ref를 사용하여 셀 색인에 직접 액세스하십시오.
  QCPColorMapData :: setCell.
*/

/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */

/*! \fn QCPColorMapData *QCPColorMap::data() const
  
  Returns a pointer to the internal data storage of type \ref QCPColorMapData. Access this to
  modify data points (cells) and the color map key/value range.
  
  \see setData
*/
/*! \ fn QCPColorMapData * QCPColorMap :: data () const
  
  \ ref QCPColorMapData 유형의 내부 데이터 저장소에 대한 포인터를 반환합니다. 이 주소로 액세스
  데이터 포인트 (셀) 및 색상 맵 키 / 값 범위를 수정합니다.
  
  \ see setData
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */

/* start documentation of signals */
/* 신호의 문서화를 시작한다. */

/*! \fn void QCPColorMap::dataRangeChanged(const QCPRange &newRange);
  
  This signal is emitted when the data range changes.
  
  \see setDataRange
*/
/*! \ fn void QCPColorMap :: dataRangeChanged (const QCPRange & newRange);
  
  이 신호는 데이터 범위가 변경 될 때 방출됩니다.
  
  \ 참조 setDataRange
*/

/*! \fn void QCPColorMap::dataScaleTypeChanged(QCPAxis::ScaleType scaleType);
  
  This signal is emitted when the data scale type changes.
  
  \see setDataScaleType
*/
/*! \ fn void QCPColorMap :: dataScaleTypeChanged (QCPAxis :: ScaleType scaleType);
  
  이 신호는 데이터 스케일 유형이 변경 될 때 방출됩니다.
  
  \ setDataScaleType 참조
*/

/*! \fn void QCPColorMap::gradientChanged(const QCPColorGradient &newGradient);
  
  This signal is emitted when the gradient changes.
  
  \see setGradient
*/
/*! \ fn void QCPColorMap :: gradientChanged (const QCPColorGradient & newGradient);
  
  이 신호는 그래디언트가 변경 될 때 방출됩니다.
  
  \ setGradient를 참조하십시오.
*/


/* end documentation of signals */
/* 신호의 끝 문서 */

/*!
  Constructs a color map with the specified \a keyAxis and \a valueAxis.
  
  The created QCPColorMap is automatically registered with the QCustomPlot instance inferred from
  \a keyAxis. This QCustomPlot instance takes ownership of the QCPColorMap, so do not delete it
  manually but use QCustomPlot::removePlottable() instead.
*/
/*!
  지정된 \ keyAxis 및 \ a valueAxis를 가지는 컬러 맵을 구축합니다.
  
  생성 된 QCPColorMap은에서 유추 된 QCustomPlot 인스턴스에 자동으로 등록됩니다.
  \ a keyAxis. 이 QCustomPlot 인스턴스는 QCPColorMap의 소유권을 가지므로 삭제하지 마십시오.
  수동으로하지만 QCustomPlot :: removePlottable ()을 대신 사용하십시오.
*/
QCPColorMap::QCPColorMap(QCPAxis *keyAxis, QCPAxis *valueAxis) :
  QCPAbstractPlottable(keyAxis, valueAxis),
  mDataScaleType(QCPAxis::stLinear),
  mMapData(new QCPColorMapData(10, 10, QCPRange(0, 5), QCPRange(0, 5))),
  mGradient(QCPColorGradient::gpCold),
  mInterpolate(true),
  mTightBoundary(false),
  mMapImageInvalidated(true)
{
}

QCPColorMap::~QCPColorMap()
{
  delete mMapData;
}

/*!
  Replaces the current \ref data with the provided \a data.
  
  If \a copy is set to true, the \a data object will only be copied. if false, the color map
  takes ownership of the passed data and replaces the internal data pointer with it. This is
  significantly faster than copying for large datasets.
*/
/*!
  현재 \ ref 데이터를 제공된 \ a 데이터로 바꿉니다.
  
  \ copy가 true로 설정되면 \ a 데이터 객체 만 복사됩니다. false의 경우, 칼라 맵
  전달 된 데이터의 소유권을 가져 와서 내부 데이터 포인터를 그 데이터로 바꿉니다. 이것은
  대형 데이터 세트를 복사하는 것보다 훨씬 빠릅니다.
*/
void QCPColorMap::setData(QCPColorMapData *data, bool copy)
{
  if (mMapData == data)
  {
    qDebug() << Q_FUNC_INFO << "The data pointer is already in (and owned by) this plottable" << reinterpret_cast<quintptr>(data);
    return;
  }
  if (copy)
  {
    *mMapData = *data;
  } else
  {
    delete mMapData;
    mMapData = data;
  }
  mMapImageInvalidated = true;
}

/*!
  Sets the data range of this color map to \a dataRange. The data range defines which data values
  are mapped to the color gradient.
  
  To make the data range span the full range of the data set, use \ref rescaleDataRange.
  
  \see QCPColorScale::setDataRange
*/
/*!
  이 칼라 맵의 데이터 범위를 \ dataRange로 설정합니다. 데이터 범위는 어떤 데이터 값
  색상 그라디언트에 매핑됩니다.
  
  데이터 범위를 데이터 세트의 전체 범위로 확장하려면 \ ref rescaleDataRange를 사용하십시오.
  
  \ QCPColorScale :: setDataRange를 참조하십시오.
*/
void QCPColorMap::setDataRange(const QCPRange &dataRange)
{
  if (!QCPRange::validRange(dataRange)) return;
  if (mDataRange.lower != dataRange.lower || mDataRange.upper != dataRange.upper)
  {
    if (mDataScaleType == QCPAxis::stLogarithmic)
      mDataRange = dataRange.sanitizedForLogScale();
    else
      mDataRange = dataRange.sanitizedForLinScale();
    mMapImageInvalidated = true;
    emit dataRangeChanged(mDataRange);
  }
}

/*!
  Sets whether the data is correlated with the color gradient linearly or logarithmically.
  
  \see QCPColorScale::setDataScaleType
*/
/*!
  데이터가 색상 그라디언트와 선형 또는 대수 상관 관계인지 여부를 설정합니다.
  
  \ see QCPColorScale :: setDataScaleType
*/
void QCPColorMap::setDataScaleType(QCPAxis::ScaleType scaleType)
{
  if (mDataScaleType != scaleType)
  {
    mDataScaleType = scaleType;
    mMapImageInvalidated = true;
    emit dataScaleTypeChanged(mDataScaleType);
    if (mDataScaleType == QCPAxis::stLogarithmic)
      setDataRange(mDataRange.sanitizedForLogScale());
  }
}

/*!
  Sets the color gradient that is used to represent the data. For more details on how to create an
  own gradient or use one of the preset gradients, see \ref QCPColorGradient.
  
  The colors defined by the gradient will be used to represent data values in the currently set
  data range, see \ref setDataRange. Data points that are outside this data range will either be
  colored uniformly with the respective gradient boundary color, or the gradient will repeat,
  depending on \ref QCPColorGradient::setPeriodic.
  
  \see QCPColorScale::setGradient
*/
/*!
  데이터를 나타내는 데 사용되는 색상 그라디언트를 설정합니다. 생성 방법에 대한 자세한 내용은
  자신의 그라디언트를 사용하거나 사전 설정된 그라디언트 중 하나를 사용하려면 \ ref QCPColorGradient를 참조하십시오.
  
  그래디언트로 정의 된 색상은 현재 설정된 데이터 값을 나타내는 데 사용됩니다.
  데이터 범위는 \ ref setDataRange를 참조하십시오. 이 데이터 범위를 벗어나는 데이터 요소는
  각 그라디언트 경계 색으로 균일하게 채색되거나, 그라디언트가 반복되며,
  \ ref QCPColorGradient :: setPeriodic에 따라 다릅니다.
  
  \ see QCPColorScale :: setGradient
*/
void QCPColorMap::setGradient(const QCPColorGradient &gradient)
{
  if (mGradient != gradient)
  {
    mGradient = gradient;
    mMapImageInvalidated = true;
    emit gradientChanged(mGradient);
  }
}

/*!
  Sets whether the color map image shall use bicubic interpolation when displaying the color map
  shrinked or expanded, and not at a 1:1 pixel-to-data scale.
  
  \image html QCPColorMap-interpolate.png "A 10*10 color map, with interpolation and without interpolation enabled"
*/
/*!
  색상 맵 이미지를 표시 할 때 색상 맵 이미지가 바이 큐빅 보간을 사용할지 여부를 설정합니다.
  1 : 1 픽셀 대 데이터 스케일이 아니라 축소 또는 확장 된 것입니다.
  
  \ image html QCPColorMap-interpolate.png "보간 및 보간 기능이 활성화되지 않은 10 * 10 색상지도"
*/
void QCPColorMap::setInterpolate(bool enabled)
{
  mInterpolate = enabled;
  mMapImageInvalidated = true; // because oversampling factors might need to change
                               // 오버 샘플링 요인을 변경해야하기 때문에
}


/*!
  Sets whether the outer most data rows and columns are clipped to the specified key and value
  range (see \ref QCPColorMapData::setKeyRange, \ref QCPColorMapData::setValueRange).
  
  if \a enabled is set to false, the data points at the border of the color map are drawn with the
  same width and height as all other data points. Since the data points are represented by
  rectangles of one color centered on the data coordinate, this means that the shown color map
  extends by half a data point over the specified key/value range in each direction.
  
  \image html QCPColorMap-tightboundary.png "A color map, with tight boundary enabled and disabled"
*/
/*!
  가장 바깥 쪽 데이터 행과 열을 지정된 키와 값으로 클리핑할지 여부를 설정합니다.
  범위 (\ ref QCPColorMapData :: setKeyRange, \ ref QCPColorMapData :: setValueRange 참조).
  
  \ a enabled가 false로 설정되면 색상 맵의 테두리에있는 데이터 포인트가
  다른 모든 데이터 포인트와 동일한 폭과 높이. 데이터 포인트는
  데이터 좌표에 중심을 둔 한 색상의 직사각형, 즉 표시된 색상 맵
  각 방향의 지정된 키 / 값 범위에서 데이터 포인트의 반만큼 확장됩니다.
  
  \ image html QCPColorMap-tightboundary.png "꽉 경계가 활성화되고 비활성화 된 컬러 맵"
*/
void QCPColorMap::setTightBoundary(bool enabled)
{
  mTightBoundary = enabled;
}

/*!
  Associates the color scale \a colorScale with this color map.
  
  This means that both the color scale and the color map synchronize their gradient, data range and
  data scale type (\ref setGradient, \ref setDataRange, \ref setDataScaleType). Multiple color maps
  can be associated with one single color scale. This causes the color maps to also synchronize
  those properties, via the mutual color scale.
  
  This function causes the color map to adopt the current color gradient, data range and data scale
  type of \a colorScale. After this call, you may change these properties at either the color map
  or the color scale, and the setting will be applied to both.
  
  Pass 0 as \a colorScale to disconnect the color scale from this color map again.
*/
/*!
  \ colorScale의 컬러 스케일을이 칼라 맵에 관련 짓습니다.
  
  즉, 색상 스케일과 색상 맵 모두 그라데이션, 데이터 범위 및
  데이터 스케일 유형 (\ ref setGradient, \ ref setDataRange, \ ref setDataScaleType). 여러 색상지도
  하나의 컬러 스케일과 연관 될 수 있습니다. 이로 인해 색상 맵이 동기화됩니다.
  그 속성들을 상호 색 스케일을 통해
  
  이 함수는 컬러 맵이 현재 색상 그라데이션, 데이터 범위 및 데이터 배율을 채택하도록합니다.
  \ a colorScale 유형. 이 호출 후에는 색상지도에서 이러한 속성을 변경할 수 있습니다.
  또는 색상 스케일을 선택하면 설정이 양쪽에 적용됩니다.
  
  이 컬러 맵에서 색상 스케일을 다시 분리하려면 \ a colorScale으로 0을 전달합니다.
*/
void QCPColorMap::setColorScale(QCPColorScale *colorScale)
{
  if (mColorScale) // unconnect signals from old color scale
                   // 이전 색 눈금에서 신호 연결을 끊습니다.
  {
    disconnect(this, SIGNAL(dataRangeChanged(QCPRange)), mColorScale.data(), SLOT(setDataRange(QCPRange)));
    disconnect(this, SIGNAL(dataScaleTypeChanged(QCPAxis::ScaleType)), mColorScale.data(), SLOT(setDataScaleType(QCPAxis::ScaleType)));
    disconnect(this, SIGNAL(gradientChanged(QCPColorGradient)), mColorScale.data(), SLOT(setGradient(QCPColorGradient)));
    disconnect(mColorScale.data(), SIGNAL(dataRangeChanged(QCPRange)), this, SLOT(setDataRange(QCPRange)));
    disconnect(mColorScale.data(), SIGNAL(gradientChanged(QCPColorGradient)), this, SLOT(setGradient(QCPColorGradient)));
    disconnect(mColorScale.data(), SIGNAL(dataScaleTypeChanged(QCPAxis::ScaleType)), this, SLOT(setDataScaleType(QCPAxis::ScaleType)));
  }
  mColorScale = colorScale;
  if (mColorScale) // connect signals to new color scale
                   // 신호를 새로운 색상 스케일에 연결합니다.
  {
    setGradient(mColorScale.data()->gradient());
    setDataRange(mColorScale.data()->dataRange());
    setDataScaleType(mColorScale.data()->dataScaleType());
    connect(this, SIGNAL(dataRangeChanged(QCPRange)), mColorScale.data(), SLOT(setDataRange(QCPRange)));
    connect(this, SIGNAL(dataScaleTypeChanged(QCPAxis::ScaleType)), mColorScale.data(), SLOT(setDataScaleType(QCPAxis::ScaleType)));
    connect(this, SIGNAL(gradientChanged(QCPColorGradient)), mColorScale.data(), SLOT(setGradient(QCPColorGradient)));
    connect(mColorScale.data(), SIGNAL(dataRangeChanged(QCPRange)), this, SLOT(setDataRange(QCPRange)));
    connect(mColorScale.data(), SIGNAL(gradientChanged(QCPColorGradient)), this, SLOT(setGradient(QCPColorGradient)));
    connect(mColorScale.data(), SIGNAL(dataScaleTypeChanged(QCPAxis::ScaleType)), this, SLOT(setDataScaleType(QCPAxis::ScaleType)));
  }
}

/*!
  Sets the data range (\ref setDataRange) to span the minimum and maximum values that occur in the
  current data set. This corresponds to the \ref rescaleKeyAxis or \ref rescaleValueAxis methods,
  only for the third data dimension of the color map.
  
  The minimum and maximum values of the data set are buffered in the internal QCPColorMapData
  instance (\ref data). As data is updated via its \ref QCPColorMapData::setCell or \ref
  QCPColorMapData::setData, the buffered minimum and maximum values are updated, too. For
  performance reasons, however, they are only updated in an expanding fashion. So the buffered
  maximum can only increase and the buffered minimum can only decrease. In consequence, changes to
  the data that actually lower the maximum of the data set (by overwriting the cell holding the
  current maximum with a smaller value), aren't recognized and the buffered maximum overestimates
  the true maximum of the data set. The same happens for the buffered minimum. To recalculate the
  true minimum and maximum by explicitly looking at each cell, the method
  QCPColorMapData::recalculateDataBounds can be used. For convenience, setting the parameter \a
  recalculateDataBounds calls this method before setting the data range to the buffered minimum and
  maximum.
  
  \see setDataRange
*/
/*!
  데이터 범위 (\ ref setDataRange)를 설정합니다.
  현재 데이터 세트. 이것은 \ ref rescaleKeyAxis 또는 \ ref rescaleValueAxis 메소드에 해당하며,
  색상 맵의 세 번째 데이터 차원에만 적용됩니다.
  
  데이터 세트의 최소 및 최대 값은 내부 QCPColorMapData에 버퍼링됩니다
  인스턴스 (\ ref 데이터). 데이터가 \ ref QCPColorMapData :: setCell 또는 \ ref를 통해 업데이트됨에 따라
  QCPColorMapData :: setData, 버퍼링 된 최소값과 최대 값도 업데이트됩니다. 에 대한
  그러나 성능상의 이유로 업데이트 된 방식으로 만 업데이트됩니다. 따라서 버퍼링 된
  최대 값은 증가 만 할 수 있고 버퍼링 된 최소값은 감소 할 수 있습니다. 결과적으로,
  데이터 세트의 최대 값을 실제로 낮추는 데이터 (셀을 덮어 씀으로써
  현재 값이 작은 현재 최대 값)은 인식되지 않고 버퍼링 된 최대 값이 과대 평가됩니다
  데이터 세트의 실제 최대 값 버퍼링 된 최소값에서도 마찬가지입니다. 다시 계산하려면
  각 셀을 명시 적으로 살펴봄으로써 실제 최소값과 최대 값, 메소드
  QCPColorMapData :: recalculateDataBounds를 사용할 수 있습니다. 편의상 \ a 매개 변수 설정
  recalculateDataBounds는 데이터 범위를 버퍼링 된 최소값으로 설정하기 전에이 메서드를 호출합니다.
  최고.
  
  \ 참조 setDataRange
*/
void QCPColorMap::rescaleDataRange(bool recalculateDataBounds)
{
  if (recalculateDataBounds)
    mMapData->recalculateDataBounds();
  setDataRange(mMapData->dataBounds());
}

/*!
  Takes the current appearance of the color map and updates the legend icon, which is used to
  represent this color map in the legend (see \ref QCPLegend).
  
  The \a transformMode specifies whether the rescaling is done by a faster, low quality image
  scaling algorithm (Qt::FastTransformation) or by a slower, higher quality algorithm
  (Qt::SmoothTransformation).
  
  The current color map appearance is scaled down to \a thumbSize. Ideally, this should be equal to
  the size of the legend icon (see \ref QCPLegend::setIconSize). If it isn't exactly the configured
  legend icon size, the thumb will be rescaled during drawing of the legend item.
  
  \see setDataRange
*/
/*!
  색상 맵의 현재 모양을 가져와 범례 아이콘을 업데이트합니다.
  범례에서이 색상 맵을 나타냅니다 (\ ref QCPLegend 참조).
  
  \ a transformMode는 크기 재조정이 더 빠르고 낮은 품질의 이미지로 수행되는지 여부를 지정합니다.
  스케일링 알고리즘 (Qt :: FastTransformation) 또는 더 느리고 높은 품질의 알고리즘
  (Qt :: SmoothTransformation).
  
  현재의 컬러 맵 모양은 \ a thumbSize로 축소됩니다. 이상적으로 이것은
  범례 아이콘의 크기 (\ ref QCPLegend :: setIconSize를 참조). 정확히 구성되지 않은 경우
  범례 아이콘 크기를 선택하면 범례 항목 그리기 중 엄지가 다시 조정됩니다.
  
  \ 참조 setDataRange
*/
void QCPColorMap::updateLegendIcon(Qt::TransformationMode transformMode, const QSize &thumbSize)
{
  if (mMapImage.isNull() && !data()->isEmpty())
    updateMapImage(); // try to update map image if it's null (happens if no draw has happened yet)
                      // null 인 경우지도 이미지를 업데이트하려고 시도합니다. 아직 그리기가없는 경우 발생합니다.
  if (!mMapImage.isNull()) // might still be null, e.g. if data is empty, so check here again
                           // 여전히 null 일 수 있습니다. 예를 들어 데이터가 비어 있으면 다시 확인하십시오.
  {
    bool mirrorX = (keyAxis()->orientation() == Qt::Horizontal ? keyAxis() : valueAxis())->rangeReversed();
    bool mirrorY = (valueAxis()->orientation() == Qt::Vertical ? valueAxis() : keyAxis())->rangeReversed();
    mLegendIcon = QPixmap::fromImage(mMapImage.mirrored(mirrorX, mirrorY)).scaled(thumbSize, Qt::KeepAspectRatio, transformMode);
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPColorMap::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  Q_UNUSED(details)
  if ((onlySelectable && mSelectable == QCP::stNone) || mMapData->isEmpty())
    return -1;
  if (!mKeyAxis || !mValueAxis)
    return -1;
  
  if (mKeyAxis.data()->axisRect()->rect().contains(pos.toPoint()))
  {
    double posKey, posValue;
    pixelsToCoords(pos, posKey, posValue);
    if (mMapData->keyRange().contains(posKey) && mMapData->valueRange().contains(posValue))
    {
      if (details)
        details->setValue(QCPDataSelection(QCPDataRange(0, 1))); 
// temporary solution, to facilitate whole-plottable selection. Replace in future version with segmented 2D selection.
// 임시 해결책, 전체 plottable 선택을 용이하게합니다. 분할 된 2D 선택으로 향후 버전으로 대체하십시오.
      return mParentPlot->selectionTolerance()*0.99;
    }
  }
  return -1;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPRange QCPColorMap::getKeyRange(bool &foundRange, QCP::SignDomain inSignDomain) const
{
  foundRange = true;
  QCPRange result = mMapData->keyRange();
  result.normalize();
  if (inSignDomain == QCP::sdPositive)
  {
    if (result.lower <= 0 && result.upper > 0)
      result.lower = result.upper*1e-3;
    else if (result.lower <= 0 && result.upper <= 0)
      foundRange = false;
  } else if (inSignDomain == QCP::sdNegative)
  {
    if (result.upper >= 0 && result.lower < 0)
      result.upper = result.lower*1e-3;
    else if (result.upper >= 0 && result.lower >= 0)
      foundRange = false;
  }
  return result;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPRange QCPColorMap::getValueRange(bool &foundRange, QCP::SignDomain inSignDomain, const QCPRange &inKeyRange) const
{
  if (inKeyRange != QCPRange())
  {
    if (mMapData->keyRange().upper < inKeyRange.lower || mMapData->keyRange().lower > inKeyRange.upper)
    {
      foundRange = false;
      return QCPRange();
    }
  }
  
  foundRange = true;
  QCPRange result = mMapData->valueRange();
  result.normalize();
  if (inSignDomain == QCP::sdPositive)
  {
    if (result.lower <= 0 && result.upper > 0)
      result.lower = result.upper*1e-3;
    else if (result.lower <= 0 && result.upper <= 0)
      foundRange = false;
  } else if (inSignDomain == QCP::sdNegative)
  {
    if (result.upper >= 0 && result.lower < 0)
      result.upper = result.lower*1e-3;
    else if (result.upper >= 0 && result.lower >= 0)
      foundRange = false;
  }
  return result;
}

/*! \internal
  
  Updates the internal map image buffer by going through the internal \ref QCPColorMapData and
  turning the data values into color pixels with \ref QCPColorGradient::colorize.
  
  This method is called by \ref QCPColorMap::draw if either the data has been modified or the map image
  has been invalidated for a different reason (e.g. a change of the data range with \ref
  setDataRange).
  
  If the map cell count is low, the image created will be oversampled in order to avoid a
  QPainter::drawImage bug which makes inner pixel boundaries jitter when stretch-drawing images
  without smooth transform enabled. Accordingly, oversampling isn't performed if \ref
  setInterpolate is true.
*/
/*! \내부의
  
  내부 \ ref QCPColorMapData를 통해 내부 맵 이미지 버퍼를 업데이트하고
  \ ref QCPColorGradient :: colorize를 사용하여 데이터 값을 컬러 픽셀로 변환.
  
  이 메소드는 데이터가 수정되거나 맵 이미지가있는 경우 \ ref QCPColorMap :: draw에 의해 호출됩니다.
  다른 이유로 무효화되었습니다 (예 : \ ref로 데이터 범위 변경).
  setDataRange).
  
  지도 셀 수가 낮 으면 생성 된 이미지가 오버 샘플링되어
  QPainter :: drawImage - 이미지를 늘릴 때 내부 픽셀 경계가 떨리는 버그
  원활한 변환이 가능하지 않습니다. 따라서 \ ref의 경우 오버 샘플링이 수행되지 않습니다.
  setInterpolate가 true입니다.
*/
void QCPColorMap::updateMapImage()
{
  QCPAxis *keyAxis = mKeyAxis.data();
  if (!keyAxis) return;
  if (mMapData->isEmpty()) return;
  
  const QImage::Format format = QImage::Format_ARGB32_Premultiplied;
  const int keySize = mMapData->keySize();
  const int valueSize = mMapData->valueSize();
  int keyOversamplingFactor = mInterpolate ? 1 : (int)(1.0+100.0/(double)keySize);
// make mMapImage have at least size 100, factor becomes 1 if size > 200 or interpolation is on
// mMapImage의 크기를 100 이상으로 설정하고, size> 200 또는 보간이 설정된 경우 인수가 1이됩니다.
  int valueOversamplingFactor = mInterpolate ? 1 : (int)(1.0+100.0/(double)valueSize); 
// make mMapImage have at least size 100, factor becomes 1 if size > 200 or interpolation is on
// mMapImage의 크기를 100 이상으로 설정하고, size> 200 또는 보간이 설정된 경우 인수가 1이됩니다.
  
// resize mMapImage to correct dimensions including possible oversampling factors, according to key/value axes orientation:
// 키 / 값 축 방향에 따라 가능한 오버 샘플링 계수를 포함하여 차원을 수정하려면 mMapImage 크기 조정 :
  if (keyAxis->orientation() == Qt::Horizontal && (mMapImage.width() != keySize*keyOversamplingFactor || mMapImage.height() != valueSize*valueOversamplingFactor))
    mMapImage = QImage(QSize(keySize*keyOversamplingFactor, valueSize*valueOversamplingFactor), format);
  else if (keyAxis->orientation() == Qt::Vertical && (mMapImage.width() != valueSize*valueOversamplingFactor || mMapImage.height() != keySize*keyOversamplingFactor))
    mMapImage = QImage(QSize(valueSize*valueOversamplingFactor, keySize*keyOversamplingFactor), format);
  
  if (mMapImage.isNull())
  {
    qDebug() << Q_FUNC_INFO << "Couldn't create map image (possibly too large for memory)";
    mMapImage = QImage(QSize(10, 10), format);
    mMapImage.fill(Qt::black);
  } else
  {
    QImage *localMapImage = &mMapImage; // this is the image on which the colorization operates. Either the final mMapImage, or if we need oversampling, mUndersampledMapImage
// 이것은 색칠이 작동하는 이미지입니다. 최종 mMapImage 또는 오버 샘플링이 필요한 경우 
    if (keyOversamplingFactor > 1 || valueOversamplingFactor > 1)
    {
      // resize undersampled map image to actual key/value cell sizes:
      // 언더 샘플 된 맵 이미지의 실제 키 / 값 셀 크기로 크기 변경 :
      if (keyAxis->orientation() == Qt::Horizontal && (mUndersampledMapImage.width() != keySize || mUndersampledMapImage.height() != valueSize))
        mUndersampledMapImage = QImage(QSize(keySize, valueSize), format);
      else if (keyAxis->orientation() == Qt::Vertical && (mUndersampledMapImage.width() != valueSize || mUndersampledMapImage.height() != keySize))
        mUndersampledMapImage = QImage(QSize(valueSize, keySize), format);
      localMapImage = &mUndersampledMapImage; // make the colorization run on the undersampled image
                                              // 언더 샘플 이미지에서 색상 화를 실행합니다.
    } else if (!mUndersampledMapImage.isNull())
      mUndersampledMapImage = QImage(); // don't need oversampling mechanism anymore (map size has changed) but mUndersampledMapImage still has nonzero size, free it
// 오버 샘플링 메커니즘을 더 이상 필요로하지 않습니다 (맵 크기가 변경되었습니다). 그러나 mUndersampledMapImage는 여전히 0이 아닌 크기를 가지고 있습니다.
    
    const double *rawData = mMapData->mData;
    const unsigned char *rawAlpha = mMapData->mAlpha;
    if (keyAxis->orientation() == Qt::Horizontal)
    {
      const int lineCount = valueSize;
      const int rowCount = keySize;
      for (int line=0; line<lineCount; ++line)
      {
        QRgb* pixels = reinterpret_cast<QRgb*>(localMapImage->scanLine(lineCount-1-line)); // invert scanline index because QImage counts scanlines from top, but our vertical index counts from bottom (mathematical coordinate system)
 // QImage는 스캔 라인을 맨 위에서 계산하기 때문에 스캔 라인 인덱스를 뒤집지 만 수직 인덱스는 맨 아래부터 계산합니다 (수학적 좌표 시스템)
        if (rawAlpha)
          mGradient.colorize(rawData+line*rowCount, rawAlpha+line*rowCount, mDataRange, pixels, rowCount, 1, mDataScaleType==QCPAxis::stLogarithmic);
        else
          mGradient.colorize(rawData+line*rowCount, mDataRange, pixels, rowCount, 1, mDataScaleType==QCPAxis::stLogarithmic);
      }
    } else // keyAxis->orientation() == Qt::Vertical
    {
      const int lineCount = keySize;
      const int rowCount = valueSize;
      for (int line=0; line<lineCount; ++line)
      {
        QRgb* pixels = reinterpret_cast<QRgb*>(localMapImage->scanLine(lineCount-1-line)); // invert scanline index because QImage counts scanlines from top, but our vertical index counts from bottom (mathematical coordinate system)
 // QImage는 스캔 라인을 맨 위에서 계산하기 때문에 스캔 라인 인덱스를 뒤집지 만 수직 인덱스는 맨 아래부터 계산합니다 (수학적 좌표 시스템)
        if (rawAlpha)
          mGradient.colorize(rawData+line, rawAlpha+line, mDataRange, pixels, rowCount, lineCount, mDataScaleType==QCPAxis::stLogarithmic);
        else
          mGradient.colorize(rawData+line, mDataRange, pixels, rowCount, lineCount, mDataScaleType==QCPAxis::stLogarithmic);
      }
    }
    
    if (keyOversamplingFactor > 1 || valueOversamplingFactor > 1)
    {
      if (keyAxis->orientation() == Qt::Horizontal)
        mMapImage = mUndersampledMapImage.scaled(keySize*keyOversamplingFactor, valueSize*valueOversamplingFactor, Qt::IgnoreAspectRatio, Qt::FastTransformation);
      else
        mMapImage = mUndersampledMapImage.scaled(valueSize*valueOversamplingFactor, keySize*keyOversamplingFactor, Qt::IgnoreAspectRatio, Qt::FastTransformation);
    }
  }
  mMapData->mDataModified = false;
  mMapImageInvalidated = false;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPColorMap::draw(QCPPainter *painter)
{
  if (mMapData->isEmpty()) return;
  if (!mKeyAxis || !mValueAxis) return;
  applyDefaultAntialiasingHint(painter);
  
  if (mMapData->mDataModified || mMapImageInvalidated)
    updateMapImage();
  
  // use buffer if painting vectorized (PDF):
  // 벡터화 페인팅의 경우 버퍼 사용 (PDF) :
  const bool useBuffer = painter->modes().testFlag(QCPPainter::pmVectorized);
  QCPPainter *localPainter = painter; // will be redirected to paint on mapBuffer if painting vectorized
                                      // mapBuffer의 페인트로 리디렉션됩니다.
  QRectF mapBufferTarget; 
// the rect in absolute widget coordinates where the visible map portion/buffer will end up in
// 보이는 위 부분 / 버퍼가 끝나는 절대 위젯 좌표의 rect
  QPixmap mapBuffer;
  if (useBuffer)
  {
    const double mapBufferPixelRatio = 3; // factor by which DPI is increased in embedded bitmaps
                                          // 삽입 된 비트 맵에서 DPI가 증가하는 요소
    mapBufferTarget = painter->clipRegion().boundingRect();
    mapBuffer = QPixmap((mapBufferTarget.size()*mapBufferPixelRatio).toSize());
    mapBuffer.fill(Qt::transparent);
    localPainter = new QCPPainter(&mapBuffer);
    localPainter->scale(mapBufferPixelRatio, mapBufferPixelRatio);
    localPainter->translate(-mapBufferTarget.topLeft());
  }
  
  QRectF imageRect = QRectF(coordsToPixels(mMapData->keyRange().lower, mMapData->valueRange().lower),
                            coordsToPixels(mMapData->keyRange().upper, mMapData->valueRange().upper)).normalized();
  // extend imageRect to contain outer halves/quarters of bordering/cornering pixels (cells are centered on map range boundary):
  // border / cornering 픽셀의 바깥 쪽 절반 / 4 분의 1을 포함하도록 imageRect를 확장합니다 (셀은 맵 범위 경계의 가운데에 배치됩니다).
  double halfCellWidth = 0; // in pixels
  double halfCellHeight = 0; // in pixels
  if (keyAxis()->orientation() == Qt::Horizontal)
  {
    if (mMapData->keySize() > 1)
      halfCellWidth = 0.5*imageRect.width()/(double)(mMapData->keySize()-1);
    if (mMapData->valueSize() > 1)
      halfCellHeight = 0.5*imageRect.height()/(double)(mMapData->valueSize()-1);
  } else // keyAxis orientation is Qt::Vertical
  {
    if (mMapData->keySize() > 1)
      halfCellHeight = 0.5*imageRect.height()/(double)(mMapData->keySize()-1);
    if (mMapData->valueSize() > 1)
      halfCellWidth = 0.5*imageRect.width()/(double)(mMapData->valueSize()-1);
  }
  imageRect.adjust(-halfCellWidth, -halfCellHeight, halfCellWidth, halfCellHeight);
  const bool mirrorX = (keyAxis()->orientation() == Qt::Horizontal ? keyAxis() : valueAxis())->rangeReversed();
  const bool mirrorY = (valueAxis()->orientation() == Qt::Vertical ? valueAxis() : keyAxis())->rangeReversed();
  const bool smoothBackup = localPainter->renderHints().testFlag(QPainter::SmoothPixmapTransform);
  localPainter->setRenderHint(QPainter::SmoothPixmapTransform, mInterpolate);
  QRegion clipBackup;
  if (mTightBoundary)
  {
    clipBackup = localPainter->clipRegion();
    QRectF tightClipRect = QRectF(coordsToPixels(mMapData->keyRange().lower, mMapData->valueRange().lower),
                                  coordsToPixels(mMapData->keyRange().upper, mMapData->valueRange().upper)).normalized();
    localPainter->setClipRect(tightClipRect, Qt::IntersectClip);
  }
  localPainter->drawImage(imageRect, mMapImage.mirrored(mirrorX, mirrorY));
  if (mTightBoundary)
    localPainter->setClipRegion(clipBackup);
  localPainter->setRenderHint(QPainter::SmoothPixmapTransform, smoothBackup);
  
  if (useBuffer) // localPainter painted to mapBuffer, so now draw buffer with original painter
                 // localPainter가 mapBuffer에 그려지면, 원래의 화가와 버퍼를 그립니다.
  {
    delete localPainter;
    painter->drawPixmap(mapBufferTarget.toRect(), mapBuffer);
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPColorMap::drawLegendIcon(QCPPainter *painter, const QRectF &rect) const
{
  applyDefaultAntialiasingHint(painter);
  // draw map thumbnail:
  //지도 축소판 그리기 :
  if (!mLegendIcon.isNull())
  {
    QPixmap scaledIcon = mLegendIcon.scaled(rect.size().toSize(), Qt::KeepAspectRatio, Qt::FastTransformation);
    QRectF iconRect = QRectF(0, 0, scaledIcon.width(), scaledIcon.height());
    iconRect.moveCenter(rect.center());
    painter->drawPixmap(iconRect.topLeft(), scaledIcon);
  }
  /*
  // draw frame:
  painter->setBrush(Qt::NoBrush);
  painter->setPen(Qt::black);
  painter->drawRect(rect.adjusted(1, 1, 0, 0));
  */
  /*
  // 프레임 그리기 :
  painter-> setBrush (Qt :: NoBrush);
  painter-> setPen (Qt :: black);
  painter-> drawRect (rect.adjusted (1, 1, 0, 0));
  */
}
/* end of 'src/plottables/plottable-colormap.cpp' */


/* including file 'src/plottables/plottable-financial.cpp', size 42610       */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / plottables / plottable-colormap.cpp'의 끝 */


/* 'src / plottables / plottable-financial.cpp'파일 포함, 크기 42610 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPFinancialData
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPFinancialData
  \brief Holds the data of one single data point for QCPFinancial.
  
  The stored data is:
  \li \a key: coordinate on the key axis of this data point (this is the \a mainKey and the \a sortKey)
  \li \a open: The opening value at the data point (this is the \a mainValue)
  \li \a high: The high/maximum value at the data point
  \li \a low: The low/minimum value at the data point
  \li \a close: The closing value at the data point
  
  The container for storing multiple data points is \ref QCPFinancialDataContainer. It is a typedef
  for \ref QCPDataContainer with \ref QCPFinancialData as the DataType template parameter. See the
  documentation there for an explanation regarding the data type's generic methods.
  
  \see QCPFinancialDataContainer
*/
/*! \ class QCPFinancialData
  \ brief QCPFinancial에 대한 하나의 단일 데이터 포인트의 데이터를 보유합니다.
  
  저장된 데이터는 다음과 같습니다.
  \ li \ a key :이 데이터 포인트의 키 축의 좌표입니다 (이것은 mainKey와 \ a sortKey입니다)
  \ li \ a open : 데이터 포인트의 시작 값 (\ a mainValue)
  \ li \ a high : 데이터 포인트의 최고 / 최대 값
  \ li \ a 낮음 : 데이터 포인트의 최소값 / 최소값
  \ li \ a close : 데이터 포인트의 종가
  
  여러 데이터 요소를 저장하는 컨테이너는 \ ref QCPFinancialDataContainer입니다. 그것은 typedef이다.
  \ ref QCPDataContainer의 경우 \ ref QCPFinancialData를 DataType 템플리트 매개 변수로 사용합니다. 자세한 내용은
  데이터 유형의 제네릭 메소드에 대한 설명은 문서를 참조하십시오.
  
  \ see QCPFinancialDataContainer
*/

/* start documentation of inline functions */
/* 인라인 함수의 시작 문서 */

/*! \fn double QCPFinancialData::sortKey() const
  
  Returns the \a key member of this data point.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn double QCPFinancialData :: sortKey () const
  
  이 데이터 포인트의 키 멤버를 돌려줍니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn static QCPFinancialData QCPFinancialData::fromSortKey(double sortKey)
  
  Returns a data point with the specified \a sortKey. All other members are set to zero.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn 정적 QCPFinancialData QCPFinancialData :: fromSortKey (double sortKey)
  
  지정된 \ a sortKey를 가지는 데이터 포인트를 돌려줍니다. 다른 모든 멤버는 0으로 설정됩니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn static static bool QCPFinancialData::sortKeyIsMainKey()
  
  Since the member \a key is both the data point key coordinate and the data ordering parameter,
  this method returns true.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn 정적 정적 bool QCPFinancialData :: sortKeyIsMainKey ()
  
  member \ a 키는 데이터 포인트 키 좌표와 데이터 정렬 매개 변수이기 때문에,
  이 메소드는 true를 리턴합니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn double QCPFinancialData::mainKey() const
  
  Returns the \a key member of this data point.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn double QCPFinancialData :: mainKey () const
  
  이 데이터 포인트의 키 멤버를 돌려줍니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn double QCPFinancialData::mainValue() const
  
  Returns the \a open member of this data point.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn 두 번 QCPFinancialData :: mainValue () const
  
  이 데이터 포인트의 열린 멤버를 반환합니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/*! \fn QCPRange QCPFinancialData::valueRange() const
  
  Returns a QCPRange spanning from the \a low to the \a high value of this data point.
  
  For a general explanation of what this method is good for in the context of the data container,
  see the documentation of \ref QCPDataContainer.
*/
/*! \ fn QCPRange QCPFinancialData :: valueRange () const
  
  이 데이터 포인트의 \ low로부터 \ high 값까지의 QCPRange를 리턴합니다.
  
  이 메소드가 데이터 컨테이너의 컨텍스트에서 좋은 점에 대한 일반적인 설명을 보려면,
  \ ref QCPDataContainer의 문서를 참조하십시오.
*/

/* end documentation of inline functions */
/* 인라인 함수의 끝 문서화 */

/*!
  Constructs a data point with key and all values set to zero.
*/
/*!
  key 및 모든 값을 0으로 설정하여 데이터 요소를 구성합니다.
*/
QCPFinancialData::QCPFinancialData() :
  key(0),
  open(0),
  high(0),
  low(0),
  close(0)
{
}

/*!
  Constructs a data point with the specified \a key and OHLC values.
*/
/*!
  지정된 \ a 키와 OHLC 값을 사용하여 데이터 요소를 만듭니다.
*/
QCPFinancialData::QCPFinancialData(double key, double open, double high, double low, double close) :
  key(key),
  open(open),
  high(high),
  low(low),
  close(close)
{
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPFinancial
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPFinancial
  \brief A plottable representing a financial stock chart

  \image html QCPFinancial.png

  This plottable represents time series data binned to certain intervals, mainly used for stock
  charts. The two common representations OHLC (Open-High-Low-Close) bars and Candlesticks can be
  set via \ref setChartStyle.

  The data is passed via \ref setData as a set of open/high/low/close values at certain keys
  (typically times). This means the data must be already binned appropriately. If data is only
  available as a series of values (e.g. \a price against \a time), you can use the static
  convenience function \ref timeSeriesToOhlc to generate binned OHLC-data which can then be passed
  to \ref setData.

  The width of the OHLC bars/candlesticks can be controlled with \ref setWidth and \ref
  setWidthType. A typical choice is to set the width type to \ref wtPlotCoords (the default) and
  the width to (or slightly less than) one time bin interval width.

  \section qcpfinancial-appearance Changing the appearance

  Charts can be either single- or two-colored (\ref setTwoColored). If set to be single-colored,
  lines are drawn with the plottable's pen (\ref setPen) and fills with the brush (\ref setBrush).

  If set to two-colored, positive changes of the value during an interval (\a close >= \a open) are
  represented with a different pen and brush than negative changes (\a close < \a open). These can
  be configured with \ref setPenPositive, \ref setPenNegative, \ref setBrushPositive, and \ref
  setBrushNegative. In two-colored mode, the normal plottable pen/brush is ignored. Upon selection
  however, the normal selected pen/brush (provided by the \ref selectionDecorator) is used,
  irrespective of whether the chart is single- or two-colored.

  \section qcpfinancial-usage Usage

  Like all data representing objects in QCustomPlot, the QCPFinancial is a plottable
  (QCPAbstractPlottable). So the plottable-interface of QCustomPlot applies
  (QCustomPlot::plottable, QCustomPlot::removePlottable, etc.)

  Usually, you first create an instance:

  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpfinancial-creation-1
  which registers it with the QCustomPlot instance of the passed axes. Note that this QCustomPlot
  instance takes ownership of the plottable, so do not delete it manually but use
  QCustomPlot::removePlottable() instead. The newly created plottable can be modified, e.g.:

  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpfinancial-creation-2
  Here we have used the static helper method \ref timeSeriesToOhlc, to turn a time-price data
  series into a 24-hour binned open-high-low-close data series as QCPFinancial uses.
*/
/*! \ class QCPFinancial
  \ brief 금융 주식형 차트를 나타내는 plottable

  \ image html QCPFinancial.png

  이 플롯 테이블은 특정 간격으로 비닝 된 시계열 데이터를 나타냅니다. 주로 주식에 사용됩니다.
  차트. OHLC (Open-High-Low-Close) 막대와 촛대는 두 가지 공통된 표현이 될 수 있습니다.
  \ ref setChartStyle을 통해 설정하십시오.

  데이터는 특정 키에서 open / high / low / close 값의 집합으로 \ ref setData를 통해 전달됩니다.
  (일반적으로 시간). 즉, 데이터가 이미 적절히 저장되어야합니다. 데이터 만있는 경우
  일련의 값 (예 : \ a 시간에 대한 가격)으로 사용할 수있는 경우 정적
  편의 함수 \ ref timeSeriesToOhlc - 전달 된 비닝 된 OHLC- 데이터를 생성합니다.
  to \ ref setData.

  OHLC 막대 / 촛대의 너비는 \ ref setWidth 및 \ ref를 사용하여 제어 할 수 있습니다.
  setWidthType. 일반적으로 너비 유형을 \ ref wtPlotCoords (기본값)로 설정하고
  1 개의 시간 빈 (bin) 간격 폭에 대한 폭 (또는 약간 작음).

  \ section qcpfinancial-appearance 모양 변경

  차트는 단색 또는 두 가지 색상이 될 수 있습니다 (\ ref setTwoColored). 단색으로 설정하면,
  선은 플롯 테이블 (\ ref setPen)으로 그려지고 브러시 (\ ref setBrush)로 채워집니다.

  2 색으로 설정하면 간격 (\ a close> = \ a open) 동안 값이 양수로 변경됩니다.
  네거티브 변경 (\ a 닫기 <\ a 열기)보다 다른 펜 및 브러시로 나타납니다. 이들은 할 수있다.
  \ ref setPenPositive, \ ref setPenNegative, \ ref setBrushPositive 및 \ ref로 구성됩니다.
  setBrushNegative. 2 색 모드에서는 일반적인 플롯 펜 / 브러시가 무시됩니다. 선택시
  그러나 일반적으로 선택한 펜 / 브러시 (\ ref selectionDecorator에서 제공)가 사용되며,
  차트가 단일 또는 2 색인지 여부에 관계없이

  \ section qcpfinancial-usage 사용법

  QCustomPlot의 객체를 나타내는 모든 데이터와 마찬가지로 QCPFinancial은 plottable입니다.
  (QCPAbstractPlottable). QCustomPlot의 plottable-interface가 적용됩니다.
  (QCustomPlot :: plottable, QCustomPlot :: removePlottable 등)

  일반적으로 먼저 인스턴스를 만듭니다.

  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpfinancial-creation-1
  전달 된 축의 QCustomPlot 인스턴스에이를 등록합니다. 이 QCustomPlot
  인스턴스는 플롯 테이블의 소유권을 가지므로 수동으로 삭제하지 말고
  QCustomPlot :: removePlottable ()을 대신 사용하십시오. 새로 생성 된 플롯 테이블은 다음과 같이 수정할 수 있습니다.

  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpfinancial-creation-2
  여기 우리는 정적 도우미 메서드 \ ref timeSeriesToOhlc를 사용하여 시간 가격 데이터를 설정했습니다.
  시리즈를 QCPFinancial이 사용하는 24 시간 비공개 오픈 - 로우 - 로우 - 클로즈 데이터 시리즈로 변환합니다.
*/ 


/* start of documentation of inline functions */
/* 인라인 함수의 문서화 시작 */

/*! \fn QCPFinancialDataContainer *QCPFinancial::data() const
  
  Returns a pointer to the internal data storage of type \ref QCPFinancialDataContainer. You may
  use it to directly manipulate the data, which may be more convenient and faster than using the
  regular \ref setData or \ref addData methods, in certain situations.
*/
/*! \ fn QCPFinancialDataContainer * QCPFinancial :: data () const
  
  \ ref QCPFinancialDataContainer 유형의 내부 데이터 저장소에 대한 포인터를 반환합니다. 당신은 할 수있다
  그것을 사용하여 데이터를 직접 조작하십시오. 이는 데이터를 사용하는 것보다 더 편리하고 빠릅니다.
  특정 상황에서는 정규 \ ref setData 또는 \ ref addData 메소드를 사용하십시오.
*/

/* end of documentation of inline functions */
/* 인라인 함수의 문서 끝 */

/*!
  Constructs a financial chart which uses \a keyAxis as its key axis ("x") and \a valueAxis as its value
  axis ("y"). \a keyAxis and \a valueAxis must reside in the same QCustomPlot instance and not have
  the same orientation. If either of these restrictions is violated, a corresponding message is
  printed to the debug output (qDebug), the construction is not aborted, though.
  
  The created QCPFinancial is automatically registered with the QCustomPlot instance inferred from \a
  keyAxis. This QCustomPlot instance takes ownership of the QCPFinancial, so do not delete it manually
  but use QCustomPlot::removePlottable() instead.
*/
/*!
  \ a keyAxis를 키 축 ( "x")으로 사용하고 \ a valueAxis를 값으로 사용하는 재무 차트를 만듭니다.
  축 ( "y"). \ a keyAxis 및 \ a valueAxis는 동일한 QCustomPlot 인스턴스에 있어야하며
  같은 방향. 이러한 제한 사항 중 하나라도 위반하면 해당 메시지가 다음과 같습니다.
  디버그 출력 (qDebug)에 인쇄되면, 구성은 중단되지 않습니다.
  
  생성 된 QCPFinancial은 \ a에서 유추 한 QCustomPlot 인스턴스에 자동으로 등록됩니다.
  keyAxis. 이 QCustomPlot 인스턴스는 QCPFinancial의 소유권을 가지므로 수동으로 삭제하지 마십시오.
  QCustomPlot :: removePlottable ()을 대신 사용하십시오.
*/
QCPFinancial::QCPFinancial(QCPAxis *keyAxis, QCPAxis *valueAxis) :
  QCPAbstractPlottable1D<QCPFinancialData>(keyAxis, valueAxis),
  mChartStyle(csCandlestick),
  mWidth(0.5),
  mWidthType(wtPlotCoords),
  mTwoColored(true),
  mBrushPositive(QBrush(QColor(50, 160, 0))),
  mBrushNegative(QBrush(QColor(180, 0, 15))),
  mPenPositive(QPen(QColor(40, 150, 0))),
  mPenNegative(QPen(QColor(170, 5, 5)))
{
  mSelectionDecorator->setBrush(QBrush(QColor(160, 160, 255)));
}

QCPFinancial::~QCPFinancial()
{
}

/*! \overload
  
  Replaces the current data container with the provided \a data container.
  
  Since a QSharedPointer is used, multiple QCPFinancials may share the same data container safely.
  Modifying the data in the container will then affect all financials that share the container.
  Sharing can be achieved by simply exchanging the data containers wrapped in shared pointers:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpfinancial-datasharing-1
  
  If you do not wish to share containers, but create a copy from an existing container, rather use
  the \ref QCPDataContainer<DataType>::set method on the financial's data container directly:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcpfinancial-datasharing-2
  
  \see addData, timeSeriesToOhlc
*/
/*! \초과 적재
  
  현재 데이터 컨테이너를 제공된 \ 데이터 컨테이너로 바꿉니다.
  
  QSharedPointer가 사용되기 때문에 여러 QCPFinancials가 동일한 데이터 컨테이너를 안전하게 공유 할 수 있습니다.
  컨테이너의 데이터를 수정하면 컨테이너를 공유하는 모든 재무에 영향을 미칩니다.
  공유는 단순히 공유 포인터로 싸여진 데이터 컨테이너를 교환함으로써 이루어질 수 있습니다 :
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpfinancial-datasharing-1
  
  컨테이너를 공유하지 않고 기존 컨테이너에서 사본을 만들려면
  재무 데이터 컨테이너의 \ ref QCPDataContainer <DataType> :: set 메서드
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcpfinancial-datasharing-2
  
  \ addData, timeSeriesToOhlc를 참조하십시오.
*/
void QCPFinancial::setData(QSharedPointer<QCPFinancialDataContainer> data)
{
  mDataContainer = data;
}

/*! \overload
  
  Replaces the current data with the provided points in \a keys, \a open, \a high, \a low and \a
  close. The provided vectors should have equal length. Else, the number of added points will be
  the size of the smallest vector.
  
  If you can guarantee that the passed data points are sorted by \a keys in ascending order, you
  can set \a alreadySorted to true, to improve performance by saving a sorting run.
  
  \see addData, timeSeriesToOhlc
*/
/*! \초과 적재
  
  현재 데이터를 \ a 키, \ a 열린 상태, \ a 높음, \ a 낮음 및 \ a 키의 제공된 지점으로 바꿉니다.
  닫기. 제공된 벡터의 길이는 동일해야합니다. 그렇지 않으면, 추가 된 포인트의 수는
  최소의 벡터의 사이즈
  
  전달 된 데이터 요소가 \ a 키에 따라 오름차순으로 정렬되도록 보장 할 수 있으면
  정렬 실행을 저장하여 성능을 향상 시키려면 \ a alreadySorted를 true로 설정할 수 있습니다.
  
  \ addData, timeSeriesToOhlc를 참조하십시오.
*/
void QCPFinancial::setData(const QVector<double> &keys, const QVector<double> &open, const QVector<double> &high, const QVector<double> &low, const QVector<double> &close, bool alreadySorted)
{
  mDataContainer->clear();
  addData(keys, open, high, low, close, alreadySorted);
}

/*!
  Sets which representation style shall be used to display the OHLC data.
*/
/*!
  OHLC 데이터를 표시하는 데 사용할 표현 스타일을 설정합니다.
*/
void QCPFinancial::setChartStyle(QCPFinancial::ChartStyle style)
{
  mChartStyle = style;
}

/*!
  Sets the width of the individual bars/candlesticks to \a width in plot key coordinates.
  
  A typical choice is to set it to (or slightly less than) one bin interval width.
*/
/*!
  개별 막대 / 촛대의 너비를 플롯 키 좌표의 너비로 설정합니다.
  
  일반적으로 한 빈 간격 너비 (또는 약간 미만)로 설정하는 것이 일반적입니다.
*/
void QCPFinancial::setWidth(double width)
{
  mWidth = width;
}

/*!
  Sets how the width of the financial bars is defined. See the documentation of \ref WidthType for
  an explanation of the possible values for \a widthType.

  The default value is \ref wtPlotCoords.

  \see setWidth
*/
/*!
  금융 바의 너비 정의 방법을 설정합니다. 자세한 내용은 \ ref WidthType 문서를 참조하십시오.
  \ a widthType에 가능한 값에 대한 설명.

  기본값은 \ ref wtPlotCoords입니다.

  \ 참조 setWidth
*/
void QCPFinancial::setWidthType(QCPFinancial::WidthType widthType)
{
  mWidthType = widthType;
}

/*!
  Sets whether this chart shall contrast positive from negative trends per data point by using two
  separate colors to draw the respective bars/candlesticks.
  
  If \a twoColored is false, the normal plottable's pen and brush are used (\ref setPen, \ref
  setBrush).
  
  \see setPenPositive, setPenNegative, setBrushPositive, setBrushNegative
*/
/*!
  이 차트가 2 점을 사용하여 데이터 포인트 당 음수 경향과 양수를 대조할지 여부를 설정합니다.
  각각의 바 / 촛대를 그리기 위해 색을 분리하십시오.
  
  \ a twoColored가 false이면 일반 플롯 테이블의 펜과 브러쉬가 사용됩니다 (\ ref setPen, \ ref
  setBrush).
  
  \ setPenPositive, setPenNegative, setBrushPositive, setBrushNegative를 참조하십시오.
*/
void QCPFinancial::setTwoColored(bool twoColored)
{
  mTwoColored = twoColored;
}

/*!
  If \ref setTwoColored is set to true, this function controls the brush that is used to draw fills
  of data points with a positive trend (i.e. bars/candlesticks with close >= open).
  
  If \a twoColored is false, the normal plottable's pen and brush are used (\ref setPen, \ref
  setBrush).
  
  \see setBrushNegative, setPenPositive, setPenNegative
*/
/*!
  \ ref setTwoColored가 true로 설정된 경우이 함수는 채우기를 그리는 데 사용되는 브러시를 제어합니다
  긍정적 인 추세를 가진 데이터 포인트 (즉, 닫기> = 열린 막대 / 촛대).
  
  \ a twoColored가 false이면 일반 플롯 테이블의 펜과 브러쉬가 사용됩니다 (\ ref setPen, \ ref
  setBrush).
  
  \ setBrushNegative, setPenPositive, setPenNegative를 참조하십시오.
*/
void QCPFinancial::setBrushPositive(const QBrush &brush)
{
  mBrushPositive = brush;
}

/*!
  If \ref setTwoColored is set to true, this function controls the brush that is used to draw fills
  of data points with a negative trend (i.e. bars/candlesticks with close < open).
  
  If \a twoColored is false, the normal plottable's pen and brush are used (\ref setPen, \ref
  setBrush).
  
  \see setBrushPositive, setPenNegative, setPenPositive
*/
/*!
  \ ref setTwoColored가 true로 설정된 경우이 함수는 채우기를 그리는 데 사용되는 브러시를 제어합니다
  (즉, 닫힌 <열린 상태의 막대 / 촛대) 부정적인 경향을 가진 데이터 포인트
  
  \ a twoColored가 false이면 일반 플롯 테이블의 펜과 브러쉬가 사용됩니다 (\ ref setPen, \ ref
  setBrush).
  
  \ setBrushPositive 참조, setPenNegative, setPenPositive
*/
void QCPFinancial::setBrushNegative(const QBrush &brush)
{
  mBrushNegative = brush;
}

/*!
  If \ref setTwoColored is set to true, this function controls the pen that is used to draw
  outlines of data points with a positive trend (i.e. bars/candlesticks with close >= open).
  
  If \a twoColored is false, the normal plottable's pen and brush are used (\ref setPen, \ref
  setBrush).
  
  \see setPenNegative, setBrushPositive, setBrushNegative
*/
/*!
  \ ref setTwoColored가 true로 설정된 경우이 함수는 그리는 데 사용되는 펜을 제어합니다.
  긍정적 인 추세를 가진 데이터 포인트의 윤곽 (즉, 닫기> = 열린 막대 / 촛대).
  
  \ a twoColored가 false이면 일반 플롯 테이블의 펜과 브러쉬가 사용됩니다 (\ ref setPen, \ ref
  setBrush).
  
  \ setPenNegative, setBrushPositive, setBrushNe Gative를 참조하십시오.
*/
void QCPFinancial::setPenPositive(const QPen &pen)
{
  mPenPositive = pen;
}

/*!
  If \ref setTwoColored is set to true, this function controls the pen that is used to draw
  outlines of data points with a negative trend (i.e. bars/candlesticks with close < open).
  
  If \a twoColored is false, the normal plottable's pen and brush are used (\ref setPen, \ref
  setBrush).
  
  \see setPenPositive, setBrushNegative, setBrushPositive
*/

/*!
  \ ref setTwoColored가 true로 설정된 경우이 함수는 그리는 데 사용되는 펜을 제어합니다.
  부정적인 경향을 가진 데이터 포인트의 윤곽 (예 : 닫힌 <열린 상태의 막대 / 촛대).
  
  \ a twoColored가 false이면 일반 플롯 테이블의 펜과 브러쉬가 사용됩니다 (\ ref setPen, \ ref
  setBrush).
  
  \ setPenPositive, setBrushNegative, setBrushPositive를 참조하십시오.
*/
void QCPFinancial::setPenNegative(const QPen &pen)
{
  mPenNegative = pen;
}

/*! \overload
  
  Adds the provided points in \a keys, \a open, \a high, \a low and \a close to the current data.
  The provided vectors should have equal length. Else, the number of added points will be the size
  of the smallest vector.
  
  If you can guarantee that the passed data points are sorted by \a keys in ascending order, you
  can set \a alreadySorted to true, to improve performance by saving a sorting run.
  
  Alternatively, you can also access and modify the data directly via the \ref data method, which
  returns a pointer to the internal data container.
  
  \see timeSeriesToOhlc
*/
/*! \초과 적재
  
  제공된 포인트를 \ a 키, \ a 열기, \ a 높음, \ a 낮음 및 \ a 현재 데이터에 추가합니다.
  제공된 벡터의 길이는 동일해야합니다. 그렇지 않으면 추가 된 점의 수는 크기가됩니다.
  가장 작은 벡터의.
  
  전달 된 데이터 요소가 \ a 키에 따라 오름차순으로 정렬되도록 보장 할 수 있으면
  정렬 실행을 저장하여 성능을 향상 시키려면 \ a alreadySorted를 true로 설정할 수 있습니다.
  
  또는 \ ref 데이터 메서드를 통해 직접 데이터에 액세스하고 수정할 수도 있습니다.
  내부 데이터 컨테이너에 대한 포인터를 반환합니다.
  
  \ see timeSeriesToOhlc
*/
void QCPFinancial::addData(const QVector<double> &keys, const QVector<double> &open, const QVector<double> &high, const QVector<double> &low, const QVector<double> &close, bool alreadySorted)
{
  if (keys.size() != open.size() || open.size() != high.size() || high.size() != low.size() || low.size() != close.size() || close.size() != keys.size())
    qDebug() << Q_FUNC_INFO << "keys, open, high, low, close have different sizes:" << keys.size() << open.size() << high.size() << low.size() << close.size();
  const int n = qMin(keys.size(), qMin(open.size(), qMin(high.size(), qMin(low.size(), close.size()))));
  QVector<QCPFinancialData> tempData(n);
  QVector<QCPFinancialData>::iterator it = tempData.begin();
  const QVector<QCPFinancialData>::iterator itEnd = tempData.end();
  int i = 0;
  while (it != itEnd)
  {
    it->key = keys[i];
    it->open = open[i];
    it->high = high[i];
    it->low = low[i];
    it->close = close[i];
    ++it;
    ++i;
  }
  mDataContainer->add(tempData, alreadySorted); 
// don't modify tempData beyond this to prevent copy on write
// 복사시 쓰기를 방지하기 위해 tempData를이 값 이상으로 수정하지 마십시오.
}

/*! \overload
  
  Adds the provided data point as \a key, \a open, \a high, \a low and \a close to the current
  data.
  
  Alternatively, you can also access and modify the data directly via the \ref data method, which
  returns a pointer to the internal data container.
  
  \see timeSeriesToOhlc
*/
/*! \초과 적재
  
  제공된 데이터 포인트를 \ a 키, \ a 열기, \ a 높은 값, \ a 낮은 값 및 현재 값에 가까운 값으로 추가합니다.
  데이터.
  
  또는 \ ref 데이터 메서드를 통해 직접 데이터에 액세스하고 수정할 수도 있습니다.
  내부 데이터 컨테이너에 대한 포인터를 반환합니다.
  
  \ see timeSeriesToOhlc
*/
void QCPFinancial::addData(double key, double open, double high, double low, double close)
{
  mDataContainer->add(QCPFinancialData(key, open, high, low, close));
}

/*!
  \copydoc QCPPlottableInterface1D::selectTestRect
*/
QCPDataSelection QCPFinancial::selectTestRect(const QRectF &rect, bool onlySelectable) const
{
  QCPDataSelection result;
  if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())
    return result;
  if (!mKeyAxis || !mValueAxis)
    return result;
  
  QCPFinancialDataContainer::const_iterator visibleBegin, visibleEnd;
  getVisibleDataBounds(visibleBegin, visibleEnd);
  
  for (QCPFinancialDataContainer::const_iterator it=visibleBegin; it!=visibleEnd; ++it)
  {
    if (rect.intersects(selectionHitBox(it)))
      result.addDataRange(QCPDataRange(it-mDataContainer->constBegin(), it-mDataContainer->constBegin()+1), false);
  }
  result.simplify();
  return result;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPFinancial::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  Q_UNUSED(details)
  if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())
    return -1;
  if (!mKeyAxis || !mValueAxis)
    return -1;
  
  if (mKeyAxis.data()->axisRect()->rect().contains(pos.toPoint()))
  {
    // get visible data range:
    // 표시되는 데이터 범위 가져 오기 :
    QCPFinancialDataContainer::const_iterator visibleBegin, visibleEnd;
    QCPFinancialDataContainer::const_iterator closestDataPoint = mDataContainer->constEnd();
    getVisibleDataBounds(visibleBegin, visibleEnd);
    // perform select test according to configured style:
    // 구성된 스타일에 따라 select 테스트를 수행합니다.
    double result = -1;
    switch (mChartStyle)
    {
      case QCPFinancial::csOhlc:
        result = ohlcSelectTest(pos, visibleBegin, visibleEnd, closestDataPoint); break;
      case QCPFinancial::csCandlestick:
        result = candlestickSelectTest(pos, visibleBegin, visibleEnd, closestDataPoint); break;
    }
    if (details)
    {
      int pointIndex = closestDataPoint-mDataContainer->constBegin();
      details->setValue(QCPDataSelection(QCPDataRange(pointIndex, pointIndex+1)));
    }
    return result;
  }
  
  return -1;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPRange QCPFinancial::getKeyRange(bool &foundRange, QCP::SignDomain inSignDomain) const
{
  QCPRange range = mDataContainer->keyRange(foundRange, inSignDomain);
  // determine exact range by including width of bars/flags:
  // 막대 / 플래그의 너비를 포함하여 정확한 범위를 결정합니다.
  if (foundRange)
  {
    if (inSignDomain != QCP::sdPositive || range.lower-mWidth*0.5 > 0)
      range.lower -= mWidth*0.5;
    if (inSignDomain != QCP::sdNegative || range.upper+mWidth*0.5 < 0)
      range.upper += mWidth*0.5;
  }
  return range;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPRange QCPFinancial::getValueRange(bool &foundRange, QCP::SignDomain inSignDomain, const QCPRange &inKeyRange) const
{
  return mDataContainer->valueRange(foundRange, inSignDomain, inKeyRange);
}

/*!
  A convenience function that converts time series data (\a value against \a time) to OHLC binned
  data points. The return value can then be passed on to \ref QCPFinancialDataContainer::set(const
  QCPFinancialDataContainer&).
  
  The size of the bins can be controlled with \a timeBinSize in the same units as \a time is given.
  For example, if the unit of \a time is seconds and single OHLC/Candlesticks should span an hour
  each, set \a timeBinSize to 3600.
  
  \a timeBinOffset allows to control precisely at what \a time coordinate a bin should start. The
  value passed as \a timeBinOffset doesn't need to be in the range encompassed by the \a time keys.
  It merely defines the mathematical offset/phase of the bins that will be used to process the
  data.
*/
/*!
  시계열 데이터 (\ a 값과 \ a 값)를 OHLC binned로 변환하는 편리한 함수
  데이터 점수. 그런 다음 반환 값을 \ ref QCPFinancialDataContainer :: set (const
  QCPFinancialDataContainer &).
  
  bin의 크기는 \ a timeBinSize로 시간 단위와 동일한 단위로 제어 할 수 있습니다.
  예를 들어 시간의 단위가 초이고 단일 OHLC / 촛대가 한 시간
  각각은 \ timeBinSize를 3600으로 설정합니다.
  
  \ timeBinOffset을 사용하면 bin이 시작해야하는 시간 좌표를 정확하게 제어 할 수 있습니다. 그만큼
  값을 \ a timeBinOffset으로 전달한 값은 \ a 시간 키가 포함하는 범위에있을 필요는 없습니다.
  그것은 단순히 수학적 오프셋 / 위상을 정의하는데 사용됩니다.
  데이터.
*/
QCPFinancialDataContainer QCPFinancial::timeSeriesToOhlc(const QVector<double> &time, const QVector<double> &value, double timeBinSize, double timeBinOffset)
{
  QCPFinancialDataContainer data;
  int count = qMin(time.size(), value.size());
  if (count == 0)
    return QCPFinancialDataContainer();
  
  QCPFinancialData currentBinData(0, value.first(), value.first(), value.first(), value.first());
  int currentBinIndex = qFloor((time.first()-timeBinOffset)/timeBinSize+0.5);
  for (int i=0; i<count; ++i)
  {
    int index = qFloor((time.at(i)-timeBinOffset)/timeBinSize+0.5);
    if (currentBinIndex == index) // data point still in current bin, extend high/low:
                                  // 현재 bin에있는 데이터 포인트가 상한 / 하한 연장 :
    {
      if (value.at(i) < currentBinData.low) currentBinData.low = value.at(i);
      if (value.at(i) > currentBinData.high) currentBinData.high = value.at(i);
      if (i == count-1) // last data point is in current bin, finalize bin:
                        // 마지막 데이터 포인트가 현재 bin에 있으면, finalize bin :
      {
        currentBinData.close = value.at(i);
        currentBinData.key = timeBinOffset+(index)*timeBinSize;
        data.add(currentBinData);
      }
    } else // data point not anymore in current bin, set close of old and open of new bin, and add old to map:
           // 현재 bin에 더 이상 존재하지 않는 데이터 포인트, old의 close를 설정하고 새 bin을 열고 map에 old를 추가합니다.
    {
      // finalize current bin:
      // 현재 bin을 finalize :
      currentBinData.close = value.at(i-1);
      currentBinData.key = timeBinOffset+(index-1)*timeBinSize;
      data.add(currentBinData);
      // start next bin:
      // 다음 bin 시작 :
      currentBinIndex = index;
      currentBinData.open = value.at(i);
      currentBinData.high = value.at(i);
      currentBinData.low = value.at(i);
    }
  }
  
  return data;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPFinancial::draw(QCPPainter *painter)
{
  // get visible data range:
  // 표시되는 데이터 범위 가져 오기 :
  QCPFinancialDataContainer::const_iterator visibleBegin, visibleEnd;
  getVisibleDataBounds(visibleBegin, visibleEnd);
  
  // loop over and draw segments of unselected/selected data:
  // 선택되지 않은 / 선택한 데이터의 세그먼트를 반복 및 그립니다.
  QList<QCPDataRange> selectedSegments, unselectedSegments, allSegments;
  getDataSegments(selectedSegments, unselectedSegments);
  allSegments << unselectedSegments << selectedSegments;
  for (int i=0; i<allSegments.size(); ++i)
  {
    bool isSelectedSegment = i >= unselectedSegments.size();
    QCPFinancialDataContainer::const_iterator begin = visibleBegin;
    QCPFinancialDataContainer::const_iterator end = visibleEnd;
    mDataContainer->limitIteratorsToDataRange(begin, end, allSegments.at(i));
    if (begin == end)
      continue;
    
    // draw data segment according to configured style:
    // 구성된 스타일에 따라 데이터 세그먼트를 그립니다.
    switch (mChartStyle)
    {
      case QCPFinancial::csOhlc:
        drawOhlcPlot(painter, begin, end, isSelectedSegment); break;
      case QCPFinancial::csCandlestick:
        drawCandlestickPlot(painter, begin, end, isSelectedSegment); break;
    }
  }
  
  // draw other selection decoration that isn't just line/scatter pens and brushes:
  // 선 / 산란 펜 및 브러쉬가 아닌 다른 선택 장식을 그립니다.
  if (mSelectionDecorator)
    mSelectionDecorator->drawDecoration(painter, selection());
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPFinancial::drawLegendIcon(QCPPainter *painter, const QRectF &rect) const
{
  painter->setAntialiasing(false); // legend icon especially of csCandlestick looks better without antialiasing
                                   // csCandlestick의 범례 아이콘은 앤티 엘리 어싱없이 잘 보입니다.
  if (mChartStyle == csOhlc)
  {
    if (mTwoColored)
    {
      // draw upper left half icon with positive color:
      // 위 왼쪽 절반 아이콘을 양수로 그립니다.
      painter->setBrush(mBrushPositive);
      painter->setPen(mPenPositive);
      painter->setClipRegion(QRegion(QPolygon() << rect.bottomLeft().toPoint() << rect.topRight().toPoint() << rect.topLeft().toPoint()));
      painter->drawLine(QLineF(0, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));
      painter->drawLine(QLineF(rect.width()*0.2, rect.height()*0.3, rect.width()*0.2, rect.height()*0.5).translated(rect.topLeft()));
      painter->drawLine(QLineF(rect.width()*0.8, rect.height()*0.5, rect.width()*0.8, rect.height()*0.7).translated(rect.topLeft()));
      // draw bottom right half icon with negative color:
      // 네거티브 컬러로 오른쪽 하단 아이콘을 그립니다.
      painter->setBrush(mBrushNegative);
      painter->setPen(mPenNegative);
      painter->setClipRegion(QRegion(QPolygon() << rect.bottomLeft().toPoint() << rect.topRight().toPoint() << rect.bottomRight().toPoint()));
      painter->drawLine(QLineF(0, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));
      painter->drawLine(QLineF(rect.width()*0.2, rect.height()*0.3, rect.width()*0.2, rect.height()*0.5).translated(rect.topLeft()));
      painter->drawLine(QLineF(rect.width()*0.8, rect.height()*0.5, rect.width()*0.8, rect.height()*0.7).translated(rect.topLeft()));
    } else
    {
      painter->setBrush(mBrush);
      painter->setPen(mPen);
      painter->drawLine(QLineF(0, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));
      painter->drawLine(QLineF(rect.width()*0.2, rect.height()*0.3, rect.width()*0.2, rect.height()*0.5).translated(rect.topLeft()));
      painter->drawLine(QLineF(rect.width()*0.8, rect.height()*0.5, rect.width()*0.8, rect.height()*0.7).translated(rect.topLeft()));
    }
  } else if (mChartStyle == csCandlestick)
  {
    if (mTwoColored)
    {
      // draw upper left half icon with positive color:
      // 위 왼쪽 절반 아이콘을 양수로 그립니다.
      painter->setBrush(mBrushPositive);
      painter->setPen(mPenPositive);
      painter->setClipRegion(QRegion(QPolygon() << rect.bottomLeft().toPoint() << rect.topRight().toPoint() << rect.topLeft().toPoint()));
      painter->drawLine(QLineF(0, rect.height()*0.5, rect.width()*0.25, rect.height()*0.5).translated(rect.topLeft()));
      painter->drawLine(QLineF(rect.width()*0.75, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));
      painter->drawRect(QRectF(rect.width()*0.25, rect.height()*0.25, rect.width()*0.5, rect.height()*0.5).translated(rect.topLeft()));
      // draw bottom right half icon with negative color:
      // 네거티브 컬러로 오른쪽 하단 아이콘을 그립니다.
      painter->setBrush(mBrushNegative);
      painter->setPen(mPenNegative);
      painter->setClipRegion(QRegion(QPolygon() << rect.bottomLeft().toPoint() << rect.topRight().toPoint() << rect.bottomRight().toPoint()));
      painter->drawLine(QLineF(0, rect.height()*0.5, rect.width()*0.25, rect.height()*0.5).translated(rect.topLeft()));
      painter->drawLine(QLineF(rect.width()*0.75, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));
      painter->drawRect(QRectF(rect.width()*0.25, rect.height()*0.25, rect.width()*0.5, rect.height()*0.5).translated(rect.topLeft()));
    } else
    {
      painter->setBrush(mBrush);
      painter->setPen(mPen);
      painter->drawLine(QLineF(0, rect.height()*0.5, rect.width()*0.25, rect.height()*0.5).translated(rect.topLeft()));
      painter->drawLine(QLineF(rect.width()*0.75, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));
      painter->drawRect(QRectF(rect.width()*0.25, rect.height()*0.25, rect.width()*0.5, rect.height()*0.5).translated(rect.topLeft()));
    }
  }
}

/*! \internal
  
  Draws the data from \a begin to \a end-1 as OHLC bars with the provided \a painter.

  This method is a helper function for \ref draw. It is used when the chart style is \ref csOhlc.
*/
/*! \내부의
  
  제공된 \ a 페인터를 사용하여 \ a부터 \ aend-1까지의 데이터를 OHLC 막대로 그립니다.

  이 메소드는 \ ref draw를위한 도우미 함수입니다. 차트 스타일이 \ ref csOhlc 일 때 사용됩니다.
*/
void QCPFinancial::drawOhlcPlot(QCPPainter *painter, const QCPFinancialDataContainer::const_iterator &begin, const QCPFinancialDataContainer::const_iterator &end, bool isSelected)
{
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
  
  if (keyAxis->orientation() == Qt::Horizontal)
  {
    for (QCPFinancialDataContainer::const_iterator it = begin; it != end; ++it)
    {
      if (isSelected && mSelectionDecorator)
        mSelectionDecorator->applyPen(painter);
      else if (mTwoColored)
        painter->setPen(it->close >= it->open ? mPenPositive : mPenNegative);
      else
        painter->setPen(mPen);
      double keyPixel = keyAxis->coordToPixel(it->key);
      double openPixel = valueAxis->coordToPixel(it->open);
      double closePixel = valueAxis->coordToPixel(it->close);
      // draw backbone:
      // 백본 그리기 :
      painter->drawLine(QPointF(keyPixel, valueAxis->coordToPixel(it->high)), QPointF(keyPixel, valueAxis->coordToPixel(it->low)));
      // draw open:
      double pixelWidth = getPixelWidth(it->key, keyPixel); 
      // sign of this makes sure open/close are on correct sides
      //이 기호는 열기 / 닫기가 올바른면에 있는지 확인합니다.
      painter->drawLine(QPointF(keyPixel-pixelWidth, openPixel), QPointF(keyPixel, openPixel));
      // draw close:
      // 가까이 다가 가라.
      painter->drawLine(QPointF(keyPixel, closePixel), QPointF(keyPixel+pixelWidth, closePixel));
    }
  } else
  {
    for (QCPFinancialDataContainer::const_iterator it = begin; it != end; ++it)
    {
      if (isSelected && mSelectionDecorator)
        mSelectionDecorator->applyPen(painter);
      else if (mTwoColored)
        painter->setPen(it->close >= it->open ? mPenPositive : mPenNegative);
      else
        painter->setPen(mPen);
      double keyPixel = keyAxis->coordToPixel(it->key);
      double openPixel = valueAxis->coordToPixel(it->open);
      double closePixel = valueAxis->coordToPixel(it->close);
      // draw backbone:
      // 백본 그리기 :
      painter->drawLine(QPointF(valueAxis->coordToPixel(it->high), keyPixel), QPointF(valueAxis->coordToPixel(it->low), keyPixel));
      // draw open:
      double pixelWidth = getPixelWidth(it->key, keyPixel);
// sign of this makes sure open/close are on correct sides
//이 기호는 열기 / 닫기가 올바른면에 있는지 확인합니다.
      painter->drawLine(QPointF(openPixel, keyPixel-pixelWidth), QPointF(openPixel, keyPixel));
      // draw close:
      // 가까이 다가 가라.
      painter->drawLine(QPointF(closePixel, keyPixel), QPointF(closePixel, keyPixel+pixelWidth));
    }
  }
}

/*! \internal
  
  Draws the data from \a begin to \a end-1 as Candlesticks with the provided \a painter.

  This method is a helper function for \ref draw. It is used when the chart style is \ref csCandlestick.
*/
/*! \내부의
  
  제공된 \ a 페인터를 사용하여 \ a부터 \ end-1까지의 데이터를 촛대로 그립니다.

  이 메소드는 \ ref draw를위한 도우미 함수입니다. 차트 스타일이 \ ref csCandlestick 일 때 사용됩니다.
*/
void QCPFinancial::drawCandlestickPlot(QCPPainter *painter, const QCPFinancialDataContainer::const_iterator &begin, const QCPFinancialDataContainer::const_iterator &end, bool isSelected)
{
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
  
  if (keyAxis->orientation() == Qt::Horizontal)
  {
    for (QCPFinancialDataContainer::const_iterator it = begin; it != end; ++it)
    {
      if (isSelected && mSelectionDecorator)
      {
        mSelectionDecorator->applyPen(painter);
        mSelectionDecorator->applyBrush(painter);
      } else if (mTwoColored)
      {
        painter->setPen(it->close >= it->open ? mPenPositive : mPenNegative);
        painter->setBrush(it->close >= it->open ? mBrushPositive : mBrushNegative);
      } else
      {
        painter->setPen(mPen);
        painter->setBrush(mBrush);
      }
      double keyPixel = keyAxis->coordToPixel(it->key);
      double openPixel = valueAxis->coordToPixel(it->open);
      double closePixel = valueAxis->coordToPixel(it->close);
      // draw high:
      // 높은 값으로 그립니다.
      painter->drawLine(QPointF(keyPixel, valueAxis->coordToPixel(it->high)), QPointF(keyPixel, valueAxis->coordToPixel(qMax(it->open, it->close))));
      // draw low:
      // 낮은 값으로 그립니다.
      painter->drawLine(QPointF(keyPixel, valueAxis->coordToPixel(it->low)), QPointF(keyPixel, valueAxis->coordToPixel(qMin(it->open, it->close))));
      // draw open-close box:
      // 열기 닫기 상자를 그립니다.
      double pixelWidth = getPixelWidth(it->key, keyPixel);
      painter->drawRect(QRectF(QPointF(keyPixel-pixelWidth, closePixel), QPointF(keyPixel+pixelWidth, openPixel)));
    }
  } else // keyAxis->orientation() == Qt::Vertical
  {
    for (QCPFinancialDataContainer::const_iterator it = begin; it != end; ++it)
    {
      if (isSelected && mSelectionDecorator)
      {
        mSelectionDecorator->applyPen(painter);
        mSelectionDecorator->applyBrush(painter);
      } else if (mTwoColored)
      {
        painter->setPen(it->close >= it->open ? mPenPositive : mPenNegative);
        painter->setBrush(it->close >= it->open ? mBrushPositive : mBrushNegative);
      } else
      {
        painter->setPen(mPen);
        painter->setBrush(mBrush);
      }
      double keyPixel = keyAxis->coordToPixel(it->key);
      double openPixel = valueAxis->coordToPixel(it->open);
      double closePixel = valueAxis->coordToPixel(it->close);
      // draw high:
      // 높은 값으로 그립니다.
      painter->drawLine(QPointF(valueAxis->coordToPixel(it->high), keyPixel), QPointF(valueAxis->coordToPixel(qMax(it->open, it->close)), keyPixel));
      // draw low:
      // 낮은 값으로 그립니다.
      painter->drawLine(QPointF(valueAxis->coordToPixel(it->low), keyPixel), QPointF(valueAxis->coordToPixel(qMin(it->open, it->close)), keyPixel));
      // draw open-close box:
      // 열기 닫기 상자를 그립니다.
      double pixelWidth = getPixelWidth(it->key, keyPixel);
      painter->drawRect(QRectF(QPointF(closePixel, keyPixel-pixelWidth), QPointF(openPixel, keyPixel+pixelWidth)));
    }
  }
}

/*! \internal

  This function is used to determine the width of the bar at coordinate \a key, according to the
  specified width (\ref setWidth) and width type (\ref setWidthType). Provide the pixel position of
  \a key in \a keyPixel (because usually this was already calculated via \ref QCPAxis::coordToPixel
  when this function is called).

  It returns the number of pixels the bar extends to higher keys, relative to the \a key
  coordinate. So with a non-reversed horizontal axis, the return value is positive. With a reversed
  horizontal axis, the return value is negative. This is important so the open/close flags on the
  \ref csOhlc bar are drawn to the correct side.
*/
/*! \내부의

  이 함수는 좌표 \ a 키에있는 막대의 너비를 결정하는 데 사용됩니다.
  지정된 너비 (\ ref setWidth)와 너비 유형 (\ ref setWidthType). 픽셀 위치 제공
  \ a keyPixel의 키 (대개 \ ref를 통해 이미 계산 되었기 때문에) QCPAxis :: coordToPixel
  이 함수가 호출 될 때).

  bar가 상위 키로 확장하는 픽셀의 수를 리턴한다.
  동등 어구. 따라서 역방향이 아닌 가로 축인 경우 반환 값은 양수입니다. 반전 된
  가로 축, 반환 값은 음수입니다. 이것은 중요하기 때문에 열기 / 닫기 플래그는
  \ ref csOhlc 표시 줄이 올바른면으로 그려집니다.
*/
double QCPFinancial::getPixelWidth(double key, double keyPixel) const
{
  double result = 0;
  switch (mWidthType)
  {
    case wtAbsolute:
    {
      if (mKeyAxis)
        result = mWidth*0.5*mKeyAxis.data()->pixelOrientation();
      break;
    }
    case wtAxisRectRatio:
    {
      if (mKeyAxis && mKeyAxis.data()->axisRect())
      {
        if (mKeyAxis.data()->orientation() == Qt::Horizontal)
          result = mKeyAxis.data()->axisRect()->width()*mWidth*0.5*mKeyAxis.data()->pixelOrientation();
        else
          result = mKeyAxis.data()->axisRect()->height()*mWidth*0.5*mKeyAxis.data()->pixelOrientation();
      } else
        qDebug() << Q_FUNC_INFO << "No key axis or axis rect defined";
      break;
    }
    case wtPlotCoords:
    {
      if (mKeyAxis)
        result = mKeyAxis.data()->coordToPixel(key+mWidth*0.5)-keyPixel;
      else
        qDebug() << Q_FUNC_INFO << "No key axis defined";
      break;
    }
  }
  return result;
}

/*! \internal

  This method is a helper function for \ref selectTest. It is used to test for selection when the
  chart style is \ref csOhlc. It only tests against the data points between \a begin and \a end.
  
  Like \ref selectTest, this method returns the shortest distance of \a pos to the graphical
  representation of the plottable, and \a closestDataPoint will point to the respective data point.
*/
/*! \내부의

  이 메소드는 \ ref selectTest의 도우미 함수입니다. 선택을 테스트 할 때 사용됩니다.
  차트 스타일은 \ ref csOhlc입니다. \ begin과 \ end 사이의 데이터 포인트에 대해서만 테스트합니다.
  
  \ ref selectTest와 마찬가지로이 메소드는 \ a pos의 최단 거리를 그래픽으로 리턴한다.
  \ n closestDataPoint는 해당 데이터 포인트를 가리 킵니다.
*/
double QCPFinancial::ohlcSelectTest(const QPointF &pos, const QCPFinancialDataContainer::const_iterator &begin, const QCPFinancialDataContainer::const_iterator &end, QCPFinancialDataContainer::const_iterator &closestDataPoint) const
{
  closestDataPoint = mDataContainer->constEnd();
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return -1; }

  double minDistSqr = std::numeric_limits<double>::max();
  if (keyAxis->orientation() == Qt::Horizontal)
  {
    for (QCPFinancialDataContainer::const_iterator it=begin; it!=end; ++it)
    {
      double keyPixel = keyAxis->coordToPixel(it->key);
      // calculate distance to backbone:
      // 백본과의 거리 계산 :
      double currentDistSqr = QCPVector2D(pos).distanceSquaredToLine(QCPVector2D(keyPixel, valueAxis->coordToPixel(it->high)), QCPVector2D(keyPixel, valueAxis->coordToPixel(it->low)));
      if (currentDistSqr < minDistSqr)
      {
        minDistSqr = currentDistSqr;
        closestDataPoint = it;
      }
    }
  } else // keyAxis->orientation() == Qt::Vertical
  {
    for (QCPFinancialDataContainer::const_iterator it=begin; it!=end; ++it)
    {
      double keyPixel = keyAxis->coordToPixel(it->key);
      // calculate distance to backbone:
      // 백본과의 거리 계산 :

      double currentDistSqr = QCPVector2D(pos).distanceSquaredToLine(QCPVector2D(valueAxis->coordToPixel(it->high), keyPixel), QCPVector2D(valueAxis->coordToPixel(it->low), keyPixel));
      if (currentDistSqr < minDistSqr)
      {
        minDistSqr = currentDistSqr;
        closestDataPoint = it;
      }
    }
  }
  return qSqrt(minDistSqr);
}

/*! \internal
  
  This method is a helper function for \ref selectTest. It is used to test for selection when the
  chart style is \ref csCandlestick. It only tests against the data points between \a begin and \a
  end.
  
  Like \ref selectTest, this method returns the shortest distance of \a pos to the graphical
  representation of the plottable, and \a closestDataPoint will point to the respective data point.
*/
/*! \내부의
  
  이 메소드는 \ ref selectTest의 도우미 함수입니다. 선택을 테스트 할 때 사용됩니다.
  차트 스타일은 \ ref csCandlestick입니다. \ a와 \ a 사이의 데이터 점에 대해서만 테스트합니다.
  종료.
  
  \ ref selectTest와 마찬가지로이 메소드는 \ a pos의 최단 거리를 그래픽으로 리턴한다.
  \ n closestDataPoint는 해당 데이터 포인트를 가리 킵니다.
*/
double QCPFinancial::candlestickSelectTest(const QPointF &pos, const QCPFinancialDataContainer::const_iterator &begin, const QCPFinancialDataContainer::const_iterator &end, QCPFinancialDataContainer::const_iterator &closestDataPoint) const
{
  closestDataPoint = mDataContainer->constEnd();
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return -1; }

  double minDistSqr = std::numeric_limits<double>::max();
  if (keyAxis->orientation() == Qt::Horizontal)
  {
    for (QCPFinancialDataContainer::const_iterator it=begin; it!=end; ++it)
    {
      double currentDistSqr;
      // determine whether pos is in open-close-box:
      // pos가 열린 닫기 상자에 있는지 여부를 확인합니다.
      QCPRange boxKeyRange(it->key-mWidth*0.5, it->key+mWidth*0.5);
      QCPRange boxValueRange(it->close, it->open);
      double posKey, posValue;
      pixelsToCoords(pos, posKey, posValue);
      if (boxKeyRange.contains(posKey) && boxValueRange.contains(posValue))
      // is in open-close-box
      // open-close-box에 있음
      {
        currentDistSqr = mParentPlot->selectionTolerance()*0.99 * mParentPlot->selectionTolerance()*0.99;
      } else
      {
        // calculate distance to high/low lines:
        // 고 / 저선 거리 계산 :
        double keyPixel = keyAxis->coordToPixel(it->key);
        double highLineDistSqr = QCPVector2D(pos).distanceSquaredToLine(QCPVector2D(keyPixel, valueAxis->coordToPixel(it->high)), QCPVector2D(keyPixel, valueAxis->coordToPixel(qMax(it->open, it->close))));
        double lowLineDistSqr = QCPVector2D(pos).distanceSquaredToLine(QCPVector2D(keyPixel, valueAxis->coordToPixel(it->low)), QCPVector2D(keyPixel, valueAxis->coordToPixel(qMin(it->open, it->close))));
        currentDistSqr = qMin(highLineDistSqr, lowLineDistSqr);
      }
      if (currentDistSqr < minDistSqr)
      {
        minDistSqr = currentDistSqr;
        closestDataPoint = it;
      }
    }
  } else // keyAxis->orientation() == Qt::Vertical
  {
    for (QCPFinancialDataContainer::const_iterator it=begin; it!=end; ++it)
    {
      double currentDistSqr;
      // determine whether pos is in open-close-box:
      // pos가 열린 닫기 상자에 있는지 여부를 확인합니다.
      QCPRange boxKeyRange(it->key-mWidth*0.5, it->key+mWidth*0.5);
      QCPRange boxValueRange(it->close, it->open);
      double posKey, posValue;
      pixelsToCoords(pos, posKey, posValue);
      if (boxKeyRange.contains(posKey) && boxValueRange.contains(posValue)) // is in open-close-box
      {
        currentDistSqr = mParentPlot->selectionTolerance()*0.99 * mParentPlot->selectionTolerance()*0.99;
      } else
      {
        // calculate distance to high/low lines:
        // 고 / 저선 거리 계산 :
        double keyPixel = keyAxis->coordToPixel(it->key);
        double highLineDistSqr = QCPVector2D(pos).distanceSquaredToLine(QCPVector2D(valueAxis->coordToPixel(it->high), keyPixel), QCPVector2D(valueAxis->coordToPixel(qMax(it->open, it->close)), keyPixel));
        double lowLineDistSqr = QCPVector2D(pos).distanceSquaredToLine(QCPVector2D(valueAxis->coordToPixel(it->low), keyPixel), QCPVector2D(valueAxis->coordToPixel(qMin(it->open, it->close)), keyPixel));
        currentDistSqr = qMin(highLineDistSqr, lowLineDistSqr);
      }
      if (currentDistSqr < minDistSqr)
      {
        minDistSqr = currentDistSqr;
        closestDataPoint = it;
      }
    }
  }
  return qSqrt(minDistSqr);
}

/*! \internal
  
  called by the drawing methods to determine which data (key) range is visible at the current key
  axis range setting, so only that needs to be processed.
  
  \a begin returns an iterator to the lowest data point that needs to be taken into account when
  plotting. Note that in order to get a clean plot all the way to the edge of the axis rect, \a
  begin may still be just outside the visible range.
  
  \a end returns the iterator just above the highest data point that needs to be taken into
  account. Same as before, \a end may also lie just outside of the visible range
  
  if the plottable contains no data, both \a begin and \a end point to \c constEnd.
*/
/*! \내부의
  
  현재의 키로 어느 데이터 (키) 범위가 표시되는지를 결정하기 위해서 드로잉 메서드에 의해 불려갑니다.
  축 범위 설정이므로 처리해야합니다.
  
  \ a begin은 가장 낮은 데이터 점에 대한 반복자를 반환합니다.
  플로팅. 깨끗한 그림을 축 rect의 끝까지 가져 오려면 \ a
  시작은 여전히 ​​가시 범위 밖에있을 수 있습니다.
  
  \ end는 받아 들여야 할 가장 높은 데이터 점 바로 위에있는 반복자를 반환합니다.
  계정. 이전과 동일하게 \ end도 가시 범위 밖에있을 수 있습니다.
  
  plottable에 데이터가 없으면 시작과 끝 모두 \ c constEnd를 가리 킵니다.
*/
void QCPFinancial::getVisibleDataBounds(QCPFinancialDataContainer::const_iterator &begin, QCPFinancialDataContainer::const_iterator &end) const
{
  if (!mKeyAxis)
  {
    qDebug() << Q_FUNC_INFO << "invalid key axis";
    begin = mDataContainer->constEnd();
    end = mDataContainer->constEnd();
    return;
  }
  begin = mDataContainer->findBegin(mKeyAxis.data()->range().lower-mWidth*0.5); 
// subtract half width of ohlc/candlestick to include partially visible data points
// 부분적으로 보이는 데이터 포인트를 포함하도록 ohlc / 촛대 반값을 뺍니다.

  end = mDataContainer->findEnd(mKeyAxis.data()->range().upper+mWidth*0.5); 
// add half width of ohlc/candlestick to include partially visible data points
// 부분적으로 표시되는 데이터 요소를 포함하도록 ohlc / 촛대 반값 추가
}

/*!  \internal

  Returns the hit box in pixel coordinates that will be used for data selection with the selection
  rect (\ref selectTestRect), of the data point given by \a it.
*/
/*! \내부의

  선택 항목을 사용하여 데이터를 선택하는 데 사용할 픽셀 좌표의 적중 상자를 반환합니다.
  rect (\ ref selectTestRect), \ a에 의해 주어진 데이터 포인트.
*/
QRectF QCPFinancial::selectionHitBox(QCPFinancialDataContainer::const_iterator it) const
{
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QRectF(); }
  
  double keyPixel = keyAxis->coordToPixel(it->key);
  double highPixel = valueAxis->coordToPixel(it->high);
  double lowPixel = valueAxis->coordToPixel(it->low);
  double keyWidthPixels = keyPixel-keyAxis->coordToPixel(it->key-mWidth*0.5);
  if (keyAxis->orientation() == Qt::Horizontal)
    return QRectF(keyPixel-keyWidthPixels, highPixel, keyWidthPixels*2, lowPixel-highPixel).normalized();
  else
    return QRectF(highPixel, keyPixel-keyWidthPixels, lowPixel-highPixel, keyWidthPixels*2).normalized();
}
/* end of 'src/plottables/plottable-financial.cpp' */


/* including file 'src/plottables/plottable-errorbar.cpp', size 37355        */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / plottables / plottable-financial.cpp'의 끝 */


/* 파일 'src / plottables / plottable-errorbar.cpp'포함, 크기 37355 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPErrorBarsData
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPErrorBarsData
  \brief Holds the data of one single error bar for QCPErrorBars.

  The stored data is:
  \li \a errorMinus: how much the error bar extends towards negative coordinates from the data
  point position
  \li \a errorPlus: how much the error bar extends towards positive coordinates from the data point
  position

  The container for storing the error bar information is \ref QCPErrorBarsDataContainer. It is a
  typedef for <tt>QVector<\ref QCPErrorBarsData></tt>.

  \see QCPErrorBarsDataContainer
*/
/*! \ class QCPErrorBarsData
  \ brief QCPErrorBars에 대한 단일 오류 막대의 데이터를 보유합니다.

  저장된 데이터는 다음과 같습니다.
  \ li \ a errorMinus : 오류 막대가 데이터에서 음의 좌표로 확장되는 정도
  포인트 위치
  \ li \ a errorPlus : 오류 막대가 데이터 포인트의 양수 좌표로 확장되는 정도
  위치

  오류 막대 정보를 저장하는 컨테이너는 \ ref QCPErrorBarsDataContainer입니다. 이것은
  <tt> QVector <\ ref QCPErrorBarsData> </ tt>에 대한 typedef입니다.

  \ see QCPErrorBarsDataContainer
*/

/*!
  Constructs an error bar with errors set to zero.
*/
/*!
  오류가 0으로 설정된 오류 막대를 구성합니다.
*/
QCPErrorBarsData::QCPErrorBarsData() :
  errorMinus(0),
  errorPlus(0)
{
}

/*!
  Constructs an error bar with equal \a error in both negative and positive direction.
*/
/*!
  음수와 양의 방향 모두에서 \ a 오류가있는 오류 막대를 구성합니다.
*/
QCPErrorBarsData::QCPErrorBarsData(double error) :
  errorMinus(error),
  errorPlus(error)
{
}

/*!
  Constructs an error bar with negative and positive errors set to \a errorMinus and \a errorPlus,
  respectively.
*/
/*!
  \ a errorMinus 및 \ a errorPlus로 설정된 음수 및 양수 오류가있는 오류 막대를 구성하고,
  각기.
*/
QCPErrorBarsData::QCPErrorBarsData(double errorMinus, double errorPlus) :
  errorMinus(errorMinus),
  errorPlus(errorPlus)
{
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPErrorBars
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPErrorBars
  \brief A plottable that adds a set of error bars to other plottables.

  \image html QCPErrorBars.png

  The \ref QCPErrorBars plottable can be attached to other one-dimensional plottables (e.g. \ref
  QCPGraph, \ref QCPCurve, \ref QCPBars, etc.) and equips them with error bars.

  Use \ref setDataPlottable to define for which plottable the \ref QCPErrorBars shall display the
  error bars. The orientation of the error bars can be controlled with \ref setErrorType.

  By using \ref setData, you can supply the actual error data, either as symmetric error or
  plus/minus asymmetric errors. \ref QCPErrorBars only stores the error data. The absolute
  key/value position of each error bar will be adopted from the configured data plottable. The
  error data of the \ref QCPErrorBars are associated one-to-one via their index to the data points
  of the data plottable. You can directly access and manipulate the error bar data via \ref data.

  Set either of the plus/minus errors to NaN (<tt>qQNaN()</tt> or
  <tt>std::numeric_limits<double>::quiet_NaN()</tt>) to not show the respective error bar on the data point at
  that index.

  \section qcperrorbars-appearance Changing the appearance

  The appearance of the error bars is defined by the pen (\ref setPen), and the width of the
  whiskers (\ref setWhiskerWidth). Further, the error bar backbones may leave a gap around the data
  point center to prevent that error bars are drawn too close to or even through scatter points.
  This gap size can be controlled via \ref setSymbolGap.
*/
/*! \ class QCPErrorBars
  \ brief 다른 plottables에 오류 막대 세트를 추가하는 plottable입니다.

  \ image html QCPErrorBars.png

  \ ref QCPErrorBars 플롯 테이블은 다른 1 차원 플롯 테이블 (예 : \ ref
  QCPGraph, \ ref QCPCurve, \ ref QCPBars 등) 오류 막대를 장비합니다.

  \ ref setDataPlottable을 사용하여 \ ref QCPErrorBars가 어떤 플롯 테이블을 표시할지 정의하십시오.
  오류 막대. 오류 막대의 방향은 \ ref setErrorType을 사용하여 제어 할 수 있습니다.

  \ ref setData를 사용하면 실제 오류 데이터를 대칭 오류 또는
  플러스 / 마이너스 비대칭 오류. \ ref QCPErrorBars는 오류 데이터 만 저장합니다. 절대 값
  각 오류 막대의 키 / 값 위치가 구성된 데이터 플롯에서 채택됩니다. 그만큼
  \ ref QCPErrorBars의 오류 데이터는 색인을 통해 데이터 요소에 일대일로 연결됩니다
  데이터의 plottable. \ ref 데이터를 통해 오류 막대 데이터에 직접 액세스하고 조작 할 수 있습니다.

  더하기 / 빼기 오류 중 하나를 NaN (<tt> qQNaN () </ tt> 또는
  <tt> std :: numeric_limits <double> :: quiet_NaN () </ tt>) 데이터 포인트의 해당 오류 막대를 표시하지 않습니다.
  그 색인.

  \ section qcperrorbars-appearance 모양 변경

  오류 막대의 모양은 펜 (\ ref setPen)에 의해 정의되고
  수염 (\ ref setWhiskerWidth). 또한 오류 막대 백본은 데이터 주변에 틈새를 남길 수 있습니다.
  오차 막대가 산란 점에 너무 가깝게 또는 심지어 산란 점을 통과하여 그려지는 것을 방지합니다.
  이 간격 크기는 \ ref setSymbolGap을 통해 제어 할 수 있습니다.
*/

/* start of documentation of inline functions */
/* 인라인 함수의 문서화 시작 */

/*! \fn QSharedPointer<QCPErrorBarsDataContainer> QCPErrorBars::data() const

  Returns a shared pointer to the internal data storage of type \ref QCPErrorBarsDataContainer. You
  may use it to directly manipulate the error values, which may be more convenient and faster than
  using the regular \ref setData methods.
*/
/*! \ fn QSharedPointer <QCPErrorBarsDataContainer> QCPErrorBars :: data () const

  \ ref QCPErrorBarsDataContainer 유형의 내부 데이터 저장소에 대한 공유 포인터를 반환합니다. 당신
  오류 값을 직접 조작하는 데 사용할 수 있습니다.이 오류 값은
  일반 \ ref setData 메소드를 사용합니다.
*/

/* end of documentation of inline functions */
/* 인라인 함수의 문서 끝 */

/*!
  Constructs an error bars plottable which uses \a keyAxis as its key axis ("x") and \a valueAxis as its value
  axis ("y"). \a keyAxis and \a valueAxis must reside in the same QCustomPlot instance and not have
  the same orientation. If either of these restrictions is violated, a corresponding message is
  printed to the debug output (qDebug), the construction is not aborted, though.

  It is also important that the \a keyAxis and \a valueAxis are the same for the error bars
  plottable and the data plottable that the error bars shall be drawn on (\ref setDataPlottable).

  The created \ref QCPErrorBars is automatically registered with the QCustomPlot instance inferred
  from \a keyAxis. This QCustomPlot instance takes ownership of the \ref QCPErrorBars, so do not
  delete it manually but use \ref QCustomPlot::removePlottable() instead.
*/
/*!
  키 축 ( "x")으로서 \ keyAxis를 사용해, 값으로서 \ valueAxis를 사용하는 에러 바 plottable를 구축합니다.
  축 ( "y"). \ a keyAxis 및 \ a valueAxis는 동일한 QCustomPlot 인스턴스에 있어야하며
  같은 방향. 이러한 제한 사항 중 하나라도 위반하면 해당 메시지가 다음과 같습니다.
  디버그 출력 (qDebug)에 인쇄되면, 구성은 중단되지 않습니다.

  오류 막대에 대해 \ a keyAxis 및 \ a valueAxis가 동일해야합니다.
  plottable과 오류 막대가 그려지는 데이터 플롯 테이블 (\ ref setDataPlottable).

  생성 된 \ ref QCPErrorBars는 유추 된 QCustomPlot 인스턴스와 함께 자동으로 등록됩니다.
  \ a keyAxis에서. 이 QCustomPlot 인스턴스는 \ ref QCPErrorBars의 소유권을 가지므로
  수동으로 삭제하지만 대신 \ ref QCustomPlot :: removePlottable ()을 사용하십시오.
*/
QCPErrorBars::QCPErrorBars(QCPAxis *keyAxis, QCPAxis *valueAxis) :
  QCPAbstractPlottable(keyAxis, valueAxis),
  mDataContainer(new QVector<QCPErrorBarsData>),
  mErrorType(etValueError),
  mWhiskerWidth(9),
  mSymbolGap(10)
{
  setPen(QPen(Qt::black, 0));
  setBrush(Qt::NoBrush);
}

QCPErrorBars::~QCPErrorBars()
{
}

/*! \overload

  Replaces the current data container with the provided \a data container.

  Since a QSharedPointer is used, multiple \ref QCPErrorBars instances may share the same data
  container safely. Modifying the data in the container will then affect all \ref QCPErrorBars
  instances that share the container. Sharing can be achieved by simply exchanging the data
  containers wrapped in shared pointers:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcperrorbars-datasharing-1

  If you do not wish to share containers, but create a copy from an existing container, assign the
  data containers directly:
  \snippet documentation/doc-code-snippets/mainwindow.cpp qcperrorbars-datasharing-2
  (This uses different notation compared with other plottables, because the \ref QCPErrorBars
  uses a \c QVector<QCPErrorBarsData> as its data container, instead of a \ref QCPDataContainer.)

  \see addData
*/

/*! \초과 적재

  현재 데이터 컨테이너를 제공된 \ 데이터 컨테이너로 바꿉니다.

  QSharedPointer가 사용되기 때문에 여러 개의 \ ref QCPErrorBars 인스턴스가 동일한 데이터를 공유 할 수 있습니다
  컨테이너에 안전하게. 컨테이너의 데이터를 수정하면 모든 \ ref QCPErrorBars에 영향을줍니다.
  컨테이너를 공유하는 인스턴스 단순히 데이터를 교환하여 공유 할 수 있습니다.
  공유 포인터로 싸인 컨테이너 :
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcperrorbars-datasharing-1

  컨테이너를 공유하지 않고 기존 컨테이너에서 사본을 만들려면
  데이터 컨테이너 직접 :
  \ snippet documentation / doc-code-snippets / mainwindow.cpp qcperrorbars-datasharing-2
  (이것은 \ ref QCPErrorBars가 다른 plottable에 비해 다른 표기법을 사용합니다.
  \ ref QCPDataContainer 대신 데이터 컨테이너로 \ Q QVector <QCPErrorBarsData>를 사용합니다.

  \ addData를 참조하십시오.
*/
void QCPErrorBars::setData(QSharedPointer<QCPErrorBarsDataContainer> data)
{
  mDataContainer = data;
}

/*! \overload

  Sets symmetrical error values as specified in \a error. The errors will be associated one-to-one
  by the data point index to the associated data plottable (\ref setDataPlottable).

  You can directly access and manipulate the error bar data via \ref data.

  \see addData
*/
/*! \초과 적재

  \ 오류에 지정된 대칭 오류 값을 설정합니다. 오류는 일대일로 연결됩니다.
  연결된 데이터 플롯 테이블 (\ ref setDataPlottable)에 대한 데이터 포인트 인덱스에 의해 지정됩니다.

  \ ref 데이터를 통해 오류 막대 데이터에 직접 액세스하고 조작 할 수 있습니다.

  \ addData를 참조하십시오.
*/
void QCPErrorBars::setData(const QVector<double> &error)
{
  mDataContainer->clear();
  addData(error);
}

/*! \overload

  Sets asymmetrical errors as specified in \a errorMinus and \a errorPlus. The errors will be
  associated one-to-one by the data point index to the associated data plottable (\ref
  setDataPlottable).

  You can directly access and manipulate the error bar data via \ref data.

  \see addData
*/
/*! \초과 적재

  \ errorMinus 및 \ errorPlus에 지정된대로 비대칭 오류를 설정합니다. 오류는
  데이터 포인트 인덱스와 관련된 데이터 플롯 테이블 (\ ref
  setDataPlottable).

  \ ref 데이터를 통해 오류 막대 데이터에 직접 액세스하고 조작 할 수 있습니다.

  \ addData를 참조하십시오.
*/
void QCPErrorBars::setData(const QVector<double> &errorMinus, const QVector<double> &errorPlus)
{
  mDataContainer->clear();
  addData(errorMinus, errorPlus);
}

/*!
  Sets the data plottable to which the error bars will be applied. The error values specified e.g.
  via \ref setData will be associated one-to-one by the data point index to the data points of \a
  plottable. This means that the error bars will adopt the key/value coordinates of the data point
  with the same index.

  The passed \a plottable must be a one-dimensional plottable, i.e. it must implement the \ref
  QCPPlottableInterface1D. Further, it must not be a \ref QCPErrorBars instance itself. If either
  of these restrictions is violated, a corresponding qDebug output is generated, and the data
  plottable of this \ref QCPErrorBars instance is set to zero.

  For proper display, care must also be taken that the key and value axes of the \a plottable match
  those configured for this \ref QCPErrorBars instance.
*/
/*!
  오류 막대가 적용될 데이터 플롯을 설정합니다. 예를 들어 지정된 오류 값
  via \ ref setData는 데이터 포인트 인덱스와 \ a의 데이터 포인트를 일대일로 연결합니다
  plottable. 즉, 오류 막대는 데이터 요소의 키 / 값 좌표를 채택합니다
  같은 지수로

  전달 된 \ plottable은 1 차원 plottable이어야합니다. 즉 \ ref를 구현해야합니다.
  QCPPlottableInterface1D. 또한 \ ref QCPErrorBars 인스턴스 자체가 아니어야합니다. 어느 쪽이든
  이 제한 사항 중 하나라도 위반되면 해당 qDebug 출력이 생성되고 데이터
  이 \ ref QCPErrorBars 인스턴스의 plottable은 0으로 설정됩니다.

  적절한 표시를 위해서는 \ a 표식의 키와 값 축이 일치해야합니다.
  이 \ ref QCPErrorBars 인스턴스에 대해 구성된 값.
*/
void QCPErrorBars::setDataPlottable(QCPAbstractPlottable *plottable)
{
  if (plottable && qobject_cast<QCPErrorBars*>(plottable))
  {
    mDataPlottable = 0;
    qDebug() << Q_FUNC_INFO << "can't set another QCPErrorBars instance as data plottable";
    return;
  }
  if (plottable && !plottable->interface1D())
  {
    mDataPlottable = 0;
    qDebug() << Q_FUNC_INFO << "passed plottable doesn't implement 1d interface, can't associate with QCPErrorBars";
    return;
  }
  
  mDataPlottable = plottable;
}

/*!
  Sets in which orientation the error bars shall appear on the data points. If your data needs both
  error dimensions, create two \ref QCPErrorBars with different \a type.
*/
/*!
  오류 막대가 데이터 포인트에 표시되는 방향을 설정합니다. 데이터에 둘 다 필요하다면
  오류 차원, 다른 \ a 형식으로 두 개의 \ ref QCPErrorBars를 만듭니다.
*/
void QCPErrorBars::setErrorType(ErrorType type)
{
  mErrorType = type;
}

/*!
  Sets the width of the whiskers (the short bars at the end of the actual error bar backbones) to
  \a pixels.
*/
/*!
  수염의 폭 (실제 오차 막대 백본 끝의 짧은 막대)을
  \ a 픽셀.
*/
void QCPErrorBars::setWhiskerWidth(double pixels)
{
  mWhiskerWidth = pixels;
}

/*!
  Sets the gap diameter around the data points that will be left out when drawing the error bar
  backbones. This gap prevents that error bars are drawn too close to or even through scatter
  points.
*/
/*!
  오류 막대를 그릴 때 누락 될 데이터 점 주위의 간격 직경을 설정합니다.
  백본. 이 간격은 오차 막대가 산란에 너무 가깝게 또는 심지어 산란을 통해 그려지는 것을 방지합니다.
  전철기.
*/
void QCPErrorBars::setSymbolGap(double pixels)
{
  mSymbolGap = pixels;
}

/*! \overload

  Adds symmetrical error values as specified in \a error. The errors will be associated one-to-one
  by the data point index to the associated data plottable (\ref setDataPlottable).

  You can directly access and manipulate the error bar data via \ref data.

  \see setData
*/
/*! \초과 적재

  \ 오류에 지정된 대칭 오류 값을 추가합니다. 오류는 일대일로 연결됩니다.
  연결된 데이터 플롯 테이블 (\ ref setDataPlottable)에 대한 데이터 포인트 인덱스에 의해 지정됩니다.

  \ ref 데이터를 통해 오류 막대 데이터에 직접 액세스하고 조작 할 수 있습니다.

  \ see setData
*/
void QCPErrorBars::addData(const QVector<double> &error)
{
  addData(error, error);
}

/*! \overload

  Adds asymmetrical errors as specified in \a errorMinus and \a errorPlus. The errors will be
  associated one-to-one by the data point index to the associated data plottable (\ref
  setDataPlottable).

  You can directly access and manipulate the error bar data via \ref data.

  \see setData
*/
/*! \초과 적재

  \ errorMinus 및 \ errorPlus에 지정된대로 비대칭 오류를 추가합니다. 오류는
  데이터 포인트 인덱스와 관련된 데이터 플롯 테이블 (\ ref
  setDataPlottable).

  \ ref 데이터를 통해 오류 막대 데이터에 직접 액세스하고 조작 할 수 있습니다.

  \ see setData
*/
void QCPErrorBars::addData(const QVector<double> &errorMinus, const QVector<double> &errorPlus)
{
  if (errorMinus.size() != errorPlus.size())
    qDebug() << Q_FUNC_INFO << "minus and plus error vectors have different sizes:" << errorMinus.size() << errorPlus.size();
  const int n = qMin(errorMinus.size(), errorPlus.size());
  mDataContainer->reserve(n);
  for (int i=0; i<n; ++i)
    mDataContainer->append(QCPErrorBarsData(errorMinus.at(i), errorPlus.at(i)));
}

/*! \overload

  Adds a single symmetrical error bar as specified in \a error. The errors will be associated
  one-to-one by the data point index to the associated data plottable (\ref setDataPlottable).

  You can directly access and manipulate the error bar data via \ref data.

  \see setData
*/
/*! \초과 적재

  \ a 오류로 지정된 대칭 오류 막대를 하나 추가합니다. 오류는
  연관된 데이터 플롯 테이블 (\ ref setDataPlottable)에 데이터 포인트 인덱스에 의해 일대일로 연결됩니다.

  \ ref 데이터를 통해 오류 막대 데이터에 직접 액세스하고 조작 할 수 있습니다.

  \ see setData
*/
void QCPErrorBars::addData(double error)
{
  mDataContainer->append(QCPErrorBarsData(error));
}

/*! \overload

  Adds a single asymmetrical error bar as specified in \a errorMinus and \a errorPlus. The errors
  will be associated one-to-one by the data point index to the associated data plottable (\ref
  setDataPlottable).

  You can directly access and manipulate the error bar data via \ref data.

  \see setData
*/
/*! \초과 적재

  \ errorMinus 및 \ errorPlus에 지정된대로 비대칭 오류 막대를 하나 추가합니다. 오류
  데이터 포인트 인덱스와 관련 데이터 플롯 테이블에 일대일로 연결됩니다 (\ ref
  setDataPlottable).

  \ ref 데이터를 통해 오류 막대 데이터에 직접 액세스하고 조작 할 수 있습니다.

  \ see setData
*/
void QCPErrorBars::addData(double errorMinus, double errorPlus)
{
  mDataContainer->append(QCPErrorBarsData(errorMinus, errorPlus));
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
int QCPErrorBars::dataCount() const
{
  return mDataContainer->size();
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPErrorBars::dataMainKey(int index) const
{
  if (mDataPlottable)
    return mDataPlottable->interface1D()->dataMainKey(index);
  else
    qDebug() << Q_FUNC_INFO << "no data plottable set";
  return 0;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPErrorBars::dataSortKey(int index) const
{
  if (mDataPlottable)
    return mDataPlottable->interface1D()->dataSortKey(index);
  else
    qDebug() << Q_FUNC_INFO << "no data plottable set";
  return 0;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPErrorBars::dataMainValue(int index) const
{
  if (mDataPlottable)
    return mDataPlottable->interface1D()->dataMainValue(index);
  else
    qDebug() << Q_FUNC_INFO << "no data plottable set";
  return 0;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPRange QCPErrorBars::dataValueRange(int index) const
{
  if (mDataPlottable)
  {
    const double value = mDataPlottable->interface1D()->dataMainValue(index);
    if (index >= 0 && index < mDataContainer->size() && mErrorType == etValueError)
      return QCPRange(value-mDataContainer->at(index).errorMinus, value+mDataContainer->at(index).errorPlus);
    else
      return QCPRange(value, value);
  } else
  {
    qDebug() << Q_FUNC_INFO << "no data plottable set";
    return QCPRange();
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QPointF QCPErrorBars::dataPixelPosition(int index) const
{
  if (mDataPlottable)
    return mDataPlottable->interface1D()->dataPixelPosition(index);
  else
    qDebug() << Q_FUNC_INFO << "no data plottable set";
  return QPointF();
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
bool QCPErrorBars::sortKeyIsMainKey() const
{
  if (mDataPlottable)
  {
    return mDataPlottable->interface1D()->sortKeyIsMainKey();
  } else
  {
    qDebug() << Q_FUNC_INFO << "no data plottable set";
    return true;
  }
}

/*!
  \copydoc QCPPlottableInterface1D::selectTestRect
*/
QCPDataSelection QCPErrorBars::selectTestRect(const QRectF &rect, bool onlySelectable) const
{
  QCPDataSelection result;
  if (!mDataPlottable)
    return result;
  if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())
    return result;
  if (!mKeyAxis || !mValueAxis)
    return result;
  
  QCPErrorBarsDataContainer::const_iterator visibleBegin, visibleEnd;
  getVisibleDataBounds(visibleBegin, visibleEnd, QCPDataRange(0, dataCount()));
  
  QVector<QLineF> backbones, whiskers;
  for (QCPErrorBarsDataContainer::const_iterator it=visibleBegin; it!=visibleEnd; ++it)
  {
    backbones.clear();
    whiskers.clear();
    getErrorBarLines(it, backbones, whiskers);
    for (int i=0; i<backbones.size(); ++i)
    {
      if (rectIntersectsLine(rect, backbones.at(i)))
      {
        result.addDataRange(QCPDataRange(it-mDataContainer->constBegin(), it-mDataContainer->constBegin()+1), false);
        break;
      }
    }
  }
  result.simplify();
  return result;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
int QCPErrorBars::findBegin(double sortKey, bool expandedRange) const
{
  if (mDataPlottable)
  {
    if (mDataContainer->isEmpty())
      return 0;
    int beginIndex = mDataPlottable->interface1D()->findBegin(sortKey, expandedRange);
    if (beginIndex >= mDataContainer->size())
      beginIndex = mDataContainer->size()-1;
    return beginIndex;
  } else
    qDebug() << Q_FUNC_INFO << "no data plottable set";
  return 0;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
int QCPErrorBars::findEnd(double sortKey, bool expandedRange) const
{
  if (mDataPlottable)
  {
    if (mDataContainer->isEmpty())
      return 0;
    int endIndex = mDataPlottable->interface1D()->findEnd(sortKey, expandedRange);
    if (endIndex > mDataContainer->size())
      endIndex = mDataContainer->size();
    return endIndex;
  } else
    qDebug() << Q_FUNC_INFO << "no data plottable set";
  return 0;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPErrorBars::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  if (!mDataPlottable) return -1;
  
  if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())
    return -1;
  if (!mKeyAxis || !mValueAxis)
    return -1;
  
  if (mKeyAxis.data()->axisRect()->rect().contains(pos.toPoint()))
  {
    QCPErrorBarsDataContainer::const_iterator closestDataPoint = mDataContainer->constEnd();
    double result = pointDistance(pos, closestDataPoint);
    if (details)
    {
      int pointIndex = closestDataPoint-mDataContainer->constBegin();
      details->setValue(QCPDataSelection(QCPDataRange(pointIndex, pointIndex+1)));
    }
    return result;
  } else
    return -1;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPErrorBars::draw(QCPPainter *painter)
{
  if (!mDataPlottable) return;
  if (!mKeyAxis || !mValueAxis) { qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; }
  if (mKeyAxis.data()->range().size() <= 0 || mDataContainer->isEmpty()) return;
  
  // if the sort key isn't the main key, we must check the visibility for each data point/error bar individually
  // (getVisibleDataBounds applies range restriction, but otherwise can only return full data range):
  // 정렬 키가 기본 키가 아닌 경우 각 데이터 요소 / 오류 막대의 가시성을 개별적으로 확인해야합니다
  // (getVisibleDataBounds는 범위 제한을 적용하지만 그렇지 않으면 전체 데이터 범위 만 반환 할 수 있음) :
  bool checkPointVisibility = !mDataPlottable->interface1D()->sortKeyIsMainKey();
      
    // check data validity if flag set:
    // 플래그가 설정된 경우 데이터 유효성을 검사합니다.
#ifdef QCUSTOMPLOT_CHECK_DATA
  QCPErrorBarsDataContainer::const_iterator it;
  for (it = mDataContainer->constBegin(); it != mDataContainer->constEnd(); ++it)
  {
    if (QCP::isInvalidData(it->errorMinus, it->errorPlus))
      qDebug() << Q_FUNC_INFO << "Data point at index" << it-mDataContainer->constBegin() << "invalid." << "Plottable name:" << name();
  }
#endif
  
  applyDefaultAntialiasingHint(painter);
  painter->setBrush(Qt::NoBrush);
  // loop over and draw segments of unselected/selected data:
  // 선택되지 않은 / 선택한 데이터의 세그먼트를 반복 및 그립니다.
  QList<QCPDataRange> selectedSegments, unselectedSegments, allSegments;
  getDataSegments(selectedSegments, unselectedSegments);
  allSegments << unselectedSegments << selectedSegments;
  QVector<QLineF> backbones, whiskers;
  for (int i=0; i<allSegments.size(); ++i)
  {
    QCPErrorBarsDataContainer::const_iterator begin, end;
    getVisibleDataBounds(begin, end, allSegments.at(i));
    if (begin == end)
      continue;
    
    bool isSelectedSegment = i >= unselectedSegments.size();
    if (isSelectedSegment && mSelectionDecorator)
      mSelectionDecorator->applyPen(painter);
    else
      painter->setPen(mPen);
    if (painter->pen().capStyle() == Qt::SquareCap)
    {
      QPen capFixPen(painter->pen());
      capFixPen.setCapStyle(Qt::FlatCap);
      painter->setPen(capFixPen);
    }
    backbones.clear();
    whiskers.clear();
    for (QCPErrorBarsDataContainer::const_iterator it=begin; it!=end; ++it)
    {
      if (!checkPointVisibility || errorBarVisible(it-mDataContainer->constBegin()))
        getErrorBarLines(it, backbones, whiskers);
    }
    painter->drawLines(backbones);
    painter->drawLines(whiskers);
  }
  
  // draw other selection decoration that isn't just line/scatter pens and brushes:
  // 선 / 산란 펜 및 브러쉬가 아닌 다른 선택 장식을 그립니다.
  if (mSelectionDecorator)
    mSelectionDecorator->drawDecoration(painter, selection());
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPErrorBars::drawLegendIcon(QCPPainter *painter, const QRectF &rect) const
{
  applyDefaultAntialiasingHint(painter);
  painter->setPen(mPen);
  if (mErrorType == etValueError && mValueAxis && mValueAxis->orientation() == Qt::Vertical)
  {
    painter->drawLine(QLineF(rect.center().x(), rect.top()+2, rect.center().x(), rect.bottom()-1));
    painter->drawLine(QLineF(rect.center().x()-4, rect.top()+2, rect.center().x()+4, rect.top()+2));
    painter->drawLine(QLineF(rect.center().x()-4, rect.bottom()-1, rect.center().x()+4, rect.bottom()-1));
  } else
  {
    painter->drawLine(QLineF(rect.left()+2, rect.center().y(), rect.right()-2, rect.center().y()));
    painter->drawLine(QLineF(rect.left()+2, rect.center().y()-4, rect.left()+2, rect.center().y()+4));
    painter->drawLine(QLineF(rect.right()-2, rect.center().y()-4, rect.right()-2, rect.center().y()+4));
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPRange QCPErrorBars::getKeyRange(bool &foundRange, QCP::SignDomain inSignDomain) const
{
  if (!mDataPlottable)
  {
    foundRange = false;
    return QCPRange();
  }
  
  QCPRange range;
  bool haveLower = false;
  bool haveUpper = false;
  QCPErrorBarsDataContainer::const_iterator it;
  for (it = mDataContainer->constBegin(); it != mDataContainer->constEnd(); ++it)
  {
    if (mErrorType == etValueError)
    {
// error bar doesn't extend in key dimension (except whisker but we ignore that here), so only use data point center
// 오류 막대는 키 차원에서 확장되지 않습니다 (수염을 제외하고 여기서는 무시하지만). 따라서 데이터 포인트 중심 만 사용하십시오.
      const double current = mDataPlottable->interface1D()->dataMainKey(it-mDataContainer->constBegin());
      if (qIsNaN(current)) continue;
      if (inSignDomain == QCP::sdBoth || (inSignDomain == QCP::sdNegative && current < 0) || (inSignDomain == QCP::sdPositive && current > 0))
      {
        if (current < range.lower || !haveLower)
        {
          range.lower = current;
          haveLower = true;
        }
        if (current > range.upper || !haveUpper)
        {
          range.upper = current;
          haveUpper = true;
        }
      }
    } else // mErrorType == etKeyError
    {
      const double dataKey = mDataPlottable->interface1D()->dataMainKey(it-mDataContainer->constBegin());
      if (qIsNaN(dataKey)) continue;
      // plus error:
      // 더하기 오류 :
      double current = dataKey + (qIsNaN(it->errorPlus) ? 0 : it->errorPlus);
      if (inSignDomain == QCP::sdBoth || (inSignDomain == QCP::sdNegative && current < 0) || (inSignDomain == QCP::sdPositive && current > 0))
      {
        if (current > range.upper || !haveUpper)
        {
          range.upper = current;
          haveUpper = true;
        }
      }
      // minus error:
      // 빼기 오류 :
      current = dataKey - (qIsNaN(it->errorMinus) ? 0 : it->errorMinus);
      if (inSignDomain == QCP::sdBoth || (inSignDomain == QCP::sdNegative && current < 0) || (inSignDomain == QCP::sdPositive && current > 0))
      {
        if (current < range.lower || !haveLower)
        {
          range.lower = current;
          haveLower = true;
        }
      }
    }
  }
  
  if (haveUpper && !haveLower)
  {
    range.lower = range.upper;
    haveLower = true;
  } else if (haveLower && !haveUpper)
  {
    range.upper = range.lower;
    haveUpper = true;
  }
  
  foundRange = haveLower && haveUpper;
  return range;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QCPRange QCPErrorBars::getValueRange(bool &foundRange, QCP::SignDomain inSignDomain, const QCPRange &inKeyRange) const
{
  if (!mDataPlottable)
  {
    foundRange = false;
    return QCPRange();
  }
  
  QCPRange range;
  const bool restrictKeyRange = inKeyRange != QCPRange();
  bool haveLower = false;
  bool haveUpper = false;
  QCPErrorBarsDataContainer::const_iterator itBegin = mDataContainer->constBegin();
  QCPErrorBarsDataContainer::const_iterator itEnd = mDataContainer->constEnd();
  if (mDataPlottable->interface1D()->sortKeyIsMainKey() && restrictKeyRange)
  {
    itBegin = mDataContainer->constBegin()+findBegin(inKeyRange.lower);
    itEnd = mDataContainer->constBegin()+findEnd(inKeyRange.upper);
  }
  for (QCPErrorBarsDataContainer::const_iterator it = itBegin; it != itEnd; ++it)
  {
    if (restrictKeyRange)
    {
      const double dataKey = mDataPlottable->interface1D()->dataMainKey(it-mDataContainer->constBegin());
      if (dataKey < inKeyRange.lower || dataKey > inKeyRange.upper)
        continue;
    }
    if (mErrorType == etValueError)
    {
      const double dataValue = mDataPlottable->interface1D()->dataMainValue(it-mDataContainer->constBegin());
      if (qIsNaN(dataValue)) continue;
      // plus error:
      double current = dataValue + (qIsNaN(it->errorPlus) ? 0 : it->errorPlus);
      if (inSignDomain == QCP::sdBoth || (inSignDomain == QCP::sdNegative && current < 0) || (inSignDomain == QCP::sdPositive && current > 0))
      {
        if (current > range.upper || !haveUpper)
        {
          range.upper = current;
          haveUpper = true;
        }
      }
      // minus error:
      current = dataValue - (qIsNaN(it->errorMinus) ? 0 : it->errorMinus);
      if (inSignDomain == QCP::sdBoth || (inSignDomain == QCP::sdNegative && current < 0) || (inSignDomain == QCP::sdPositive && current > 0))
      {
        if (current < range.lower || !haveLower)
        {
          range.lower = current;
          haveLower = true;
        }
      }
    } else // mErrorType == etKeyError
    {
// error bar doesn't extend in value dimension (except whisker but we ignore that here), so only use data point center
// 오류 막대는 값 차원에서 확장되지 않습니다 (수염을 제외하고 여기서는 무시하지만). 따라서 데이터 포인트 중심 만 사용하십시오.
      const double current = mDataPlottable->interface1D()->dataMainValue(it-mDataContainer->constBegin());
      if (qIsNaN(current)) continue;
      if (inSignDomain == QCP::sdBoth || (inSignDomain == QCP::sdNegative && current < 0) || (inSignDomain == QCP::sdPositive && current > 0))
      {
        if (current < range.lower || !haveLower)
        {
          range.lower = current;
          haveLower = true;
        }
        if (current > range.upper || !haveUpper)
        {
          range.upper = current;
          haveUpper = true;
        }
      }
    }
  }
  
  if (haveUpper && !haveLower)
  {
    range.lower = range.upper;
    haveLower = true;
  } else if (haveLower && !haveUpper)
  {
    range.upper = range.lower;
    haveUpper = true;
  }
  
  foundRange = haveLower && haveUpper;
  return range;
}

/*! \internal

  Calculates the lines that make up the error bar belonging to the data point \a it.

  The resulting lines are added to \a backbones and \a whiskers. The vectors are not cleared, so
  calling this method with different \a it but the same \a backbones and \a whiskers allows to
  accumulate lines for multiple data points.

  This method assumes that \a it is a valid iterator within the bounds of this \ref QCPErrorBars
  instance and within the bounds of the associated data plottable.
*/
/*! \내부의

  데이터 점에 속하는 오차 막대를 구성하는 선을 계산합니다.

  결과 행은 백본과 \ whiskers에 추가됩니다. 벡터는 지워지지 않으므로
  이 메소드를 다른 \ a로 호출하지만 백본과 \ whiskers는 같은 것을 사용할 수 있습니다.
  여러 데이터 요소에 대한 선을 누적하십시오.

  이 메서드는이 \ ref QCPErrorBars 범위 내에서 유효한 iterator라고 가정합니다.
  인스턴스와 관련 데이터 plottable 범위 내에 있어야합니다.
*/
void QCPErrorBars::getErrorBarLines(QCPErrorBarsDataContainer::const_iterator it, QVector<QLineF> &backbones, QVector<QLineF> &whiskers) const
{
  if (!mDataPlottable) return;
  
  int index = it-mDataContainer->constBegin();
  QPointF centerPixel = mDataPlottable->interface1D()->dataPixelPosition(index);
  if (qIsNaN(centerPixel.x()) || qIsNaN(centerPixel.y()))
    return;
  QCPAxis *errorAxis = mErrorType == etValueError ? mValueAxis.data() : mKeyAxis.data();
  QCPAxis *orthoAxis = mErrorType == etValueError ? mKeyAxis.data() : mValueAxis.data();
  const double centerErrorAxisPixel = errorAxis->orientation() == Qt::Horizontal ? centerPixel.x() : centerPixel.y();
  const double centerOrthoAxisPixel = orthoAxis->orientation() == Qt::Horizontal ? centerPixel.x() : centerPixel.y();
  const double centerErrorAxisCoord = errorAxis->pixelToCoord(centerErrorAxisPixel); 
// depending on plottable, this might be different from just mDataPlottable->interface1D()->dataMainKey/Value
// 플롯 테이블에 따라 mDataPlottable-> interface1D () -> dataMainKey / Value와 다를 수 있습니다.
  const double symbolGap = mSymbolGap*0.5*errorAxis->pixelOrientation();
  // plus error:
  double errorStart, errorEnd;
  if (!qIsNaN(it->errorPlus))
  {
    errorStart = centerErrorAxisPixel+symbolGap;
    errorEnd = errorAxis->coordToPixel(centerErrorAxisCoord+it->errorPlus);
    if (errorAxis->orientation() == Qt::Vertical)
    {
      if ((errorStart > errorEnd) != errorAxis->rangeReversed())
        backbones.append(QLineF(centerOrthoAxisPixel, errorStart, centerOrthoAxisPixel, errorEnd));
      whiskers.append(QLineF(centerOrthoAxisPixel-mWhiskerWidth*0.5, errorEnd, centerOrthoAxisPixel+mWhiskerWidth*0.5, errorEnd));
    } else
    {
      if ((errorStart < errorEnd) != errorAxis->rangeReversed())
        backbones.append(QLineF(errorStart, centerOrthoAxisPixel, errorEnd, centerOrthoAxisPixel));
      whiskers.append(QLineF(errorEnd, centerOrthoAxisPixel-mWhiskerWidth*0.5, errorEnd, centerOrthoAxisPixel+mWhiskerWidth*0.5));
    }
  }
  // minus error:
  if (!qIsNaN(it->errorMinus))
  {
    errorStart = centerErrorAxisPixel-symbolGap;
    errorEnd = errorAxis->coordToPixel(centerErrorAxisCoord-it->errorMinus);
    if (errorAxis->orientation() == Qt::Vertical)
    {
      if ((errorStart < errorEnd) != errorAxis->rangeReversed())
        backbones.append(QLineF(centerOrthoAxisPixel, errorStart, centerOrthoAxisPixel, errorEnd));
      whiskers.append(QLineF(centerOrthoAxisPixel-mWhiskerWidth*0.5, errorEnd, centerOrthoAxisPixel+mWhiskerWidth*0.5, errorEnd));
    } else
    {
      if ((errorStart > errorEnd) != errorAxis->rangeReversed())
        backbones.append(QLineF(errorStart, centerOrthoAxisPixel, errorEnd, centerOrthoAxisPixel));
      whiskers.append(QLineF(errorEnd, centerOrthoAxisPixel-mWhiskerWidth*0.5, errorEnd, centerOrthoAxisPixel+mWhiskerWidth*0.5));
    }
  }
}

/*! \internal

  This method outputs the currently visible data range via \a begin and \a end. The returned range
  will also never exceed \a rangeRestriction.

  Since error bars with type \ref etKeyError may extend to arbitrarily positive and negative key
  coordinates relative to their data point key, this method checks all outer error bars whether
  they truly don't reach into the visible portion of the axis rect, by calling \ref
  errorBarVisible. On the other hand error bars with type \ref etValueError that are associated
  with data plottables whose sort key is equal to the main key (see \ref qcpdatacontainer-datatype
  "QCPDataContainer DataType") can be handled very efficiently by finding the visible range of
  error bars through binary search (\ref QCPPlottableInterface1D::findBegin and \ref
  QCPPlottableInterface1D::findEnd).

  If the plottable's sort key is not equal to the main key, this method returns the full data
  range, only restricted by \a rangeRestriction. Drawing optimization then has to be done on a
  point-by-point basis in the \ref draw method.
*/
/*! \내부의

  이 메서드는 \ a begin과 \ a end를 통해 현재 보이는 데이터 범위를 출력합니다. 반환 된 범위
  \ rangeRestriction을 초과하지 않습니다.

  \ ref etKeyError 유형의 오류 막대는 임의로 양수 및 음수 키로 확장 될 수 있기 때문에
  좌표를 데이터 포인트 키에 상대적으로 설정하면이 메서드는 모든 외부 오류 막대를 확인합니다.
  그들은 진정으로 축 rect의 눈에 보이는 부분에 도달하지 않는다. \ ref를 호출하면된다.
  errorBarVisible. 반면에 관련된 \ ref etValueError 유형의 오류 막대
  정렬 키가 기본 키와 동일한 데이터 플롯 테이블 (\ ref qcpdatacontainer-datatype
  "QCPDataContainer DataType")은 다음과 같은 가시 범위를 찾음으로써 매우 효율적으로 처리 할 수 ​​있습니다.
  이진 검색 (\ ref QCPPlottableInterface1D :: findBegin 및 \ ref를 통한 오류 막대)
  QCPPlottableInterface1D :: findEnd).

  플롯 테이블의 정렬 키가 기본 키와 같지 않으면이 메서드는 전체 데이터를 반환합니다.
  범위는 \ rangeRestriction에 의해서만 제한됩니다. 그리기 최적화는
  \ ref draw 메서드에서 점별로 기준을 설정합니다.
*/
void QCPErrorBars::getVisibleDataBounds(QCPErrorBarsDataContainer::const_iterator &begin, QCPErrorBarsDataContainer::const_iterator &end, const QCPDataRange &rangeRestriction) const
{
  QCPAxis *keyAxis = mKeyAxis.data();
  QCPAxis *valueAxis = mValueAxis.data();
  if (!keyAxis || !valueAxis)
  {
    qDebug() << Q_FUNC_INFO << "invalid key or value axis";
    end = mDataContainer->constEnd();
    begin = end;
    return;
  }
  if (!mDataPlottable || rangeRestriction.isEmpty())
  {
    end = mDataContainer->constEnd();
    begin = end;
    return;
  }
  if (!mDataPlottable->interface1D()->sortKeyIsMainKey())
  {
    // if the sort key isn't the main key, it's not possible to find a contiguous range of visible
    // data points, so this method then only applies the range restriction and otherwise returns
    // the full data range. Visibility checks must be done on a per-datapoin-basis during drawing
    // 정렬 키가 기본 키가 아닌 경우 표시 가능한 연속 범위를 찾을 수 없습니다.
    // 데이터 포인트이므로이 메서드는 범위 제한을 적용하고 그렇지 않으면 반환합니다.
    // 전체 데이터 범위. 가시성 검사는 그림을 그리는 동안 데이터 단위 기준으로 수행해야합니다.
    QCPDataRange dataRange(0, mDataContainer->size());
    dataRange = dataRange.bounded(rangeRestriction);
    begin = mDataContainer->constBegin()+dataRange.begin();
    end = mDataContainer->constBegin()+dataRange.end();
    return;
  }
  
  // get visible data range via interface from data plottable, and then restrict to available error data points:
  // 데이터 plottable의 인터페이스를 통해 보이는 데이터 범위를 얻은 다음 사용 가능한 오류 데이터 포인트로 제한합니다.
  const int n = qMin(mDataContainer->size(), mDataPlottable->interface1D()->dataCount());
  int beginIndex = mDataPlottable->interface1D()->findBegin(keyAxis->range().lower);
  int endIndex = mDataPlottable->interface1D()->findEnd(keyAxis->range().upper);
  int i = beginIndex;
  while (i > 0 && i < n && i > rangeRestriction.begin())
  {
    if (errorBarVisible(i))
      beginIndex = i;
    --i;
  }
  i = endIndex;
  while (i >= 0 && i < n && i < rangeRestriction.end())
  {
    if (errorBarVisible(i))
      endIndex = i+1;
    ++i;
  }
  QCPDataRange dataRange(beginIndex, endIndex);
  dataRange = dataRange.bounded(rangeRestriction.bounded(QCPDataRange(0, mDataContainer->size())));
  begin = mDataContainer->constBegin()+dataRange.begin();
  end = mDataContainer->constBegin()+dataRange.end();
}

/*! \internal

  Calculates the minimum distance in pixels the error bars' representation has from the given \a
  pixelPoint. This is used to determine whether the error bar was clicked or not, e.g. in \ref
  selectTest. The closest data point to \a pixelPoint is returned in \a closestData.
*/
/*! \내부의

  주어진 오차 막대의 표현으로부터 얻은 최소 거리를 픽셀 단위로 계산합니다.
  pixelPoint. 이것은 오류 표시 줄이 클릭되었는지 여부를 결정하는 데 사용됩니다 (예 : \ ref).
  selectTest. \ pixelPoint에 가장 근접한 데이터 포인트는 \ nearestData에 반환됩니다.
*/
double QCPErrorBars::pointDistance(const QPointF &pixelPoint, QCPErrorBarsDataContainer::const_iterator &closestData) const
{
  closestData = mDataContainer->constEnd();
  if (!mDataPlottable || mDataContainer->isEmpty())
    return -1.0;
  if (!mKeyAxis || !mValueAxis)
  {
    qDebug() << Q_FUNC_INFO << "invalid key or value axis";
    return -1.0;
  }
  
  QCPErrorBarsDataContainer::const_iterator begin, end;
  getVisibleDataBounds(begin, end, QCPDataRange(0, dataCount()));
  
  // calculate minimum distances to error backbones (whiskers are ignored for speed) and find closestData iterator:
  // 오류 백본에 대한 최소 거리를 계산합니다 (속도는 무시됩니다). closestData를 찾습니다. iterator :
  double minDistSqr = std::numeric_limits<double>::max();
  QVector<QLineF> backbones, whiskers;
  for (QCPErrorBarsDataContainer::const_iterator it=begin; it!=end; ++it)
  {
    getErrorBarLines(it, backbones, whiskers);
    for (int i=0; i<backbones.size(); ++i)
    {
      const double currentDistSqr = QCPVector2D(pixelPoint).distanceSquaredToLine(backbones.at(i));
      if (currentDistSqr < minDistSqr)
      {
        minDistSqr = currentDistSqr;
        closestData = it;
      }
    }
  }
  return qSqrt(minDistSqr);
}

/*! \internal

  \note This method is identical to \ref QCPAbstractPlottable1D::getDataSegments but needs to be
  reproduced here since the \ref QCPErrorBars plottable, as a special case that doesn't have its
  own key/value data coordinates, doesn't derive from \ref QCPAbstractPlottable1D. See the
  documentation there for details.
*/
/*! \내부의

  \ note이 메소드는 \ ref QCPAbstractPlottable1D :: getDataSegments와 동일하지만 꼭 필요합니다.
  \ ref QCPErrorBars plottable 이후로 여기에서 재현 한
  자체 키 / 값 데이터 좌표는 \ ref QCPAbstractPlottable1D에서 파생되지 않습니다. 자세한 내용은
  자세한 내용은 설명서를 참조하십시오.
*/
void QCPErrorBars::getDataSegments(QList<QCPDataRange> &selectedSegments, QList<QCPDataRange> &unselectedSegments) const
{
  selectedSegments.clear();
  unselectedSegments.clear();
  if (mSelectable == QCP::stWhole) 
// stWhole selection type draws the entire plottable with selected style if mSelection isn't empty
// stWhole 선택 유형은 mSelection이 비어 있지 않은 경우 선택한 스타일로 전체 플롯을 그립니다.
  {
    if (selected())
      selectedSegments << QCPDataRange(0, dataCount());
    else
      unselectedSegments << QCPDataRange(0, dataCount());
  } else
  {
    QCPDataSelection sel(selection());
    sel.simplify();
    selectedSegments = sel.dataRanges();
    unselectedSegments = sel.inverse(QCPDataRange(0, dataCount())).dataRanges();
  }
}

/*! \internal

  Returns whether the error bar at the specified \a index is visible within the current key axis
  range.

  This method assumes for performance reasons without checking that the key axis, the value axis,
  and the data plottable (\ref setDataPlottable) are not zero and that \a index is within valid
  bounds of this \ref QCPErrorBars instance and the bounds of the data plottable.
*/
/*! \내부의

  지정된 \ a 인덱스의 오류 막대가 현재 키 축에서 볼 수 있는지 여부를 반환합니다.
  범위.

  이 메서드는 성능상의 이유 때문에 키 축, 값 축,
  및 데이터 plottable (\ ref setDataPlottable)이 0이 아니고 해당 인덱스가 유효한 범위 내에 있음을 나타냅니다.
  이 \ ref QCPErrorBars 인스턴스의 범위와 데이터 plottable의 범위.
*/
bool QCPErrorBars::errorBarVisible(int index) const
{
  QPointF centerPixel = mDataPlottable->interface1D()->dataPixelPosition(index);
  const double centerKeyPixel = mKeyAxis->orientation() == Qt::Horizontal ? centerPixel.x() : centerPixel.y();
  if (qIsNaN(centerKeyPixel))
    return false;
  
  double keyMin, keyMax;
  if (mErrorType == etKeyError)
  {
    const double centerKey = mKeyAxis->pixelToCoord(centerKeyPixel);
    const double errorPlus = mDataContainer->at(index).errorPlus;
    const double errorMinus = mDataContainer->at(index).errorMinus;
    keyMax = centerKey+(qIsNaN(errorPlus) ? 0 : errorPlus);
    keyMin = centerKey-(qIsNaN(errorMinus) ? 0 : errorMinus);
  } else // mErrorType == etValueError
  {
    keyMax = mKeyAxis->pixelToCoord(centerKeyPixel+mWhiskerWidth*0.5*mKeyAxis->pixelOrientation());
    keyMin = mKeyAxis->pixelToCoord(centerKeyPixel-mWhiskerWidth*0.5*mKeyAxis->pixelOrientation());
  }
  return ((keyMax > mKeyAxis->range().lower) && (keyMin < mKeyAxis->range().upper));
}

/*! \internal

  Returns whether \a line intersects (or is contained in) \a pixelRect.

  \a line is assumed to be either perfectly horizontal or perfectly vertical, as is the case for
  error bar lines.
*/
/*! \내부의

  \ a 라인이 pixelRect와 교차하는지 (또는 그 안에 포함되는지)를 반환합니다.

  \ a 라인은 완전히 수평이거나 완전히 수직 인 것으로 가정합니다.
  오류 막대 줄.
*/
bool QCPErrorBars::rectIntersectsLine(const QRectF &pixelRect, const QLineF &line) const
{
  if (pixelRect.left() > line.x1() && pixelRect.left() > line.x2())
    return false;
  else if (pixelRect.right() < line.x1() && pixelRect.right() < line.x2())
    return false;
  else if (pixelRect.top() > line.y1() && pixelRect.top() > line.y2())
    return false;
  else if (pixelRect.bottom() < line.y1() && pixelRect.bottom() < line.y2())
    return false;
  else
    return true;
}
/* end of 'src/plottables/plottable-errorbar.cpp' */


/* including file 'src/items/item-straightline.cpp', size 7592               */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / plottables / plottable-errorbar.cpp'의 끝 */


/* 파일 'src / items / item-straightline.cpp', 크기 7592 포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPItemStraightLine
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPItemStraightLine
  \brief A straight line that spans infinitely in both directions

  \image html QCPItemStraightLine.png "Straight line example. Blue dotted circles are anchors, solid blue discs are positions."

  It has two positions, \a point1 and \a point2, which define the straight line.
*/
/*! \ class QCPItemStraightLine
  \ brief 양방향으로 무한히 뻗어있는 직선

  \ image html QCPItemStraightLine.png "직선의 예 : 파란색 점선 원은 앵커, 단색 파란색 디스크는 위치입니다."

  직선을 정의하는 두 개의 위치, \ a point1 및 \ a point2가 있습니다.
*/

/*!
  Creates a straight line item and sets default values.
  
  The created item is automatically registered with \a parentPlot. This QCustomPlot instance takes
  ownership of the item, so do not delete it manually but use QCustomPlot::removeItem() instead.
*/
/*!
  직선 항목을 만들고 기본값을 설정합니다.
  
  생성 된 항목은 parentPlot에 자동으로 등록됩니다. 이 QCustomPlot 인스턴스는
  아이템의 소유권이므로 수동으로 삭제하지 말고 대신 QCustomPlot :: removeItem ()을 사용하십시오.
*/
QCPItemStraightLine::QCPItemStraightLine(QCustomPlot *parentPlot) :
  QCPAbstractItem(parentPlot),
  point1(createPosition(QLatin1String("point1"))),
  point2(createPosition(QLatin1String("point2")))
{
  point1->setCoords(0, 0);
  point2->setCoords(1, 1);
  
  setPen(QPen(Qt::black));
  setSelectedPen(QPen(Qt::blue,2));
}

QCPItemStraightLine::~QCPItemStraightLine()
{
}

/*!
  Sets the pen that will be used to draw the line
  
  \see setSelectedPen
*/
/*!
  선 그리기에 사용할 펜을 설정합니다.
  
  \ setSelectedPen 참조
*/
void QCPItemStraightLine::setPen(const QPen &pen)
{
  mPen = pen;
}

/*!
  Sets the pen that will be used to draw the line when selected
  
  \see setPen, setSelected
*/
/*!
  선택한 경우 선을 그리는 데 사용할 펜을 설정합니다.
  
  \ setPen 참조, setSelected
*/
void QCPItemStraightLine::setSelectedPen(const QPen &pen)
{
  mSelectedPen = pen;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPItemStraightLine::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  Q_UNUSED(details)
  if (onlySelectable && !mSelectable)
    return -1;
  
  return QCPVector2D(pos).distanceToStraightLine(point1->pixelPosition(), point2->pixelPosition()-point1->pixelPosition());
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPItemStraightLine::draw(QCPPainter *painter)
{
  QCPVector2D start(point1->pixelPosition());
  QCPVector2D end(point2->pixelPosition());
  // get visible segment of straight line inside clipRect:
  // clipRect 안에 직선의 보이는 부분을 얻는다 :
  double clipPad = mainPen().widthF();
  QLineF line = getRectClippedStraightLine(start, end-start, clipRect().adjusted(-clipPad, -clipPad, clipPad, clipPad));
  // paint visible segment, if existent:
  // 존재하는 경우 보이는 세그먼트를 페인트 :
  if (!line.isNull())
  {
    painter->setPen(mainPen());
    painter->drawLine(line);
  }
}

/*! \internal

  Returns the section of the straight line defined by \a base and direction vector \a
  vec, that is visible in the specified \a rect.
  
  This is a helper function for \ref draw.
*/
/*! \내부의

  \ a에 의해 정의 된 직선의 단면을 반환하고 방향 벡터 \ a
  vec, 지정된 \ a rect에 표시됩니다.
  
  이것은 \ ref draw를위한 도우미 함수입니다.
*/
QLineF QCPItemStraightLine::getRectClippedStraightLine(const QCPVector2D &base, const QCPVector2D &vec, const QRect &rect) const
{
  double bx, by;
  double gamma;
  QLineF result;
  if (vec.x() == 0 && vec.y() == 0)
    return result;
  if (qFuzzyIsNull(vec.x())) // line is vertical
                             // 행이 수직 인 경우
  {
    // check top of rect:
    // rect of top 검색 :
    bx = rect.left();
    by = rect.top();
    gamma = base.x()-bx + (by-base.y())*vec.x()/vec.y();
    if (gamma >= 0 && gamma <= rect.width())
      result.setLine(bx+gamma, rect.top(), bx+gamma, rect.bottom()); 
    // no need to check bottom because we know line is vertical
    // 선이 수직이라는 것을 알고 있기 때문에 바닥을 확인할 필요가 없습니다.
  } else if (qFuzzyIsNull(vec.y())) // line is horizontal
                                    // 라인이 수평입니다.
  {
    // check left of rect:
    // rect 왼쪽의 체크 :
    bx = rect.left();
    by = rect.top();
    gamma = base.y()-by + (bx-base.x())*vec.y()/vec.x();
    if (gamma >= 0 && gamma <= rect.height())
      result.setLine(rect.left(), by+gamma, rect.right(), by+gamma); 
    // no need to check right because we know line is horizontal
    // 라인이 수평임을 알기 때문에 오른쪽으로 체크 할 필요가 없다.
  } else // line is skewed
         // 줄이 비뚤어졌습니다.
  {
    QList<QCPVector2D> pointVectors;
    // check top of rect:
    // rect of top 검색 :
    bx = rect.left();
    by = rect.top();
    gamma = base.x()-bx + (by-base.y())*vec.x()/vec.y();
    if (gamma >= 0 && gamma <= rect.width())
      pointVectors.append(QCPVector2D(bx+gamma, by));
    // check bottom of rect:
    // rect의 하단을 확인하십시오.
    bx = rect.left();
    by = rect.bottom();
    gamma = base.x()-bx + (by-base.y())*vec.x()/vec.y();
    if (gamma >= 0 && gamma <= rect.width())
      pointVectors.append(QCPVector2D(bx+gamma, by));
    // check left of rect:
    // rect 왼쪽의 체크 :
    bx = rect.left();
    by = rect.top();
    gamma = base.y()-by + (bx-base.x())*vec.y()/vec.x();
    if (gamma >= 0 && gamma <= rect.height())
      pointVectors.append(QCPVector2D(bx, by+gamma));
    // check right of rect:
    // rect의 오른쪽을 검사합니다.
    bx = rect.right();
    by = rect.top();
    gamma = base.y()-by + (bx-base.x())*vec.y()/vec.x();
    if (gamma >= 0 && gamma <= rect.height())
      pointVectors.append(QCPVector2D(bx, by+gamma));
    
    // evaluate points:
    // 포인트를 평가합니다.
    if (pointVectors.size() == 2)
    {
      result.setPoints(pointVectors.at(0).toPointF(), pointVectors.at(1).toPointF());
    } else if (pointVectors.size() > 2)
    {
// line probably goes through corner of rect, and we got two points there. single out the point pair with greatest distance:
// line은 아마도 rect의 구석을 통과 할 것이며, 우리는 거기에 두 개의 점을 얻습니다. 가장 먼 거리의 점 쌍을 하나씩 선택하십시오.
      double distSqrMax = 0;
      QCPVector2D pv1, pv2;
      for (int i=0; i<pointVectors.size()-1; ++i)
      {
        for (int k=i+1; k<pointVectors.size(); ++k)
        {
          double distSqr = (pointVectors.at(i)-pointVectors.at(k)).lengthSquared();
          if (distSqr > distSqrMax)
          {
            pv1 = pointVectors.at(i);
            pv2 = pointVectors.at(k);
            distSqrMax = distSqr;
          }
        }
      }
      result.setPoints(pv1.toPointF(), pv2.toPointF());
    }
  }
  return result;
}

/*! \internal

  Returns the pen that should be used for drawing lines. Returns mPen when the
  item is not selected and mSelectedPen when it is.
*/
/*! \내부의

  선 그리기에 사용해야하는 펜을 반환합니다. mPen을 반환하면
  항목이 선택되지 않았 으면 mSelectedPen이 선택됩니다.
*/
QPen QCPItemStraightLine::mainPen() const
{
  return mSelected ? mSelectedPen : mPen;
}
/* end of 'src/items/item-straightline.cpp' */


/* including file 'src/items/item-line.cpp', size 8498                       */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / items / item-straightline.cpp'의 끝 */


/* 'src / items / item-line.cpp'파일 포함, 크기 8498 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */


////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPItemLine
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPItemLine
  \brief A line from one point to another

  \image html QCPItemLine.png "Line example. Blue dotted circles are anchors, solid blue discs are positions."

  It has two positions, \a start and \a end, which define the end points of the line.
  
  With \ref setHead and \ref setTail you may set different line ending styles, e.g. to create an arrow.
*/
/*! \ class QCPItemLine
  \ brief 한 점에서 다른 점까지의 선

  \ image html QCPItemLine.png "줄 예 : 파란색 점선 원은 앵커, 단색 파란색 디스크는 위치입니다."

  행의 끝점을 정의하는 두 개의 위치, \ a start 및 \ end가 있습니다.
  
  \ ref setHead와 \ ref setTail을 사용하면 다른 줄 끝 스타일을 설정할 수 있습니다 (예 : 화살표 만들기).
*/

/*!
  Creates a line item and sets default values.
  
  The created item is automatically registered with \a parentPlot. This QCustomPlot instance takes
  ownership of the item, so do not delete it manually but use QCustomPlot::removeItem() instead.
*/
/*!
  광고 항목을 만들고 기본값을 설정합니다.
  
  생성 된 항목은 parentPlot에 자동으로 등록됩니다. 이 QCustomPlot 인스턴스는
  아이템의 소유권이므로 수동으로 삭제하지 말고 대신 QCustomPlot :: removeItem ()을 사용하십시오.
*/
QCPItemLine::QCPItemLine(QCustomPlot *parentPlot) :
  QCPAbstractItem(parentPlot),
  start(createPosition(QLatin1String("start"))),
  end(createPosition(QLatin1String("end")))
{
  start->setCoords(0, 0);
  end->setCoords(1, 1);
  
  setPen(QPen(Qt::black));
  setSelectedPen(QPen(Qt::blue,2));
}

QCPItemLine::~QCPItemLine()
{
}

/*!
  Sets the pen that will be used to draw the line
  
  \see setSelectedPen
*/
/*!
  선 그리기에 사용할 펜을 설정합니다.
  
  \ setSelectedPen 참조
*/
void QCPItemLine::setPen(const QPen &pen)
{
  mPen = pen;
}

/*!
  Sets the pen that will be used to draw the line when selected
  
  \see setPen, setSelected
*/
/*!
  선택한 경우 선을 그리는 데 사용할 펜을 설정합니다.
  
  \ setPen 참조, setSelected
*/
void QCPItemLine::setSelectedPen(const QPen &pen)
{
  mSelectedPen = pen;
}

/*!
  Sets the line ending style of the head. The head corresponds to the \a end position.
  
  Note that due to the overloaded QCPLineEnding constructor, you may directly specify
  a QCPLineEnding::EndingStyle here, e.g. \code setHead(QCPLineEnding::esSpikeArrow) \endcode
  
  \see setTail
*/
/*!
  머리의 줄 끝 스타일을 설정합니다. 머리는 \ a 끝 위치에 해당합니다.
  
  오버로드 된 QCPLineEnding 생성자로 인해 직접 지정한
  QCPLineEnding :: EndingStyle 예 : \ code setHead (QCPLineEnding :: esSpikeArrow) \ endcode
  
  \ see setTail
*/
void QCPItemLine::setHead(const QCPLineEnding &head)
{
  mHead = head;
}

/*!
  Sets the line ending style of the tail. The tail corresponds to the \a start position.
  
  Note that due to the overloaded QCPLineEnding constructor, you may directly specify
  a QCPLineEnding::EndingStyle here, e.g. \code setTail(QCPLineEnding::esSpikeArrow) \endcode
  
  \see setHead
*/

/*!
  꼬리의 줄 끝 스타일을 설정합니다. 꼬리는 \ a 시작 위치에 해당합니다.
  
  오버로드 된 QCPLineEnding 생성자로 인해 직접 지정한
  QCPLineEnding :: EndingStyle 예 : \ code setTail (QCPLineEnding :: esSpikeArrow) \ endcode
  
  \ see setHead
*/
void QCPItemLine::setTail(const QCPLineEnding &tail)
{
  mTail = tail;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */ 
double QCPItemLine::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  Q_UNUSED(details)
  if (onlySelectable && !mSelectable)
    return -1;
  
  return qSqrt(QCPVector2D(pos).distanceSquaredToLine(start->pixelPosition(), end->pixelPosition()));
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPItemLine::draw(QCPPainter *painter)
{
  QCPVector2D startVec(start->pixelPosition());
  QCPVector2D endVec(end->pixelPosition());
  if (qFuzzyIsNull((startVec-endVec).lengthSquared()))
    return;
  // get visible segment of straight line inside clipRect:
  // clipRect 안에 직선의 보이는 부분을 얻는다 :
  double clipPad = qMax(mHead.boundingDistance(), mTail.boundingDistance());
  clipPad = qMax(clipPad, (double)mainPen().widthF());
  QLineF line = getRectClippedLine(startVec, endVec, clipRect().adjusted(-clipPad, -clipPad, clipPad, clipPad));
  // paint visible segment, if existent:
  // 존재하는 경우 보이는 세그먼트를 페인트 :
  if (!line.isNull())
  {
    painter->setPen(mainPen());
    painter->drawLine(line);
    painter->setBrush(Qt::SolidPattern);
    if (mTail.style() != QCPLineEnding::esNone)
      mTail.draw(painter, startVec, startVec-endVec);
    if (mHead.style() != QCPLineEnding::esNone)
      mHead.draw(painter, endVec, endVec-startVec);
  }
}

/*! \internal

  Returns the section of the line defined by \a start and \a end, that is visible in the specified
  \a rect.
  
  This is a helper function for \ref draw.
*/

/*! \내부의

  \ a start 및 \ a end로 정의 된 행의 섹션을 반환합니다.이 섹션은 지정된
  \ a rect.
  
  이것은 \ ref draw를위한 도우미 함수입니다.
*/
QLineF QCPItemLine::getRectClippedLine(const QCPVector2D &start, const QCPVector2D &end, const QRect &rect) const
{
  bool containsStart = rect.contains(start.x(), start.y());
  bool containsEnd = rect.contains(end.x(), end.y());
  if (containsStart && containsEnd)
    return QLineF(start.toPointF(), end.toPointF());
  
  QCPVector2D base = start;
  QCPVector2D vec = end-start;
  double bx, by;
  double gamma, mu;
  QLineF result;
  QList<QCPVector2D> pointVectors;

  if (!qFuzzyIsNull(vec.y())) // line is not horizontal
                              // line이 가로가 아닙니다.
  {
    // check top of rect:
    // rect of top 검색 :
    bx = rect.left();
    by = rect.top();
    mu = (by-base.y())/vec.y();
    if (mu >= 0 && mu <= 1)
    {
      gamma = base.x()-bx + mu*vec.x();
      if (gamma >= 0 && gamma <= rect.width())
        pointVectors.append(QCPVector2D(bx+gamma, by));
    }
    // check bottom of rect:
    // rect의 하단을 확인하십시오.
    bx = rect.left();
    by = rect.bottom();
    mu = (by-base.y())/vec.y();
    if (mu >= 0 && mu <= 1)
    {
      gamma = base.x()-bx + mu*vec.x();
      if (gamma >= 0 && gamma <= rect.width())
        pointVectors.append(QCPVector2D(bx+gamma, by));
    }
  }
  if (!qFuzzyIsNull(vec.x())) // line is not vertical
                              // line이 수직이 아닙니다.
  {
    // check left of rect:
    // rect 왼쪽의 체크 :
    bx = rect.left();
    by = rect.top();
    mu = (bx-base.x())/vec.x();
    if (mu >= 0 && mu <= 1)
    {
      gamma = base.y()-by + mu*vec.y();
      if (gamma >= 0 && gamma <= rect.height())
        pointVectors.append(QCPVector2D(bx, by+gamma));
    }
    // check right of rect:
    // rect의 오른쪽을 검사합니다.
    bx = rect.right();
    by = rect.top();
    mu = (bx-base.x())/vec.x();
    if (mu >= 0 && mu <= 1)
    {
      gamma = base.y()-by + mu*vec.y();
      if (gamma >= 0 && gamma <= rect.height())
        pointVectors.append(QCPVector2D(bx, by+gamma));
    }
  }
  
  if (containsStart)
    pointVectors.append(start);
  if (containsEnd)
    pointVectors.append(end);
  
  // evaluate points:
  // 포인트를 평가합니다.
  if (pointVectors.size() == 2)
  {
    result.setPoints(pointVectors.at(0).toPointF(), pointVectors.at(1).toPointF());
  } else if (pointVectors.size() > 2)
  {
  // line probably goes through corner of rect, and we got two points there. single out the point pair with greatest distance:
// line은 아마도 rect의 구석을 통과 할 것이며, 우리는 거기에 두 개의 점을 얻습니다. 가장 먼 거리의 점 쌍을 하나씩 선택하십시오.
    double distSqrMax = 0;
    QCPVector2D pv1, pv2;
    for (int i=0; i<pointVectors.size()-1; ++i)
    {
      for (int k=i+1; k<pointVectors.size(); ++k)
      {
        double distSqr = (pointVectors.at(i)-pointVectors.at(k)).lengthSquared();
        if (distSqr > distSqrMax)
        {
          pv1 = pointVectors.at(i);
          pv2 = pointVectors.at(k);
          distSqrMax = distSqr;
        }
      }
    }
    result.setPoints(pv1.toPointF(), pv2.toPointF());
  }
  return result;
}

/*! \internal

  Returns the pen that should be used for drawing lines. Returns mPen when the
  item is not selected and mSelectedPen when it is.
*/
/*! \내부의

  선 그리기에 사용해야하는 펜을 반환합니다. mPen을 반환하면
  항목이 선택되지 않았 으면 mSelectedPen이 선택됩니다.
*/
QPen QCPItemLine::mainPen() const
{
  return mSelected ? mSelectedPen : mPen;
}
/* end of 'src/items/item-line.cpp' */


/* including file 'src/items/item-curve.cpp', size 7159                      */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / items / item-line.cpp'의 끝 */


/* 파일 'src / items / item-curve.cpp', 크기 7159 포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPItemCurve
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPItemCurve
  \brief A curved line from one point to another

  \image html QCPItemCurve.png "Curve example. Blue dotted circles are anchors, solid blue discs are positions."

  It has four positions, \a start and \a end, which define the end points of the line, and two
  control points which define the direction the line exits from the start and the direction from
  which it approaches the end: \a startDir and \a endDir.
  
  With \ref setHead and \ref setTail you may set different line ending styles, e.g. to create an
  arrow.
  
  Often it is desirable for the control points to stay at fixed relative positions to the start/end
  point. This can be achieved by setting the parent anchor e.g. of \a startDir simply to \a start,
  and then specify the desired pixel offset with QCPItemPosition::setCoords on \a startDir.
*/
/*! \ class QCPItemCurve
  \ brief 한 지점에서 다른 지점으로가는 곡선

  \ image html QCPItemCurve.png "곡선 예 파란색 점선 원은 앵커, 단색 파란색 디스크는 위치입니다."

  그것은 네 개의 위치, \ a 시작과 \ end, 라인의 끝점을 정의하고, 두 개
  선이 시작과 끝에서 나오는 방향을 정의하는 제어점
  \ endDir \ a startDir 및 \ endDir에 접근합니다.
  
  \ ref setHead와 \ ref setTail을 사용하면 다른 줄 끝 스타일을 설정할 수 있습니다.
  화살.
  
  종종 제어점이 시작 / 끝의 고정 된 상대 위치에 머무르는 것이 바람직합니다
  포인트. 이것은 상위 앵커를 \ a startDir로 간단히 \ a start로 설정하고,
  \ startDir에 QCPItemPosition :: setCoords를 사용하여 원하는 픽셀 오프셋을 지정하십시오.
*/

/*!
  Creates a curve item and sets default values.
  
  The created item is automatically registered with \a parentPlot. This QCustomPlot instance takes
  ownership of the item, so do not delete it manually but use QCustomPlot::removeItem() instead.
*/
/*!
  커브 항목을 만들고 기본값을 설정합니다.
  
  생성 된 항목은 parentPlot에 자동으로 등록됩니다. 이 QCustomPlot 인스턴스는
  아이템의 소유권이므로 수동으로 삭제하지 말고 대신 QCustomPlot :: removeItem ()을 사용하십시오.
*/
QCPItemCurve::QCPItemCurve(QCustomPlot *parentPlot) :
  QCPAbstractItem(parentPlot),
  start(createPosition(QLatin1String("start"))),
  startDir(createPosition(QLatin1String("startDir"))),
  endDir(createPosition(QLatin1String("endDir"))),
  end(createPosition(QLatin1String("end")))
{
  start->setCoords(0, 0);
  startDir->setCoords(0.5, 0);
  endDir->setCoords(0, 0.5);
  end->setCoords(1, 1);
  
  setPen(QPen(Qt::black));
  setSelectedPen(QPen(Qt::blue,2));
}

QCPItemCurve::~QCPItemCurve()
{
}

/*!
  Sets the pen that will be used to draw the line
  
  \see setSelectedPen
*/
/*!
  선 그리기에 사용할 펜을 설정합니다.
  
  \ setSelectedPen 참조
*/
void QCPItemCurve::setPen(const QPen &pen)
{
  mPen = pen;
}

/*!
  Sets the pen that will be used to draw the line when selected
  
  \see setPen, setSelected
*/
/*!
  선택한 경우 선을 그리는 데 사용할 펜을 설정합니다.
  
  \ setPen 참조, setSelected
*/
void QCPItemCurve::setSelectedPen(const QPen &pen)
{
  mSelectedPen = pen;
}

/*!
  Sets the line ending style of the head. The head corresponds to the \a end position.
  
  Note that due to the overloaded QCPLineEnding constructor, you may directly specify
  a QCPLineEnding::EndingStyle here, e.g. \code setHead(QCPLineEnding::esSpikeArrow) \endcode
  
  \see setTail
*/
/*!
  머리의 줄 끝 스타일을 설정합니다. 머리는 \ a 끝 위치에 해당합니다.
  
  오버로드 된 QCPLineEnding 생성자로 인해 직접 지정한
  QCPLineEnding :: EndingStyle 예 : \ code setHead (QCPLineEnding :: esSpikeArrow) \ endcode
  
  \ see setTail
*/
void QCPItemCurve::setHead(const QCPLineEnding &head)
{
  mHead = head;
}

/*!
  Sets the line ending style of the tail. The tail corresponds to the \a start position.
  
  Note that due to the overloaded QCPLineEnding constructor, you may directly specify
  a QCPLineEnding::EndingStyle here, e.g. \code setTail(QCPLineEnding::esSpikeArrow) \endcode
  
  \see setHead
*/
/*!
  꼬리의 줄 끝 스타일을 설정합니다. 꼬리는 \ a 시작 위치에 해당합니다.
  
  오버로드 된 QCPLineEnding 생성자로 인해 직접 지정한
  QCPLineEnding :: EndingStyle 예 : \ code setTail (QCPLineEnding :: esSpikeArrow) \ endcode
  
  \ see setHead
*/
void QCPItemCurve::setTail(const QCPLineEnding &tail)
{
  mTail = tail;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPItemCurve::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  Q_UNUSED(details)
  if (onlySelectable && !mSelectable)
    return -1;
  
  QPointF startVec(start->pixelPosition());
  QPointF startDirVec(startDir->pixelPosition());
  QPointF endDirVec(endDir->pixelPosition());
  QPointF endVec(end->pixelPosition());

  QPainterPath cubicPath(startVec);
  cubicPath.cubicTo(startDirVec, endDirVec, endVec);
  
  QPolygonF polygon = cubicPath.toSubpathPolygons().first();
  QCPVector2D p(pos);
  double minDistSqr = std::numeric_limits<double>::max();
  for (int i=1; i<polygon.size(); ++i)
  {
    double distSqr = p.distanceSquaredToLine(polygon.at(i-1), polygon.at(i));
    if (distSqr < minDistSqr)
      minDistSqr = distSqr;
  }
  return qSqrt(minDistSqr);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPItemCurve::draw(QCPPainter *painter)
{
  QCPVector2D startVec(start->pixelPosition());
  QCPVector2D startDirVec(startDir->pixelPosition());
  QCPVector2D endDirVec(endDir->pixelPosition());
  QCPVector2D endVec(end->pixelPosition());
  if ((endVec-startVec).length() > 1e10) // too large curves cause crash
                                         // 너무 큰 커브로 인해 충돌이 발생합니다.
    return;

  QPainterPath cubicPath(startVec.toPointF());
  cubicPath.cubicTo(startDirVec.toPointF(), endDirVec.toPointF(), endVec.toPointF());

  // paint visible segment, if existent:
  // 존재하는 경우 보이는 세그먼트를 페인트 :
  QRect clip = clipRect().adjusted(-mainPen().widthF(), -mainPen().widthF(), mainPen().widthF(), mainPen().widthF());
  QRect cubicRect = cubicPath.controlPointRect().toRect();
  if (cubicRect.isEmpty()) // may happen when start and end exactly on same x or y position
                           // 동일한 x 또는 y 위치에서 시작 및 끝낼 때 발생할 수 있습니다.
    cubicRect.adjust(0, 0, 1, 1);
  if (clip.intersects(cubicRect))
  {
    painter->setPen(mainPen());
    painter->drawPath(cubicPath);
    painter->setBrush(Qt::SolidPattern);
    if (mTail.style() != QCPLineEnding::esNone)
      mTail.draw(painter, startVec, M_PI-cubicPath.angleAtPercent(0)/180.0*M_PI);
    if (mHead.style() != QCPLineEnding::esNone)
      mHead.draw(painter, endVec, -cubicPath.angleAtPercent(1)/180.0*M_PI);
  }
}

/*! \internal

  Returns the pen that should be used for drawing lines. Returns mPen when the
  item is not selected and mSelectedPen when it is.
*/
/*! \내부의

  선 그리기에 사용해야하는 펜을 반환합니다. mPen을 반환하면
  항목이 선택되지 않았 으면 mSelectedPen이 선택됩니다.
*/
QPen QCPItemCurve::mainPen() const
{
  return mSelected ? mSelectedPen : mPen;
}
/* end of 'src/items/item-curve.cpp' */


/* including file 'src/items/item-rect.cpp', size 6479                       */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / items / item-curve.cpp'의 끝 */


/* 파일 'src / items / item-rect.cpp', 크기 6479 포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPItemRect
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPItemRect
  \brief A rectangle

  \image html QCPItemRect.png "Rectangle example. Blue dotted circles are anchors, solid blue discs are positions."

  It has two positions, \a topLeft and \a bottomRight, which define the rectangle.
*/
/*! \ class QCPItemRect
  \ brief 직사각형

  \ image html QCPItemRect.png "직사각형의 예 : 파란색 점선 원은 앵커, 단색 파란색 디스크는 위치입니다."

  사각형을 정의하는 두 개의 위치, \ a topLeft 및 \ a bottomRight가 있습니다.
*/

/*!
  Creates a rectangle item and sets default values.
  
  The created item is automatically registered with \a parentPlot. This QCustomPlot instance takes
  ownership of the item, so do not delete it manually but use QCustomPlot::removeItem() instead.
*/
/*!
  사각형 항목을 만들고 기본값을 설정합니다.
  
  생성 된 항목은 parentPlot에 자동으로 등록됩니다. 이 QCustomPlot 인스턴스는
  아이템의 소유권이므로 수동으로 삭제하지 말고 대신 QCustomPlot :: removeItem ()을 사용하십시오.
*/
QCPItemRect::QCPItemRect(QCustomPlot *parentPlot) :
  QCPAbstractItem(parentPlot),
  topLeft(createPosition(QLatin1String("topLeft"))),
  bottomRight(createPosition(QLatin1String("bottomRight"))),
  top(createAnchor(QLatin1String("top"), aiTop)),
  topRight(createAnchor(QLatin1String("topRight"), aiTopRight)),
  right(createAnchor(QLatin1String("right"), aiRight)),
  bottom(createAnchor(QLatin1String("bottom"), aiBottom)),
  bottomLeft(createAnchor(QLatin1String("bottomLeft"), aiBottomLeft)),
  left(createAnchor(QLatin1String("left"), aiLeft))
{
  topLeft->setCoords(0, 1);
  bottomRight->setCoords(1, 0);
  
  setPen(QPen(Qt::black));
  setSelectedPen(QPen(Qt::blue,2));
  setBrush(Qt::NoBrush);
  setSelectedBrush(Qt::NoBrush);
}

QCPItemRect::~QCPItemRect()
{
}

/*!
  Sets the pen that will be used to draw the line of the rectangle
  
  \see setSelectedPen, setBrush
*/
/*!
  직사각형의 선을 그릴 때 사용할 펜을 설정합니다.
  
  \ setSelectedPen 참조, setBrush
*/
void QCPItemRect::setPen(const QPen &pen)
{
  mPen = pen;
}

/*!
  Sets the pen that will be used to draw the line of the rectangle when selected
  
  \see setPen, setSelected
*/
/*!
  선택시 사각형의 선을 그릴 때 사용할 펜을 설정합니다.
  
  \ setPen 참조, setSelected
*/
void QCPItemRect::setSelectedPen(const QPen &pen)
{
  mSelectedPen = pen;
}

/*!
  Sets the brush that will be used to fill the rectangle. To disable filling, set \a brush to
  Qt::NoBrush.
  
  \see setSelectedBrush, setPen
*/
/*!
  사각형을 채우는 데 사용할 브러시를 설정합니다. 채우기를 사용하지 않으려면 브러시를 다음으로 설정하십시오.
  Qt :: NoBrush.
  
  \ setSelectedBrush, setPen을 참조하십시오.
*/
void QCPItemRect::setBrush(const QBrush &brush)
{
  mBrush = brush;
}

/*!
  Sets the brush that will be used to fill the rectangle when selected. To disable filling, set \a
  brush to Qt::NoBrush.
  
  \see setBrush
*/
/*!
  선택시 사각형을 채우는 데 사용할 브러시를 설정합니다. 채우기를 사용 중지하려면 \ a
  Qt :: NoBrush로 브러쉬.
  
  \ setBrush를 참조하십시오.
*/
void QCPItemRect::setSelectedBrush(const QBrush &brush)
{
  mSelectedBrush = brush;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPItemRect::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  Q_UNUSED(details)
  if (onlySelectable && !mSelectable)
    return -1;
  
  QRectF rect = QRectF(topLeft->pixelPosition(), bottomRight->pixelPosition()).normalized();
  bool filledRect = mBrush.style() != Qt::NoBrush && mBrush.color().alpha() != 0;
  return rectDistance(rect, pos, filledRect);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPItemRect::draw(QCPPainter *painter)
{
  QPointF p1 = topLeft->pixelPosition();
  QPointF p2 = bottomRight->pixelPosition();
  if (p1.toPoint() == p2.toPoint())
    return;
  QRectF rect = QRectF(p1, p2).normalized();
  double clipPad = mainPen().widthF();
  QRectF boundingRect = rect.adjusted(-clipPad, -clipPad, clipPad, clipPad);
  if (boundingRect.intersects(clipRect())) // only draw if bounding rect of rect item is visible in cliprect
                                           // rect item의 경계 rect가 cliprect에 표시되는 경우에만 그리기
  {
    painter->setPen(mainPen());
    painter->setBrush(mainBrush());
    painter->drawRect(rect);
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QPointF QCPItemRect::anchorPixelPosition(int anchorId) const
{
  QRectF rect = QRectF(topLeft->pixelPosition(), bottomRight->pixelPosition());
  switch (anchorId)
  {
    case aiTop:         return (rect.topLeft()+rect.topRight())*0.5;
    case aiTopRight:    return rect.topRight();
    case aiRight:       return (rect.topRight()+rect.bottomRight())*0.5;
    case aiBottom:      return (rect.bottomLeft()+rect.bottomRight())*0.5;
    case aiBottomLeft:  return rect.bottomLeft();
    case aiLeft:        return (rect.topLeft()+rect.bottomLeft())*0.5;
  }
  
  qDebug() << Q_FUNC_INFO << "invalid anchorId" << anchorId;
  return QPointF();
}

/*! \internal

  Returns the pen that should be used for drawing lines. Returns mPen when the item is not selected
  and mSelectedPen when it is.
*/
/*! \내부의

  선 그리기에 사용해야하는 펜을 반환합니다. 항목이 선택되지 않은 경우 mPen을 반환합니다.
  및 mSelectedPen 때.
*/
QPen QCPItemRect::mainPen() const
{
  return mSelected ? mSelectedPen : mPen;
}

/*! \internal

  Returns the brush that should be used for drawing fills of the item. Returns mBrush when the item
  is not selected and mSelectedBrush when it is.
*/
/*! \내부의

  항목의 칠을 그리는 데 사용해야하는 브러시를 반환합니다. 항목이 나타날 때 mBrush를 반환합니다.
  선택되어 있지 않으면 mSelectedBrush가 선택됩니다.
*/
QBrush QCPItemRect::mainBrush() const
{
  return mSelected ? mSelectedBrush : mBrush;
}
/* end of 'src/items/item-rect.cpp' */


/* including file 'src/items/item-text.cpp', size 13338                      */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / items / item-rect.cpp'의 끝 */


/* 파일 'src / items / item-text.cpp'포함, 크기 13338 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPItemText
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPItemText
  \brief A text label

  \image html QCPItemText.png "Text example. Blue dotted circles are anchors, solid blue discs are positions."

  Its position is defined by the member \a position and the setting of \ref setPositionAlignment.
  The latter controls which part of the text rect shall be aligned with \a position.
  
  The text alignment itself (i.e. left, center, right) can be controlled with \ref
  setTextAlignment.
  
  The text may be rotated around the \a position point with \ref setRotation.
*/
/*! \ class QCPItemText
  \ brief 텍스트 레이블

  \ image html QCPItemText.png "텍스트 예제. 파란색 점선 원은 앵커, 단색 파란색 디스크는 위치입니다."

  위치는 멤버 \ a 위치와 \ ref setPositionAlignment의 설정에 의해 정의됩니다.
  후자는 텍스트 입력란의 어느 부분이 \ a 위치에 정렬되는지를 제어합니다.
  
  텍스트 정렬 자체 (즉, 왼쪽, 가운데, 오른쪽)는 \ ref로 제어 할 수 있습니다.
  setTextAlignment.
  
  텍스트는 \ ref setRotation을 사용하여 \ a 위치 점을 중심으로 회전 할 수 있습니다.
*/

/*!
  Creates a text item and sets default values.
  
  The created item is automatically registered with \a parentPlot. This QCustomPlot instance takes
  ownership of the item, so do not delete it manually but use QCustomPlot::removeItem() instead.
*/
/*!
  텍스트 항목을 만들고 기본값을 설정합니다.
  
  생성 된 항목은 parentPlot에 자동으로 등록됩니다. 이 QCustomPlot 인스턴스는
  아이템의 소유권이므로 수동으로 삭제하지 말고 대신 QCustomPlot :: removeItem ()을 사용하십시오.
*/
QCPItemText::QCPItemText(QCustomPlot *parentPlot) :
  QCPAbstractItem(parentPlot),
  position(createPosition(QLatin1String("position"))),
  topLeft(createAnchor(QLatin1String("topLeft"), aiTopLeft)),
  top(createAnchor(QLatin1String("top"), aiTop)),
  topRight(createAnchor(QLatin1String("topRight"), aiTopRight)),
  right(createAnchor(QLatin1String("right"), aiRight)),
  bottomRight(createAnchor(QLatin1String("bottomRight"), aiBottomRight)),
  bottom(createAnchor(QLatin1String("bottom"), aiBottom)),
  bottomLeft(createAnchor(QLatin1String("bottomLeft"), aiBottomLeft)),
  left(createAnchor(QLatin1String("left"), aiLeft)),
  mText(QLatin1String("text")),
  mPositionAlignment(Qt::AlignCenter),
  mTextAlignment(Qt::AlignTop|Qt::AlignHCenter),
  mRotation(0)
{
  position->setCoords(0, 0);
  
  setPen(Qt::NoPen);
  setSelectedPen(Qt::NoPen);
  setBrush(Qt::NoBrush);
  setSelectedBrush(Qt::NoBrush);
  setColor(Qt::black);
  setSelectedColor(Qt::blue);
}

QCPItemText::~QCPItemText()
{
}

/*!
  Sets the color of the text.
*/
/*!
  텍스트의 색을 설정합니다.
*/
void QCPItemText::setColor(const QColor &color)
{
  mColor = color;
}

/*!
  Sets the color of the text that will be used when the item is selected.
*/
/*!
  항목을 선택할 때 사용할 텍스트의 색을 설정합니다.
*/
void QCPItemText::setSelectedColor(const QColor &color)
{
  mSelectedColor = color;
}

/*!
  Sets the pen that will be used do draw a rectangular border around the text. To disable the
  border, set \a pen to Qt::NoPen.
  
  \see setSelectedPen, setBrush, setPadding
*/
/*!
  텍스트 주위에 직사각형 테두리를 그리는 데 사용할 펜을 설정합니다. 해당 기능을 사용하지 않으려면
  펜을 Qt :: NoPen으로 설정하십시오.
  
  \ setSelectedPen, setBrush, setPadding을 참조하십시오.
*/
void QCPItemText::setPen(const QPen &pen)
{
  mPen = pen;
}

/*!
  Sets the pen that will be used do draw a rectangular border around the text, when the item is
  selected. To disable the border, set \a pen to Qt::NoPen.
  
  \see setPen
*/
/*!
  항목을 사용할 때 텍스트 주위에 직사각형 테두리를 그리는 데 사용할 펜을 설정합니다.
  선택된. 테두리를 비활성화하려면 펜을 Qt :: NoPen으로 설정하십시오.
  
  \ see setPen
*/
void QCPItemText::setSelectedPen(const QPen &pen)
{
  mSelectedPen = pen;
}

/*!
  Sets the brush that will be used do fill the background of the text. To disable the
  background, set \a brush to Qt::NoBrush.
  
  \see setSelectedBrush, setPen, setPadding
*/
/*!
  텍스트의 백그라운드를 칠하는 데 사용할 브러시를 설정합니다. 해당 기능을 사용하지 않으려면
  배경, 브러시를 Qt :: NoBrush로 설정하십시오.
  
  \ setSelectedBrush, setPen, setPadding을 참조하십시오.
*/
void QCPItemText::setBrush(const QBrush &brush)
{
  mBrush = brush;
}

/*!
  Sets the brush that will be used do fill the background of the text, when the item is selected. To disable the
  background, set \a brush to Qt::NoBrush.
  
  \see setBrush
*/
/*!
  항목을 선택하면 사용할 브러쉬를 설정하여 텍스트의 배경을 채 웁니다. 해당 기능을 사용하지 않으려면
  배경, 브러시를 Qt :: NoBrush로 설정하십시오.
  
  \ setBrush를 참조하십시오.
*/
void QCPItemText::setSelectedBrush(const QBrush &brush)
{
  mSelectedBrush = brush;
}

/*!
  Sets the font of the text.
  
  \see setSelectedFont, setColor
*/
/*!
  텍스트의 글꼴을 설정합니다.
  
  \ setSelectedFont 참조, setColor
*/
void QCPItemText::setFont(const QFont &font)
{
  mFont = font;
}

/*!
  Sets the font of the text that will be used when the item is selected.
  
  \see setFont
*/
/*!
  항목을 선택할 때 사용할 텍스트의 글꼴을 설정합니다.
  
  \ see setFont
*/
void QCPItemText::setSelectedFont(const QFont &font)
{
  mSelectedFont = font;
}

/*!
  Sets the text that will be displayed. Multi-line texts are supported by inserting a line break
  character, e.g. '\n'.
  
  \see setFont, setColor, setTextAlignment
*/
/*!
  표시 할 텍스트를 설정합니다. 여러 줄 텍스트는 줄 바꿈을 삽입하여 지원됩니다.
  문자 (예 : '\ n').
  
  \ setFont, setColor, setTextAlignment를 참조하십시오.
*/
void QCPItemText::setText(const QString &text)
{
  mText = text;
}

/*!
  Sets which point of the text rect shall be aligned with \a position.
  
  Examples:
  \li If \a alignment is <tt>Qt::AlignHCenter | Qt::AlignTop</tt>, the text will be positioned such
  that the top of the text rect will be horizontally centered on \a position.
  \li If \a alignment is <tt>Qt::AlignLeft | Qt::AlignBottom</tt>, \a position will indicate the
  bottom left corner of the text rect.
  
  If you want to control the alignment of (multi-lined) text within the text rect, use \ref
  setTextAlignment.
*/
/*!
  텍스트의 구석의 점을 \ a의 위치에 가지도록 설정합니다.
  
  예 :
  \ li 정렬이 <tt> 인 경우 Qt :: AlignHCenter | Qt :: AlignTop </ tt>을 선택하면 텍스트가
  텍스트 직사각형의 맨 위가 수평으로 가운데에 배치됩니다.
  \ li 정렬이 <tt> 인 경우 Qt :: AlignLeft | Qt :: AlignBottom </ tt>, \ a 위치는
  텍스트 rect의 왼쪽 하단 모서리.
  
  text rect 내에서 (여러 줄의) 텍스트의 정렬을 제어하려면 \ ref를 사용하십시오
  setTextAlignment.
*/
void QCPItemText::setPositionAlignment(Qt::Alignment alignment)
{
  mPositionAlignment = alignment;
}

/*!
  Controls how (multi-lined) text is aligned inside the text rect (typically Qt::AlignLeft, Qt::AlignCenter or Qt::AlignRight).
*/
/*!
  Qt :: AlignLeft, Qt :: AlignCenter 또는 Qt :: AlignRight 등의 텍스트 정렬 방법을 여러 줄로 정렬하는 방법을 제어합니다.
*/
void QCPItemText::setTextAlignment(Qt::Alignment alignment)
{
  mTextAlignment = alignment;
}

/*!
  Sets the angle in degrees by which the text (and the text rectangle, if visible) will be rotated
  around \a position.
*/
/*!
  텍스트 (및 표시되는 경우 텍스트 사각형)가 회전되는 각도 (도)를 설정합니다.
  \ a 위치 주위에.
*/
void QCPItemText::setRotation(double degrees)
{
  mRotation = degrees;
}

/*!
  Sets the distance between the border of the text rectangle and the text. The appearance (and
  visibility) of the text rectangle can be controlled with \ref setPen and \ref setBrush.
*/
/*!
  텍스트 구형의 경계와 텍스트의 간격을 설정합니다. 외관 (및
  가시성)은 \ ref setPen과 \ ref setBrush로 제어 할 수 있습니다.
*/
void QCPItemText::setPadding(const QMargins &padding)
{
  mPadding = padding;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPItemText::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  Q_UNUSED(details)
  if (onlySelectable && !mSelectable)
    return -1;
  
  // The rect may be rotated, so we transform the actual clicked pos to the rotated
  // coordinate system, so we can use the normal rectDistance function for non-rotated rects:
  // rect는 회전 될 수 있으므로 실제 클릭 된 위치가 회전 된 것으로 변환됩니다.
  // 좌표계이므로 회전되지 않은 rect에는 일반적인 rectDistance 함수를 사용할 수 있습니다.
  QPointF positionPixels(position->pixelPosition());
  QTransform inputTransform;
  inputTransform.translate(positionPixels.x(), positionPixels.y());
  inputTransform.rotate(-mRotation);
  inputTransform.translate(-positionPixels.x(), -positionPixels.y());
  QPointF rotatedPos = inputTransform.map(pos);
  QFontMetrics fontMetrics(mFont);
  QRect textRect = fontMetrics.boundingRect(0, 0, 0, 0, Qt::TextDontClip|mTextAlignment, mText);
  QRect textBoxRect = textRect.adjusted(-mPadding.left(), -mPadding.top(), mPadding.right(), mPadding.bottom());
  QPointF textPos = getTextDrawPoint(positionPixels, textBoxRect, mPositionAlignment);
  textBoxRect.moveTopLeft(textPos.toPoint());

  return rectDistance(textBoxRect, rotatedPos, true);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */

void QCPItemText::draw(QCPPainter *painter)
{
  QPointF pos(position->pixelPosition());
  QTransform transform = painter->transform();
  transform.translate(pos.x(), pos.y());
  if (!qFuzzyIsNull(mRotation))
    transform.rotate(mRotation);
  painter->setFont(mainFont());
  QRect textRect = painter->fontMetrics().boundingRect(0, 0, 0, 0, Qt::TextDontClip|mTextAlignment, mText);
  QRect textBoxRect = textRect.adjusted(-mPadding.left(), -mPadding.top(), mPadding.right(), mPadding.bottom());
  QPointF textPos = getTextDrawPoint(QPointF(0, 0), textBoxRect, mPositionAlignment); 
// 0, 0 because the transform does the translation
// 변환을 수행하기 때문에 // 0, 0
  textRect.moveTopLeft(textPos.toPoint()+QPoint(mPadding.left(), mPadding.top()));
  textBoxRect.moveTopLeft(textPos.toPoint());
  double clipPad = mainPen().widthF();
  QRect boundingRect = textBoxRect.adjusted(-clipPad, -clipPad, clipPad, clipPad);
  if (transform.mapRect(boundingRect).intersects(painter->transform().mapRect(clipRect())))
  {
    painter->setTransform(transform);
    if ((mainBrush().style() != Qt::NoBrush && mainBrush().color().alpha() != 0) ||
        (mainPen().style() != Qt::NoPen && mainPen().color().alpha() != 0))
    {
      painter->setPen(mainPen());
      painter->setBrush(mainBrush());
      painter->drawRect(textBoxRect);
    }
    painter->setBrush(Qt::NoBrush);
    painter->setPen(QPen(mainColor()));
    painter->drawText(textRect, Qt::TextDontClip|mTextAlignment, mText);
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QPointF QCPItemText::anchorPixelPosition(int anchorId) const
{
  // get actual rect points (pretty much copied from draw function):
  // 실제 직사각형 점을 얻습니다 (draw 함수에서 꽤 많이 복사 됨).
  QPointF pos(position->pixelPosition());
  QTransform transform;
  transform.translate(pos.x(), pos.y());
  if (!qFuzzyIsNull(mRotation))
    transform.rotate(mRotation);
  QFontMetrics fontMetrics(mainFont());
  QRect textRect = fontMetrics.boundingRect(0, 0, 0, 0, Qt::TextDontClip|mTextAlignment, mText);
  QRectF textBoxRect = textRect.adjusted(-mPadding.left(), -mPadding.top(), mPadding.right(), mPadding.bottom());
  QPointF textPos = getTextDrawPoint(QPointF(0, 0), textBoxRect, mPositionAlignment); 
// 0, 0 because the transform does the translation
// 변환을 수행하기 때문에 // 0, 0
  textBoxRect.moveTopLeft(textPos.toPoint());
  QPolygonF rectPoly = transform.map(QPolygonF(textBoxRect));
  
  switch (anchorId)
  {
    case aiTopLeft:     return rectPoly.at(0);
    case aiTop:         return (rectPoly.at(0)+rectPoly.at(1))*0.5;
    case aiTopRight:    return rectPoly.at(1);
    case aiRight:       return (rectPoly.at(1)+rectPoly.at(2))*0.5;
    case aiBottomRight: return rectPoly.at(2);
    case aiBottom:      return (rectPoly.at(2)+rectPoly.at(3))*0.5;
    case aiBottomLeft:  return rectPoly.at(3);
    case aiLeft:        return (rectPoly.at(3)+rectPoly.at(0))*0.5;
  }
  
  qDebug() << Q_FUNC_INFO << "invalid anchorId" << anchorId;
  return QPointF();
}

/*! \internal
  
  Returns the point that must be given to the QPainter::drawText function (which expects the top
  left point of the text rect), according to the position \a pos, the text bounding box \a rect and
  the requested \a positionAlignment.
  
  For example, if \a positionAlignment is <tt>Qt::AlignLeft | Qt::AlignBottom</tt> the returned point
  will be shifted upward by the height of \a rect, starting from \a pos. So if the text is finally
  drawn at that point, the lower left corner of the resulting text rect is at \a pos.
*/
/*! \내부의
  
  QPainter :: drawText 함수에 부여해야하는 점을 반환합니다.
  텍스트 직사각형의 왼쪽 포인트), 위치 \ a pos, 텍스트 경계 상자 \ a rect 및
  요청 된 \ a positionAlignment.
  
  예를 들어, \ a positionAlignment가 <tt> Qt :: AlignLeft | Qt :: AlignBottom </ tt> 반환 된 포인트
  \ a 위치에서 시작하여 \ a rect 높이만큼 위로 이동합니다. 따라서 텍스트가 마침내
  그 시점에서 그린 결과 텍스트 rect의 왼쪽 아래 모서리는 \ a pos에 있습니다.
*/
QPointF QCPItemText::getTextDrawPoint(const QPointF &pos, const QRectF &rect, Qt::Alignment positionAlignment) const
{
  if (positionAlignment == 0 || positionAlignment == (Qt::AlignLeft|Qt::AlignTop))
    return pos;
  
  QPointF result = pos; // start at top left  // 왼쪽 상단에서 시작합니다.
  if (positionAlignment.testFlag(Qt::AlignHCenter))
    result.rx() -= rect.width()/2.0;
  else if (positionAlignment.testFlag(Qt::AlignRight))
    result.rx() -= rect.width();
  if (positionAlignment.testFlag(Qt::AlignVCenter))
    result.ry() -= rect.height()/2.0;
  else if (positionAlignment.testFlag(Qt::AlignBottom))
    result.ry() -= rect.height();
  return result;
}

/*! \internal

  Returns the font that should be used for drawing text. Returns mFont when the item is not selected
  and mSelectedFont when it is.
*/
/*! \내부의

  텍스트의 묘화에 사용하는 폰트를 돌려줍니다. 항목이 선택되지 않은 경우 mFont를 반환합니다.
  있을 때 mSelectedFont.
*/
QFont QCPItemText::mainFont() const
{
  return mSelected ? mSelectedFont : mFont;
}

/*! \internal

  Returns the color that should be used for drawing text. Returns mColor when the item is not
  selected and mSelectedColor when it is.
*/
/*! \내부의

  텍스트의 묘화에 사용하는 색을 돌려줍니다. 항목이 아닌 경우 mColor를 반환합니다.
  선택되었을 경우는 mSelectedColor가 선택됩니다.
*/
QColor QCPItemText::mainColor() const
{
  return mSelected ? mSelectedColor : mColor;
}

/*! \internal

  Returns the pen that should be used for drawing lines. Returns mPen when the item is not selected
  and mSelectedPen when it is.
*/
/*! \내부의

  선 그리기에 사용해야하는 펜을 반환합니다. 항목이 선택되지 않은 경우 mPen을 반환합니다.
  및 mSelectedPen 때.
*/
QPen QCPItemText::mainPen() const
{
  return mSelected ? mSelectedPen : mPen;
}

/*! \internal

  Returns the brush that should be used for drawing fills of the item. Returns mBrush when the item
  is not selected and mSelectedBrush when it is.
*/
/*! \내부의

  항목의 칠을 그리는 데 사용해야하는 브러시를 반환합니다. 항목이 나타날 때 mBrush를 반환합니다.
  선택되어 있지 않으면 mSelectedBrush가 선택됩니다.
*/
QBrush QCPItemText::mainBrush() const
{
  return mSelected ? mSelectedBrush : mBrush;
}
/* end of 'src/items/item-text.cpp' */


/* including file 'src/items/item-ellipse.cpp', size 7863                    */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / items / item-text.cpp'의 끝 */


/* 파일 'src / items / item-ellipse.cpp', 크기 7863 포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPItemEllipse
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPItemEllipse
  \brief An ellipse

  \image html QCPItemEllipse.png "Ellipse example. Blue dotted circles are anchors, solid blue discs are positions."

  It has two positions, \a topLeft and \a bottomRight, which define the rect the ellipse will be drawn in.
*/
/*! \ class QCPItemEllipse
  \ brief 타원

  \ image html QCPItemEllipse.png "타원형 예 : 파란색 점선 원은 앵커, 단색 파란색 디스크는 위치입니다."

  그것은 타원이 그려지는 rect를 정의하는 두 개의 위치, \ a topLeft와 \ a bottomRight를가집니다.
*/

/*!
  Creates an ellipse item and sets default values.
  
  The created item is automatically registered with \a parentPlot. This QCustomPlot instance takes
  ownership of the item, so do not delete it manually but use QCustomPlot::removeItem() instead.
*/
/*!
  타원 항목을 만들고 기본값을 설정합니다.
  
  생성 된 항목은 parentPlot에 자동으로 등록됩니다. 이 QCustomPlot 인스턴스는
  아이템의 소유권이므로 수동으로 삭제하지 말고 대신 QCustomPlot :: removeItem ()을 사용하십시오.
*/
QCPItemEllipse::QCPItemEllipse(QCustomPlot *parentPlot) :
  QCPAbstractItem(parentPlot),
  topLeft(createPosition(QLatin1String("topLeft"))),
  bottomRight(createPosition(QLatin1String("bottomRight"))),
  topLeftRim(createAnchor(QLatin1String("topLeftRim"), aiTopLeftRim)),
  top(createAnchor(QLatin1String("top"), aiTop)),
  topRightRim(createAnchor(QLatin1String("topRightRim"), aiTopRightRim)),
  right(createAnchor(QLatin1String("right"), aiRight)),
  bottomRightRim(createAnchor(QLatin1String("bottomRightRim"), aiBottomRightRim)),
  bottom(createAnchor(QLatin1String("bottom"), aiBottom)),
  bottomLeftRim(createAnchor(QLatin1String("bottomLeftRim"), aiBottomLeftRim)),
  left(createAnchor(QLatin1String("left"), aiLeft)),
  center(createAnchor(QLatin1String("center"), aiCenter))
{
  topLeft->setCoords(0, 1);
  bottomRight->setCoords(1, 0);
  
  setPen(QPen(Qt::black));
  setSelectedPen(QPen(Qt::blue, 2));
  setBrush(Qt::NoBrush);
  setSelectedBrush(Qt::NoBrush);
}

QCPItemEllipse::~QCPItemEllipse()
{
}

/*!
  Sets the pen that will be used to draw the line of the ellipse
  
  \see setSelectedPen, setBrush
*/
/*!
  타원의 선을 그릴 때 사용할 펜을 설정합니다.
  
  \ setSelectedPen 참조, setBrush
*/
void QCPItemEllipse::setPen(const QPen &pen)
{
  mPen = pen;
}

/*!
  Sets the pen that will be used to draw the line of the ellipse when selected
  
  \see setPen, setSelected
*/
/*!
  선택한 경우 타원 선을 그릴 때 사용할 펜을 설정합니다.
  
  \ setPen 참조, setSelected
*/
void QCPItemEllipse::setSelectedPen(const QPen &pen)
{
  mSelectedPen = pen;
}

/*!
  Sets the brush that will be used to fill the ellipse. To disable filling, set \a brush to
  Qt::NoBrush.
  
  \see setSelectedBrush, setPen
*/
/*!
  타원을 채우는 데 사용할 브러시를 설정합니다. 채우기를 사용하지 않으려면 브러시를 다음으로 설정하십시오.
  Qt :: NoBrush.
  
  \ setSelectedBrush, setPen을 참조하십시오.
*/
void QCPItemEllipse::setBrush(const QBrush &brush)
{
  mBrush = brush;
}

/*!
  Sets the brush that will be used to fill the ellipse when selected. To disable filling, set \a
  brush to Qt::NoBrush.
  
  \see setBrush
*/
/*!
  선택한 경우 타원 채우기에 사용할 브러시를 설정합니다. 채우기를 사용 중지하려면 \ a
  Qt :: NoBrush로 브러쉬.
  
  \ setBrush를 참조하십시오.
*/
void QCPItemEllipse::setSelectedBrush(const QBrush &brush)
{
  mSelectedBrush = brush;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPItemEllipse::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  Q_UNUSED(details)
  if (onlySelectable && !mSelectable)
    return -1;
  
  QPointF p1 = topLeft->pixelPosition();
  QPointF p2 = bottomRight->pixelPosition();
  QPointF center((p1+p2)/2.0);
  double a = qAbs(p1.x()-p2.x())/2.0;
  double b = qAbs(p1.y()-p2.y())/2.0;
  double x = pos.x()-center.x();
  double y = pos.y()-center.y();
  
  // distance to border:
  // 경계와의 거리 :
  double c = 1.0/qSqrt(x*x/(a*a)+y*y/(b*b));
  double result = qAbs(c-1)*qSqrt(x*x+y*y);
  // filled ellipse, allow click inside to count as hit:
  // 채워진 타원, 내부를 클릭하면 조회 가능 :
  if (result > mParentPlot->selectionTolerance()*0.99 && mBrush.style() != Qt::NoBrush && mBrush.color().alpha() != 0)
  {
    if (x*x/(a*a) + y*y/(b*b) <= 1)
      result = mParentPlot->selectionTolerance()*0.99;
  }
  return result;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPItemEllipse::draw(QCPPainter *painter)
{
  QPointF p1 = topLeft->pixelPosition();
  QPointF p2 = bottomRight->pixelPosition();
  if (p1.toPoint() == p2.toPoint())
    return;
  QRectF ellipseRect = QRectF(p1, p2).normalized();
  QRect clip = clipRect().adjusted(-mainPen().widthF(), -mainPen().widthF(), mainPen().widthF(), mainPen().widthF());
  if (ellipseRect.intersects(clip)) // only draw if bounding rect of ellipse is visible in cliprect
                                    // cliprect에서 타원의 경계 사각형이 보이는 경우에만 그리기
  {
    painter->setPen(mainPen());
    painter->setBrush(mainBrush());
#ifdef __EXCEPTIONS
    try // drawEllipse sometimes throws exceptions if ellipse is too big
        // 타원이 너무 크면 tryEllipse가 예외를 던질 수 있습니다.
    {
#endif
      painter->drawEllipse(ellipseRect);
#ifdef __EXCEPTIONS
    } catch (...)
    {
      qDebug() << Q_FUNC_INFO << "Item too large for memory, setting invisible";
      setVisible(false);
    }
#endif
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QPointF QCPItemEllipse::anchorPixelPosition(int anchorId) const
{
  QRectF rect = QRectF(topLeft->pixelPosition(), bottomRight->pixelPosition());
  switch (anchorId)
  {
    case aiTopLeftRim:     return rect.center()+(rect.topLeft()-rect.center())*1/qSqrt(2);
    case aiTop:            return (rect.topLeft()+rect.topRight())*0.5;
    case aiTopRightRim:    return rect.center()+(rect.topRight()-rect.center())*1/qSqrt(2);
    case aiRight:          return (rect.topRight()+rect.bottomRight())*0.5;
    case aiBottomRightRim: return rect.center()+(rect.bottomRight()-rect.center())*1/qSqrt(2);
    case aiBottom:         return (rect.bottomLeft()+rect.bottomRight())*0.5;
    case aiBottomLeftRim:  return rect.center()+(rect.bottomLeft()-rect.center())*1/qSqrt(2);
    case aiLeft:           return (rect.topLeft()+rect.bottomLeft())*0.5;
    case aiCenter:         return (rect.topLeft()+rect.bottomRight())*0.5;
  }
  
  qDebug() << Q_FUNC_INFO << "invalid anchorId" << anchorId;
  return QPointF();
}

/*! \internal

  Returns the pen that should be used for drawing lines. Returns mPen when the item is not selected
  and mSelectedPen when it is.
*/
/*! \내부의

  선 그리기에 사용해야하는 펜을 반환합니다. 항목이 선택되지 않은 경우 mPen을 반환합니다.
  및 mSelectedPen 때.
*/
QPen QCPItemEllipse::mainPen() const
{
  return mSelected ? mSelectedPen : mPen;
}

/*! \internal

  Returns the brush that should be used for drawing fills of the item. Returns mBrush when the item
  is not selected and mSelectedBrush when it is.
*/
/*! \내부의

  항목의 칠을 그리는 데 사용해야하는 브러시를 반환합니다. 항목이 나타날 때 mBrush를 반환합니다.
  선택되어 있지 않으면 mSelectedBrush가 선택됩니다.
*/
QBrush QCPItemEllipse::mainBrush() const
{
  return mSelected ? mSelectedBrush : mBrush;
}
/* end of 'src/items/item-ellipse.cpp' */


/* including file 'src/items/item-pixmap.cpp', size 10615                    */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / items / item-ellipse.cpp'의 끝 */


/* 파일 'src / items / item-pixmap.cpp', 크기 10615   포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPItemPixmap
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPItemPixmap
  \brief An arbitrary pixmap

  \image html QCPItemPixmap.png "Pixmap example. Blue dotted circles are anchors, solid blue discs are positions."

  It has two positions, \a topLeft and \a bottomRight, which define the rectangle the pixmap will
  be drawn in. Depending on the scale setting (\ref setScaled), the pixmap will be either scaled to
  fit the rectangle or be drawn aligned to the topLeft position.
  
  If scaling is enabled and \a topLeft is further to the bottom/right than \a bottomRight (as shown
  on the right side of the example image), the pixmap will be flipped in the respective
  orientations.
*/
/*! \ class QCPItemPixmap
  \ brief 임의의 픽스맵

  \ image html QCPItemPixmap.png "픽스맵 예제. 파란색 점선 원은 앵커, 단색 파란색 디스크는 위치입니다."

  pixmap이 될 직사각형을 정의하는 \ a topLeft와 \ a bottomRight 두 가지 위치를가집니다.
  스케일 설정 (\ ref setScaled)에 따라, pixmap은
  사각형을 맞추거나 topLeft 위치에 맞춰 그려야합니다.
  
  확대 / 축소가 사용 가능하고 \ a topLeft가 \ a bottomRight보다 아래 / 오른쪽으로 더 멀리있는 경우 (그림과 같이)
  예제 이미지의 오른쪽에), pixmap은 각각의
  방향.
*/

/*!
  Creates a rectangle item and sets default values.
  
  The created item is automatically registered with \a parentPlot. This QCustomPlot instance takes
  ownership of the item, so do not delete it manually but use QCustomPlot::removeItem() instead.
*/
/*!
  사각형 항목을 만들고 기본값을 설정합니다.
  
  생성 된 항목은 parentPlot에 자동으로 등록됩니다. 이 QCustomPlot 인스턴스는
  아이템의 소유권이므로 수동으로 삭제하지 말고 대신 QCustomPlot :: removeItem ()을 사용하십시오.
*/
QCPItemPixmap::QCPItemPixmap(QCustomPlot *parentPlot) :
  QCPAbstractItem(parentPlot),
  topLeft(createPosition(QLatin1String("topLeft"))),
  bottomRight(createPosition(QLatin1String("bottomRight"))),
  top(createAnchor(QLatin1String("top"), aiTop)),
  topRight(createAnchor(QLatin1String("topRight"), aiTopRight)),
  right(createAnchor(QLatin1String("right"), aiRight)),
  bottom(createAnchor(QLatin1String("bottom"), aiBottom)),
  bottomLeft(createAnchor(QLatin1String("bottomLeft"), aiBottomLeft)),
  left(createAnchor(QLatin1String("left"), aiLeft)),
  mScaled(false),
  mScaledPixmapInvalidated(true),
  mAspectRatioMode(Qt::KeepAspectRatio),
  mTransformationMode(Qt::SmoothTransformation)
{
  topLeft->setCoords(0, 1);
  bottomRight->setCoords(1, 0);
  
  setPen(Qt::NoPen);
  setSelectedPen(QPen(Qt::blue));
}

QCPItemPixmap::~QCPItemPixmap()
{
}

/*!
  Sets the pixmap that will be displayed.
*/
/*!
  표시 할 픽스맵을 설정합니다.
*/
void QCPItemPixmap::setPixmap(const QPixmap &pixmap)
{
  mPixmap = pixmap;
  mScaledPixmapInvalidated = true;
  if (mPixmap.isNull())
    qDebug() << Q_FUNC_INFO << "pixmap is null";
}

/*!
  Sets whether the pixmap will be scaled to fit the rectangle defined by the \a topLeft and \a
  bottomRight positions.
*/
/*!
  pixmap이 \ a topLeft와 \ a에 의해 정의 된 사각형에 맞게 크기가 조절되는지 여부를 설정합니다.
  bottomRight 위치.
*/
void QCPItemPixmap::setScaled(bool scaled, Qt::AspectRatioMode aspectRatioMode, Qt::TransformationMode transformationMode)
{
  mScaled = scaled;
  mAspectRatioMode = aspectRatioMode;
  mTransformationMode = transformationMode;
  mScaledPixmapInvalidated = true;
}

/*!
  Sets the pen that will be used to draw a border around the pixmap.
  
  \see setSelectedPen, setBrush
*/
/*!
  픽스맵 주위에 테두리를 그릴 때 사용할 펜을 설정합니다.
  
  \ setSelectedPen 참조, setBrush
*/
void QCPItemPixmap::setPen(const QPen &pen)
{
  mPen = pen;
}

/*!
  Sets the pen that will be used to draw a border around the pixmap when selected
  
  \see setPen, setSelected
*/
/*!
  선택할 때 픽스맵 주위에 테두리를 그릴 때 사용할 펜을 설정합니다.
  
  \ setPen 참조, setSelected
*/
void QCPItemPixmap::setSelectedPen(const QPen &pen)
{
  mSelectedPen = pen;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPItemPixmap::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  Q_UNUSED(details)
  if (onlySelectable && !mSelectable)
    return -1;
  
  return rectDistance(getFinalRect(), pos, true);
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPItemPixmap::draw(QCPPainter *painter)
{
  bool flipHorz = false;
  bool flipVert = false;
  QRect rect = getFinalRect(&flipHorz, &flipVert);
  double clipPad = mainPen().style() == Qt::NoPen ? 0 : mainPen().widthF();
  QRect boundingRect = rect.adjusted(-clipPad, -clipPad, clipPad, clipPad);
  if (boundingRect.intersects(clipRect()))
  {
    updateScaledPixmap(rect, flipHorz, flipVert);
    painter->drawPixmap(rect.topLeft(), mScaled ? mScaledPixmap : mPixmap);
    QPen pen = mainPen();
    if (pen.style() != Qt::NoPen)
    {
      painter->setPen(pen);
      painter->setBrush(Qt::NoBrush);
      painter->drawRect(rect);
    }
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QPointF QCPItemPixmap::anchorPixelPosition(int anchorId) const
{
  bool flipHorz;
  bool flipVert;
  QRect rect = getFinalRect(&flipHorz, &flipVert);
  // we actually want denormal rects (negative width/height) here, so restore
  // the flipped state:
  // 실제로는 denormal rect (음수 너비 / 높이)를 원한다.
  // 뒤집힌 상태 :
  if (flipHorz)
    rect.adjust(rect.width(), 0, -rect.width(), 0);
  if (flipVert)
    rect.adjust(0, rect.height(), 0, -rect.height());
  
  switch (anchorId)
  {
    case aiTop:         return (rect.topLeft()+rect.topRight())*0.5;
    case aiTopRight:    return rect.topRight();
    case aiRight:       return (rect.topRight()+rect.bottomRight())*0.5;
    case aiBottom:      return (rect.bottomLeft()+rect.bottomRight())*0.5;
    case aiBottomLeft:  return rect.bottomLeft();
    case aiLeft:        return (rect.topLeft()+rect.bottomLeft())*0.5;;
  }
  
  qDebug() << Q_FUNC_INFO << "invalid anchorId" << anchorId;
  return QPointF();
}

/*! \internal
  
  Creates the buffered scaled image (\a mScaledPixmap) to fit the specified \a finalRect. The
  parameters \a flipHorz and \a flipVert control whether the resulting image shall be flipped
  horizontally or vertically. (This is used when \a topLeft is further to the bottom/right than \a
  bottomRight.)
  
  This function only creates the scaled pixmap when the buffered pixmap has a different size than
  the expected result, so calling this function repeatedly, e.g. in the \ref draw function, does
  not cause expensive rescaling every time.
  
  If scaling is disabled, sets mScaledPixmap to a null QPixmap.
*/
/*! \내부의
  
  지정된 \ a finalRect에 맞게 버퍼링 된 크기 조정 된 이미지 (\ a mScaledPixmap)를 만듭니다. 그만큼
  매개 변수 \ a flipHorz 및 \ a flipVert는 결과 이미지를 뒤집을 것인지 여부를 제어합니다.
  수평 또는 수직으로. (topLeft가 \ a보다 맨 아래 / 오른쪽에있을 때 사용됩니다.
  bottomRight.)
  
  이 함수는 버퍼링 된 픽스맵이 다른 크기를 가질 때만 스케일 된 픽스맵을 생성합니다.
  예를 들어 \ ref draw 함수에서 반복적으로이 함수를 호출하면 예상되는 결과가됩니다.
  매번 값 비싼 재조정을 일으키지 않아야합니다.
  
  배율이 비활성화 된 경우 mScaledPixmap을 null QPixmap으로 설정합니다.
*/
void QCPItemPixmap::updateScaledPixmap(QRect finalRect, bool flipHorz, bool flipVert)
{
  if (mPixmap.isNull())
    return;
  
  if (mScaled)
  {
#ifdef QCP_DEVICEPIXELRATIO_SUPPORTED
    double devicePixelRatio = mPixmap.devicePixelRatio();
#else
    double devicePixelRatio = 1.0;
#endif
    if (finalRect.isNull())
      finalRect = getFinalRect(&flipHorz, &flipVert);
    if (mScaledPixmapInvalidated || finalRect.size() != mScaledPixmap.size()/devicePixelRatio)
    {
      mScaledPixmap = mPixmap.scaled(finalRect.size()*devicePixelRatio, mAspectRatioMode, mTransformationMode);
      if (flipHorz || flipVert)
        mScaledPixmap = QPixmap::fromImage(mScaledPixmap.toImage().mirrored(flipHorz, flipVert));
#ifdef QCP_DEVICEPIXELRATIO_SUPPORTED
      mScaledPixmap.setDevicePixelRatio(devicePixelRatio);
#endif
    }
  } else if (!mScaledPixmap.isNull())
    mScaledPixmap = QPixmap();
  mScaledPixmapInvalidated = false;
}

/*! \internal
  
  Returns the final (tight) rect the pixmap is drawn in, depending on the current item positions
  and scaling settings.
  
  The output parameters \a flippedHorz and \a flippedVert return whether the pixmap should be drawn
  flipped horizontally or vertically in the returned rect. (The returned rect itself is always
  normalized, i.e. the top left corner of the rect is actually further to the top/left than the
  bottom right corner). This is the case when the item position \a topLeft is further to the
  bottom/right than \a bottomRight.
  
  If scaling is disabled, returns a rect with size of the original pixmap and the top left corner
  aligned with the item position \a topLeft. The position \a bottomRight is ignored.
*/
/*! \내부의
  
  현재 항목 위치에 따라 pixmap이 그려지는 마지막 (단단한) rect를 반환합니다.
  및 배율 설정.
  
  출력 매개 변수 \ flippedHorz 및 \ flappedVert는 픽스맵을 그려야하는지 여부를 반환합니다.
  반환 된 rect에서 가로 또는 세로로 뒤집습니다. (반환 된 rect 자체는 항상
  즉, rect의 왼쪽 위 모서리는 실제로는 위쪽 / 왼쪽에 있습니다.
  오른쪽 하단 모서리). 이것은 item position \ a topLeft가 더 멀리있는 경우입니다.
  bottom / right보다 \ a bottomRight.
  
  크기 조절이 비활성화되면 원래 픽스맵의 크기와 왼쪽 위 모서리의 사각형을 반환합니다.
  항목 위치 \ a topLeft에 맞 춥니 다. \ bottomRight 위치는 무시됩니다.
*/
QRect QCPItemPixmap::getFinalRect(bool *flippedHorz, bool *flippedVert) const
{
  QRect result;
  bool flipHorz = false;
  bool flipVert = false;
  QPoint p1 = topLeft->pixelPosition().toPoint();
  QPoint p2 = bottomRight->pixelPosition().toPoint();
  if (p1 == p2)
    return QRect(p1, QSize(0, 0));
  if (mScaled)
  {
    QSize newSize = QSize(p2.x()-p1.x(), p2.y()-p1.y());
    QPoint topLeft = p1;
    if (newSize.width() < 0)
    {
      flipHorz = true;
      newSize.rwidth() *= -1;
      topLeft.setX(p2.x());
    }
    if (newSize.height() < 0)
    {
      flipVert = true;
      newSize.rheight() *= -1;
      topLeft.setY(p2.y());
    }
    QSize scaledSize = mPixmap.size();
#ifdef QCP_DEVICEPIXELRATIO_SUPPORTED
    scaledSize /= mPixmap.devicePixelRatio();
    scaledSize.scale(newSize*mPixmap.devicePixelRatio(), mAspectRatioMode);
#else
    scaledSize.scale(newSize, mAspectRatioMode);
#endif
    result = QRect(topLeft, scaledSize);
  } else
  {
#ifdef QCP_DEVICEPIXELRATIO_SUPPORTED
    result = QRect(p1, mPixmap.size()/mPixmap.devicePixelRatio());
#else
    result = QRect(p1, mPixmap.size());
#endif
  }
  if (flippedHorz)
    *flippedHorz = flipHorz;
  if (flippedVert)
    *flippedVert = flipVert;
  return result;
}

/*! \internal

  Returns the pen that should be used for drawing lines. Returns mPen when the item is not selected
  and mSelectedPen when it is.
*/
/*! \내부의

  선 그리기에 사용해야하는 펜을 반환합니다. 항목이 선택되지 않은 경우 mPen을 반환합니다.
  및 mSelectedPen 때.
*/
QPen QCPItemPixmap::mainPen() const
{
  return mSelected ? mSelectedPen : mPen;
}
/* end of 'src/items/item-pixmap.cpp' */


/* including file 'src/items/item-tracer.cpp', size 14624                    */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / items / item-pixmap.cpp'의 끝 */


/* 파일 'src / items / item-tracer.cpp', 크기 14624 포함   */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPItemTracer
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPItemTracer
  \brief Item that sticks to QCPGraph data points

  \image html QCPItemTracer.png "Tracer example. Blue dotted circles are anchors, solid blue discs are positions."

  The tracer can be connected with a QCPGraph via \ref setGraph. Then it will automatically adopt
  the coordinate axes of the graph and update its \a position to be on the graph's data. This means
  the key stays controllable via \ref setGraphKey, but the value will follow the graph data. If a
  QCPGraph is connected, note that setting the coordinates of the tracer item directly via \a
  position will have no effect because they will be overriden in the next redraw (this is when the
  coordinate update happens).
  
  If the specified key in \ref setGraphKey is outside the key bounds of the graph, the tracer will
  stay at the corresponding end of the graph.
  
  With \ref setInterpolating you may specify whether the tracer may only stay exactly on data
  points or whether it interpolates data points linearly, if given a key that lies between two data
  points of the graph.
  
  The tracer has different visual styles, see \ref setStyle. It is also possible to make the tracer
  have no own visual appearance (set the style to \ref tsNone), and just connect other item
  positions to the tracer \a position (used as an anchor) via \ref
  QCPItemPosition::setParentAnchor.
  
  \note The tracer position is only automatically updated upon redraws. So when the data of the
  graph changes and immediately afterwards (without a redraw) the position coordinates of the
  tracer are retrieved, they will not reflect the updated data of the graph. In this case \ref
  updatePosition must be called manually, prior to reading the tracer coordinates.
*/
/*! \ class QCPItemTracer
  \ brief QCPGraph 데이터 포인트에 집착하는 항목

  \ image html QCPItemTracer.png "추적자 예 : 파란색 점선 원은 앵커이며 단색 파란색 디스크는 위치입니다."

  추적기는 \ ref setGraph를 통해 QCPGraph와 연결할 수 있습니다. 그런 다음 자동으로 채택 할 것입니다.
  그래프의 좌표축을 지정해, \ a 위치를 그래프의 데이터 상에 갱신합니다. 이것은
  키는 \ ref setGraphKey를 통해 제어 할 수 있지만 값은 그래프 데이터를 따릅니다. 만약
  QCPGraph가 연결되면 \ a를 통해 추적 프로그램 항목의 좌표를 직접 설정하는 것
  위치는 다음 다시 그리기에서 재정의 될 것이므로 아무 효과가 없습니다 (이것은
  좌표 업데이트가 발생합니다.
  
  \ ref setGraphKey의 지정된 키가 그래프의 키 경계를 벗어나면 추적 프로그램은
  그래프의 해당 끝에서 머물러 라.
  
  \ ref setInterpolating을 사용하면 추적 프로그램이 데이터에만 정확하게 머물 수 있는지 여부를 지정할 수 있습니다
  또는 두 데이터 사이에있는 키가 주어진 경우 데이터 포인트를 선형 적으로 보간하는지 여부
  그래프의 포인트.
  
  추적 프로그램은 다른 시각적 스타일을 가지고 있습니다. \ ref setStyle을보십시오. 추적자를 만드는 것도 가능합니다.
  시각적 인 외관 (\ ref tsNone으로 스타일을 설정)이 없으며 다른 항목을 연결하기 만하면됩니다.
  \ ref를 통해 tracer \ a 위치 (앵커로 사용됨)의 위치
  QCPItemPosition :: setParentAnchor.
  
  \ note 추적 위치는 다시 그리기 할 때 자동으로 업데이트됩니다. 따라서
  그래프가 변경되고 직후에 (다시 그리기없이)
  추적 프로그램이 검색되면 그래프의 업데이트 된 데이터를 반영하지 않습니다. 이 경우 \ ref
  추적 포인터 좌표를 읽기 전에 updatePosition을 수동으로 호출해야합니다.
*/

/*!
  Creates a tracer item and sets default values.
  
  The created item is automatically registered with \a parentPlot. This QCustomPlot instance takes
  ownership of the item, so do not delete it manually but use QCustomPlot::removeItem() instead.
*/
/*!
  추적 프로그램 항목을 만들고 기본값을 설정합니다.
  
  생성 된 항목은 parentPlot에 자동으로 등록됩니다. 이 QCustomPlot 인스턴스는
  아이템의 소유권이므로 수동으로 삭제하지 말고 대신 QCustomPlot :: removeItem ()을 사용하십시오.
*/
QCPItemTracer::QCPItemTracer(QCustomPlot *parentPlot) :
  QCPAbstractItem(parentPlot),
  position(createPosition(QLatin1String("position"))),
  mSize(6),
  mStyle(tsCrosshair),
  mGraph(0),
  mGraphKey(0),
  mInterpolating(false)
{
  position->setCoords(0, 0);

  setBrush(Qt::NoBrush);
  setSelectedBrush(Qt::NoBrush);
  setPen(QPen(Qt::black));
  setSelectedPen(QPen(Qt::blue, 2));
}

QCPItemTracer::~QCPItemTracer()
{
}

/*!
  Sets the pen that will be used to draw the line of the tracer
  
  \see setSelectedPen, setBrush
*/
/*!
  추적 프로그램의 선을 그릴 때 사용할 펜을 설정합니다.
  
  \ setSelectedPen 참조, setBrush
*/
void QCPItemTracer::setPen(const QPen &pen)
{
  mPen = pen;
}

/*!
  Sets the pen that will be used to draw the line of the tracer when selected
  
  \see setPen, setSelected
*/
/*!
  선택할 때 추적자의 선을 그릴 때 사용할 펜을 설정합니다.
  
  \ setPen 참조, setSelected
*/
void QCPItemTracer::setSelectedPen(const QPen &pen)
{
  mSelectedPen = pen;
}

/*!
  Sets the brush that will be used to draw any fills of the tracer
  
  \see setSelectedBrush, setPen
*/
/*!
  추적자의 채우기를 그리는 데 사용할 브러시를 설정합니다.
  
  \ setSelectedBrush, setPen을 참조하십시오.
*/
void QCPItemTracer::setBrush(const QBrush &brush)
{
  mBrush = brush;
}

/*!
  Sets the brush that will be used to draw any fills of the tracer, when selected.
  
  \see setBrush, setSelected
*/
/*!
  선택할 때 추적기의 채우기를 그리는 데 사용할 브러시를 설정합니다.
  
  \ setBrush 참조, setSelected
*/
void QCPItemTracer::setSelectedBrush(const QBrush &brush)
{
  mSelectedBrush = brush;
}

/*!
  Sets the size of the tracer in pixels, if the style supports setting a size (e.g. \ref tsSquare
  does, \ref tsCrosshair does not).
*/
/*!
  스타일이 크기 설정을 지원하는 경우 추적자의 크기를 픽셀 단위로 설정합니다 (예 : \ ref tsSquare
  않습니다, \ ref tsCrosshair 않습니다).
*/
void QCPItemTracer::setSize(double size)
{
  mSize = size;
}

/*!
  Sets the style/visual appearance of the tracer.
  
  If you only want to use the tracer \a position as an anchor for other items, set \a style to
  \ref tsNone.
*/
/*!
  추적 프로그램의 스타일 / 시각적 모양을 설정합니다.
  
  추적기 \ a 위치 만 다른 항목의 앵커로 사용하려면 \ a 스타일을로 설정하십시오.
  \ ref tsNone.
*/
void QCPItemTracer::setStyle(QCPItemTracer::TracerStyle style)
{
  mStyle = style;
}

/*!
  Sets the QCPGraph this tracer sticks to. The tracer \a position will be set to type
  QCPItemPosition::ptPlotCoords and the axes will be set to the axes of \a graph.
  
  To free the tracer from any graph, set \a graph to 0. The tracer \a position can then be placed
  freely like any other item position. This is the state the tracer will assume when its graph gets
  deleted while still attached to it.
  
  \see setGraphKey
*/
/*!
  이 트레이서가 붙어있는 QCPGraph를 설정합니다. 추적 프로그램 \ 위치가 입력으로 설정됩니다.
  QCPItemPosition :: ptPlotCoords와 축은 \ 그래프의 축으로 설정됩니다.
  
  모든 그래프에서 추적 프로그램을 해제하려면 \ 그래프를 0으로 설정하십시오. 그러면 추적 프로그램의 \ 위치를 배치 할 수 있습니다
  다른 항목 위치와 마찬가지로 자유롭게 사용할 수 있습니다. 추적기가 그래프를 가져올 때 가정 할 상태입니다.
  여전히 첨부 된 상태에서 삭제되었습니다.
  
  \ setGraphKey 참조
*/
void QCPItemTracer::setGraph(QCPGraph *graph)
{
  if (graph)
  {
    if (graph->parentPlot() == mParentPlot)
    {
      position->setType(QCPItemPosition::ptPlotCoords);
      position->setAxes(graph->keyAxis(), graph->valueAxis());
      mGraph = graph;
      updatePosition();
    } else
      qDebug() << Q_FUNC_INFO << "graph isn't in same QCustomPlot instance as this item";
  } else
  {
    mGraph = 0;
  }
}

/*!
  Sets the key of the graph's data point the tracer will be positioned at. This is the only free
  coordinate of a tracer when attached to a graph.
  
  Depending on \ref setInterpolating, the tracer will be either positioned on the data point
  closest to \a key, or will stay exactly at \a key and interpolate the value linearly.
  
  \see setGraph, setInterpolating
*/
/*!
  트레이서가 위치 할 그래프의 데이터 포인트의 키를 설정합니다. 이것은 유일한 무료입니다
  그래프에 첨부 할 때 추적자의 좌표.
  
  \ ref setInterpolating에 따라 추적 프로그램이 데이터 요소에 배치되거나
  \ 키에 가장 가깝거나 \ 키에 정확히 머물러 값을 선형 적으로 보간 할 것이다.
  
  \ setGraph 참조, setInterpolating
*/
void QCPItemTracer::setGraphKey(double key)
{
  mGraphKey = key;
}

/*!
  Sets whether the value of the graph's data points shall be interpolated, when positioning the
  tracer.
  
  If \a enabled is set to false and a key is given with \ref setGraphKey, the tracer is placed on
  the data point of the graph which is closest to the key, but which is not necessarily exactly
  there. If \a enabled is true, the tracer will be positioned exactly at the specified key, and
  the appropriate value will be interpolated from the graph's data points linearly.
  
  \see setGraph, setGraphKey
*/
/*!
  그래프를 배치 할 때 그래프의 데이터 포인트 값을 보간할지 여부를 설정합니다.
  트레이서.
  
  \ a enabled가 false로 설정되고 \ ref setGraphKey로 키가 주어진 경우 추적 프로그램이
  키에 가장 가까운 그래프의 데이터 포인트. 다만, 반드시 정확하게는 아니다
  그곳에. \ a enabled가 true이면 추적 프로그램이 지정된 키에 정확히 위치하게됩니다.
  적절한 값은 그래프의 데이터 포인트로부터 선형 적으로 보간됩니다.
  
  \ setGraph, setGraphKey를 참조하십시오.
*/
void QCPItemTracer::setInterpolating(bool enabled)
{
  mInterpolating = enabled;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPItemTracer::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  Q_UNUSED(details)
  if (onlySelectable && !mSelectable)
    return -1;

  QPointF center(position->pixelPosition());
  double w = mSize/2.0;
  QRect clip = clipRect();
  switch (mStyle)
  {
    case tsNone: return -1;
    case tsPlus:
    {
      if (clipRect().intersects(QRectF(center-QPointF(w, w), center+QPointF(w, w)).toRect()))
        return qSqrt(qMin(QCPVector2D(pos).distanceSquaredToLine(center+QPointF(-w, 0), center+QPointF(w, 0)),
                          QCPVector2D(pos).distanceSquaredToLine(center+QPointF(0, -w), center+QPointF(0, w))));
      break;
    }
    case tsCrosshair:
    {
      return qSqrt(qMin(QCPVector2D(pos).distanceSquaredToLine(QCPVector2D(clip.left(), center.y()), QCPVector2D(clip.right(), center.y())),
                        QCPVector2D(pos).distanceSquaredToLine(QCPVector2D(center.x(), clip.top()), QCPVector2D(center.x(), clip.bottom()))));
    }
    case tsCircle:
    {
      if (clip.intersects(QRectF(center-QPointF(w, w), center+QPointF(w, w)).toRect()))
      {
        // distance to border:
        // 경계와의 거리 :
        double centerDist = QCPVector2D(center-pos).length();
        double circleLine = w;
        double result = qAbs(centerDist-circleLine);
        // filled ellipse, allow click inside to count as hit:
        // 채워진 타원, 내부를 클릭하면 조회 가능 :
        if (result > mParentPlot->selectionTolerance()*0.99 && mBrush.style() != Qt::NoBrush && mBrush.color().alpha() != 0)
        {
          if (centerDist <= circleLine)
            result = mParentPlot->selectionTolerance()*0.99;
        }
        return result;
      }
      break;
    }
    case tsSquare:
    {
      if (clip.intersects(QRectF(center-QPointF(w, w), center+QPointF(w, w)).toRect()))
      {
        QRectF rect = QRectF(center-QPointF(w, w), center+QPointF(w, w));
        bool filledRect = mBrush.style() != Qt::NoBrush && mBrush.color().alpha() != 0;
        return rectDistance(rect, pos, filledRect);
      }
      break;
    }
  }
  return -1;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPItemTracer::draw(QCPPainter *painter)
{
  updatePosition();
  if (mStyle == tsNone)
    return;

  painter->setPen(mainPen());
  painter->setBrush(mainBrush());
  QPointF center(position->pixelPosition());
  double w = mSize/2.0;
  QRect clip = clipRect();
  switch (mStyle)
  {
    case tsNone: return;
    case tsPlus:
    {
      if (clip.intersects(QRectF(center-QPointF(w, w), center+QPointF(w, w)).toRect()))
      {
        painter->drawLine(QLineF(center+QPointF(-w, 0), center+QPointF(w, 0)));
        painter->drawLine(QLineF(center+QPointF(0, -w), center+QPointF(0, w)));
      }
      break;
    }
    case tsCrosshair:
    {
      if (center.y() > clip.top() && center.y() < clip.bottom())
        painter->drawLine(QLineF(clip.left(), center.y(), clip.right(), center.y()));
      if (center.x() > clip.left() && center.x() < clip.right())
        painter->drawLine(QLineF(center.x(), clip.top(), center.x(), clip.bottom()));
      break;
    }
    case tsCircle:
    {
      if (clip.intersects(QRectF(center-QPointF(w, w), center+QPointF(w, w)).toRect()))
        painter->drawEllipse(center, w, w);
      break;
    }
    case tsSquare:
    {
      if (clip.intersects(QRectF(center-QPointF(w, w), center+QPointF(w, w)).toRect()))
        painter->drawRect(QRectF(center-QPointF(w, w), center+QPointF(w, w)));
      break;
    }
  }
}

/*!
  If the tracer is connected with a graph (\ref setGraph), this function updates the tracer's \a
  position to reside on the graph data, depending on the configured key (\ref setGraphKey).
  
  It is called automatically on every redraw and normally doesn't need to be called manually. One
  exception is when you want to read the tracer coordinates via \a position and are not sure that
  the graph's data (or the tracer key with \ref setGraphKey) hasn't changed since the last redraw.
  In that situation, call this function before accessing \a position, to make sure you don't get
  out-of-date coordinates.
  
  If there is no graph set on this tracer, this function does nothing.
*/
/*!
  추적 프로그램이 그래프 (\ ref setGraph)와 연결된 경우이 함수는 추적 프로그램의 \ a
  구성된 키 (\ ref setGraphKey)에 따라 그래프 데이터에 상주 할 위치입니다.
  
  이것은 모든 다시 그리기시 자동으로 호출되며 일반적으로 수동으로 호출 할 필요는 없습니다. 하나
  예외는 \ a 위치를 통해 추적 프로그램 좌표를 읽고 싶지 않을 때입니다.
  그래프의 데이터 (또는 \ ref setGraphKey를 가지는 트레이서 키)는 마지막의 재 draw 이후에 변경되지 않았다.
  이 상황에서 \ a 위치에 액세스하기 전에이 함수를 호출하여 얻을 수 없는지 확인하십시오.
  구식 좌표.
  
  이 추적자에 설정된 그래프가 없으면이 함수는 아무 것도 수행하지 않습니다.
*/
void QCPItemTracer::updatePosition()
{
  if (mGraph)
  {
    if (mParentPlot->hasPlottable(mGraph))
    {
      if (mGraph->data()->size() > 1)
      {
        QCPGraphDataContainer::const_iterator first = mGraph->data()->constBegin();
        QCPGraphDataContainer::const_iterator last = mGraph->data()->constEnd()-1;
        if (mGraphKey <= first->key)
          position->setCoords(first->key, first->value);
        else if (mGraphKey >= last->key)
          position->setCoords(last->key, last->value);
        else
        {
          QCPGraphDataContainer::const_iterator it = mGraph->data()->findBegin(mGraphKey);
          if (it != mGraph->data()->constEnd()) 
          // mGraphKey is not exactly on last iterator, but somewhere between iterators
          // mGraphKey가 마지막 iterator에 정확하게 있지 않지만 반복자 사이에 있습니다.
          {
            QCPGraphDataContainer::const_iterator prevIt = it;
            ++it; 
            // won't advance to constEnd because we handled that case (mGraphKey >= last->key) before
            // 우리가 그 사건을 처리했기 때문에 constEnd로 넘어 가지 않을 것입니다 (mGraphKey> = last-> key).
            if (mInterpolating)
            {
              // interpolate between iterators around mGraphKey:
              // mGraphKey 주변의 반복자 사이를 보간 :
              double slope = 0;
              if (!qFuzzyCompare((double)it->key, (double)prevIt->key))
                slope = (it->value-prevIt->value)/(it->key-prevIt->key);
              position->setCoords(mGraphKey, (mGraphKey-prevIt->key)*slope+prevIt->value);
            } else
            {
              // find iterator with key closest to mGraphKey:
              // mGraphKey에 가장 가까운 키를 가진 반복자를 찾는다 
              if (mGraphKey < (prevIt->key+it->key)*0.5)
                position->setCoords(prevIt->key, prevIt->value);
              else
                position->setCoords(it->key, it->value);
            }
          } else // mGraphKey is exactly on last iterator (should actually be caught when comparing first/last keys, but this is a failsafe for fp uncertainty)
 // mGraphKey가 정확히 마지막 반복자에 있습니다. (첫 번째 / 마지막 키를 비교할 때 실제로 잡아야하지만, fp 불확실성에 대한 안전 장치입니다.)
            position->setCoords(it->key, it->value);
        }
      } else if (mGraph->data()->size() == 1)
      {
        QCPGraphDataContainer::const_iterator it = mGraph->data()->constBegin();
        position->setCoords(it->key, it->value);
      } else
        qDebug() << Q_FUNC_INFO << "graph has no data";
    } else
      qDebug() << Q_FUNC_INFO << "graph not contained in QCustomPlot instance (anymore)";
  }
}

/*! \internal

  Returns the pen that should be used for drawing lines. Returns mPen when the item is not selected
  and mSelectedPen when it is.
*/
/*! \내부의

  선 그리기에 사용해야하는 펜을 반환합니다. 항목이 선택되지 않은 경우 mPen을 반환합니다.
  및 mSelectedPen 때.
*/
QPen QCPItemTracer::mainPen() const
{
  return mSelected ? mSelectedPen : mPen;
}

/*! \internal

  Returns the brush that should be used for drawing fills of the item. Returns mBrush when the item
  is not selected and mSelectedBrush when it is.
*/
/*! \내부의

  항목의 칠을 그리는 데 사용해야하는 브러시를 반환합니다. 항목이 나타날 때 mBrush를 반환합니다.
  선택되어 있지 않으면 mSelectedBrush가 선택됩니다.
*/
QBrush QCPItemTracer::mainBrush() const
{
  return mSelected ? mSelectedBrush : mBrush;
}
/* end of 'src/items/item-tracer.cpp' */


/* including file 'src/items/item-bracket.cpp', size 10687                   */
/* commit 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
/* 'src / items / item-tracer.cpp'의 끝 */


/* 파일 'src / items / item-bracket.cpp', 크기 10687 포함 */
/* 커밋 9868e55d3b412f2f89766bb482fcf299e93a0988 2017-09-04 01:56:22 +0200 */
////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// QCPItemBracket
////////////////////////////////////////////////////////////////////////////////////////////////////

/*! \class QCPItemBracket
  \brief A bracket for referencing/highlighting certain parts in the plot.

  \image html QCPItemBracket.png "Bracket example. Blue dotted circles are anchors, solid blue discs are positions."

  It has two positions, \a left and \a right, which define the span of the bracket. If \a left is
  actually farther to the left than \a right, the bracket is opened to the bottom, as shown in the
  example image.
  
  The bracket supports multiple styles via \ref setStyle. The length, i.e. how far the bracket
  stretches away from the embraced span, can be controlled with \ref setLength.
  
  \image html QCPItemBracket-length.png
  <center>Demonstrating the effect of different values for \ref setLength, for styles \ref
  bsCalligraphic and \ref bsSquare. Anchors and positions are displayed for reference.</center>
  
  It provides an anchor \a center, to allow connection of other items, e.g. an arrow (QCPItemLine
  or QCPItemCurve) or a text label (QCPItemText), to the bracket.
*/
/*! \ class QCPItemBracket
  \ brief 플롯의 특정 부분을 참조 / 강조 표시하기위한 브래킷.

  \ image html QCPItemBracket.png "대괄호 예제 : 파란색 점선 원은 앵커이고 단색 파란색 디스크는 위치입니다."

  브라켓의 스팬을 정의하는 \ a와 \ a의 두 가지 위치가 있습니다. \ a가 왼쪽 인 경우
  실제로는 \ a 오른쪽보다 왼쪽으로 멀리 떨어지면 브래킷이 아래쪽으로 열립니다.
  예제 이미지.
  
  브라켓은 \ ref setStyle을 통해 여러 스타일을 지원합니다. 길이, 즉 브래킷까지의 거리
  \ span setLength로 제어 할 수 있습니다.
  
  \ image html QCPItemBracket-length.png
  <center> \ ref setLength에 대한 다양한 값의 효과를 보여주는 스타일 \ ref
  bsCalligraphic 및 \ ref bsSquare. 참조 용 앵커 및 위치가 표시됩니다. </ center>
  
  앵커 \ 센터를 제공하여 다른 항목 (예 : 화살표 (QCPItemLine)
  또는 QCPItemCurve) 또는 텍스트 레이블 (QCPItemText)을 대괄호에 추가하십시오.
*/

/*!
  Creates a bracket item and sets default values.
  
  The created item is automatically registered with \a parentPlot. This QCustomPlot instance takes
  ownership of the item, so do not delete it manually but use QCustomPlot::removeItem() instead.
*/
/*!
  대괄호 항목을 만들고 기본값을 설정합니다.
  
  생성 된 항목은 parentPlot에 자동으로 등록됩니다. 이 QCustomPlot 인스턴스는
  아이템의 소유권이므로 수동으로 삭제하지 말고 대신 QCustomPlot :: removeItem ()을 사용하십시오.
*/
QCPItemBracket::QCPItemBracket(QCustomPlot *parentPlot) :
  QCPAbstractItem(parentPlot),
  left(createPosition(QLatin1String("left"))),
  right(createPosition(QLatin1String("right"))),
  center(createAnchor(QLatin1String("center"), aiCenter)),
  mLength(8),
  mStyle(bsCalligraphic)
{
  left->setCoords(0, 0);
  right->setCoords(1, 1);
  
  setPen(QPen(Qt::black));
  setSelectedPen(QPen(Qt::blue, 2));
}

QCPItemBracket::~QCPItemBracket()
{
}

/*!
  Sets the pen that will be used to draw the bracket.
  
  Note that when the style is \ref bsCalligraphic, only the color will be taken from the pen, the
  stroke and width are ignored. To change the apparent stroke width of a calligraphic bracket, use
  \ref setLength, which has a similar effect.
  
  \see setSelectedPen
*/
/*!
  브래킷을 그리는 데 사용할 펜을 설정합니다.
  
  스타일이 \ ref bsCalligraphic 인 경우 펜에서만 색상이 추출됩니다.
  선 및 너비는 무시됩니다. 붓글씨 괄호의 겉보기 획 폭을 변경하려면 다음을 사용하십시오.
  \ ref setLength와 비슷한 효과가 있습니다.
  
  \ setSelectedPen 참조
*/
void QCPItemBracket::setPen(const QPen &pen)
{
  mPen = pen;
}

/*!
  Sets the pen that will be used to draw the bracket when selected
  
  \see setPen, setSelected
*/
/*!
  선택한 경우 괄호 그리기에 사용할 펜을 설정합니다.
  
  \ setPen 참조, setSelected
*/
void QCPItemBracket::setSelectedPen(const QPen &pen)
{
  mSelectedPen = pen;
}

/*!
  Sets the \a length in pixels how far the bracket extends in the direction towards the embraced
  span of the bracket (i.e. perpendicular to the <i>left</i>-<i>right</i>-direction)
  
  \image html QCPItemBracket-length.png
  <center>Demonstrating the effect of different values for \ref setLength, for styles \ref
  bsCalligraphic and \ref bsSquare. Anchors and positions are displayed for reference.</center>
*/
/*!
  브라켓이 포용 방향을 향하는 방향으로 \ a 길이를 픽셀 단위로 설정합니다.
  브래킷의 스팬 (즉, <i> 왼쪽 </ i> - <i> 오른쪽 </ i> 방향)
  
  \ image html QCPItemBracket-length.png
  <center> \ ref setLength에 대한 다양한 값의 효과를 보여주는 스타일 \ ref
  bsCalligraphic 및 \ ref bsSquare. 참조 용 앵커 및 위치가 표시됩니다. </ center>
*/
void QCPItemBracket::setLength(double length)
{
  mLength = length;
}

/*!
  Sets the style of the bracket, i.e. the shape/visual appearance.
  
  \see setPen
*/
/*!
  괄호의 스타일, 즉 모양 / 시각적 모양을 설정합니다.
  
  \ see setPen
*/
void QCPItemBracket::setStyle(QCPItemBracket::BracketStyle style)
{
  mStyle = style;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
double QCPItemBracket::selectTest(const QPointF &pos, bool onlySelectable, QVariant *details) const
{
  Q_UNUSED(details)
  if (onlySelectable && !mSelectable)
    return -1;
  
  QCPVector2D p(pos);
  QCPVector2D leftVec(left->pixelPosition());
  QCPVector2D rightVec(right->pixelPosition());
  if (leftVec.toPoint() == rightVec.toPoint())
    return -1;
  
  QCPVector2D widthVec = (rightVec-leftVec)*0.5;
  QCPVector2D lengthVec = widthVec.perpendicular().normalized()*mLength;
  QCPVector2D centerVec = (rightVec+leftVec)*0.5-lengthVec;
  
  switch (mStyle)
  {
    case QCPItemBracket::bsSquare:
    case QCPItemBracket::bsRound:
    {
      double a = p.distanceSquaredToLine(centerVec-widthVec, centerVec+widthVec);
      double b = p.distanceSquaredToLine(centerVec-widthVec+lengthVec, centerVec-widthVec);
      double c = p.distanceSquaredToLine(centerVec+widthVec+lengthVec, centerVec+widthVec);
      return qSqrt(qMin(qMin(a, b), c));
    }
    case QCPItemBracket::bsCurly:
    case QCPItemBracket::bsCalligraphic:
    {
      double a = p.distanceSquaredToLine(centerVec-widthVec*0.75+lengthVec*0.15, centerVec+lengthVec*0.3);
      double b = p.distanceSquaredToLine(centerVec-widthVec+lengthVec*0.7, centerVec-widthVec*0.75+lengthVec*0.15);
      double c = p.distanceSquaredToLine(centerVec+widthVec*0.75+lengthVec*0.15, centerVec+lengthVec*0.3);
      double d = p.distanceSquaredToLine(centerVec+widthVec+lengthVec*0.7, centerVec+widthVec*0.75+lengthVec*0.15);
      return qSqrt(qMin(qMin(a, b), qMin(c, d)));
    }
  }
  return -1;
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
void QCPItemBracket::draw(QCPPainter *painter)
{
  QCPVector2D leftVec(left->pixelPosition());
  QCPVector2D rightVec(right->pixelPosition());
  if (leftVec.toPoint() == rightVec.toPoint())
    return;
  
  QCPVector2D widthVec = (rightVec-leftVec)*0.5;
  QCPVector2D lengthVec = widthVec.perpendicular().normalized()*mLength;
  QCPVector2D centerVec = (rightVec+leftVec)*0.5-lengthVec;

  QPolygon boundingPoly;
  boundingPoly << leftVec.toPoint() << rightVec.toPoint()
               << (rightVec-lengthVec).toPoint() << (leftVec-lengthVec).toPoint();
  QRect clip = clipRect().adjusted(-mainPen().widthF(), -mainPen().widthF(), mainPen().widthF(), mainPen().widthF());
  if (clip.intersects(boundingPoly.boundingRect()))
  {
    painter->setPen(mainPen());
    switch (mStyle)
    {
      case bsSquare:
      {
        painter->drawLine((centerVec+widthVec).toPointF(), (centerVec-widthVec).toPointF());
        painter->drawLine((centerVec+widthVec).toPointF(), (centerVec+widthVec+lengthVec).toPointF());
        painter->drawLine((centerVec-widthVec).toPointF(), (centerVec-widthVec+lengthVec).toPointF());
        break;
      }
      case bsRound:
      {
        painter->setBrush(Qt::NoBrush);
        QPainterPath path;
        path.moveTo((centerVec+widthVec+lengthVec).toPointF());
        path.cubicTo((centerVec+widthVec).toPointF(), (centerVec+widthVec).toPointF(), centerVec.toPointF());
        path.cubicTo((centerVec-widthVec).toPointF(), (centerVec-widthVec).toPointF(), (centerVec-widthVec+lengthVec).toPointF());
        painter->drawPath(path);
        break;
      }
      case bsCurly:
      {
        painter->setBrush(Qt::NoBrush);
        QPainterPath path;
        path.moveTo((centerVec+widthVec+lengthVec).toPointF());
        path.cubicTo((centerVec+widthVec-lengthVec*0.8).toPointF(), (centerVec+0.4*widthVec+lengthVec).toPointF(), centerVec.toPointF());
        path.cubicTo((centerVec-0.4*widthVec+lengthVec).toPointF(), (centerVec-widthVec-lengthVec*0.8).toPointF(), (centerVec-widthVec+lengthVec).toPointF());
        painter->drawPath(path);
        break;
      }
      case bsCalligraphic:
      {
        painter->setPen(Qt::NoPen);
        painter->setBrush(QBrush(mainPen().color()));
        QPainterPath path;
        path.moveTo((centerVec+widthVec+lengthVec).toPointF());
        
        path.cubicTo((centerVec+widthVec-lengthVec*0.8).toPointF(), (centerVec+0.4*widthVec+0.8*lengthVec).toPointF(), centerVec.toPointF());
        path.cubicTo((centerVec-0.4*widthVec+0.8*lengthVec).toPointF(), (centerVec-widthVec-lengthVec*0.8).toPointF(), (centerVec-widthVec+lengthVec).toPointF());
        
        path.cubicTo((centerVec-widthVec-lengthVec*0.5).toPointF(), (centerVec-0.2*widthVec+1.2*lengthVec).toPointF(), (centerVec+lengthVec*0.2).toPointF());
        path.cubicTo((centerVec+0.2*widthVec+1.2*lengthVec).toPointF(), (centerVec+widthVec-lengthVec*0.5).toPointF(), (centerVec+widthVec+lengthVec).toPointF());
        
        painter->drawPath(path);
        break;
      }
    }
  }
}

/* inherits documentation from base class */
/* 기본 클래스에서 문서를 상속받습니다. */
QPointF QCPItemBracket::anchorPixelPosition(int anchorId) const
{
  QCPVector2D leftVec(left->pixelPosition());
  QCPVector2D rightVec(right->pixelPosition());
  if (leftVec.toPoint() == rightVec.toPoint())
    return leftVec.toPointF();
  
  QCPVector2D widthVec = (rightVec-leftVec)*0.5;
  QCPVector2D lengthVec = widthVec.perpendicular().normalized()*mLength;
  QCPVector2D centerVec = (rightVec+leftVec)*0.5-lengthVec;
  
  switch (anchorId)
  {
    case aiCenter:
      return centerVec.toPointF();
  }
  qDebug() << Q_FUNC_INFO << "invalid anchorId" << anchorId;
  return QPointF();
}

/*! \internal

  Returns the pen that should be used for drawing lines. Returns mPen when the
  item is not selected and mSelectedPen when it is.
*/
/*! \내부의

  선 그리기에 사용해야하는 펜을 반환합니다. mPen을 반환하면
  항목이 선택되지 않았 으면 mSelectedPen이 선택됩니다.
*/
QPen QCPItemBracket::mainPen() const
{
    return mSelected ? mSelectedPen : mPen;
}
/* end of 'src/items/item-bracket.cpp' */


